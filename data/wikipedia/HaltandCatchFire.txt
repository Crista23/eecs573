Halt and Catch Fire

In computer engineering, Halt and Catch Fire, known by the assembly mnemonic HCF, is an idiom referring to a computer machine code instruction that causes the computer's central processing unit (CPU) to cease meaningful operation, typically requiring a restart of the computer. It originally referred to a fictitious instruction in IBM System/360 computers, but later computer developers who saw the joke created real versions of this instruction for some machines. In the case of real instructions, the implication of this expression is that, (whereas in most cases) in which a CPU executes an unintended instruction (a bug in the code), the computer may still be able to recover, but in the case of an HCF instruction there is, by definition, no way for the system to recover without a restart.
The expression "catch fire" in this context is normally facetious, rather than literal, referring to a total loss of CPU functionality during the current session. The imaginative idea is that the CPU chip would be switching some circuits so fast that it would cause them to overheat and burn.

Assembly language mnemonics
In a computer's assembly language, mnemonics are used that are directly equivalent to machine code instructions. The mnemonics are frequently three letters long, such as ADD, CMP (to compare two numbers), and JMP (jump to a different location in the program). The HCF instruction was originally a fictitious assembly language instruction, said to be under development at IBM for use in their System/360 computers, along with many other amusing three-letter acronyms like XPR (Execute Programmer) and CAI (Corrupt Accounting Information),[2] and similar to other joke mnemonics such as "SDI" for "Self Destruct Immediately"[2] and "CRN" for Convert to Roman Numerals.[3] A list of such mnemonics, including HCF, shows up as "Overextended Mnemonics" in the April 1980 Creative Computing flip-side parody issue.[4]
The S/360 instruction set already included numerous non-obvious mnemonics like ZAP (Zero and Add Packed), EDMK (EDit and MarK), TRT (TRanslate and Test), and Read Backward (an I/O channel command),[5] and programmers began creating similarly cryptic, but fictitious, instructions in a humorous vein.[6][7]
In a 1990 USENET discussion, it was claimed that HCF dated back to before 1977.
In Rick Cook's science fiction/fantasy novel, The Wizardry Compiled, about programmers transported to a universe where magic could be programmed, one of them refers to the command as HMCF, for "Halt, Melt and Catch Fire".

In modern CPUs

CPU designers sometimes incorporate one or more undocumented machine code instructions for testing purposes, such as the IBM System/360 DIAGnose instruction.[5] These instructions are not intended to be executed during normal operation of the CPU; when they are actually executed by a program during normal operation, they can have unusual side-effects.[citation needed] The "Halt and Catch Fire" (HCF) instruction and mnemonic are sometimes appropriated by users who discover these instructions as a humorous way of expressing that the unintended execution of such an instruction causes the system to fail to perform its normal functions.

Motorola 6800

The Motorola 6800 microprocessor was the first for which an undocumented assembly mnemonic HCF became widely known. The operation codes (opcodes—the portions of the machine language instructions that specify an operation to be performed)—referred to by the mnemonic HCF are hexadecimal 9D and DD, and were reported in an article written by Gerry Wheeler in the December 1977 issue of BYTE magazine on undocumented opcodes.[10] Wheeler noted that Motorola reported 197 valid operation codes for the M6800 processor, and so inferred that with 256 possible 8 bit combinations, there must be 59 "invalid instructions." He goes on to describe the HCF as a "big surprise," and saying of the Catch Fire portion of the moniker, "Well, almost.":
When this instruction is run the only way to see what it is doing is with an oscilloscope. From the user's point of view the machine halts and defies most attempts to get it restarted. Those persons with indicator lamps on the address bus will see that the processor begins to read all of the memory, sequentially, very quickly. In effect, the address bus turns into a 16 bit counter. However, the processor takes no notice of what it is reading… it just reads.[10]
The process is reviewed by David Agans, thus: "In the old days of the Motorola 6800 microprocessor, instruction code DD caused the processor to go into an endless loop, reading from each memory address in order. (Other engineers referred to this as the 'Halt and Catch Fire' (HCF) instruction, but we remembered the code by calling it the 'Drop Dead' instruction.) Drop Dead mode was wonderful for spotting hardware timing and address logic problems with a scope; all of the address and clock lines were nice, cycling square waves."[11]
That is, either opcode made the processor enter a mode, continuously performing memory read cycles from successive addresses with no intervening instruction fetches. Hence, the address bus effectively became a counter, allowing the operation of all address lines to be quickly verified. Once the processor entered this mode, it was not responsive to interrupts, so normal operation could only be restored by a reset (hence the "Drop Dead" and "Halt and Catch Fire" monikers). These references were thus to the unresponsive behavior of the CPU in this state, and not to any form of erratic behavior.[citation needed]
The mnemonic HCF is believed to be the first built-in self-test feature on a Motorola microprocessor.[12]
Intel x86[edit]
See also: HLT (x86 instruction) and Pentium F00F bug
The Intel 8086 and subsequent processors in the x86 series had an HLT (halt) instruction, opcode F4, which stopped instruction execution and placed the processor in a HALT state. An enabled interrupt, a debug exception, the BINIT signal, the INIT signal, or the RESET signal resumed execution, which meant the processor could always be restarted.[13] Some of the early Intel DX4 chips had a problem with the HLT instruction and could not be restarted after this instruction was used, which disabled the computer and turned HLT into more of an HCF instruction. The Linux kernel added a "no-hlt" option telling Linux to run an infinite loop instead of using HLT, which allowed users of these broken chips to use Linux.[14]
The 80286 has the undocumented opcode 0F 04, causing the CPU to hang when executed. The only way out is CPU reset.[citation needed] [15] In some implementations, emulated through BIOS as a halting sequence.[16]
Many computers in the Intel Pentium line could be locked up by executing an invalid instruction (F00F C7C8), which caused the computer to lock up. This became known as the Pentium F00F bug. No compiler would create the instruction, but a malicious programmer could insert it into code to render an afflicted computer inoperable until the machine was power-cycled. Since its discovery, workarounds have been developed to prevent it from locking the computer, and the bug has been eliminated in subsequent Intel processors.[17][18]
Other CPUs[edit]
The MOS Technology 6502 has 12 invalid instructions which will freeze the CPU.[19][20]
On the Zilog Z80, executing DI (disable interrupts) followed by HALT (wait for an interrupt) results in the CPU staying frozen indefinitely, waiting for an interrupt that cannot happen. The similar processor found in the Game Boy contained a partial fix allowing it to recover from one HALT, but it would become frozen with two consecutive HALTs with interrupts disabled.[citation needed]
It should also be noted that the Z80 supports a non-maskable interrupt[21][22] with /NMI being on Pin 17 of the original 40 pin DIP package.[23][24] Since a non-maskable interrupt will regain control of the CPU even after executing the instruction sequence DI / HALT, that pair does not represent a true HCF, it will only result in a HCF condition if either the /NMI pin is connected directly to the +5V rail, making the generation of that signal impossible, or if the interrupt routine that services /NMI ends with a return, placing it back in the HALT state.
In early CPUs[edit]
One apocryphal story about the HCF instruction in an actual early CPU goes back to the late 1960s, when computers used magnetic core memory.[citation needed] The story goes that in order to speed up the core memory on their next model the engineers increased the read/write currents in the very fine wires that were threaded through the cores. This worked fine when the computer was executing normal programs, since memory accesses were spread throughout memory. However, the HALT instruction was implemented as a "Jump to self". This meant that the same core memory location was repeatedly accessed, and the very fine wires became so hot that they started to smoke—hence the instruction was labeled "Halt and Catch Fire".
