Core	Manufacturer	Chip	Details	Workaround	Failure
ARM9	ST	STR91xFA	Description of limitation Status register bit 7 (ready bit) does not reflect the correct status when it is read immediately after the CPU issues a Flash memory program or erase command.	This requires bit 18 (instruction TCM order bit) in the configuration control register of the ARM966E-S core to be set. This can be done by the following assembler code: MOV R0, #0x40000 MCR P15,0x1,R0,C15,C1,0 When set, the write and read to the Flash bank are performed in the order generated by the ARM966-ES core.This ensures that writes are committed to the Flash memory before any subsequent read. This will not be fixed in future silicon revisions.	2.1 Flash memory status register bit 7
ARM9	ST	STR91xFA	Description of limitation At power up, the Flash protection level 1 register is reset to 0FFFh (all Flash sectors are protected). A warm reset does not reset the register.	Firmware must change the values if desired. This will not be fixed in future silicon revisions.	2.2 Flash memory sector protection
ARM9	ST	STR91xFA	Description of limitation in revision G There are two independent Flash memory banks (primary and secondary) that allow read-while-write capability from one bank to the other, enabling in-application programming (IAP) of the primary bank while executing code from the secondary bank. After IAP has upgraded firmware in the primary bank, the bootloader code in the secondary bank should remap the banks by writing to FMI registers FMI_BBADR and FMI_NBBADR in order to have the primary bank start at address 0x0, which allows interrupt handlers to reside in the application code primary bank instead of interrupts being handled by bootloader code in the secondary bank. There are two forms of reset in the STR91xFA: A global reset (from power-up or voltage drop-out) that clears all functions in the device, and a system reset (from the reset input pin, watchdog, or JTAG reset command) that clears all but a few configuration registers. 4/16 STR91xFA Silicon limitations and fixes Silicon limitation The remapping operation is possible. However, when a system reset occurs after the remapping, the application hangs because the FMI_BBADR and FMI_NBBADR registers which define bank locations are not cleared by the system reset, while the FMI_CR register which controls the chip select enable of the non boot bank are cleared by the system reset.	using revision G Do not remap the banks after IAP (keep secondary bank at address 0x0), and in the secondary bank redirect ARM interrupts to be handled in the primary bank. This limitation is fixed in revision H devices by clearing all FMI registers (including bank base address and bank size) after a system reset.	2.3 Flash memory remapping
ARM9	ST	STR91xFA	Description of limitation In either of the following two conditions, the CPU may freeze or generate an exception: 1. When the two banks (Bank0 and Bank1) are configured at contiguous addresses in the STR91xFA address map and if a code sequence is stored and then fetched by the CPU across this boundary, 2. When data is read from a bank other than the bank fetched by the CPU for execution. This will not be fixed in future silicon revisions.	s For the first case, three workarounds are proposed: 1. Do not use the last 8 x 32-bit words of a Flash bank for storing code and use it instead to store data constants (this can be configured by the linker to specify the last zone). 2. If the application firmware is larger than one bank in size, ensure that before reaching the last 8 x 32-bit words of one bank, application code must jump (using LDR, or a branch) to an address forced by the linker to a location in the other bank. 3. Disable the PFQ block before executing code stored across a bank boundary. For the second case, the workaround is as follows: Disable the PFQ block before reading (data/constants) from a bank other than the bank from which code is fetched and enable it again after completing the read operations. 5/16 Silicon limitations and fixes STR91xFA	2.4 Flash fetch/read across banks
ARM9	ST	STR91xFA	Description of limitation When programming the internal Flash or the Flash registers with an FMICLK frequency of 96 MHz, either using read-while-write operations or executing from the internal SRAM, for some STR91xFA slow parts that may be seen in the field, some data are not properly written. This issue is due to a limitation in the Flash command interface that affects Flash write operations (such as program or erase).	To ensure that internal Flash programming and CUI registers (command user interface) programmings are performed correctly, configure the frequency of FMICLK to RCLK/2 during these operations.	2.5 Flash frequency limitation when programming
ARM9	ST	STR91xFA	Description of limitation By default, the ETM9 interface in the STR91xFA core is an 8-bit medium size model as defined by ARM Ltd. When an emulator tool boots up and performs an automatic configuration on the ETM (ETM sniffers), the configuration register always sends back the 8-bit model status. However, in order to reduce the number of I/O pins required for debugging, the ETM trace data port is implemented as a 4-bit port. When polled, the 8-bit status provided by the configuration register is incorrect.	When booting up an emulator, do not select the automatic configuration option. Instead, configure the ETM to be a 4-bit port manually. This limitation will not be fixed in future silicon revisions.	2.6 ETM (embedded trace module) configuration
ARM9	ST	STR91xFA	Description of limitation When the EMI clock is configured with a ratio of 2, modifying SCU_CLKCNTR register may cause incorrect EMI write cycles to occur when the EMI is used. This is due to the de-synchronization of the two clock state machines feeding the EMI when the EMI clock ratio is configured with a ratio of 2.	Whenever the SCU_CLKCNTR register is modified, the EMI must be subsequently reset by writing bit 6 (RST_EMI) of the SCU_PRR0 register to 0 and setting it again just before configuring and using the EMI. 6/16 STR91xFA Silicon limitations and fixes 2.7.2 Address boundary limitation in 16-bit asynchronous or synchronous modes Description of limitation When accessing the external memory in 16-bit mode, the address must always be aligned to half word (16 bit) or word (32 bit) boundary. The memory address must consequently be an even address, and reading or writing from/to an odd address location may result in incorrect data. This limitation applies to data memory space only, as code fetch is always aligned to word boundary. Workaround All data must be stored at even address location. 2.7.3 Write signal configuration in 16-bit synchronous mode Description of limitation (applies only to BGA144 devices) There are two sets of write control signals for 16-bit write bus cycle: 1. EMI_WRLn, EMI_WRHn 2. EMI_WEn, EMI_UBn, EMI_LBn The 2nd set of signals is activated by setting bit 2 in the SCU_GPIOEMI register. When configured in 16-bit synchronous mode, the EMI bus works only with the 2nd set of write signals. The 1st set of signal results in incorrect write signal timings. Workaround When using EMI in 16-bit synchronous mode, choose a memory device which accepts write enable (EMI_WEn), EMI_UBn and EMI_LBn signals. If these signals are not available on the memory, it is recommended to operate in asynchronous mode.	2.7 EMI bus limitations 2.7.1 Impact of SCU_CLKCNTR register modification on EMI operation with clock ratio of 2
ARM9	ST	STR91xFA	Description of limitation When the STR91xFA enters Sleep mode, the current drawn from the CPU core voltage (VDD) and from the I/O supply voltage (VDDQ) should drop to a very low value. ISLEEP current on VDD pins correctly drops to as low as 50 ÂµA at 25 Â°C. However ISLEEP current on the VDDQ pins drops to around 500 ÂµA at 25 Â°C while it should be less than 10 ÂµA.	using revision G A limited workaround may be implemented to save around 120 ÂµA by using firmware to put the USB transceiver into Suspend mode (bit2, LP_MODE in the USB_CNTR register). This allows reducing Sleep mode current on VDDQ pins to around 380 ÂµA. 7/16 Silicon limitations and fixes STR91xFA Sleep mode current consumption on VDDQ pins is reduced to less than 10 ÂµA on revision H silicon devices.	2.8 Sleep mode current (ISLEEP) on VDDQ pins
ARM9	ST	STR91xFA	Description of limitation After the CPU enters sleep mode, it can be woken up by: 1. External interrupt 2. RTC/USB interrupt 3. External reset When an oscillator chip is used as the clock source for the STR91xFA, the CPU wakes up from sleep mode following any of the above three input events. If a crystal is used as the clock source, the crystal is disabled in sleep mode to save power consumption. When a wakeup event occurs, the crystal does not recover fast enough and the CPU hangs.	s Workaround solutions include: 1. Use the 32 kHz RTC clock as the clock source for sleep mode: a) Select the RTC clock as the CPU clock source prior entering sleep mode. b) The CPU wakes up following any of the three wakeup events and waits for the crystal to start oscillation. A crystal startup time is about 1.5 ms typical. c) After the crystal wakes up, the CPU waits for a tWAIT time before the first code is fetched from Flash memory. The software can then change the CPU clock source back to the OSC or PLL clock. The duration of tWAIT depends on the crystal frequency. tWAIT equals 50 Âµs at 25 MHz and 312 Âµs at 4 MHz. 2. Instead of a crystal, use an oscillator as STR91xFA clock source. This limitation will not be fixed in future silicon revisions	2.9 Waking up from sleep mode
ARM9	ST	STR91xFA	Description of limitation Once the idle or sleep mode are entered by writing the PWR_MODE[2:0] bits in the SCU_PWRMNG register, it takes about 12 fOSC cycles for the device to stop the execution. In addition, if a wakeup event or an interrupt (external or internal coming from peripherals) occurs during this period while entering idle, the internal low power state machine is frozen and the STR91xFA hangs. In this case, only a reset event can wake up the device. 8/16 STR91xFA Silicon limitations and fixes	s In order to avoid executing any valid instructions after setting the idle or sleep bit and before entering the mode, it is mandatory to execute a certain number of dummy instructions after setting the SCU_PWRMNG register. The number of dummy instructions to be executed is given by the following formula: No_dummy_instr = (f â f ) Ã 12 CPUCLK OSC Where fCPUCLK is the CPU core clock frequency and fOSC is the oscillator frequency. The worst scenario is obtained when the core works from the PLL maximum frequency (96 MHz) with an 4 MHz crystal or oscillator connected to the X1_CPU input. In this case 288 dummy instructions are needed. Note: If (fCPUCLK/ fOSC) is less than 1, the number of dummy instruction is always 3. Random external/internal wakeup events or interrupts may freeze the STR91xFA when occurring during the execution of these dummy instructions. In this case, only a reset event can wake up the CPU. This limitation will not be fixed in future silicon revisions 2.10.2 Time required to enter sleep mode Description of limitation After the mode bit is set in the SCU_PWRMNG register, the power management unit requires a period of time (tSLEEP) to switch off all CPU and peripheral clocks safely before entering sleep mode. A very slow peripheral clock results in a long switch off time. The tSLEEP time required to enter sleep mode depends on the oscillator frequency, on the slowest peripheral clock frequency, and on the CPU clock frequency. If a wakeup event occurs during tSLEEP, it is ignored and the STR91xFA does not exit from sleep mode. tSLEEP is given by the following formula: t = 17 Ã t_OSC + 14 Ã t_Slowest_IP_CLK + 6 Ã t_CPUCLK SLEEP Where t_OSC is the oscillator frequency, t_Slowest_IP_CLK the slowest peripheral clock frequency, and t_CPUCLK the CPU clock frequency. Example â CPU running on RTC clock before entering sleep mode (fCPUCLK = 32 kHz) (see Section 2.9). â t_OSC = 40 ns (fOSC = 25 MHz) â t_CPUCLK = t_RTC = 31,250 ns (fCPUCLK = 32 kHz) â t_Slowest_IP_CLK = 2*31,250 ns assuming all clock dividers are set to 1 (default state) except for APB clock divided which is set to 2, the slowest peripheral clock frequency is then fCPUCLK/2. Then, the value of tSLEEP is: t = 17 Ã 40 + 14 Ã 2 Ã 31, 250 + 6 Ã 31, 250 1.06 â¼ ms SLEEP 9/16 Silicon limitations and fixes STR91xFA Workaround To prevent random external wakeup events from occurring while the device is entering sleep mode (during tSLEEP), the maximum time required by the application to enter sleep mode must be taken into account. This limitation will not be fixed in future silicon revisions.	2.10 Sleep and Idle mode requirements 2.10.1 Code execution after setting the sleep or idle mode bit
ARM9	ST	STR91xFA	Description of limitation None of the STR9 general inputs have hysteresis which means they have no Schmitt trigger. Simulation in typical conditions (3.3 V, ambient temperature, typical processing) shows that approximately 25 mV noise is enough to provide unexpected glitches in the core when the 1 kHz pad signaling crosses the input buffer threshold. The slower the input signaling frequency is, the greater this limitation.	s Some possible software workarounds can be implemented depending on the application and the impact of the limitation. A hardware workaround, feasible in all cases, is to implement an external Schmitt trigger to act as a noise filter.	2.11 Noise sensitivity of GPIO ports
ARM9	ST	STR91xFA	Description of limitation A high leakage current is observed when applying 5.5 V on 5 V-tolerant I/O pins. This leakage does not dependent on VDDQ, and increases with the temperature. This high leakage is distributed between the different pins when using a 5.5 V supply voltage. If the application hardware has 10 pins connected to 5.5 V, the leakage current is not multiplied by 10, but distributed between the 10 pins. This limitation will not be fixed in future silicon revisions.	Limit the voltage applied to the 5 V-tolerant I/O pins to 5 V to limit the leakage current. 10/16 STR91xFA Silicon limitations and fixes	2.12 High leakage on GPIO ports at 5.5 V
ARM9	ST	STR91xFA	Description of limitation The ADC generates an end of conversion (EVC) or an analog watchdog (AWD) interrupt when enabled. Before returning from serving the interrupt, the ISR typically clears the interrupt by setting the corresponding EVC or AWD flag bit in the ADC_CR register to â0â. The ADC clock is used to clear the interrupt flags. The time taken to clear the flags is longer when the ADC runs on a slow clock. The CPU may return from ISR before the interrupt flag has been cleared. Since the interrupt controller input is level sensitive, the CPU sees immediately if another interrupt is pending.	Instead of clearing the ADC interrupt flag at the end of the ISR, clear the flag when ISR is entered. This limitation will not be fixed in future silicon revisions.	2.13 ADC interrupt generation
ARM9	ST	STR91xFA	Description of limitation When the ADC unit is in single conversion mode, the time to complete the conversion varies between 36 and 48 ADC clock periods after the conversion is initiated by an external ADC trigger, a timer trigger, or a firmware command. This limits the maximum ADC conversion rate to 500,000 samples per second for a single channel using an external trigger. This situation also introduces a "jitter" of as many as 12 ADC clocks from one completed conversion to the next. When the ADC unit is in continuous and scan conversion modes, the time to complete the first conversion varies between 36 and 48 ADC clocks like single conversion mode, but subsequent conversions complete every 16 ADC clocks producing a maximum ADC conversion rate of 1,500,000 samples per second for a single channel.	on revision G In single conversion mode, there is no workaround to exceed 500 Ksps conversion rate with external trigger or timer trigger, and no workaround to reduce jitter from one sample to the next. In continuous and scan conversion modes there is no workaround to reduce delay of the first conversion. To eliminate jitter, a new conversion mode started by fast trigger has been added in silicon revision H (refer to STR91xFA datasheet and reference manual). It allows each conversion to be completed in 16 ADC clocks after it has been triggered by external ADC trigger or internal timer event. A minimum conversion rate of 1.2 Msps can be achieved on a single channel. In single and scan mode, the time to complete the first conversion is reduced to the range of 20 to 32 clocks (down from 36 to 48 clocks) after a trigger event allowing continuous conversion. In this case, the maximum rate on subsequent continuous conversions remains 1.5 Msps on a single channel. 11/16 Silicon limitations and fixes STR91xFA	2.14 ADC conversion time and external trigger mode
ARM9	ST	STR91xFA	Description of limitation only in revision H ADC scan and continuous mode cannot be used together on revision H silicon. The first conversion is performed, but the next channel is not selected, so the end of conversion never occurs.	Instead of using scan mode with continuous mode, the application has to select scan mode in single mode. Each conversion can be started by an internal trigger (PWM) for the required number of channels. The conversion time is deterministic in fast trigger mode. This is a new feature available in revision H silicon (see STR91xFA datasheet and reference manual). It can be computed using the following formula: f < 1 â (nb_channels Ã 16 â f ) TRIGGER ADC	2.15 ADC scan and continuous modes
ARM9	ST	STR91xFA	Description of limitation only in rev H If both channel selection and start conversion bits (SC and STR bits) are written at the same time, it may occur that the ADC sampling/conversion is performed on the previous selected channel.	A delay max. of 16 ADC clocks between the channel selection and the conversion start should be enough to prevent this effect. A generic dummy loop (equivalent to 16 ADC clocks) is recommended. This workaround is only needed in single mode with a channel selection change.	2.16 ADC single mode and channel selection
ARM9	ST	STR91xFA	Description of limitation For daisy-chained interrupts, if only the VAR from one VIC is read, it does not update the hardware priority in the other VIC. This means the daisy chained interrupt controller doesn't realize the interrupt is being serviced and keeps the interrupt request active. For daisy-chained interrupts the processor must read the VAR register from both interrupt controllers and branch to the addresses provided. However, the address provided by reading the daisy-chained VAR register must be manipulated to skip the interrupt preamble. If two daisy chained interrupts occur soon after each other and the daisy chained VAR register address isn't branched to, the interrupt controller priority logic may be updated incorrectly. This may cause a low priority interrupt to be missed. 12/16 STR91xFA Silicon limitations and fixes	Note: This workaround is taken from the ARM prime cell vectored interrupt controller (PL190) errata notice. For already existing software that services daisy-chained nested interrupts, a possible software workaround is to branch to the address provided by the VIC1 VAR register. This ensures that the correct ISR is serviced. 0x18 LDR pc, [VIC0_VAR] ; VIC0 VAR read ; daisy_chained_vector_handler: STMFD r13!, {r12-r14} LDR r12, [VIC1_VAR] ; Read VIC1 VAR and update PC, ; VIC1 priority hardware is updated LDR PC, [r12, #12] ; Processor branches to the highest priority ; daisy chained ISR and skips ; the preamble(+12) Note: The value, 12, used in instruction LDR PC, [r12, #12] is only specific to the example code given here. The offset #12 is dependent on the system's interrupt stacking preamble code size.	2.17 Daisy chained interrupt controller VIC1 hardware priority management limitation
ARM9	ST	STR91xFA	Description of limitation Using wait state insertion bits and/or the Flash bus clock bit under some specific configurations and/or combinations with respect to the Flash programming manual, may cause the device to be used outside its operating conditions.	To ensure that the application use of the above bits is well supported, a new Flash configuration specification has been put in place: Bits 12:11 WSTATES[1:0]: Wait states These bits define the number of wait states inserted in asynchronous read access. 00: 1 wait state (default) 01: 2 wait states 10: 3 wait states Note: Wait states are inserted only for non-bursting Flash read bus cycles. One wait state is required for a Flash memory interface (FMI) bus clock frequency < 66 MHz. Two wait states are required for an FMI bus clock frequency â¥ 66 MHz. Bit 4 BUSCFG: Flash bus clock configuration This bit selects the FMI Flash bus clock configuration. 0: BUSCFG disabled (default) 1: BUSCFG enabled Note: The BUSCFG bit must be set for a frequency of: â¥ 48 MHz (with 1 wait state) â¥ 66 MHz (with 2 wait state).	2.18 Flash configuration register bits correction
ARM9	NXP	LPC3220	The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst. When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3220 . Â© Rev. 9 â 1 June 2011 4 of 16 ES_LPC3220 LPC3220 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3220 . Â© Rev. 9 â 1 June 2011 5 of 16 ES_LPC3220 LPC3220	When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status).	3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus
ARM9	NXP	LPC3220	In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3220 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices. If the LPC3220 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3220 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3220 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3220. In this situation, the LPC3220 will fail to boot.	Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3220 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3220 . Â© Rev. 9 â 1 June 2011 6 of 16 ES_LPC3220 LPC3220 Fig 3. 128 MB DDR SDRAM example ES_LPC3220 . Â© Rev. 9 â 1 June 2011 7 of 16 ES_LPC3220 LPC3220	3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3220 from booting correctly
ARM9	NXP	LPC3220	DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing For DDR writes the LPC3220 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times.	To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. ES_LPC3220 . Â© Rev. 9 â 1 June 2011 8 of 16 ES_LPC3220 LPC3220 3. Series termination resistors are not needed for the LPC3220 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3220 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3220 and DDR memory (closer to the DDR). 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the "DDR SDRAM setup code for the LPC32x0 series" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3220 . Â© Rev. 9 â 1 June 2011 9 of 16 ES_LPC3220 LPC3220	3.3 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations.
ARM9	NXP	LPC3220	DDR memory uses a differential clock which is generated by the LPC3220. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock. There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3220 has a programmable DQS delay to achieve center alignment for accurate data reads.	Connecting the DDR device negative clock input (DDR_nCLK from the LPC3220) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3220 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference. ES_LPC3220 . Â© Rev. 9 â 1 June 2011 10 of 16 ES_LPC3220 LPC3220	3.4 DDR.1: DDR interface has >1.2 ns clock skew
ARM9	NXP	LPC3220	An ONSW output pin (M15) is included in the LPC3220 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active. When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition.	There is no work-around for this problem.	3.5 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH)
ARM9	NXP	LPC3220	The LPC3220 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin. When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly.	There is no work-around for this problem. ES_LPC3220 . Â© Rev. 9 â 1 June 2011 11 of 16 ES_LPC3220 LPC3220	3.6 INT.1: GPI_08 does not generate an interrupt signal
ARM9	NXP	LPC3220	On the LPC3220, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details). The input pins (MCI0-2) are not functional.	The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3220, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3220 . Â© Rev. 9 â 1 June 2011 12 of 16 ES_LPC3220 LPC3220	3.7 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional
ARM9	NXP	LPC3220	The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior. It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses.	If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3220 . Â© Rev. 9 â 1 June 2011 13 of 16 ES_LPC3220 LPC3220	3.8 HSUART.1: High speed UART receive FIFO and status can freeze
ARM9	NXP	LPC3220	Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP. The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller.	None. 4. AC/DC deviations detail	3.9 USB.1: USB host controller hangs on a dribble bit
ARM9	NXP	LPC3220	The LPC3220 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model. The RESET_N pad (pin M14) does not pass ESD tests above 1000 V.	Observe proper ESD handling precautions for the RESET_N pin ES_LPC3220 . Â© Rev. 9 â 1 June 2011 14 of 16	4.1 ESD.1: Weak ESD protection on Reset_N pad
ARM9	NXP	LPC3240	The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst. When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3240 . Â© Rev. 9 â 1 June 2011 5 of 17 ES_LPC3240 LPC3240 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3240 . Â© Rev. 9 â 1 June 2011 6 of 17 ES_LPC3240 LPC3240	When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status).	3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus
ARM9	NXP	LPC3240	In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3240 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices. If the LPC3240 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3240 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3240 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3240. In this situation, the LPC3240 will fail to boot.	Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3240 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3240 . Â© Rev. 9 â 1 June 2011 7 of 17 ES_LPC3240 LPC3240 Fig 3. 128 MB DDR SDRAM example	3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3240 from booting correctly
ARM9	NXP	LPC3240	The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors. The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached)	Software can correct this situation in many ways; for example, sending a dummy frame after initialization.	3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent
ARM9	NXP	LPC3240	DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. ES_LPC3240 . Â© Rev. 9 â 1 June 2011 8 of 17 ES_LPC3240 LPC3240 EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing For DDR writes the LPC3240 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times.	To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. 3. Series termination resistors are not needed for the LPC3240 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3240 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3240 and DDR memory (closer to the DDR). ES_LPC3240 . Â© Rev. 9 â 1 June 2011 9 of 17 ES_LPC3240 LPC3240 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the "DDR SDRAM setup code for the LPC32x0 series" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3240 . Â© Rev. 9 â 1 June 2011 10 of 17 ES_LPC3240 LPC3240	3.4 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations.
ARM9	NXP	LPC3240	DDR memory uses a differential clock which is generated by the LPC3240. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock. There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3240 has a programmable DQS delay to achieve center alignment for accurate data reads.	Connecting the DDR device negative clock input (DDR_nCLK from the LPC3240) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3240 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference. ES_LPC3240 . Â© Rev. 9 â 1 June 2011 11 of 17 ES_LPC3240 LPC3240	3.5 DDR.1: DDR interface has >1.2 ns clock skew
ARM9	NXP	LPC3240	An ONSW output pin (M15) is included in the LPC3240 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active. When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition.	There is no work-around for this problem.	3.6 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH)
ARM9	NXP	LPC3240	The LPC3240 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28 ) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin. When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly.	There is no work-around for this problem. ES_LPC3240 . Â© Rev. 9 â 1 June 2011 12 of 17 ES_LPC3240 LPC3240	3.7 INT.1: GPI_08 does not generate an interrupt signal
ARM9	NXP	LPC3240	On the LPC3240, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details). The input pins (MCI0-2) are not functional.	The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3240, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3240 . Â© Rev. 9 â 1 June 2011 13 of 17 ES_LPC3240 LPC3240	3.8 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional
ARM9	NXP	LPC3240	The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior. It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses.	If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3240 . Â© Rev. 9 â 1 June 2011 14 of 17 ES_LPC3240 LPC3240	3.9 HSUART.1: High speed UART receive FIFO and status can freeze
ARM9	NXP	LPC3240	Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP. The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller.	None. 4. AC/DC deviations detail	3.10 USB.1: USB host controller hangs on a dribble bit
ARM9	NXP	LPC3240	The LPC3240 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model. The RESET_N pad (pin M14) does not pass ESD tests above 1000 V.	Observe proper ESD handling precautions for the RESET_N pin	4.1 ESD.1: Weak ESD protection on Reset_N pad
ARM9	NXP	LPC3250	The DMA controller is an AHB master that can transfer blocks of data between peripheral-to-memory, memory-to-peripheral, peripheral-to-peripheral, and memory-to-memory. In addition to transferring data between memories, a DMA memory-to-memory flow can be used to transfer blocks of data to / from an FPGA or external peripheral chip connected to an EMC static memory chip select. When a memory, FPGA or external peripheral chip does not support burst transfers (i.e. multiple reads for each active chip select or read strobe) the burst size for that memory-to-memory flow must be set for one transfer per burst. When using memory-to-memory DMA with the EMC static chip select (EMC_CS[x]_N) as the DMA source and the DMA channel source burst size is set for a single transfer (DMACCxControl:SBSIZE = 0), each DMA source read should be a single bus-wide access. The access should be similar to reading the EMC_CS[x]_N static memory with an ARM LDR instruction, as shown in Figure 1. Note the EMC signal timing for the read is controlled by the EMCSTATICx registers. In all example scope shots the EMCSTATICWAITx registers are set to the maximum value. Fig 1. Scope shot 1 - expected read timing However, the actual EMC timing for the source DMA read is a double wide chip select with a burst of two reads (notice how the address increments near the halfway point of nCS0 active), see Figure 2. The second data read during the burst is discarded, as the DMA destination write (also to nCS0 in Figure 2) following each read, always writes the first value read during the read burst. When the DMA source address is set to auto-increment, the last DMA read transfer will address the last address of the source buffer and the last source buffer address +1. This behavior only happens during the read part of the DMA transfer. Memory-to-memory DMA destination writes to the EMC static chip select work as expected. ES_LPC3250 . Â© Rev. 9 â 1 June 2011 5 of 17 ES_LPC3250 LPC3250 DMA register values used in Figure 2: DMACConfig = 0x01 DMACCxSrcAddr = 0xe0000000; EMC_CS0 DMACCxDestAddr = 0xe0000040; EMC_CS0 DMACCxLLI = 0x0 DMACCxControl = 0x0c480004; Dest & Src addrs increment, Dest & Src 32-bit; Dburst & Sburst size 1; transfer size 4 DMACCxConfig = 0x01 EMCStaticConfig0 = 0x00000082; 32-bit width, Byte lane state 1 Fig 2. Scope shot 2 - actual read timing Results of this behavior: 1. DMA reads from an external memory will have lower performance than a software read loop. The source read burst of two, to get one transfer, will significantly increase the time to complete all transfers in the memory-to-memory DMA, therefore decreasing the overall throughput possible on the EMC_CSx_N static memory interface. 2. Potential unintended consequence when the last DMA read accesses the address beyond the DMA source buffer address in the FPGA or external peripheral chip. This extra address is the second access during the last DMA source read. ES_LPC3250 . Â© Rev. 9 â 1 June 2011 6 of 17 ES_LPC3250 LPC3250	When interfacing an external peripheral device that does not support burst mode access through the EMC Static Memory interface the following work-arounds are recommended: 1. Avoid using DMA to transfer read blocks of data from the external device. Instead use a software loop with LDR instruction to read blocks of data from the external device. 2. If DMA can't be avoided, ensure there is at least one unused address between the highest address used for the external device DMA data buffer and any status or control register in the device that will initiate any unwanted action just by reading from the register (i.e. clear an interrupt or status).	3.1 DMA.1: Single burst DMA memory-to-memory transfers have additional memory cycles when the DMA source memory is on the EMC bus
ARM9	NXP	LPC3250	In systems that use SDRAM and boot from NOR FLASH, an issue can occur on system reset that will prevent the SDRAM devices from releasing the data bus. This will prevent normal operation of NOR FLASH due to data bus contention and prevent the LPC3250 from booting correctly. This applies to systems using either Single Data Rate (SDR) or Double Data Rate (DDR) SDRAM devices. If the LPC3250 is reset during an SDRAM access, the SDRAM clock and clock enable will be immediately de-asserted. If the de-assertion occurs during the period of time the SDRAM is driving the data bus, the SDRAM will hold that state until the next clock occurs at the SDRAM clock input when the clock enable is active. However, the LPC3250 won't deliver the clock and clock enables until software actually sets up the EMC state to do this, so the SDRAM will remain in the data assertion state on the data bus while the LPC3250 tries to boot. When the chip attempts to load boot code from NOR FLASH after reset, the correct signals are asserted to the NOR FLASH device and the NOR FLASH device places its data on the data bus. But if the SDRAM is still driving the bus, the NOR FLASH device and SDRAM device are in contention and the data will not be read correctly into the LPC3250. In this situation, the LPC3250 will fail to boot.	Since this issue only occurs with NOR FLASH, using one of the other boot methods such as NAND or SPI FLASH boot is a good workaround for the issue. If booting from NOR FLASH is a requirement, the simple circuit shown in Figure 3 can be used to clear the SDRAM state at system reset. This will not change the normal functioning of the LPC3250 EMC or SDRAM operations. If SDRAM devices are also present on the 2nd SDRAM chip select, a similar circuit will be needed for those devices using EMC_CKE1. ES_LPC3250 . Â© Rev. 9 â 1 June 2011 7 of 17 ES_LPC3250 LPC3250 Fig 3. 128 MB DDR SDRAM example	3.2 NOR.1: When booting from NOR flash, SDRAM devices will not release the data bus, preventing the LPC3250 from booting correctly
ARM9	NXP	LPC3250	The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors. The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached)	Software can correct this situation in many ways; for example, sending a dummy frame after initialization.	3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent
ARM9	NXP	LPC3250	DDR memory interface signal EMC_DQS[1:0] is source synchronous, defined to be driven by the MCU center aligned to the data EMC_D[15:0] for writes, while driven by the DDR memory edge aligned to the EMC_D[15:0] for reads. The basic DDR write timing is shown in the data sheet Fig 1. ES_LPC3250 . Â© Rev. 9 â 1 June 2011 8 of 17 ES_LPC3250 LPC3250 EMC_CLK t t DSS DSH command WRITE tDQSS tDQSL tDQSH EMC_DQS[1:0] t t su(Q) h(Q) EMC_D[15:0], EMC_DQM[1:0] 002aae437 Fig 4. Basic DDR write timing For DDR writes the LPC3250 drives the EMC_DQS[1:0] earlier in the data valid window than center aligned. With the EMC_CLK at 133 MHz this produces a minimum set-up time between the EMC_D[15:0] and EMC_DQS[1:0] of 600 ps across silicon process, voltage and temperature. Test conditions are with the EMC buffers set to fast slew rate driving 2 inches of 50 ï transmission line and 10 pF load capacitance. DDR memories specify EMC_D[15:0] to EMC_DQS[1:0] set-up time minimum as 400 ps. This leaves 200 ps set-up time margin due to customer specific load and PCB layout implementation. See the LPC3220_30_40_50 data sheet for the complete range of DDR data output set-up time, tsu(Q), and data output hold time th(Q) times.	To get the most DDR set-up time margin, the following is recommended: 1. The DDR initialization software should set the SDRAMCLK_CTRL register (0x4000 4068) SDRAM_PIN_SPEED[3:1] bits = 0 (fast slew rate). This is for both 1.8 V mobile and 2.5 V DDR memories. 2. Systems requiring 128 MB or less of DDR should be implemented using a single EMC_DYCSx_N for DDR. The single chip select system may be constructed with a single 16-bit wide DDR or two 8-bit wide DDR SDRAMs using up to the maximum supported 512 Mbit DDR density. Using two 8-bit wide DDRs will have less capacitive loading and facilitate simple point-to-point routing of EMC_D[15:0] and EMC_DQS[1:0] signals over using two 16-bit DDRs and two EMC_DYCSx banks. 3. Series termination resistors are not needed for the LPC3250 EMC outputs. If series termination resistors are used they should be placed as close to the DDR EMC_D[15:0] and EMC_DQS[1:0] pins as possible. 4. If the data bus EMC_D[15:0] is shared with additional devices (i.e., NOR flash, buffers, etc.) the board should be routed with a daisy chain topology, where the LPC3250 is placed at one extreme of the data bus and the DDR(s) at the other extreme. Other device(s) should be placed between the LPC3250 and DDR memory (closer to the DDR). ES_LPC3250 . Â© Rev. 9 â 1 June 2011 9 of 17 ES_LPC3250 LPC3250 5. The PCB trace length of EMC_DQS[1:0] should be at least 2 inches (but not more than 4 inches) longer than EMC_DQ[15:0] and EMC_DQM[1:0]. On a typical FR4 PCB this adds at least 334 ps to set-up time margin for DDR writes. For reads from DDR the increased trace length of EMC_DQS[1:0] will be automatically compensated for by the software initialization function find_ddr_dqsin_delay() which sets the optimal value DDR_DQSIN_DELAY(SDRAMCLK_CTRL[6:2]). The function find_ddr_dqsin_delay() can be found in the "DDR SDRAM setup code for the LPC32x0 series" on the NXP web site. Example 128 MB system DDR SDRAM using a single EMC_DYCSx_N: LPC32x0 EMC DDR high byte (64M x 8) EMC_D[15:08] DQ7:0 22ohms EMC_DQS1 DQS 22ohms EMC_DQM1 DM BA1:0 / A12:0 nCS CKE, nRAS, nCAS, nWE CLK nCLK VREF low byte (64M x 8) V+_EMC EMC_D[07:00] DQ7:0 22ohms EMC_DQS0 DQS 22ohms EMC_DQM0 DM 20Kohms EMC_A[14:00] BA1:0 / A12:0 0.1uF 1% EMC_DYCS0_N nCS EMC_Control CKE, nRAS, nCAS, nWE EMC_CLK CLK 20Kohms 0.1uF 1% EMC_CLK_N NC nCLK VREF EMC_CLKIN Fig 5. 128 MB DDR SDRAM example ES_LPC3250 . Â© Rev. 9 â 1 June 2011 10 of 17 ES_LPC3250 LPC3250	3.4 DDR.2: DDR EMC_D[15:0] to EMC_DQS[1:0] data output set-up time, tsu(Q), for MCU write to DDR provides limited timing margin Remark: This affects both 1.8 V mobile and 2.5 V DDR SDRAM system implementations.
ARM9	NXP	LPC3250	DDR memory uses a differential clock which is generated by the LPC3250. The differential clock consists of two clock signals: EMC_CLK is the positive clock and DDR_nCLK is the negative clock. There is approximately 1.27 ns of skew between the low transition of the DDR_nCLK and the high transition of the EMC_CLK. This can cause two problems: 1) Some DDR devices use this clock transition to drive a digital lock loop (DLL) in the DDR device. The DDR clock skew can cause the DDR device's internal DLL to loose lock, resulting in the wrong data being latched. 2) The DDR clock skew can also cause a reduced Data Valid Window (also called Data-Out Window) from a DDR device. However, the LPC3250 has a programmable DQS delay to achieve center alignment for accurate data reads.	Connecting the DDR device negative clock input (DDR_nCLK from the LPC3250) to the DDR Reference Voltage (Vref - the midpoint of the DDR signal voltage swing, which is generally VDDQ/2) avoids the clock skew problem, though it also eliminates the advantages of differential signaling. The LPC3250 DDR_nCLK output should be left unconnected. DDR Reference Voltage can be generated with a divide-by-two voltage divider. Standard DDR memories usually require a Vref input, so this DDR reference voltage should already be available. Mobile DDR devices typically do not have a Vref input, so the external voltage divider may need to be added to the design for this work-around. It is also possible to compensate for the 1.27 ns clock skew by adding an additional 7 inches of pcb trace length to the EMC_CLK signal. However, this could have unintentional consequences; such as increased Electro-Magnetic Interference.	3.5 DDR.1: DDR interface has >1.2 ns clock skew
ARM9	NXP	LPC3250	The LCD controller is an AHB Master that uses an internal DMA controller to transfer frame data from memory to the LCD panel. The time required to read data from either SDR or DDR SDRAM using the LCD DMA controller takes longer than expected. This issue has little effect when the LCD DMA controller reads frame data from IRAM or external SRAM.	When using external SDRAM for the LCD framebuffer, use a display size and color depth that reserves sufficient system bandwidth for the remaining peripherals in the application. For systems using LCD displays sizes greater than QVGA and high color we suggest the use of external SRAM. ES_LPC3250 . Â© Rev. 9 â 1 June 2011 11 of 17 ES_LPC3250 LPC3250	3.6 LCD.1: Low throughput when LCD controller accesses DDR/SDRAM
ARM9	NXP	LPC3250	An ONSW output pin (M15) is included in the LPC3250 to assist in waking up the chip after power is removed from all functions except the RTC and Battery RAM. When there is an active match condition the RTC will drive the ONSW pin HIGH. The RTC only drives the ONSW pin while the match is active, and after 1 second of active match, if the software has not accessed the RTC block, the ONSW pin will go low when the match is no longer active. When power is removed from all functions except the RTC and Battery RAM, the RTC does NOT drive the ONSW pin HIGH when there is an active match condition.	There is no work-around for this problem.	3.7 RTC.1: An RTC match doesnât drive the ONSW pin active (HIGH)
ARM9	NXP	LPC3250	The LPC3250 contains 12 pins (GPI_00 - GPI_09, GPI_19, GPI_28 ) that function as dedicated General Purpose Inputs. Each of these pins can generate an individual interrupt for the input pin. Sub Interrupt Controller Register 1 (SIC1_ER) and Sub Interrupt Controller Register 2 (SIC2_ER) contains bits that allow enabling or disabling the interrupt for the associated pin. When bit nine is set to one in the Sub Interrupt Controller 2 Enable register (SIC2_ER[9]) it does not enable the interrupt for the GPI_08 pin. All other General Purpose Input pins (GPI_00 - GPI_07, GPI_09, GPI_19, GPI_28) interrupts work correctly.	There is no work-around for this problem. ES_LPC3250 . Â© Rev. 9 â 1 June 2011 12 of 17 ES_LPC3250 LPC3250	3.8 INT.1: GPI_08 does not generate an interrupt signal
ARM9	NXP	LPC3250	On the LPC3250, the Motor Control PWM (MCPWM) peripheral is optimized for three-phase AC and DC motor control applications and can also be used in applications which require timing, counting, capture, and comparison. The MCPWM contains three input pins (MCI0-2) for PWM channels 0, 1, and 2. The inputs can be used as feedbacks for controlling brushless DC motors with Hall sensors, and also can be used to trigger a Timer/Counterâs (TC) capture or increment a channelâs TC when MCPWM is configured as a timer/counter. Note: MCI0-2 pins are also called MCFB0-2 (refer to LPC32x0 User manual for more details). The input pins (MCI0-2) are not functional.	The GPIO interrupts1 need to be used instead of the MCPWM MCI0-2 pins. On the LPC3250, the GPIO interrupts can only be set to either trigger on the rising edge or on the falling edge. Therefore, in order to detect all six states of the connected hall sensor through an interrupt, the state of the pin needs to be determined and switch to rising or falling edge interrupt accordingly. 1. Available GPIO interrupt pins: GPIO_00 to GPIO_05, GPI_00 to GPI_09, GPI_19, GPI_28, and all port 0 and port 1 pins. ES_LPC3250 . Â© Rev. 9 â 1 June 2011 13 of 17 ES_LPC3250 LPC3250	3.9 MCPWM.1: Input pins (MCI0-2) on the Motor Control PWM peripheral are not functional
ARM9	NXP	LPC3250	The three high speed UART's (HSUART) receive (RX) FIFOs can sometimes enter a state where they no longer accept received data. When this state occurs, the HSUART's RX FIFO will no longer accept data regardless of RX FIFO fill status. The receive state of the HSUART may indicate a number of possible, but invalid, receive statuses. These invalid statuses may include RX FIFO or timeout interrupts pending with no receive data in the RX FIFO, invalid RX FIFO status, stuck RX interrupts, or other possible RX statuses. Once the HSUART enters this state, the state can only be cleared by a chip reset. This applies to the U1_RX, U2_RX, and U7_RX pins. The HSUART's transmit side is not affected by this issue and will work as normal when the HSUART receive side stops. The four standard UARTs do not exhibit this behavior. It has been determined that this failed receive state can be entered by receiving a burst of high frequency noise into the HSUART RX pin. High frequency noise consists of pulsed or random toggling of the HSUART RX line at about 2.5 MHz or greater. The chance of the HSUART entering the state increases with the number of pulses and frequency of the pulses received. Generally, a single pulse won't cause the state to occur. During normal data transfer with transfer rates 2400 bps (416 uS) to 921.6 Kbps (1.085 uS), this state won't occur. However, conditions outside the transfer itself may cause the state to occur. It has been observed in some systems that insertion of the serial cable into the board's serial connector can cause connection noise or oscillations on the transceiver. This noise is driven onto the HSUART RX pin from the transceiver as a series of random pulses.	If all 7 UARTs aren't needed or 921.6 Kbps transfer rate isn't needed, use the standard UARTs instead of the high speed UARTs to avoid the issue altogether. For systems that require the HSUARTs, care must be taken to limit the exposure of the HSUART RX signal for the type of signal conditions that can cause the state to occur. There are several possible solutions that can help reduce the state from occurring. Whenever the HSUART is not in use, place the HSUART into loopback mode. When in loopback, the RX pin is connected internally to the HSUARTs TX pin and is isolated from the external RX input. While in this loopback state, the condition won't occur on the HSUART regardless of the signal on the RX input. The HSUART TX pin will remain in the idle state in loopback mode when no data is being sent from the HSUART. Optionally, if the HSUART is connected to a transceiver that supports enabling and disabling of the input signal from the transceiver RX input to the transceiver RX output to the HSUART RX input, disable it when not expecting a transmission. Regardless of how the transceiver is connected to the RX pin, the RX pin should be prevented from floating at power-up, reset, or when the transceiver is disabled. This can be done by adding a pull-up resistor to the HSUART RX pin. If using a system where the HSUART always need to be enabled, consider adding the capability to sense when the cable has been plugged into the connector and switch the HSUART out of loopback mode only once the cable has been installed to prevent cable insertion noise. ES_LPC3250 . Â© Rev. 9 â 1 June 2011 14 of 17 ES_LPC3250 LPC3250	3.10 HSUART.1: High speed UART receive FIFO and status can freeze
ARM9	NXP	LPC3250	Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP. The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller.	None. 4. AC/DC deviations detail	3.11 USB.1: USB host controller hangs on a dribble bit
ARM9	NXP	LPC3250	The LPC3250 was designed to withstand electrostatic discharges up to 2000 V using the Human Body Model. The RESET_N pad (pin M14) does not pass ESD tests above 1000 V.	Observe proper ESD handling precautions for the RESET_N pin	4.1 ESD.1: Weak ESD protection on Reset_N pad
ARM9	NXP	MC9328MX21  MC94MX21	Details: For Infineon Cellular RAM HYE18P32160AC(-/L) 12.5, burst writes can work with the following constraints: 1. EW bit does not work correctlyâWhen the EW bit is set, failures are found when WSC= 7 and Cellular RAM is set up for LAT2. It does work when WSC=9 and Cellular RAM is set for LAT3. This greatly effects burst writes and reads. EW=0 always works (as NOR flash end current burst). 2. After performing a sync access (like burst read), the Infineon Cellular RAM expects another rising clock edge when CS goes high to terminate burstâIf the Cellular RAM is left idle after a burst read and NO rising clock edge is detected, it is stuck in sync mode not allowing internal refresh cycles to occurâthis will cause Cellular RAM to lose data. This appears to be more of an Infineon issue as Micron asserts the extra rising edge clock is not needed. Also, Infineon stated that in their next generation Cellular RAM this extra rising edge clock is not required. 3. BCS bits do not shift the burst clock correctlyâOnly BCS bit 0 (LSB) effects the shifting of burst clock, other bits do not effect burst clock phase (though they still effect LBA assertion time). 4. Only async writes are possible to Cellular RAM BCR and RCRâIn addition, when switching modes or re-programming the RCR/BCR, the system must first be placed back into async mode. 5. When D cache is enabled and EIM is doing async writes to the Cellular RAM, the EIM will hold CS asserted (low) for >10usâThis causes a problem for Cellular RAM because it cannot perform an internal refresh operation. The work around is to set CSA to 1 to force CS assertion between writes to allow time for Cellular RAM to refresh or to place EIM and Cellular RAM in sync mode of operation (burst writes) whenever D cache is enabled.	1. Cellular RAM is basically Mobile SDRAM with the exception of a NOR flash interface. MX21 has an SDRAM controller. System designers are advised to use Mobile SDRAM for its higher performance(133 MHz) and lower cost. 2. Recommend not to enable burst write and treat Cellular RAM as NOR flash burst interface.	EIM Cellular RAM support fails
ARM9	NXP	MC9328MX21  MC94MX21	Details/Impact: The PC_POE pin may cause system boot up failure when PCMCIA interface buffer is connected directly. This is due to PC_POE pin (muxed with NFCLE) driven low during initial boot (with/without NAND Flash) which enables the external buffer and results in data bus contention. This multiplexed signal can be re-programmed to perform the PC_OE function after the system starts up, therefore, only boot time is affected.	Add a logic gate on board between the PC_POE signal and the PCMCIA buffer such that the buffer is disabled at boot time. An additional GPIO is required to control the gate ON/OFF.	Inverted PC_POE causes possible system boot up failure when PCMCIA buffer is used
ARM9	NXP	MC9328MX21  MC94MX21	Details: The PCMCIA controller only supports up to 2 Kbytes of total space to map the attribute memory, common memory, or I/O space. However, the CF/CF+ specification and operating systems such as WinCE/PPC, require them to locate at a separate space and beyond the 2 Kbyte range. Impact: CF/CF+ cannot be supported on WinCE/PPC. Possible difficulty in building drivers in other OS.	CF/CF+ card support: No workaround available to support WinCE OS. For other OS, basic functionality can be fulfilled by allocating 1 Kbyte to attribute memory and 1 Kbyte to I/O memory or common memory.	Cannot fully support CF/CF+ specification.
ARM9	NXP	MC9328MX21  MC94MX21	Details: A total of 26 address lines are needed to fully support the PCMCIA standard. The i.MX21 processor does not support this many address lines. Impact: PCMCIA cards cannot be supported.	No workaround is available.	Not fully compliant with PCMCIA Ver. 2.1.
ARM9	NXP	MC9328MX21  MC94MX21	Details/Impact: In AC97 variable mode, the AC97 controller is required to process the SLOTREQ automatically and source data from the transmit FIFO. However, the SLOTREQ bits are not handled and no variable mode operation is possible.	No workaround is available.	AC97 Mode cannot be supported.
ARM9	NXP	MC9328MX21  MC94MX21	Details/Impact: When TE has been enabled and RE is enabled in the middle of a valid frame, the SSI starts to receive data immediately without synchronizing with the next frame sync event. This causes the receiver section to remain out-of-sync with the frame timing and results in incorrect data received.	System designer is advised to: 1. Wait for the TLS (Transmit Last Slot) interrupt before enabling the receiver, Or 2. Disable the transmitter, then enable both transmitter and receiver simultaneously.	SSI does not wait for frame sync to receive data when RE is enabled in sync mode.
ARM9	NXP	MC9328MX21  MC94MX21	Details/Impact: The counter is enhanced to reset automatically in restart mode. However, the change also influences freerun mode. The counter is now reset whenever the compare register is written. Applications are affected that allow compare values to change from time to time.	If more than one compare event is needed in freerun mode, use software comparisons instead.	The GP timer counter is reset even in freerun mode whenever the compare register is written.
ARM9	NXP	MC9328MX21  MC94MX21	Details: In EIM Chip select control register, there are two bits controlling the RW assertion and deassertion (negation) time: RWA and RWN. It is found that RWN incorrectly influences the assertion of the RW signal when RWA = 0 and RWN â¥ 1. The RW signal assertion is delayed 1/2 HCLK later. The RW signals acts as though RWA is set to 1, even though RWA bit is cleared in software. Other settings work correctly. Impact: Minimal. A slight timing delay is introduced to RW signal assertion.	No workaround is available.	RW assertion incorrectly influenced by RWN bit in EIM module when RWA = 0 and RWN â¥ 1.
ARM9	NXP	MC9328MX21  MC94MX21	Details/Impact: Standby current at QVDD and NVDD is higher than the typical value specified in data sheet.	No workaround is available.	Standby current at QVDD and NVDD is higher than the typical value specified in data sheet.
ARM9	NXP	MC9328MX21  MC94MX21	Details/Impact: When setting BMI Tx_Water_Mark bit to 0000, TxF_EMPTY status bit will always be set. This makes detecting 16 empty slots in FIFO impossible and user will not be able to check if the last data has been transmitted. Therefore, variable burst transfer cannot be supported.	System designer is advised to define data transfer with a fixed burst length for reliable communication.	BMI Tx_Water_Mark bit = 0000 fails.
ARM9	NXP	MC9328MX21  MC94MX21	Details: Memory access may fail at the following condition: 1. Both CSD0 and CSD1 are used, and 2. Both Power-down time-out bits of SDCTL0 and SDCTL1 are programmed to non-zero. Impact: As SDRAM cannot be put to power down mode, a slightly higher operating power may result. This issue does not affect self refresh mode operation and no difference in sleep mode power will be seen.	It is advised to program Powerdown Timout bits of SDCTL0 and SDCTL1 to ZERO when using both CSD0 and CSD1. This issue does not happen when single CSD0 or CSD1 is used.	SDRAM Power Down mode failing to support both CSD0 and CSD1 simultaneously.
ARM9	NXP	MC9328MX21  MC94MX21	Details/Impact: NAND Flash controller drives the NF_CE signal high in tR period. For NAND Flash memory that requires CE_B to be held low during the tR period, memory access failure may result.	This can be accomplished through the use of an external AND gate, where the NFCE and NFRB signals of the i.MX21 are inputs to the AND gate and the output is connected to the CE_B input of the NAND Flash device.	Cannot support NAND Flash memory requiring CE_B pin held low during tR (data transfer from cell to register) period.
ARM9	NXP	MC9328MX21  MC94MX21	Details/Impact: After sending the first block of data, the SDIO controller operation will stop if there is no BUSY signal detected. Therefore, multiple block transfers without any BUSY signal responding from card cannot be supported.	No workaround is available for multiple block transfers. It requires card manufacturers to modify their firmwire to use single block transfers if not currently supported.	Multiple block transfer support fails if no BUSY signal is detected.
ARM9	NXP	MC9328MX21  MC94MX21	Details: When the boot mode is set to NAND Flash boot-up, after the reset_in signal is asserted, the processor needs to wait about 10 seconds before continuing the boot-up process. Impact: During the NAND Flash boot-up process, there is a waiting loop that checks the transfer of boot code completion (bit 15 of NAND FLASH Operation and Configuration register 2, NAND_Flash_Config2). However, the bit will not set immediately because the NAND Flash controller will not transfer the whole code during reset_in assertion time. It is required to wait 10 seconds for the NAND Flash controller to reset when a soft reset (Reset_In or Watchdog reset) occurs.	No Workaround is available	NAND Flash warm reset delay
ARM9	NXP	MC9328MX21  MC94MX21	Impact: Not able to support single chip 4M x 16-bit (8Mbyte total size) SDRAM devices or devices with a page size of less than 1 kilobyte. A page size is defined as the number of bits in a row in the SDRAM device.	Must use SDRAM devices with 1 kilobyte or greater page sizes.	Cannot support SDRAMs with less than 1kilobyte page size.
ARM9	NXP	MC9328MX21  MC94MX21	Impact: Not able to support single chip 32M x 16-bit (64Mbyte total size) SDRAM devices or devices with a column address size of 10.	For 64 Mbyte SDRAM devices the configuration of 16M x 32 or two 16M x 16-bit must be used to form a 32-bit data bus, where either configuration contains only 9 column addresses.	Cannot support SDRAMs with column address sizes of 10.
ARM9	NXP	MC9328MX21  MC94MX21	Details: In cases when there are single-bit errors in two consecutive page reads, then the error in the second page is not corrected by the NFC. Impact: NFC error correction logic is faulty on read accesses and errors in consecutive pages are not fixed. Thus, software must correct the errors in place of the hardware. Special care must be given when booting from a Nand Flash for both 512 bytes, and 2 Kbytes page boot optionsâsee details under Workaround.	In general, when reading from Nand Flash, SW must turn off the code correction in HW (ECC) and perform the correction in SW (done by performing error check and correction at the end of each page). When booting from Nand Flash, the Nand Flash Controller (NFC) copies the first 2Kbytes to internal RAM and jumps to the beginning of the code. This is done with no option for SW intervention/modification, so the aforementioned general guideline could not be applied. Note: If the NAND flash requires Error Correction on the initial block, then the following procedure is required. Otherwise, apply the S/W ECC after boot up: Due to the nature of this bug, any single-bit error (if found) in the first 512 bytes (first page) is corrected properly, therefore, "specialâ boot loader code must be placed in those first 512 bytes. The loader code, once executed, must then perform the following: 1. Turn off error correction in HW. 2. Re-load pages 2, 3, and 4 (which comprise the remaining 1.5 Kbytes of code). 3. For every page read, perform error correction in SW. 4. Continue normal execution.	NFC (Nand Flash Controller) fails to correct two single-bit errors if they occur on consecutive pages, on data read accesses.
ARM9	NXP	MC9328MX21  MC94MX21	Details: When doing single or multiple DMA transfers the action of clearing a single DMA bit from the DISR register can result in clearing the whole DISR register. Impact: If the DISR register cleared accidentally, then an interrupt for DMA transfers does not take place. This can be an issue when there are multiple DMA channels transferring data at the same time. The Interrupt Service routine can miss interrupt notifications that DMA transfers have happened.	Do not access the DISR register to clear DMA transfer interrupts. Instead clear the interrupt of each DMA being used by setting the SMOD bits of the DMA CCR register for the DMA channel being used. Software Example: // pointer to 32bit program register DMA_CCR0 volatile unsigned int * P_32_DMA_CCR0 ; int tmp ; // save the old value of CCR tmp = *(P_32_DMA_CCR0+(0x40*channelID)) ; //Force DMA channel's source mode as reserved "11" to clear the DISR bit for the selected channel * (P_32_DMA_CCR0+(0x40*channelID)) = tmp | (0x3<<10); // restore the old value back into CCR	The DMA DISR register may be cleared accidentally when trying to clear any interrupt in the DISR register
ARM9	NXP	MC9328MX21  MC94MX21	Details: In 4 bpp, 8 bpp, 18 bpp, and TFT modes, LSCLK is missed in these conditions: â¢One clock cycle before every OE_ACD assert timing â¢Every VSYNC rising timing â¢Every VSYNC falling timing Impact: If the user connects LSCLK directly with LCD panel and the LCD panel allows missing clock, there is no issue. However, if the user adds a serializer between LSCLK and LCD panel, the serializer may not work correctly because of the missing clock and the LCD panel may have noise.	Connect LSCLK directly with the LCD panel, if the LCD panel allows it.	LSCLK is missing.
ARM9	NXP	MC9328MXS	Impact: If SyncFlash channel is disabled, the SDRAMC puts the syncflash into a mode called deep low-power mode. When the SyncFlash is re-enabled, it requires a 100 Î¼s period to initialize before allowing any access to it. The current design does not have a built-in timer to prevent access before 100 Î¼s has passed. Therefore, an access occurring during this time period could return invalid data from the SyncFlash.	Use the TIMER register to count 100 Î¼s to determine the time period during which the user is not allowed to access the SyncFlash.	It is necessary to use a separate timer to prevent access to the SyncFlash immediately after the SyncFlash is re-enabled from deep low-power mode
ARM9	NXP	MC9328MXS	Impact: Typically, the back-to-back burst access that does not use the IDLE cycle as a separator occurs for operations such as cache fill, miss, and burst operations by the ARM processor. In cases such as this, the MEMC arbiter incorrectly treats the back-to-back sequence as a single instruction process that causes the other bus masters to wait longer to access the bus. On the AHB bus, only the LCDC and MMA modules are affected. Because the MMA is not a periodic and time critical module with regards to requesting the grant of the bus, the impact of this issue is minimal, although the LCDC frame buffer refresh can be greatly impacted.	Use a dummy DMA transfer to and from a dummy memory space to force the MEMC to release the bus for other bus masters. For more detailed information and code example, please visit our website www.freescale.com/imx.	The Memory Controller arbiter (MEMC) does not break and release the ARMâ¢ coreâs back-to-back burst access to the other (for example, LCDC, DMA, and MMA) bus masters. In this situation, the ARM coreâs back-toback access does not use an IDLE cycle as a separator.
ARM9	NXP	MC9328MXS	Impact: The DMA request does not clear after the reception of a short packet, causing a long packet to start filling in the FIFO before the data in the short packet is moved out of the FIFO. This causes the USBD FIFO to overflow and generate an error that prevents a DMA interrupt DMA_ISR from being generated. This occurs because the ALARM bit (DMA request) being cleared is based on the setting of the 4*GR[2:0] granularity bits in USB_EPn_FCTRL register. The ALARM bit for IN transfer is set when the amount of data bytes that remain in the FIFO is below the alarm value (ALARM[5:0] in the USB_Epn_FALARM register and cleared when there is less than 4*GR[2:0] of free bytes that remain in the FIFO. The Granularity bits GR[2:0] are fixed at 3 bits regardless of the FIFO depth. For IN transfer, DMA requests are cleared when FREE data bytes are 4*GR[3:0]. Because GR[2:0]=3 * 111 as a maximum value, there can only be 28 free bytes. Therefore, a 6 byte short packet in the 64-byte FIFO will not dessert the DMA request.	Two methods are used to prevent this limitation depending on the data packet size: 1. For data packet sizes of less than 5 bytes: After the short packet data transfer, software must poll the USBD BYTE_COUNT==0 before initiating the next DMA transfer. This ensures that FIFO can accept the next long data packet of 64-bytes. 2. For data packet sizes of 5 bytes and greater: Use a 32-byte FIFO instead of a 64-byte FIFO to ensure that the DMA request is cleared. The granularity bits GR[2:0] must be set to 111.	Limitation on using DMA for USBD IN data transfer. There is a limitation on using DMA to transfer continuous data from memory to a 64-byte USBD FIFO (FIFO1 and FIFO2) when using a short packet (<37 bytes) followed by a long packet (> 32 bytes). For example: A 6 byte packet followed by a 64 byte packet, or a 32 byte packet followed by a 40 byte packet such that the short packet length + the long packet length is greater than 64 bytes (FIFO depth).
ARM9	NXP	MC9328MXS	Impact: This double interrupt is the result of a glitch produced by the seconds counter bits 1 and 0. Bit 0 of the seconds counter has greater loading than bit position 1. Upon receiving a clock signal to update the seconds counter, the seconds counter bit 0 changes state to be slower than counter bit 1. This glitch causes the alarm to see a momentary match, triggering the interrupt one second early. When the seconds counter actually does match the alarm value, another interrupt is triggered (if it has not been disabled following the previous interrupt) at the correct time. For example: If you set the alarm to âxx : xx : xx : 15 secâ, when the second counter changes from 13(1101) to14(1110), the bit position 1 changes faster than bit position 0. The result is 13(1101) to 15(1111) to 14(1110). This 15(1111), the glitch, matches the alarm setting and triggers the interrupt.	Either set the seconds alarm register to an even value or, if set to an odd value, when the interrupt occurs, check the current time against the alarm time. If it does not match, then clear the interrupt and return. The actual interrupt will occur one second later.	An alarm set to an odd number of seconds results in a false interrupt one second before the actual alarm time, followed by the actual interrupt.
ARM9	NXP	MC9328MXS	Impact: Using the workaround, the power-up current can be minimized to less than maximum specified operating current.	Attach a 1 KÎ© series resistor to each tied-low input pin.	Power-up leakage during the recommended power-up sequence, NVDD>AVDD>QVDD. In the normal configuration, the maximum current leakage occurring during the power-up period can be up to 600mA
ARM9	NXP	MC9328MXS	Impact: The low mark must never be set higher than 10 and the high mark must be set at 3.	For a bus that is heavily loaded and that requires SDRAM access, a dynamic burst length is recommended: â¢fixed burst length = 0 â¢high mark = 3 â¢low mark = 8 For a very heavily loaded system, increasing the low mark value increases the chance of a bus grant of the system bus, at the expense of more frequent bus requests.	The LCD flicker issue is not completely resolved by the use of dummy DMA transfer (See Erratum number 7). The LCDC DMA high/low setting does not ensure that the next bus request is triggered in the event the current DMA burst is not completed. The problem occurs when the next bus request is initiated while the LCDC is waiting for the last data in the current DMA burst. This is because when the LCDC is waiting for the last data, it only expects an HREADY signal to be asserted. So, if the next bus request is triggered while the LCDC is waiting, the bus request will be missed. A data fetch can not be initiated while data in FIFO is being continuously drained so an under-run will eventually occur. In Summary: If the next bus request is issued when the LCDC is waiting for the last data in the current DMA burst it will not be recognized.
ARM9	NXP	MC9328MXS	Impact: When CS5 is configured to an external input DTACK signal to terminate the bus cycle (for example WSC = 0x3F), using either DTACK mode (DTACK_SEL = 0) or WAIT mode (DTACK_SEL= 1), the CPU or DMA read cycles in CS5 memory space may terminate incorrectly. CS5 can function normally by using wait state control bus terminationâthat is, WSC is not set to 0x3F. All write cycles will function correctly.	DTACK mode (DTACK_SEL = 0): No workaround. WAIT mode (DTACK_SEL=1): In Wait mode the OE signal for read cycle is negated up to 1 system clock before a data latch occurs at the end of bus cycle, possibly causing incorrect data to be latched by the i.MXS because the external device releases the data bus after OE negates. The workaround is to use external logic (one D-flip flop and one OR-gate) to extend OE negation time until the CS cycle is completed (after or at CS5 rising edge). D-FF connection must be D=1, RST= /OE OR /CS5, CLK= CS5, Q=NewOE for DTACK device only. To avoid disrupting other devices using /OE, the NewOE signal only replaces the /OE signal going to a DTACK device. See Figure 1. /OE /CS5 rst1 /NewOE for device DQ using DTACK only /CS5 set 1. If using LCX logic from ON Semiconductor, expect propagation delays from /OE and /CS assertion to /newOE of 3.0 to 12.5 ns. Freescale Semiconductor cannot recommend one supplier over another and in no way suggests that ON Semiconductor is the only supplier of logic devices. Figure 1. D-FF Connection Workaround	CS5 fails read operation when using the DTACK function.
ARM9	NXP	MC9328MXS	Impact: When the DTACK signal is not used, toggling the GPIO pin PA17 will adversely affect the other EIM chip-select functions.	PA17 is restricted for the DTACK functionality only. Thus, in any other situation when DTACK is not used, this pin must be pulled up or tied high (may be done by simply setting the corresponding PUEN bit, configuring it as an input, and leaving the pin unconnected). If the DTACK functionality is used, the pin will only toggle during CS5 accesses and should not toggle during any non-CS5 access.	Port A pin 17 (multiplexed with DTACK) inadvertently affects other chip-select functions when DTACK is not used.
ARM9	NXP	MC9328MXS	Impact: Not able to support single chip 4M x 16-bit (8 Mbyte total size) SDRAM devices or devices with a page size of less than 1 kilobyte. A page size is defined as the number of bits in a row in the SDRAM device.	Must use SDRAM devices with 1 kilobyte or greater page sizes.	Cannot support SDRAMs with less than 1kilobyte page size.
ARM9	NXP	MC9328MXS	Impact: Not able to support single chip 32M x 16-bit (64 Mbyte total size) SDRAM devices or devices with a column address size of 10.	For 64 Mbyte SDRAM devices the configuration of 16 M x 32 or two 16M x 16-bit must be used to form a 32-bit data bus, where either configuration contains only 9 column addresses.	Cannot support SDRAMs with column address sizes of 10.
ARM9	NXP	MC9328MXS	Impact: In 16-bit mode, burst access is not guaranteed for SDRAM with number of columns not equal to 9. Known impact is failure to support following devices in 16-bit mode: a. SDRAM with 12 Rows and 8 Cols (4Mx16-bit, 8MB total size) b. SDRAM with 13 Rows and 10 Cols (32Mx16-bit, 64 Mbyte total size)	No workaround is available. Recommend system designer to use 32-bit SDRAM if 8 Mbyte or 64 Mbyte memory configuration is desired.	In 16-bit mode, only SDRAM device with 9 Cols are supported
ARM9	NXP	MC9328MXS	Impact: When a load multiple (LDM) instruction is used to load two specific registers from an un-cached region of memory, and the load instruction begins immediately after a delayed buffered write, then the LDM will not load the second register correctly.	The ARM Realview 3.0 SP1 Build 617 compiler and linker have a patch that addresses this issue. With this patch applied, the compiler will not generate this LDM instruction. The Build 617 patch is available to download from the ARM website. To use the patch, users must insert â--branchpatch 920t-ldm2â to the compiler and linker command lines. For code compiled by a compiler other than the above stated tool, a manual search and replace for the LDM instruction of two values in assembly code can be done with multiple options for equivalent code replacements. Example 1: LDMIA r0, {r1, r2} is functionally IDENTICAL to: LDR r1, [r0] LDR r2, [r0, #4] Example 2: If updating the base register to a new value, such as: LDMIA r0!, {r1, r2} then this is functionally IDENTICAL to: LDR r1, [r0], #4 LDR r2, [r0], #4	LDM instruction fails to load non-cached data from memory
ARM9	NXP	MC9328MXS	Impact: A parity error in UART character transmissions may occur. TxFIFO data being shifted out is not alterable after the start bit is issued. However, the parity bit can change after the start bit is issued and is not fixed until data Bit0 is issued. If the TxFIFO is overwritten by the CPU during the interval from the end of the start bit to the end of the data Bit0, there will be a mismatch between the data shifted out and the parity bit. In this case, a parity error may occur.	The following software solutions are recommended to be used in Interrupt Service Routines (ISRs) to avoid the parity bug. Polling can also be used instead of interrupts. 1. A maximum of 32 bytes can be written into the TxFIFO when transmission is complete (USR2.TXDC = 1). 2. A maximum of 31 bytes can be written into the TxFIFO when the TxFIFO is empty (USR2.TXFE = 1). 3. A maximum of 32 - n bytes, where n = UFCR.TXTL, can be written into the TxFIFO when the data level in the TxFIFO falls below the selected threshold (when USR1.TRDY = 1).	Parity bug in UART transmitter
ARM9	NXP	MC9328MXS	Impact: Receive malfunction: Rx data is usually taken with the period of FS=H. However, in some special use cases, it is changed to period of FS=L. Once this occurs, this period never returns to the period of FS=H. The issue occurs in the following conditions: Normal mode Sync mode Slave mode Some additional conditions of this scenario are: TX and RX are used at the same time (full duplex) SYN=1,RXDIR=0,TXDIR=0,TFDIR=0 External clock is 2.048MHz Frame frequency is 8kHz Frame pulse width is 1 word (8 clock) SSI_EN and RE is set to 1 within latter 4 clocks of FS=H period (8 clocks) Transmit malfunction: TxData is changed to different value at only the first time of transmitting when TE bit is set just before FS signal or within FS timing.	To ensure a gap of at least 2 bit-clock cycles between SSI_EN and TX/RX bit setting (only for External word-wide frame-sync patterns), here is an example code for this workaround. void ssi_transmit_receive_test() { //parameters defined here Statement1 (); //clock configuration here Statement2(); //AUDMUX configuration here Statement3(); //SSI configuration here Statement4(); //Enable SSI by programming SSI_SCR MEMWD(SSI2_SCR,scr_mask1); //delay some time for the SSI state machine to function //properly for(i=0;i<=5;i++); //Enable transmit and receive of SSI by programming //SSI_SCR MEMWD(SSI2_SCR,scr_mask2); ...... }	In word-wide frame-sync mode, if SSI_EN and TX/RX_EN are set near new frame start, SSI Receive and Transmit does not function properly and there is a chance of words getting missed/shifted or transmit data line being driven low for 1/2 clock cycles during the first frame.
ARM9	NXP	MCIMX27	Description: Video Codec module supporting MV and MVD ranges does not conform with the H.264 standard. â¢The standard specifies the range of MVD to be â4096 to 4095.75. However, the Video Codec module only supports up to â2048â2047.75. â¢The standard specifies that the range of horizontal MV to be â2048 to 2047.75. However, the Video Codec module only supports up to â1024 to 1023.75. Because the maximum image resolution in the i.MX27 device is 720 Ã 576, it is not likely to receive a bitstream with MV/MVD in such a large range in real codec applications; therefore, there is no real impact to applications.	No workaround	Video Codec module supporting MV and MVD ranges does not conform with standard.
ARM9	NXP	MCIMX27	Description: In Host mode in the ULPI core, a remote wake-up can be interpreted as a disconnect. This issue involves the latency when asserting in synchronous mode. In some instances, the host will not properly latch the K state. When this occurs, the core wakes up to a J state. Eventually the host will not resume, and will show an SE0 and assume a disconnect occurred.	No workaround	A remote wake-up can be interpreted as a disconnect.
ARM9	NXP	MCIMX27	Description: When a burst access to WEIM external memory is immediately followed by another burst access, the first word may be missed at write-burst access because the eb_b signal comes too late. Reason: The ecb_hburst_ecb_fw signal in the WEIM Bus Controller module has an extra-high pulse, and only one high pulse is required.	Set EDC field to two breaks, which continues the burst access to external memory.	A burst write access will miss the first word when the burst write follows another burst operation
ARM9	NXP	MCIMX27	Description: During encoding or decoding MPEG-4, the Video Codec module can lock up. In the combined AXI to AHB and 32â64 gasket, there is a FIFO for read data, which buffers data that is coming from the 64-bit bus faster than the 32-bit bus can accept it. There is no logic to send a request to memory only when the FIFO has room for return data. In a case with ideal data throughput, this FIFO overruns and read data is corrupted. This ideal data throughput only happens during MPEG-4 encoding and decoding.	â¢Set the Latency Hiding Disable (LHD) bit in the ESDCTL DDR Controller ESDMISC register. This adds latency between DDR transactions, removing the ideal data throughput. This should only be done during MPEG-4 encoding and decoding. Note that this reduces performance. During MPEG-4 encoding/decoding, this degradation is acceptable. LHD should not be set during H.264 or H.263 operation. â¢Assign all buffers accessed by the video code into the same DRAM bank and ensure every buffer type has a size of integer number of pages. This ensures that there is a page miss between accesses of different sub-masters inside the VPU, increasing the delay. The DRAM is split into four equal sizes called banks, so the bank size is 1/4 of the DRAM size.	Lockup of Video Codec in MPEG-4 encode or decode Note: Applies only to silicon revision 2.0
ARM9	NXP	MCIMX27	Description: Timing is not properly extracted for the boundary scan circuitry so post-layout gate-level simulations did not correctly simulate the circuit. A race condition prevents proper shifting of data through the Boundary Scan circuitry.	None	Boundary scan fails because of an internal timing issue. Note: Applies only to silicon revision 2.0
ARM9	NXP	MCIMX27	Description: Internal fuses on the processor could be unintentionally programmed, regardless of the voltage level set for FuseVDD. Even if FuseVDD is set to 1.8 V (read-only voltage), some processors may be programmed at that voltage. This only happens when the incorrect power-up or power-down sequence is used on the processor.	It is recommended to power up and power-down the processor following the power-up and power-down sequence documented in the MCIMX27 Multimedia Applications Processor Data Sheet.	When the incorrect power-up or power-down sequence is used on the processor, unintentional programming of IIM fuses is possible, regardless of the set FuseVDD voltage, reconfiguring the part permanently.
ARM9	NXP	MCIMX27	Description: The gasket that is between the Post Processor and the EMI cannot support burst accesses when the burst length is equal to or over 16 words. However, the Post Processor will do the burst access over 16 words when it resizes with the horizontal scale over 2. In this case, the Post Processor's access misses the data or will be pending due to no response from the gasket.	Use software for horizontal resizing when the scale is bigger than two. For example, when the scale is 2.5 for both horizontal and vertical, software should be used to produce the horizontal resize with scale 2, and the Post Processor should do the vertical 2.5 and horizontal 1.25 resize.	Resize fails when the horizontal scale is bigger than two.
ARM9	NXP	MCIMX27	Description: The AUS bits in the WEIM Configuration Register (WCR) do not work for the address bus bit A[23]. The WEIM address busâ most significant bits (ADDR[25:16], Address Bus MSB) are used for address bits [25:16]. If the corresponding AUSx bit (each WEIM chip select has a corresponding AUS bit) is set to 1 in the WCR register, then these MSB signals reflect the AHB address bits [25:16]. If the AUSx bit is set to 0, then these signals should represent AHB address bits [27:18] for word width memory, [26:17] for half word width memory, and [25:16] for byte-width memory. The error occurs when the AUSx bit is set to 1, which causes the A[23] bit to not match the correct value of the corresponding AHB address bit. Reason: This errata affects all Chip-Select regions (that is, CS0âCS5). You cannot use the WEIM AUS feature to use un-shifted address mode if address bit A[23] is needed to address the external memory device.	Set AUSx to 0, if address bit A[23] is needed to address the external device.	AUSx bits do not work for address bit A[23]. Note: The AUS feature is not only for ADDR[25:16] (Address Bus MSB), but also for ADDR[15:0] (Multiplexed Address Bus LSB)
ARM9	NXP	MCIMX27	Description: End current burst (WAIT). This active-low input signal ECB is asserted by external burst capable devices. It is serviced only in synchronous mode (SYNC = 1).This signal can be used in the following modes depending on the EW bit in the Chip Select Control Register. â¢ In the ECB mode (EW = 0), ECB indicates the end of the current (continuous) burst sequence. Following assertion, the WEIM terminates the current burst sequence and initiates a new one. â¢ In the WAIT mode (EW = 1), the memory device asserts this signal to insert WAIT states during refresh collisions or during a row boundary crossing. Following assertion, the WEIM does not terminate the current burst sequence and continues it once WAIT is negated. FCE is a parameter in the register CSCRxA that is used to enable or disable feedback clock: â¢ If FCE = 0, WEIM samples the data by internal AHB bus clock. â¢ If FCE = 1, WEIM samples the data by BCLK_FB signal that is from PAD. â¢ If FCE is configured to 1 and there is ECB assertion during access, WEIM does not sample the correct data. Reason: You cannot use FCE = 1 mode when there is ECB assertion during access.	If external device asserts ECB_B signal during burst access in FCE = 1 mode, use FCE = 0 mode instead.	In FCE = 1 mode, WEIM cannot correctly sample the data if there is ECB asserted during burst access
ARM9	NXP	MCIMX27	Description: There is a design errata in the i.MX27 PLL/DIV design, which causes the ARM_CLK to have an incorrect duty cycle. The root cause of this issue is due to an uninitialized node in the PLL, clock gating, and divider circuitry, so the probability of this issue is random. This error causes the ARMâ¢ and DDR clocks duty cycle to be 66% when they are running at 266 MHz and 75% when at 399 MHz, instead of 50%. Projected Impact: The result of the incorrect duty cycle of the clock is that the ARM core might halt. This issue affects systems that enable 399 MHz for the ARM core.	There are both a hardware and a software workaround. To guarantee correct operation, the software workaround should only be applied to devices that have had the new PLL test applied. The test will be applied from a date code 1105: â¢ Workaround 1âHardware: Keep MPLLVDD < 200 mV during the initial part of the power-up sequence and delay the MPLLVDD supply with respect to QVDD, NVDD5, and AVDD. See Figure 1 for a recommended power-up sequence. This workaround sets the uninitialized node to the correct state enabling the appropriate 399 MHz clock output duty cycle. For the clock switching errata workaround, the following conditions must be satisfied: â QVDD must be powered up before MPLLVDD. â NVCC5 must be powered up before MPLLVDD. (This is required for the POR_B signal to propagate to the clock gating logic.) â AVDD must be powered up before MPLLVDD. (This is required for the POR_B signal to propagate to the clock gating logic.) â MPLLVDD must be driven to 0, not floating, before powering up A suggested delay circuit is described in Figure 2. â¢ Workaround 2âSoftware: Originally for the ARM clock to work at 400 MHz, the MPLL is configured for 800-MHz operating frequency at the 2x Clock Port (see Figure 3 and code that follows the figure), and the DIV2 divider is selected by software to achieve the 400-MHz operating frequency at the ARM core. The default 266-MHz frequency is achieved by using the DIV3 divider with an 800-MHz frequency at the 2x Clock Port (so 400-MHz MPLL frequency). The intent of this workaround is to reconfigure the 2x Clock Port to 1.2 GHz (600-MHz MPLL frequency), and continue to use the DIV3 divider in order to achieve the 400-MHz operating frequency. This avoids switching to the DIV2 divider, which introduced the problem.	Boot problem due to improper clock duty cycle Note: Systems that use 266 MHz are not affected by this bug.
ARM9	NXP	MCIMX27	Description: Any read access from the Clock Controller Module SPCTL0 register will clear the contents of the register. Projected Impact: For silicon revision 2.0 and prior, any read access performed from the Clock Controller Module SPCTL0 register will clear the contents of the register.	The SPCTL0 register needs to be re-programmed after each read access: either with a new value, or with the same value that was just read.	Read access to Clock Controller SPCTL0 register clears it
ARM9	NXP	MCIMX27	Description: In 4 bpp, 8 bpp, 18 bpp, and TFT modes, LSCLK is missed in these conditions: â¢One clock cycle before every OE_ACD assert timing â¢Every VSYNC rising timing â¢Every VSYNC falling timing Projected Impact: If the user connects LSCLK directly with LCD panel and the LCD panel allows missing clock, then, there is no issue. However, if the user adds a serializer between LSCLK and LCD panel, then, the serializer may not work correctly because of missing clock and the LCD panel may have noise.	Connect LSCLK directly with LCD panel, if the LCD panel allows it.	LSCLK is missing
ARM9	NXP	MCIMX27	Description: There is a limitation in the i.MX27 CCM module of the latest i. MX27 silicon (rev 2.2). This limitation requires that the MPLL can only be restarted under the following conditions: â¢ CSCR register bit fields: ARMSRC == 1 and ARMDIV[1:0] == 00 (meaningARM_CLK is divided by 2 from MPLL_CLK) or â¢ CSCR register bit fields ARMSRC == 0 and ARMDIV[1:0] == 00 (meaning ARM_CLK is divided by 3) and MPLL 2x output is greater than 537 MHz. The ARMSRC and ARMDIV bits can be configured to any value required by the application immediately after the MPLL restart.	Make sure either of the following two conditions are satisfied when MPLL is restarted: â¢ ARMSRC == 1 and ARMDIV[1:0] == 00 or â¢ ARMSRC == 0 and ARMDIV=[1:0] == 00 AND MPLL 2x	MPLL restart limitation. Applies only to silicon rev. 2.2.
ARM9	NXP	MCIMX27	Description: A âwarmâ reset is a reset initiated by a watchdog timeout, RESET_IN, or by software forcing a reset via the watchdog module. Such a reset will reconfigure all the CCM registers to their default values but it will not restart the MPLL, so the full CCM configuration defined by the registers does not take effect. In particular, MCU_SEL is cleared, selecting the internal FPM output. Changes to ARMSRC and ARMDIV also take immediate effect. As a consequence, if the external high frequency reference clock is slower than the internal FPM output, and the MPLL has been configured to operate at 1.2 GHz, the MPLL will exceed the specified limite of 1.2 GHz. For example: Given an external high frequency clock of 24 MHz, a low frequency clock of 32 kHz, and the MPLL configured for 1.2 GHz (MF=50) using the external 24-MHz clock as the reference, the following will occur: After a warm reset, the MPLL will continue using MF=50, because the CCM registers are reset to default values but the PLLs are not restarted. As a result, the MPLL will lock to the FPM output (32.768 MHz, selected by the default value of MCU_SEL in CSCR), driving MPLL output frequency to 1.64 GHz, which is beyond the specified maximum.	1) Reconfigure the MPLL prior to a warm reset to avoid exceeding the 1.2-GHz maximum MPLL output frequency. This workaround only works when warm resets can be anticipated. 2) In applications that cannot anticipate a warm reset, as in the case of RESET_IN from somewhere else in the system or a watchdog timeout, the MPLL should be operated at a sufficiently lower frequency so as to prevent a warm reset causing the MPLL to exceed 1.2 GHz. 3) The CLKMODE[1:0] pads may be used to bypass the FPM and	MPLL reference clock source change following a warm reset.
ARM9	NXP	IMX28	The HW_PXP_CSCCOEFF2_C3 register does not receive the correct reset value after using the  PXP software reset function or after power up.The PXP operates incorrectly with wrong coefficient setting.	Always write the HW_PXP_CSCCOEFF2_C3 register with the expected value before using it. The  PXP_CSCCOEFF2 register address is 0x8002A0F0.	PXP: The HW_PXP_CSCCOEFF2_C3 register can not be reset  correctly under some PVT corner
ARM9	NXP	IMX28	The USB controller may not operate properly when receiving a packet in INCR8 and INCR16  modes. The packet is completed correctly (ACK is sent) on the USB bus, but cannot be seen by  software.  This issue exists when all of following conditions are met:  1. Controller is receiving data (Host Bulk IN or Device Bulk OUT)  2. Primary INCR8/INCR16 mode is selected (SBUSCFG. AHBBRST of the USB register is set  to 0b010 or 0b011)  3. Length of data received is less than the total_byte field in TD  4. Data length is not a multiple of the burst size and the remainder is a sub-burst. For example, if  the data length is 32n + 16 bytes in INCR8 mode, or 64n + 16/32/48 in INCR16 mode, this  errata is triggered.  Projected Impact:  This is a low severity bug because INCR8 and INCR16 are not mandatory modes. Other modes  should be used.	Set SBUSCFG.AHBBRST of the USB register to a modes other than 0b010 or 0b011.	USB: USB core INCR8 and INCR16 modes are inoperable
ARM9	NXP	IMX28	The ARM writes a data error to the USB core register unless SRM SWP instruction is used.  The issue occurs when all of the following conditions are met:  1. Last AHB access is to the non-USB AHB slave  2. Current AHB access is to the USB  3. These two accesses are back-to-back  4. The last data phase of the last AHB access has a wait state  5. Only happens when D-cache is enabled Projected Impact:  The USB register does not get correct data when writing to the USB slave through the AHB bus  when D-cache is enabled	All USB register write operations must use the ARM SWP instruction.	USB: ARM to USB register error issue
ARM9	NXP	IMX28	The PWM channel might not generate the required output signal when in HSADC driving mode.  When in HSADC mode, if the HSADC input clock is much lower than the APBX bus clock (for  example APBX Bus clock is 24 MHz and HSADC input clock is 4 MHz) the write signal to the  PWM registers is missed. Write access to the following registers has no effect after HSADC mode  is enabled:  â¢ PWM Control and Status Register  â¢ PWM Channel Active Register  â¢ PWM Channel Period Register  As a result, dedicated PWM channel is not triggered.  Projected Impact:  HSADC or off chip linear sensor does not receive the required control signals.	If the HSADC input clock is lower than the 24 MHz APBX bus clock the APBX bus clock should  be set to a lower frequency before every write to the PWM register. When the write access finishes,  the APBX clock can be set back to normal.	PWM: Register write sync issue when HSADC clock frequency is  lower than APBX clock frequency
ARM9	NXP	IMX28	The endian mode of the Ethernet controller is designed to be big-endian mode which is not  compatible with the ARM core and reset sections of the device.  Projected Impact:  The ARM core cannot establish data communication correctly to/from the Ethernet controller  without software endian conversion.	When communicating with the Ethernet controller, an additional byte-swap routine has to be called  by the ARM core.	ENET: ENET big endian mode not compatible with ARM little endian
ARM9	NXP	IMX28	When the channel freeze bit is set, the APBH/APBX DMA channel can stall while waiting to  access a peripheral on the APBH/APBX bus. This occurs if the channel freeze bit is set exactly at  the same time as when the channel internal state machine changes from the PIO_REQ state to the  REQ_WAIT state.  Projected Impact:  The data communication with the APBH/APBX DMA channel associated peripheral is stalled.	Do not use DMA PIO operation to configure the associated peripheral when using channel freeze  function. Use ARM PIO operation instead.	DMA: APBH/APBX DMA channel can stall while waiting to access a  APBH/APBX bus peripheral when the channel freeze bit is set
ARM9	NXP	IMX28	An Abort request to a transmit message buffer (TxMB) can block any write operation into its  CODE field. Therefore, the TxMB cannot be aborted or deactivated until it completes a valid  transmission (by winning the CAN bus arbitration and transmitting the contents of the TxMB).  Projected Impact:  The TxMB cannot be aborted or deactivated until it completes a valid transmission.	Instead of aborting the transmission, use deactivation instead.  Note that there is a chance the deactivated TxMB can be transmitted without setting IFLAG  and updating the CODE field if it is deactivated.	FlexCAN: Abort request blocks the CODE field
ARM9	NXP	IMX28	During CAN message reception by FlexCAN, the RXGMASK (Rx Global Mask) is used as an  acceptance mask for most of the Rx message buffers (MB). When the FIFO Enable bit in the  FlexCAN Module Configuration Register (CANx_MCR[FEN], bit 29) is set, the RXGMASK also  applies to most of the elements of the ID filter table. However, there is a misalignment between the  position of the ID field in the RxMB and that in the RXIDA, RXIDB and RXIDC fields of the ID  tables. In fact, the RXIDA filter in the ID tables is shifted one bit to the left from the RxMBs ID  position, as shown below:  RxMB ID = bits 28-0 of ID word corresponding to message ID bits 28-0  RXIDA = bits 29-1 of ID Table corresponding to message ID bits 28-0  Note that the mask bits align to the ID filter bits, not to the incoming ID bits. For example, the bit  4 in RXGMASK masks bit 4 in RxMB ID, but it does not mask bit 4 in incoming message ID. This  misalignment leads the RXGMASK to affect RxMB and Rx FIFO filtering in different ways.  For example, if the user intends to mask out bit 4 of the ID filter of message buffer then the  RXGMASK will be configured as 0xffff_ffef. As a result, bit 4 of the ID field of the incoming  message is ignored during the filtering process for message buffers. This very same configuration  of RXGMASK, which would lead bit 4 of RXIDA to be âdo not careâ and thus bit 3 of the ID field  of the incoming message would be ignored during the filtering process for the Rx FIFO.  Similarly, both RXIDB and RXIDC filters have multiple misalignments with regards to position of  the ID field in the RxMBs, which can lead to erroneous masking during the filtering process for  either Rx FIFO or MBs.  RX14MASK (Rx 14 Mask) and RX15MASK (Rx 15 Mask) have the same structure as the  RXGMASK. This includes the misalignment problem between the position of the ID field in the  RxMBs and in the RXIDA, RXIDB and RXIDC fields of the ID Tables. Leading to mask misalignment between RxMB and Rx FIFO filtering.	It is recommended that one of the following actions be taken to avoid problems:  â¢ Do not enable the RxFIFO. If CANx_MCR[FEN]=0 then the Rx FIFO is disabled and thus the  masks RXGMASK, RX14MASK and RX15MASK do not affect it.  â¢ Enable Rx Individual Mask Registers. If the Backwards Compatibility Configuration bit in the  FlexCAN Module Configuration Register (CANx_MCR[BCC], bit 16) is set then the Rx  Individual Mask Registers (RXIMR0-63) are enabled and thus the masks RXGMASK,  RX14MASK and RX15MASK are not used.  â¢ Do not use the masks RXGMASK, RX14MASK and RX15MASK (leave them in reset value  which is 0xffff_ffff) when CANx_MCR[FEN]=1 and CANx_MCR[BCC]=0. In this case,  filtering processes for both RxMBs and Rx FIFO are not affected by those masks.  â¢ Do not configure any MB as Rx (leave all MBs as either Tx or inactive) when  CANx_MCR[FEN]=1 and CANx_MCR[BCC]=0. In this case, the masks RXGMASK,  RX14MASK and RX15MASK can be used to affect ID tables without affecting filtering process  for RxMBs.	FlexCAN: Global Masks misalignment
ARM9	NXP	IMX28	In order to switch the EMI clock from asynchronous to synchronous mode, both the xtal_ref and  the cpu_ref must be active, even if both BYPASS_CPU and BYPASS_EMI are set in the  HW_CLKCTRL_CLKSEQ register.  Projected Impact:  The i.MX28 locks up.	If cpu_ref is inactive, then activate the cpu_ref before attempting to switch to synchronous mode.	EMI Clock: Switching to synchronous mode error
ARM9	NXP	IMX28	Currently, software checks the active bit in dTD to see whether it is finished. If the Active bit is 0,  then software frees the allocated memory for the dTD.  The hardware sequence after all data of a dTD is transferred is as follows:  1. Update the dTD. This includes an AHB write access of three DWords. The active bit is cleared  in the first DW write.  2. Update the qHead (this includes an AHB write access of three DWords).  3. Read the dTD again to check if software added a new dTD (this is a SINGLE AHB read). At  the same time, send out an interrupt if needed.  After step 1, if software finds the Active bit is cleared, then the dTD memory space is freed and  may be allocated for another threadâs use. In step 3, hardware may get a wrong dTD.  This issue does not occur if some delay is added before freeing the dTD memory space.  This issue only occurs in USB INCR8 mode, because steps 1 and 2 have 6 SINGLE AHB transfers  in INC8 mode, but only two burst AHB transfers in INCR mode.  This issue only occurs when the dTD list is used; because if only one dTD is used, the software  only checks the Active bit after an interrupt is received (step 3). However, when the dTD list is  used, the software may check the entire list after the interrupt for the first dTD is received, when  the hardware has just finished the transfer of the second dTD.  Projected Impact:  USB Controller may hang if dTD is freed too quickly.	Postpone freeing the current dTD; free it when its next dTD can be freed, so the last completed dTD  (followed by an ACTIVE dTD) is always freed when the next IOC irq comes.	USB controller may access a wrong address for the dTD (endpoint  transfer descriptor) and then hangs
ARM9	NXP	IMX28	If the DCDC_XFER bit is clear, the DCDC converter should not automatically turn on when 5 V  is removed. Instead, a power-down should occur if 5 V is removed, when DCDC_XFER and  ENABLE_DCDC are zero.  Projected Impact:  DCDC converter input source may switch to DCDC_BATT pin but no power source is present  there. This may latch-up the DCDC converter circuit.	In order to power down the system properly when 5 V is removed, set PWDN_5VBRNOUT bit in  Register HW_POWER_5VCTRL.	The DCDC converters unexpectedly turn on when 5 V is removed  while the DCDC_XFER bit is clear
ARM9	NXP	IMX28	Due to unreliability of the VDD5V_GT_VDDIO functionality, the power supply should never be  configured to be used as the 5-V plug/unplug detection method.  Projected Impact:  VDD5V_GT_VDDIO output may not change to â0â (and VDD5V_GT_VDDIO_IRQ may not be  triggered) when 5 V is unplugged.	Use the VBUSVALID comparator for 5V plug/unplug detection. Actually, the VBUSVALID  comparator is recommended in the reference manual, not VDD5V_GT_VDDIO.  The VBUSVALID_5VDETECT bit in HW_POWER_5VCTRL should be set to â1â (itâs default  value) and never cleared. The detection threshold can be changed in the VBUSVALID_TRSH bit  field in HW_POWER_5VCTRL.	Unreliability of VDD5V_GT_VDDIO functionality
ARM9	NXP	IMX28	When boot mode is set as boot from SD/MMC/eMMC on SSP0/1, the SSP_SCK polarity is not  correctly set up in ROM. The POLARITY bit in HW_SSP_CTRL1 register should be set to â1â  (command and data output on falling edge of clock) according to SD/MMC/eMMC specification.  However, the POLARITY bit is set to â0â in ROM in the existing silicon (TO1.2). As a result, input  setup time (tISU) at SD/MMC/eMMC input may not be met.  Projected Impact:  Write command error may occur when booting from the SD/MMC/eMMC on SSP0/1 and result  in boot failure.	If tISU at SD/MMC/eMMC input is violated and write command error occurs during boot from  SD/MMC/eMMC, a ROM patch of 1kByte size loaded from the EEPROM is required to fix this  issue. Boot mode should be set to [0001] for the EEPROM on I2C0 or [1000] for the EEPROM on  SPI3. The patch executes from the EEPROM, patches the ROM SSP driver code, and switches boot  to either SSP0 or SSP1. There are separate patch binaries to boot from SSP0 and SSP1.	SSP0/1-SD/MMC/eMMC Boot: SSP_SCK polarity setup issue in ROM
ARM9	NXP	IMX28	When the ENABLE_DCDC bit in HW_POWER_DCDC4P2 or HW_POWER_5V_CTRL is set, a  glitch is propagated through the brownout comparators. If the glitch is sufficiently large, it can  cause a false brownout detection. The VDDD, VDDA, VDDIO, and VBUSVALID comparators are  all susceptible to the glitch.  Projected Impact:  Can result in a false brownout detection.	The sequence below is needed to work around this issue prior to setting the ENABLE_DCDC bit  in HW_POWER_DCDC4P2:  1. Disable the power rail brownout interrupts (clear HW_POWER_CTRL VDDA, VDDD,  VDDIO ENIRQ bits).  2. Set the HW_POWER_5VCTRL PWRUP_VBUS_CMPS bit.  3. Set the HW_POWER_5VCTRL VBUSVALID_TRSH to 0x0 (2.9 V).  4. Set the HW_POWER_5VCTRL VBUSVALID_5VDETECT bit to 1.  5. Disable VBUSDROOP status and interrupts (clear VDD5V_DROOP_IRQ).  6. Set the ENABLE_DCDC bit in HW_POWER_DCDC4P2.  7. Wait 100 Âµs  8. Check VBUSVALID_IRQ bit. If it is set, then set and clear the PWD_CHARGE_4P2 bit to  repower on the 4P2 regulator because it is automatically shut off on a VBUSVALID false  condition. It may be helpful to ramp up the CHARGE_4P2_ILIMIT value at this point to  gradually draw power from 5 V rail. If HW_POWER_5VCTRL ENABLE_DCDC is already  set, the DCDC will draw current from VDD4P2 as soon as PWD_CHARGE_4P2 is cleared.  9. Clear VBUSDROOP, VBUSVALID, and the output rails IRQ bits as needed.  10. Restore the output rail ENIRQ bits, the VBUSVALID_TRSH level,  VBUSVALID_5VDETECT value, ENIRQ_VBUS_VALID, and ENIRQ_VDD5V_DROOP to  their original values.  The sequence below is needed to work-around this issue prior to setting the ENABLE_DCDC bit in  HW_POWER_5VCTRL and HW_POWER_DCDC4P2. Note that the below workaround assumes the  usual requirements for setting the HW_POWER_5VCTRL ENABLE_DCDC bit are met (that is, the  hardware and/or software battery brownout protection mechanism is enabled to properly protect the  system against the DCDC sourcing from the battery if the battery voltage is too low).  1. Disable the power rail brownout interrupts (clear HW_POWER_CTRL VDDA, VDDD,  VDDIO ENIRQ bits).  2. Set the HW_POWER_5VCTRL PWRUP_VBUS_CMPS bit.  3. Set the HW_POWER_5VCTRL VBUSVALID_TRSH to 0x0 (2.9 V).  4. Set the HW_POWER_5VCTRL VBUSVALID_5VDETECT bit to 1.  5. Disable VBUSDROOP status and interrupts (clear VDD5V_DROOP_IRQ).  6. Set the ENABLE_DCDC bit in HW_POWER_5VCTRL.  7. Wait 100 Âµs.  8. Check VBUSVALID_IRQ bit. If it is set, and 5 V is present and the VDD4P2 rail was enabled,  then repeat the sequence for enabling the 4P2 regulator and DCDC from VDD4P2. This bit  indicates that the DCDC has tried to source from the battery, even if 4P2 sourcing is enabled.  This is because a VBUSVALID false condition automatically disables the 4P2 regulator, so the  DCDC then falls back to battery sourcing.  9. Clear VBUSDROOP, VBUSVALID, and the output rails IRQ bits as needed.  10. Restore the output rail ENIRQ bits, the VBUSVALID_TRSH level,  VBUSVALID_5VDETECT value, ENIRQ_VBUS_VALID, and ENIRQ_VDD5V_DROOP to  their original values.	Setting the ENABLE_DCDC bit in the HW_POWER_DCDC4P2 or HW_POWER_5VCTRL registers can result in false brownout Detection
ARM9	NXP	IMX28	ROM in existing silicon (TO1.2) supports ONFI BA-NAND boot-up. During boot-up it reads Bit  7 of Byte 6-7 (1=supports Block Abstracted access mode) in ONFI NAND deviceâs parameter page  to determine if the NAND device is ONFI BA-NAND. BA-NAND memory devices are no longer  part of the ONFI spec and memory vendors do not support these devices anymore. However in  ONFI 3.0 Spec, that bit has been re-used to specify whether the NAND device supports extended  parameter page.  When a system is mounted with ONFI 3.0 NAND device with âsupports extended parameter pageâ  bit set to â1â, the i.MX28 boot ROM will see it as BA-NAND and will use BA-NAND commands  to access the NAND device. As a result, the system will fail to boot-up.  Projected Impact:  System mounted with ONFI 3.0 NAND device will fail to boot-up.	Contact ONFI NAND vendor to supply NAND device with the âsupports extended parameter  pageâ bit set to â0â, so that the i.MX28 boot ROM will not treat it as BA-NAND.	ONFI 3.0 NAND boot-up issue
ARM9	NXP	IMX28	The Ethernet 1588 clock (CLK_ENET_TIME) continues to toggle when the Ethernet module is disabled by setting ENET disable control bit in the HW_CLKCTRL_ENET register. The ethernet controller consumes 30 ?A on the 4.2 V power supply. Projected Impact: The Ethernet 1588 clock consumes 30 ?A on the 4.2 V power supply when the Ethernet module is disabled.	The Ethernet 1588 clock can be gated off by clearing the HW_CLKCTRL_ENET_DIV_TIME  register. The HW_CLKCTRL_ENET_DIV_TIME register address is 0x80040140.	CLKCTRL: ENET 1588 clock (CLK_ENET_TIME) is not under control  of ENET disable control bit
ARM9	Atmel	SAM9260	The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx (Channel Data Register) automatically clears the DRDY ï¬ag.	None	43.1.1.1 ADC: DRDY Bit Cleared
ARM9	Atmel	SAM9260	When reading LCDR at the same instant as an end of conversion, with DRDY already active. DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	43.1.1.2 ADC: DRDY not Cleared on Disable
ARM9	Atmel	SAM9260	Reading CDR for channel "yâ at the same instant as an end of conversion on channel "xâ with EOC[x] already active, leads to skipping to set the DRDY ï¬ag if channel "x" is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	43.1.1.3 ADC: DRDY Possibly Skipped due to CDR Read
ARM9	Atmel	SAM9260	I: u DRDY does not rise when disabling channel y at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	43.1.1.4 ADC: Possible Skip on DRDY when Disabling a Channel
ARM9	Atmel	SAM9260	Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) ï¬ag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE ï¬ag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE ï¬ag is not set.	None 790 SAM926O [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16	43.1.1.5 ADC: GOVRE Bit is Not Updated
ARM9	Atmel	SAM9260	When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel "xâ with the following conditions: 0 EOC[x] already active, 0 DRDY already active, 0 GOVRE inactive, 0 previous data stored in LCDR being neither data from channel â",y nor data from channel âx". GOVRE should be set but is not.	None	43.1.1.6 ADC: GOVRE Bit is Not Set when Reading CDR
ARM9	Atmel	SAM9260	When disabling channel ây" at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	43.1.1.7 ADC: GOVRE Bit is Not Set when Disabling a Channel
ARM9	Atmel	SAM9260	When the OVRE ï¬ag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of ECG status on channel i), does not lead to a reset of the OVRE ï¬ag (on channel i) as expected.	None	43.1.1.8 ADC: OVRE Flag Behavior
ARM9	Atmel	SAM9260	If a channel is disabled while a conversion is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the ECG of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the E00 of a disabled channel	43.1.1.9 ADC: EOC Set Although Channel Disabled
ARM9	Atmel	SAM9260	If âx" and "yâ are two successively converted channels and "zâ is yet another enabled channel ("2â being neither âx" n I: nor âyâ), reading CDR on channel â2" at the same instant as an end of conversion on channel y automatically clears EOC[x] instead of EOC[z].	None.	43.1.1.10 ADC: Spurious Clear of EOC Flag
ARM9	Atmel	SAM9260	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit ï¬eld); to start an analog-toâdigital conversion, in order put ADC into sleep mode at the end of this conversion. AtmeL SAM926O [DATASHEET] 791 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.1.2 Boot ROM	43.1.1.11 ADC: Sleep Mode
ARM9	Atmel	SAM9260	The SMC_SETUP register for the NAND Flash Chip Select (NCS3) is not initialized correctly in the ROM code. NRD_SETUP is initialized to "0" which leads to a violation of parameters tAR and tCLR. The following commands are concerned; READ ID (0x90), READ STATUS (0x70), PAGE READ (0x00, 0x30) and RANDOM DATA READ (0x05, OxEO).	Use DataFlash Boot or external memory on EBI_NCSO.	43.1.2.1 NAND Flash Boot Does Not Work Correctly
ARM9	Atmel	SAM9260	The Real-time Timer is reset by the BootROM after each power up. This prevents using the RTT as a backed up real-time clock.	Boot on an external memory connected on CSO (BMS = 0).	43.1.2.2 Problem with RTI'
ARM9	Atmel	SAM9260	The boot ROM program configures the NRST pin as an input, and programs the User Reset length. As RSTC registers are powered by VDDBU, the settings are saved and ovenNrite the user conï¬guration.	Writing the URSTEN bit to 0 in RSTC_MR disables the User Reset trigger. 43.1.3 Bus Matrix	43.1.2.3 User Reset trigger is enabled by default
ARM9	Atmel	SAM9260	MATRIX_MCFG5 is write-only. The value written is effective but not readable.	None. 43.1 .4 EMAC	43.1.3.1 Bus Matrix Master Conï¬guration Register 5
ARM9	Atmel	SAM9260	EMACB FIFO internal arbitration scheme is: 1. Receive buffer manager write Receive buffer manager read Transmit data DMA read Receive data DMA write Transmit buffer manager read 6. Transmit buffer manager write 91:59!" EMACB master interface releases the AHB bus between two transfers. EMACB has the highest priority. If EMACB RX and TX FlFOs both have pending requests, the following sequence occurs: 1. EMACB RX FIFO write (burst 4) 2 EMACB releases the AHB bus 3. The AHB matrix can grant an another master (ARM | or D for example) 4 AHB matrix re-arbitration (finishes at least the current word/halfword/byte) 792 SAM926O [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 5. The AHB matrix grants the EMACB 6. The EMACB TX FIFO read (burst 4) In case of a slow memory and/or a special operation like SDRAM refresh or SDRAM bank opening, a TX underrun may occur. (latency min 960 ns).	Reduce re-arbitration time between RX & TX EMACB transfers by using internal SRAM (or another memory slave with a short access time) to transmit buffers and descriptors. 43.1.5 IIO Considerations	43.1.4.1 EMAC: TX Underrun May Occur in Some Cases
ARM9	Atmel	SAM9260	The I/O output buffer drive is too high to guarantee the timings. This is applicable to the External Bus Interface signals and to the peripheral I/Os. This leads to fast rise and fall time when the signals change, causing high currents to be drawn on the power supply pins and leads to emission of high frequencies. This may affect the operation of the device and may result in the emission of radio-frequency signals, making EMC certiï¬cation difï¬cult.	It is strongly recommended: 0 to place the memories connected to the EBI as close as possible to the SAM9260 on the PCB o to route all the EBI signals with a series resistor, typical value 33 ohms o to adjust the series resistor value with tools taking into account the IBIS model of the pads and the characteristics of the wires of the PCB, in order to guarantee rise and fall times as long as timings permit. 43.1.6 MCI	43.1.5.1 IIO High Drive Strength
ARM9	Atmel	SAM9260	The busy status of the card during the response (R1b) is ignored for the commands CMD7, CMD28, CMD29, CMD38, CMD42, CMD56. Additionally, for commands CMD42 and CMD56 a conï¬ict can occur on data lineO if the MCI sends data to the card while the card is still busy. The behavior is correct for CMD12 command (STOP_TRANSFER).	None	43.1.6.1 MCI: Busy Signal of R1b Responses is Not Taken in Account
ARM9	Atmel	SAM9260	If there is 1-bit data bus width on slots other than slot A, the SDIO interrupt cannot be captured. The sample is made on the wrong data line.	None	43.1.6.2 MCI: SDIO Interrupt Does Not Work With Slots Other Than A
ARM9	Atmel	SAM9260	As the data Timeout error ï¬ag checking the Naac timing cannot rise, the MCI can be stalled waiting indeï¬nitely the Data start bit.	A STOP command must be sent with a software timeout.	43.1.6.3 MCI: Data Timeout Error Flag
ARM9	Atmel	SAM9260	The Data Write operation with a number of bytes less than 12 is impossible. AtmeL SAM9260 [DATASHEET] 793 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13-Jan-16	The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT field are used to specify the real count number.	43.1.6.4 MCI: Data Write Operation and Number of Bytes
ARM9	Atmel	SAM9260	In half duplex mode, the reset of the ï¬ags ENDRX, RXBUFF, ENDTX and TXBUFE can be incorrect. These ï¬ags are reset correctly after a PDC channel enable.	Enable the interrupts related to ENDRX, ENDTX, RXBUFF and TXBUFE only after enabling the PDC channel by writing PDC_TXTEN or PDC_RXTEN. 43.1.7 Reset Controller (RSTC)	43.1.6.5 MCI: Flag Reset is Not Correct in Half Duplex Mode
ARM9	Atmel	SAM9260	When a user reset, watchdog reset, or software reset occurs during SDRAM read access, the SDRAM clock is turned off while data is ready to be read on the data bus. The SDRAM maintains the data until the clock restarts. If the user reset, watchdog reset, or software reset is programmed to assert a general reset, the data maintained by the SDRAM leads to a data bus conï¬ict and adversely affects the boot memories connected on the EBI: o NAND Flash boot functionality, if the system boots out of internal ROM. 0 NOR Flash boot, if the system boots on an external memory connected on the EBI CSO.	1. Avoid user reset, watchdog reset, software reset to generate a system reset. 2. Trap the user reset, watchdog reset, software reset with an interrupt. In the interrupt routine, power down the SDRAM properly and perform Peripheral and Processor Reset with software in assembler. Example with IibV3. o The main code: //user reset interrupt setting // Configure AIC controller to handle System peripheral interrupts AT9lF_AIC_ConfigureIt ( AT91C_BASE_AIC, // AIC base address AT91C_ID_SYS, // System peripheral ID AT91C_AIC_PRIOR_HIGHEST, // Max priority AT9lC_AIC_SRCTYPE_INT_EDGE_TRIGGERED, // Level sensitive sysc_handler ); // Enable SYSC interrupt in AIC AT9lF_AIC_EnableIt(AT91C_BASE_AIC, AT91C_ID_SYS); *AT91C_RSTC_RMR = (0xA5<<24) | (Ox4<<8) | AT91C_RSTC_URSTIEN; o The C SYS handler: extern void soft_user_reset(void); void sysc_handler(void){ //check if interrupt comes from RSTC if( (*AT91C_RSTC_RSR & AT9lC_RSTC_URSTS ) == AT91C_RSTC_URSTS){ soft_user_reset(); //never reached 794 SAM9260 [DATASH EET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 while(l); } } 0 Assembly code is mandatory for the following sequence as ARM instructions need to be pipelined. The assembler routine: AREA TEST, CODE INCLUDE AT91$AM9xxx.inc EXPORTsoft_user_reset soft_user_reset ;disable IRQs MRS r0, CPSR ORR r0, r0, #0x80 MSR CPSR_c, r0 ;change refresh rate to block all data accesses LDR r0, =AT91C_SDRAMC_TR LDR r1, =1 STR r1, [r0] ;prepare power down command LDR r0, =AT9lC_SDRAMC_LPR LDR rl, =2 ;prepare proc_reset and periph_reset LDR r2, =AT91C_RSTC_RCR LDR r3, =0xA5000005 ;perform power down command STR r1, [r0] ;perform proc_reset and periph_reset (in the ARM pipeline) STR r3, [r2] END 43.1.8 Oscillators	43.1.7.1 RSTC: Reset during SDRAM Accesses
ARM9	Atmel	SAM9260	When booting from the on-chip RC, the startup time is ï¬xed at 1200 ms and not 240 us as speciï¬ed in Table 5-1 on page 18.	None	43.1.8.1 On-chip RC Startup Time
ARM9	Atmel	SAM9260	When VDDBU only is powered, either internal RC oscillator or external 32K osc may start regardless of the setting of the OSCSEL pin. The OSCSEL pin sampling is correct after applying VDDCORE power supply and remains correct if VDDCORE is removed.	The ï¬rst power-up sequence requires both VDDBU and VDDCORE to correctly sample the OSCSEL signal. AtmeL SAM9260 [DATASHEET] 795 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1.9 SDRAM Controller	43.1.8.2 Bad Sampling of OSCSEL
ARM9	Atmel	SAM9260	After a reset, the SDRAM clock is always active leading to over consumption in the pad.	The following sequence stops the SDRAM clock. 1. Set the bit LPCB in the SDRAMC Low Power Register. 2. Write 0 in the SDRAMC Mode Register and perform a dummy write in SDRAM to complete.	43.1.9.1 SDCLK Clock Active After Reset
ARM9	Atmel	SAM9260	Using Mobile SDRAM devices that need to have their DQMx level HIGH during Mobile SDRAM device initialization may lead to data bus contention and thus external memories on the same EBI must not be accessed. This does not apply to Mobile SDRAM devices whose DQMx level is âDon't care" during this phase.	Mobile SDRAM initialization must be performed in internal SRAM.	43.1.9.2 Mobile SDRAM Device Initialization Constraint
ARM9	Atmel	SAM9260	In the current revision, SDCKE rises at the same time as SDCK while exiting self-refresh mode. To be fully compliant with the JEDEC standard, SDCK must be STABLE before the rising edge of SDCKE.	None. 43.1.10 Serial Peripheral Interface (SPI)	43.1.9.3 JEDEC Standard Compatibility
ARM9	Atmel	SAM9260	If the SPI is used in the following conï¬guration: 0 Master mode 0 CPOL = 1 and NCPHA = 0 0 multiple chip selects used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR not equal to 1 o transmit with the slowest chip select and then with the fastest one then an additional pulse will be generated on output PSCK during the second transfer.	Do not use a multiple Chip Select conï¬guration where at least one SPI_CSRx register is conï¬gured with SCBR = 1 and the others differ from 1 if CPHA = 0 and CPOL = 1. If all chip selects are conï¬gured with SCBR = 1, the issue does not appear.	43.1.10.1 SPI: Bad Serial Clock Generation on Second chip_select when SCBR = 1, CPOL = 1 and NCPHA = 0
ARM9	Atmel	SAM9260	When baud rate is set to 1 (i.e., when serial clock frequency equals the system clock frequency), and when the fields BITS (number of bits to be transmitted) equals an ODD value (in this case 9, 11, 13 or 15), an additional pulse is generated on output SPCK. No error occurs if BITS ï¬eld equals 8, 10, 12, 14 or 16 and SCBR = 1.	None. 796 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16	43.1.10.2 SPI: Baud Rate Set to 1
ARM9	Atmel	SAM9260	One byte data can be lost when PDC transmits. This occurs when write accesses are performed on the base address of any peripheral, during the PDC transfer.	0 Add a timeout for the PDC transfer and check the value of the PDC transmit counter when the timeout has elapsed. Check the data integrity by a checksum. Avoid write access on the base address of peripherals during a PDC transfer.	43.1.10.3 SPI: PDC Data Loss
ARM9	Atmel	SAM9260	If a software reset (SWRST in the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select).	The SPI Control Register ï¬eld SWRST needs to be written twice to be correctly set. 43.1.11 Serial Synchronous Controller (SSC)	43.1.10.4 SPI: Software Reset Needs to be Written Twice
ARM9	Atmel	SAM9260	When the SSC receiver is used in the following conï¬guration: 0 the internal clock divider is used (CKS = 0 and DIV different from 0), o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then, at the end of the data, the RK pin is set in high impedance which may be interpreted as an unexpected clock cycle.	Enable the pull-up on RK pin.	43.1.11.1 SSC: Unexpected RK Clock Cycle when RK Outputs a Clock During Data Transfer
ARM9	Atmel	SAM9260	When the SSC receiver is used in the following conï¬guration: 0 RX clock is divided clock (CKS = 0 and DIV different from 0) o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then the ï¬rst clock cycle time generated by the RK pin is equal to MCK/(2 x (DIV + 1)) instead of MCK/(2 x DIV).	None.	43.1.11.2 SSC: Incorrect ï¬rst RK Clock Cycle when RK Outputs a Clock During Data Transfer
ARM9	Atmel	SAM9260	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	43.1.11.3 SSC: Transmitter Limitations in Slave Mode
ARM9	Atmel	SAM9260	If Least Significant Bit is sent ï¬rst (MSBF = 0) the ï¬rst TAG during the frame synchro is not sent.	None. AtmeL SAM9260 [DATASHEET] 797 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1.12 Static Memory Controller (SMC)	43.1.11.4 SSC: Periodic Transmission Limitations in Master Mode
ARM9	Atmel	SAM9260	The user must not change the conï¬guration parameters of an SMC Chip Select (Setup, Pulse, Cycle, Mode) if accesses are performed on this CS during the modiï¬cation. For example, the modiï¬cation of the Chip Select 0 (080) parameters, while fetching the code from a memory connected on this CSO, may lead to unpredictable behavior.	The code used to modify the parameters of an SMC Chip Select can be executed from the internal RAM or from a memory connected to another Chip Select. 43.1.13 Shutdown Controller (SHDWC)	43.1.12.1 SMC: Chip Select Parameters Modification
ARM9	Atmel	SAM9260	If only VDDBU is powered during boot sequence (No VDDCORE), the SHDN signal may be driven to low level voltage after a delay. This delay is linked to the startup time of the slow clock selected by OSCSEL signal. If SHDN pin is connected to the Enable pin (EN) of the VDDCORE regulator, VDDCORE establishment does not occur and the system does not start.	1. VDDCORE must be established within the delay corresponding to the startup time of the slow clock selected by OSCSEL. 2. Add a glue logic to latch the rising edge of the SHDN signal. The reset of the latch output (EN_REG) can be connected to a PIO and used to enter the shutdown mode. 43.1.14 System Controller	43.1.13.1 SHDWC: SHDN Signal may be Driven to Low Level Voltage During Device Power-on
ARM9	Atmel	SAM9260	If an event (RTTINC or ALMS) occurs within the same slow clock cycle as when the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle an RTT event as an interrupt and should not poll RTT_SR. 43.1.15 Two-wire Interface (TWI)	43.1.14.1 Possible Event Loss when Reading R1T_SR
ARM9	Atmel	SAM9260	At the end of transfer in slave mode, the slave mode is disabled, the master mode is enabled and thus a transfer in master mode can be performed. In the current device, the start event is correctly generated but the SCL line is stuck at 1, so no transfer is possible.	Two workarounds are possible: 1. Perform a software reset before going to master mode (TWI must be reconï¬gured). or 2. Perform a slave read access before switching to master mode. 798 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 43.1.16 UHP	43.1.15.1 TWI: Switch from Slave to Master Mode
ARM9	Atmel	SAM9260	Conditions: Consider the following sequence: 1. The Host controller issues an IN token. 2 The Device provides the IN data in a short packet. 3. The Host controller writes the received data to the system memory. 4 The Host controller is now supposed to carry out two Write transactions (TD status write and TD retirement write) to the system memory in order to complete the status update. 5. The Host controller raises the request for the ï¬rst write transaction. By the time the transaction is completed, a frame boundary is crossed. 6. After completing the first write transaction, the Host controller skips the second write transaction. Consequence: When this error occurs, the Host controller tries the same IN token again.	This problem can be avoided if the system guarantees that the status update can be completed within the same frame.	43.1.16.1 UHP: Non-ISO IN Transfers
ARM9	Atmel	SAM9260	Conditions: Consider the following sequence: 1. The Host controller sends an ISO OUT token after fetching 16 bytes of data from the system memory. 2. When the Host controller is sending the ISO OUT data, because of system latencies, remaining bytes of the packet are not available. This results in a buffer underrun condition. 3. While there is an underrun condition, if the Host controller is in the process of bit-stufï¬ng, it causes the Host controller to hang. Consequence: After the failure condition, the Host controller stops sending the SOF. This causes the connected device to go into suspend state.	This problem can be avoided if the system can guarantee that no buffer underrun occurs during the transfer.	43.1.16.2 UHP: ISO OUT Transfers
ARM9	Atmel	SAM9260	Conditions: When a Remote Wakeup event occurs on a downstream port, the OHCI Host controller begins sending resume signaling to the device. The Host controller is supposed to send this resume signaling for 20 ms. However, if the driver sets the HcControl.HCFS into USBOPERATIONAL state during the resume event, then the Host controller terminates sending the resume signal with an EOP to the device. Consequence: If the Device does not recognize the resume (< 20 ms) event, then the Device remains in suspend state.	Host stack can do a port resume after it sets the HcControl.HCFS to USBOPERATIONAL. AtmeL SAM9260 [DATASHEET] 799 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.1 .17 USART	43.1.16.3 UHP: Remote Wakeup Event
ARM9	Atmel	SAM9260	TXD signal should be pulled up in Modem and Hardware Handshaking mode.	TXD is multiplexed with PIO which integrates a pull up resistor. This internal pull-up must be enabled.	43.1.17.1 USART: TXD Signal is Floating in Modern and Hardware Handshaking Mode.
ARM9	Atmel	SAM9260	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter.	43.1.17.2 USART: DCD is Active High Instead of Low
ARM9	Atmel	SAM9260	In receiver mode, when two characters are consecutive (without timeguard in between) the RXBRK is not taken into account. As a result the RXBRK ï¬ag is not enabled correctly and the frame error flag is set.	Constraints on the transmitter device connected to the SAM9260 USART receiver side. The transmitter may use the timeguard feature or send 2 STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data the receiver state machine will go into idle mode and enable the RXBRK condition.	43.1.17.3 USART: RXBRK Flag Error in Asynchronous Mode
ARM9	Atmel	SAM9260	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit of the transmitter, a character is lost.	CTS must not go low during a time slot comprised between 2 Master Clock periods before the rising edge of the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	43.1.17.4 USART: CTS Signal in Hardware Handshake
ARM9	Atmel	SAM9260	1. Setting the receiver to hardware handshaking mode drops RTS line to low level even if the receiver is still turned off. USART needs to be completely configured and started before setting the receiver to hardware handshaking mode. 2. Disabling the receiver during a PDC transfer while RXBUFF ï¬ag is '0' has no effect on RTS. The only way to get the RTS line to rise to high level is to reset both PDMA buffers by writing the value '0' in both counter registers.	None.	43.1.17.5 USART: RTS Not Expected Behavior
ARM9	Atmel	SAM9260	If CTS rises to 1 during a character transmit, the Transmit Holding Register is also transmitted if not empty.	None. 800 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-DatasheetJ 3-Jan-16 43.1.18 Power Management Controller (PMC)	43.1.17.6 USART: Two Characters Sent if CTS Rises During Emission
ARM9	Atmel	SAM9260	If MDIV and another ï¬eld (088 or PRES) are changed at the same, clock frequency may not be correct.	For each clock switching user must take care to: 0 change ï¬elds CSS, MDIV, PRES one by one o wait MCKRDY bit setting in PMC_SR before changing PMC_MCKR 0 ensure each transitory frequency value is in operational range for PCK and MCK AtmeL SAM9260 [DATASHEET] 801 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2 SAM9260 Errata - Revision âBâ Parts Refer to Section 43.1 âSAM9260 Errata - Revision âAâ Partsâ on page 790. 43.2.1 Analog-to-digital Converter (ADC)	43.1.18.1 PMC: PMC bad frequency after MDIV switching
ARM9	Atmel	SAM9260	The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx (Channel Data Register) automatically clears the DRDY ï¬ag.	None	43.2.1.1 ADC: DRDY Bit Cleared
ARM9	Atmel	SAM9260	When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	43.2.1.2 ADC: DRDY not Cleared on Disable
ARM9	Atmel	SAM9260	Reading CDR for channel y at the same instant as an end of conversion on channel âx" with EOC[x] already active, leads to skipping to set the DRDY ï¬ag if channel x is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	43.2.1.3 ADC: DRDY Possibly Skipped due to CDR Read
ARM9	Atmel	SAM9260	DRDY does not rise when disabling channel y at the same time as an end of âx" channel conversion, although data is stored into CDRx and LCDR.	None.	43.2.1.4 ADC: Possible Skip on DRDY when Disabling a Channel
ARM9	Atmel	SAM9260	Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) ï¬ag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE ï¬ag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE ï¬ag is not set.	None	43.2.1.5 ADC: GOVRE Bit is Not Updated
ARM9	Atmel	SAM9260	When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel x with the following conditions: EOC[x] already active, 0 DRDY already active, 0 GOVRE inactive, 0 previous data stored in LCDR being neither data from channel â",y nor data from channel "xâ. 802 SAM9260 [DATASHEET] At m eL Almel-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 GOVRE should be set but is not.	None	43.2.1.6 ADC: GOVRE Bit is Not Set when Reading CDR
ARM9	Atmel	SAM9260	When disabling channel ây" at the same instant as an end of conversion on channel âx", EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	43.2.1.7 ADC: GOVRE Bit is Not Set when Disabling a Channel
ARM9	Atmel	SAM9260	When the OVRE ï¬ag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE ï¬ag (on channel i) as expected.	None	43.2.1.8 ADC: OVRE Flag Behavior
ARM9	Atmel	SAM9260	If a channel is disabled while a conversion is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	43.2.1.9 ADC: EOC Set Although Channel Disabled
ARM9	Atmel	SAM9260	If âx" and "y" are two successively converted channels and âz" is yet another enabled channel (â2" being neither âx" nor ây"), reading CDR on channel â2â at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	43.2.1.10 ADC: Spurious Clear of EOC Flag
ARM9	Atmel	SAM9260	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit ï¬eld); to start an analog-toâdigital conversion, in order put ADC into sleep mode at the end of this conversion. 43.2.2 Bus Matrix	43.2.1.11 ADc: Sleep Mode
ARM9	Atmel	SAM9260	MATRIX_MCFG5 is write-only. The value written is effective but not readable.	None. AtmeL SAM9260 [DATASHEET] 803 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2.3 EMAC	43.2.2.1 Bus Matrix Master Conï¬guration Register 5
ARM9	Atmel	SAM9260	EMACB FIFO internal arbitration scheme is: 1. PIPE-9!â 6. Receive buffer manager write Receive buffer manager read Transmit data DMA read Receive data DMA write Transmit buffer manager read Transmit buffer manager write EMACB master interface releases the AHB bus between two transfers. EMACB has the highest priority. If EMACB RX and TX FIFOs both have pending requests, the following sequence occurs: 1. 9391??!" EMACB RX FIFO write (burst 4) EMACB releases the AHB bus The AHB matrix can grant an another master (ARM I or D for example) AHB matrix re-arbitration (finishes at least the current word/halfword/byte) The AHB matrix grants the EMACB The EMACB TX FIFO read (burst 4) In case of a slow memory and/or a special operation like SDRAM refresh or SDRAM bank opening, a TX underrun may occur. (latency min 960 ns).	Reduce re-arbitration time between RX & TX EMACB transfers by using internal SRAM (or another memory slave with a short access time) to transmit buffers and descriptors. 43.2.4 IIO Considerations	43.2.3.1 EMAC: TX Underrun May Occur in Some Cases
ARM9	Atmel	SAM9260	The I/O output buffer drive is too high to guarantee the timings. This is applicable to the External Bus Interface signals and to the peripheral I/Os. This leads to fast rise and fall time when the signals change, causing high currents to be drawn on the power supply pins and leads to emission of high frequencies. This may affect the operation of the device and may result in the emission of radio-frequency signals, making EMC certiï¬cation difï¬cult.	It is strongly recommended: to place the memories connected to the EBI as close as possible to the SAM9260 on the PCB to route all the EBI signals with a series resistor, typical value 33 ohms to adjust the series resistor value with tools taking into account the IBIS model of the pads and the characteristics of the wires of the PCB, in order to guarantee rise and fall times as long as timings permit. 804 SAM9260 [DATASHEET] AtmeL Almel-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.5 MCI	43.2.4.1 IIO High Drive Strength
ARM9	Atmel	SAM9260	The busy status of the card during the response (R1 b) is ignored for the commands CMD7, CMD28, CMD29, CMD38, CMD42, CMD56. Additionally, for commands CMD42 and CMD56 a conï¬ict can occur on data Iine0 if the MCI sends data to the card while the card is still busy. The behavior is correct for CMD12 command (STOP_TRANSFER).	None	43.2.5.1 MCI: Busy Signal of R15 Responses is Not Taken in Account
ARM9	Atmel	SAM9260	If the data bus width is 1 bit and slots other than slot A chosen, the SDIO interrupt can not be captured. The sample is made on the bad data line.	None	43.2.5.2 MCI: SDIO Interrupt Does Not Work for Slot Different from A
ARM9	Atmel	SAM9260	As the data Timeout error ï¬ag checking the Naac timing cannot rise, the MCI can be stalled waiting indeï¬nitely the Data start bit.	A STOP command must be sent with a software timeout.	43.2.5.3 MCI: Data Timeout Error Flag
ARM9	Atmel	SAM9260	The Data Write operation with a number of bytes less than 12 is impossible.	The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT field are used to specify the real count number.	43.2.5.4 MCI: Data Write Operation and Number of Bytes
ARM9	Atmel	SAM9260	In half duplex mode, the reset of the ï¬ags ENDRX, RXBUFF, ENDTX and TXBUFE can be incorrect. These ï¬ags are reset correctly after a PDC channel enable.	Enable the interrupts related to ENDRX, ENDTX, RXBUFF and TXBUFE only after enabling the PDC channel by writing PDC_TXTEN or PDC_RXTEN. 43.2.6 SDRAM Controller	43.2.5.5 MCI: Flag Reset is Not Correct in Half Duplex Mode
ARM9	Atmel	SAM9260	After a reset, the SDRAM clock is always active leading to over consumption in the pad.	The following sequence stops the SDRAM clock. 1. Set the bit LPCB in the SDRAMC Low Power Register. 2. Write 0 in the SDRAMC Mode Register and perform a dummy write in SDRAM to complete.	43.2.6.1 SDCLK Clock Active After Reset
ARM9	Atmel	SAM9260	Using Mobile SDRAM devices that need to have their DQMx level HIGH during Mobile SDRAM device initialization may lead to data bus contention and thus external memories on the same EBI must not be accessed. AtmeL SAM9260 [DATASHEET] 805 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 This does not apply to Mobile SDRAM devices whose DQMx level is âDonât careâ during this phase.	Mobile SDRAM initialization must be performed in internal SRAM. 43.2.7 Reset Controller (RSTC)	43.2.6.2 Mobile SDRAM Device Initialization Constraint
ARM9	Atmel	SAM9260	When a user reset, watchdog reset, or software reset occurs during SDRAM read access, the SDRAM clock is turned off while data is ready to be read on the data bus. The SDRAM maintains the data until the clock restarts. If the user reset, watchdog reset, or software reset is programmed to assert a general reset, the data maintained by the SDRAM leads to a data bus conï¬ict and adversely affects the boot memories connected on the EBI: o NAND Flash boot functionality, if the system boots out of internal ROM. 0 NOR Flash boot, if the system boots on an external memory connected on the EBI CSO.	1. Avoid user reset, watchdog reset, software reset to generate a system reset. 2. Trap the user reset, watchdog reset, software reset with an interrupt. In the interrupt routine, power down the SDRAM properly and perform Peripheral and Processor Reset with software in assembler. Example with IibV3. o The main code: //user reset interrupt setting // Configure AIC controller to handle System peripheral interrupts AT9lF_AIC_ConfigureIt ( AT91C_BASE_AIC, // AIC base address AT91C_ID_SYS, // System peripheral ID AT91C_AIC_PRIOR_HIGHEST, // Max priority AT91C_AIC_SRCTYPE_INT_EDGE_TRIGGERED, // Level sensitive sysc_handler ); // Enable SYSC interrupt in AIC AT91F_AIC_EnableIt (AT91C_BASE_AIC, AT91C_ID_SYS) ; *AT91C_RSTC_RMR = (0xA5<<24) | (Ox4<<8) | AT91C_RSTC_URSTIEN; o The C SYS handler: extern void soft_user_reset(void); void sysc_handler(void){ //check if interrupt comes from RSTC if( (*AT91C_RSTC_RSR & AT91C_RSTC_URSTS ) == AT91C_RSTC_URSTS){ soft_user_reset(); //never reached while(l); } l 0 Assembly code is mandatory for the following sequence as ARM instructions need to be pipelined. The assembler routine: AREA TEST, CODE 806 SAM9260 [DATASHEET] AImeI-6221M-ATARM-SAMQZSO-DatasheetJ3-Jan-16 A t meL INCLUDE ATQlSAM9xxx.inc EXPORTsoft_user_reset soft_user_reset ;disable IRQs MRS r0, CPSR ORR r0, r0, #0x80 MSR CPSR_c, r0 ;change refresh rate to block all data accesses LDR r0, =AT91C_SDRAMC_TR LDR rl, =1 STR rl, [r0] ;prepare power down command LDR r0, =AT91C_SDRAMC_LPR LDR rl, =2 ;prepare proc_reset and periph_reset LDR r2 , =AT91C_RSTC_RCR LDR r3, =0xA5000005 ;perform power down command STR rl, [r0] ;perform proc_reset and periph_reset (in the ARM pipeline) STR r3, [r2] END 43.2.8 Serial Peripheral Interface (SPI)	43.2.7.1 RSTC: Reset during SDRAM Accesses
ARM9	Atmel	SAM9260	If the SPI is used in the following conï¬guration: 0 Master mode 0 CPOL = 1 and NCPHA = 0 0 multiple chip selects used with one transfer with baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR not equal to 1 o transmit with the slowest chip select and then with the fastest one then an additional pulse will be generated on output PSCK during the second transfer.	Do not use a multiple Chip Select conï¬guration where at least one SPI_CSRx register is conï¬gured with SCBR = 1 and the others differ from 1 if CPHA = 0 and CPOL = 1. If all chip selects are conï¬gured with SCBR = 1, the issue does not appear.	43.2.8.1 SPI: Bad Serial Clock Generation on Second chip_select when SCBR = 1, CPOL =1 and NCPHA = 0
ARM9	Atmel	SAM9260	When baud rate is set to 1 (i.e., when serial clock frequency equals the system clock frequency), and when the fields BITS (number of bits to be transmitted) equals an ODD value (in this case 9, 11, 13 or 15), an additional pulse is generated on output SPCK. No error occurs if BITS ï¬eld equals 8, 10, 12, 14 or 16 and SCBR = 1.	None. AtmeL SAM9260 [DATASHEET] 807 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 43.2.9 Serial Synchronous Controller (SSC)	43.2.8.2 SPI: Baud Rate Set to 1
ARM9	Atmel	SAM9260	When the SSC receiver is used in the following conï¬guration: 0 the internal clock divider is used (CKS = 0 and DIV different from 0), o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then, at the end of the data, the RK pin is set in high impedance which may be interpreted as an unexpected clock cycle.	Enable the pull-up on RK pin.	43.2.9.1 SSC: Unexpected RK Clock Cycle when RK Outputs a Clock During Data Transfer
ARM9	Atmel	SAM9260	When the SSC receiver is used in the following conï¬guration: 0 RX clock is divided clock (CKS = 0 and DIV different from 0) o RK pin set as output and provides the clock during data transfer (CKO = 2) 0 data sampled on RK falling edge (CKI = 0) then the ï¬rst clock cycle time generated by the RK pin is equal to MCK/(2 >< (DIV + 1)) instead of MCK/(2 >< DIV).	None.	43.2.9.2 SSC: Incorrect First RK Clock Cycle when RK Outputs a Clock During Data Transfer
ARM9	Atmel	SAM9260	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	43.2.9.3 SSC: Transmitter Limitations in Slave Mode
ARM9	Atmel	SAM9260	If Least Significant Bit is sent ï¬rst (MSBF = 0) the ï¬rst TAG during the frame synchro is not sent.	None. 43.2.10 Shutdown Controller (SHDWC)	43.2.9.4 SSC: Periodic Transmission Limitations in Master Mode
ARM9	Atmel	SAM9260	If only VDDBU is powered during boot sequence (No VDDCORE), the SHDN signal may be driven to low level voltage after a delay. This delay is linked to the startup time of the slow clock selected by OSCSEL signal. If SHDN pin is connected to the Enable pin (EN) of the VDDCORE regulator, VDDCORE establishment does not occur and the system does not start.	1. VDDCORE must be established within the delay corresponding to the startup time of the slow clock selected by OSCSEL. 2. Add a glue logic to latch the rising edge of the SHDN signal. The reset of the latch output (EN_REG) can be connected to a PIO and used to enter the shutdown mode. 808 SAM9260 [DATASHEET] AtmeL AImeI-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.11 System Controller	43.2.10.1 SHDWC: SHDN Signal may be Driven to Low Level Voltage During Device Power-on
ARM9	Atmel	SAM9260	If an event (RTTINC or ALMS) occurs within the same slow clock cycle as when the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle an RTT event as an interrupt and should not poll RTT_SR. 43.2.12 Two-wire Interface (TWI)	43.2.11.1 Possible Event Loss when Reading R1T_SR
ARM9	Atmel	SAM9260	At the end of transfer in slave mode, the slave mode is disabled, the master mode is enabled and thus a transfer in master mode can be performed. In the current device, the start event is correctly generated but the SCL line is stuck at 1, so no transfer is possible.	Two workarounds are possible: 1. Perform a software reset before going to master mode (TWI must be reconï¬gured). or 2. Perform a slave read access before switching to master mode. 43.2.13 UHP	43.2.12.1 TWI: Switch from Slave to Master Mode
ARM9	Atmel	SAM9260	Conditions: Consider the following sequence: 1. The Host controller issues an IN token. 2 The Device provides the IN data in a short packet. 3. The Host controller writes the received data to the system memory. 4 The Host controller is now supposed to carry out two Write transactions (TD status write and TD retirement write) to the system memory in order to complete the status update. 5. The Host controller raises the request for the ï¬rst write transaction. By the time the transaction is completed, a frame boundary is crossed. 6. After completing the first write transaction, the Host controller skips the second write transaction. Consequence: When this error occurs, the Host controller tries the same IN token again.	This problem can be avoided if the system guarantees that the status update can be completed within the same frame.	43.2.13.1 UHP: Non-ISO IN Transfers
ARM9	Atmel	SAM9260	Conditions: Consider the following sequence: 1. The Host controller sends an ISO OUT token after fetching 16 bytes of data from the system memory. 2. When the Host controller is sending the ISO OUT data, because of system latencies, remaining bytes of the packet are not available. This results in a buffer underrun condition. 3. While there is an underrun condition, if the Host controller is in the process of bit-stufï¬ng, it causes the Host controller to hang. AtmeL SAM9260 [DATASHEET] 809 AtmeIâ6221M-ATARM-SAMQZSO-Datasheet_13âJan-16 Consequence: After the failure condition, the Host controller stops sending the SOF. This causes the connected device to go into suspend state.	This problem can be avoided if the system can guarantee that no buffer underrun occurs during the transfer.	43.2.13.2 UHP: ISO OUT Transfers
ARM9	Atmel	SAM9260	Conditions: When a Remote Wakeup event occurs on a downstream port, the OHCI Host controller begins sending resume signaling to the device. The Host controller is supposed to send this resume signaling for 20 ms. However, if the driver sets the HcControl.HCFS into USBOPERATIONAL state during the resume event, then the Host controller terminates sending the resume signal with an EOP to the device. Consequence: If the Device does not recognize the resume (< 20 ms) event, then the Device remains in suspend state.	Host stack can do a port resume after it sets the HcControl.HCFS to USBOPERATIONAL. 43.2.14 USART	43.2.13.3 UHP: Remote Wakeup Event
ARM9	Atmel	SAM9260	TXD signal should be pulled up in Modern and Hardware Handshaking mode.	TXD is multiplexed with PIO which integrates a pull up resistor. This internal pull-up must be enabled.	43.2.14.1 USART: TXD Signal is ï¬oating in Modern and Hardware Handshaking Mode.
ARM9	Atmel	SAM9260	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter.	43.2.14.2 USART: DCD is Active High instead of Low
ARM9	Atmel	SAM9260	In receiver mode, when two characters are consecutive (without timeguard in between) the RXBRK is not taken into account. As a result the RXBRK ï¬ag is not enabled correctly and the frame error flag is set.	Constraints on the transmitter device connected to the SAM9260 USART receiver side. The transmitter may use the timeguard feature or send 2 STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data the receiver state machine will go into idle mode and enable the RXBRK condition.	43.2.14.3 USART: RXBRK Flag Error in Asynchronous Mode
ARM9	Atmel	SAM9260	1. Setting the receiver to hardware handshaking mode drops RTS line to low level even if the receiver is still turned off. USART needs to be completely conï¬gured and started before setting the receiver to hardware handshaking mode. 2. Disabling the receiver during a PDC transfer while RXBUFF ï¬ag is '0' has no effect on RTS. The only way to get the RTS line to rise to high level is to reset both PDMA buffers by writing the value '0' in both counter registers.	None. 810 SAM9260 [DATASHEET] AtmeL AImeI-6221 M-ATARM-SAMQZSO-Datasheet_13-Jan-16 43.2.15 Power Management Controller (PMC)	43.2.14.4 USART: RTS not Expected Behavior
ARM9	Atmel	SAM9G20	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digi- tal conversion, in order put ADC into sleep mode at the end of this conversion. 44.2.2 MCI	44.2.1.1 ADC: Sleep Mode
ARM9	Atmel	SAM9G20	The busy status of the card during the response (R1 b) is ignored for the commands CMD7, CMD28, CMD29, CMD38, CMD42, CMD56. Additionally, for commands CMD42 and CMD56 a conflict can occur on data lineO if the MCI sends data to the card while the card is still busy.The behavior is correct for CMD12 command (STOP_TRANSFER).	None.	44.2.2.1 MCI: Busy Signal of R1b responses is not taken in account
ARM9	Atmel	SAM9G20	If 1-bit data bus width and on other slots than slot A, the SDIO interrupt can not be captured. The sample is made on the bad data line.	None	44.2.2.2 MCI: SDIO Interrupt does not work for slot different from A
ARM9	Atmel	SAM9G20	As the data Timeout error flag checking the Naac timing cannot rise, the MCI can be stalled wait- ing indefinitely the Data start bit.	A STOP command must be sent with a software timeout.	44.2.2.3 MCI: Data Timeout Error Flag
ARM9	Atmel	SAM9G20	The Data Write operation with a number of bytes less than 12 is impossible.	The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT field are used to specify the real count number.	44.2.2.4 MCI: Data Write Operation and number of bytes
ARM9	Atmel	SAM9G20	In half duplex mode, the reset of the flags ENDRX, RXBUFF, ENDTX and TXBUFE can be incorrect. These flags are reset correctly after a PDC channel enable.	792 AT91SAM9G20 Preliminary â 6384AâATARMâ28-May-08 â AT91SAM9G20 Preliminary Enable the interrupts related to ENDRX, ENDTX, RXBUFF and TXBUFE only after enabling the PDC channel by writing PDC_TXTEN or PDC_RXT EN. 44.2.3 Reset Controller (RSTC)	44.2.2.5 MCI: Flag Reset is not correct in half duplex mode
ARM9	Atmel	SAM9G20	When a User Reset occurs during SDRAM read access, the SDRAM clock is turned off while data are ready to be read on the data bus. The SDRAM maintains the data until the clock restarts. If the user Reset is programmed to assert a general reset, the data maintained by the SDRAM leads to a data bus conflict and adversely affects the boot memories connected on the EBI: . NAND Flash boot functionality, if the system boots out of internal ROM. . NOR Flash boot, if the system boots on an external memory connected on the EBI CSO.	1. Avoid User Reset to generate a system reset. 2. Trap the User Reset with an interrupt. In the interrupt routine, Power Down SDRAM properly and perform Peripheral and Processor Reset with software in assembler. Example with libV3. - The main code: //user reset interrupt setting // Configure AIC controller to handle SSC interrupts AT91F_AIC_ConfigureIt ( AT91C_BASE_AIC, // AIC base address AT91C_ID_SYS, // System peripheral ID AT91C_AIC_PRIOR_HIGHEST, // Max priority AT91C_AIC_SRCTYPE_INT_EDGE_TRIGGERED, // Level sensitive sysc_handler ); // Enable SYSC interrupt in AIC AT91F_AIC_EnableIt (AT91C_BASE_AIC, AT91C_ID_SYS) ,' *AT91C_RSTC_R.MR = (0xA5<<24) | (0x4<<8) | AT91C_RSTC_URSTIEN; 0 The C SYS handler: extern void soft_user_reset (void); void sysc_handler (void) { A IIIEI. 793 6384AâATARMâ28-May-08 E Â® //check if interrupt comes from RSTC if( (*AT91C_RSTC_RSR s: AT91C_RSTC_URSTS ) == AT91C_RSTC_U'RSTS){ soft_user_reset(); //never reached while(1); } - The assembler routine: AREA TEST, CODE INCLUDEATSlSAMSxxx. inc EXPORTsoft_user_reset soft_user_reset ;disable IRQs MRS r0, CPSR ORR r0, r0, #0x80 MSR CPSR_C, r0 ;change refresh rate to block all data accesses LDR r0, =AT9lC_SDRAMC_TR LDR r1, 1 STR r1, [r0] ;prepare power down command LDR r0, =AT91C_SDRAMC_LPR LDR r1, =2 ;prepare proc_reset and periph_reset LDR r2, =AT91C_RSTC_RCR LDR r3, =0xA5000005 ;perform power down command STR r1, [r0] ;perform proc_reset and periph_reset (in the ARM pipeline) STR r3 , [r2] END 44.2.4 Serial Peripheral Interface (SPI)	44.2.3.1 RSTC: Reset During SDRAM Accesses
ARM9	Atmel	SAM9G20	If the SPI is used in the following configuration: - master mode 794 AT91SAM9G20 Preliminary â 6384AâATARMâ28-May-08 â AT91SAM9G20 Preliminary 0 CPOL =1 and NCPHA = O - multiple chip selects used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR not equal to 1 - transmit with the slowest chip select and then with the fastest one then an additional pulse will be generated on output PSCK during the second transfer.	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 it CPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear.	44.2.4.1 SPI: Bad Serial Clock Generation on second chip_select when SCBR = 1, CPOL = 1 and NCPHA = 0
ARM9	Atmel	SAM9G20	When Baudrate is set to 1 (i.e., when serial clock frequency equals the system clock frequency), and when the fields BITS (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse is generated on output SPCK. No error occurs if BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None. 44.2.5 Serial Synchronous Controller (SSC)	44.2.4.2 SPI: Baudrate set to 1
ARM9	Atmel	SAM9G20	When the SSC receiver is used in the following configuration: - the internal clock divider is used (CKS =0 and DIV different from 0), - RK pin set as output and provides the clock during data transfer (CKO=2) - data sampled on RK falling edge (CKI =0) then, at the end of the data, the RK pin is set in high impedance which may be interpreted as an unexpected clock cycle.	Enable the pull-up on RK pin.	44.2.5.1 SSC: Unexpected RK clock cycle when RK outputs a clock during data transfer
ARM9	Atmel	SAM9G20	When the SSC receiver is used in the following configuration: 0 RX clock is divided clock (CKS = 0 and DIV different from 0) o RK pin set as output and provides the clock during data transfer (CKO = 2) - data sampled on RK falling edge (CKI = 0) then the first clock cycle time generated by the RK pin is equal to MCK/(2 x (DIV +1)) instead of MCK/(2 x DIV).	None.	44.2.5.2 SSC: Incorrect first Fl'K clock cycle when RK outputs a clock during data transfer
ARM9	Atmel	SAM9G20	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when start of edge (rising or falling) of synchro with a Start Delay equal to zero. A IIIEI. 795 6384AâATARMâ28-May-08	None.	44.2.5.3 SSC: Transmitter Limitations in Slave Mode
ARM9	Atmel	SAM9G20	If Last Significant Bit is sent first (MSBF = 0) the first TAG during the frame synchro is not sent.	None. 44.2.6 System Controller (SYSC)	44.2.5.4 SSC: Periodic Transmission Limitations in Master Mode
ARM9	Atmel	SAM9G20	If an event (R'I'I'INC or ALMS) occurs within the same slow clock cycle as when the R'I'I'_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle an R'I'I' event as an interrupt and should not poll RTI'_SR. 44.2.7 UHP	44.2.6.1 SYSC: Possible Event Loss when reading R'IT_SR
ARM9	Atmel	SAM9G20	Conditions: Consider the following sequence: 1. The Host controller issues an IN token. 2 The Device provides the IN data in a short packet. 3. The Host controller writes the received data to the system memory. 4 The Host controller is now supposed to carry out two Write transactions (TD status write and TD retirement write) to the system memory in order to complete the status update. 5. The Host controller raises the request for the first write transaction. By the time the transaction is completed, a frame boundary is crossed. 6. After completing the first write transaction, the Host controller skips the second write transaction. Consequence: When this error occurs, the Host controller tries the same IN token again.	This problem can be avoided if the system guarantees that the status update can be completed within the same frame.	44.2.7.1 UHP:Non-ISO IN Transfers
ARM9	Atmel	SAM9G20	Conditions: Consider the following sequence: 1. The Host controller sends an ISO OUT token after fetching 16 bytes of data from the system memory. 2. When the Host controller is sending the ISO OUT data, because of system latencies, remaining bytes of the packet are not available. This results in a buffer underrun condition. 3. While there is an underrun condition, if the Host controller is in the process of bit-stuff- ing, it causes the Host controller to hang. 796 AT91SAM9G20 Preliminary â 6384AâATARMâ28-May-08 â AT91SAM9G20 Preliminary Consequence: After the failure condition, the Host controller stops sending the SOF. This causes the connected device to go into suspend state.	This problem can be avoided if the system can guarantee that no buffer underrun occurs during the transfer.	44.2.7.2 UHP: ISO OUT transfers
ARM9	Atmel	SAM9G20	Conditions: When a Remote Wakeup event occurs on a downstream port, the OHCI Host controller begins sending resume signaling to the device. The Host controller is supposed to send this resume signaling for 20 ms. However, if the driver sets the HcControl.HCFS into USBOPERATIONAL state during the resume event, then the Host controller terminates sending the resume signal with an EOP to the device. Consequence: If the Device does not recognize the resume (<20 ms) event then the Device remains in suspend state.	Host stack can do a port resume after it sets the HcControl.HCFS to USBOPERATIONAL. 44.2.8 Two-wire Interface (TWI)	44.2.7.3 UHP: Remote Wakeup Event
ARM9	Atmel	SAM9G20		44.2.9 USART The RXRDY Flag is not reset when a Software reset is performed. Problem Fix/Workaround After a Software Reset, the Register TWI_RHR must be read.	44.2.8.1 TWI: RXRDY Flag is not reset by a SOFTWARE Reset
ARM9	Atmel	AT91RM9200	A24 is not wired internally between the EBI and the PIO. Use only PIO mode on it.	Due to this error, static memories over 16 Mbytes per chip select cannot be used. To interface 32-Mbyte memories and over, the user must use two memory chips connected on two different chip selects. 41.2 EMAC	41.1.1 A24 not wired internally between the EBI and the PIO
ARM9	Atmel	AT91RM9200	A dead lock may appear when the Ethernet MAC attempts to store a new received valid frame while there are no more rx buffer descriptors. This appears only when the received frame length is not a multiple of 4 bytes. In this conï¬guration, even if the application enables new receive buffer descriptors, all packets will be rejected.	The software workaround is to disable and re-enable the receive function in the network function register ETH_CTL each time a buffer is not available (RBNA in the status register). ETH CTL &= ~0x00000004 ; ETH CTL |= 0x00000004 ; Note that an interrupt can be activated for the RBNA detection. Another workaround is to align the address of the receive buffer descriptor on a boundary of 16 Words (address Oxaaaa aaOO, Oxaaaa aa40, Oxaaaa aa80, ..... ) 41.3 MCI	41.2.1 Using Receive frames and buffers not word-aligned
ARM9	Atmel	AT91RM9200	The data endianess is inverted when writing or reading to or from an MMC or SD card. If the MCI interface is exclusively used to read/write from/to a dedicated card the inversion is not visible (two inversions). Furthermore, if the card is shared with other systems then endianess will not match. This endianess inversion concerns only data sectors and not command and response.	A software workaround consists of swapping the order of word bytes before writing and after reading.	41.3.1 Data Endianess inversion from the MCI to MMC or SD Card
ARM9	Atmel	AT91RM9200	As the data timeout error ï¬ag cannot rise, the MCI is stalled indeï¬nitely waiting for the data start bit.	A STOP command must be sent with a software timeout.	41.3.2 Data Timeout Error Flag
ARM9	Atmel	AT91RM9200	The STREAM READ/WRITE commands are not supported by the MCI.	None. 682 AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G	41.3.3 STREAM command not supported
ARM9	Atmel	AT91RM9200	The WRITE_MULTIPLE_BLOCK with a transfer size (PDC) not a multiple of the block length is not stopped by the STOP command.	Choose an appropriate size for the block length.	41.3.4 STOP during a WRITE_MULTIPLE_BLOCK command
ARM9	Atmel	AT91RM9200	The DTIP ï¬ag is not reset if STOP_COMMAND is received in the middle of a block data transfer.	None.	41.3.5 DTIP flag
ARM9	Atmel	AT91RM9200	A STOP command with SYNCHRONISED special command is sent after the block data transfer ends. During this time the MMCI receives data but the RXRDY ï¬ag is no longer asserted.	Do not send a STOP command with SYNCHRONISED special command.	41.3.6 STOP command with SYNCHRONISED special command
ARM9	Atmel	AT91RM9200	Do not read/write the Data FIFO if RXRDY/TXRDY status bits are not set.	None.	41.3.7 Data FIFO and status bits
ARM9	Atmel	AT91RM9200	The shared FIFO is reset at the beginning of a transfer command.	So as to avoid losing data, it is mandatory to enable the PDC channel after writing to the command register. In order to achieve this sequence correctly, it is mandatory to disable all IT sources.	41.3.8 DATA FIFO problem with PDC
ARM9	Atmel	AT91RM9200	The DATA_CRC_ERR (error ï¬ag) never rises during the checking of bad data CRC status sent by MMC/SD card after block writing.	CRC must be done by software.	41.3.9 DATA_CRC_ERR ï¬ag never rises
ARM9	Atmel	AT91RM9200	If the user sends a READ_MULT|PLE_BLOCK command and stops it by using a STOP_COMMAND in the middle of a data block transfer then the internal state of the MMCI controller stops in a bad state.After that the following read block (with READ_SINGLE_BLOCK or READ_MULT|PLE_BLOCK) will be entirely corrupted.	It consists in doing a software reset if RXRDY = 1 after the STOP_COMMAND. This ï¬ag indicates that the MMCI receives more data than the PDC has been settle to transfer. After this soft reset the MCI_CR, MCI_MR, MCI_DTOR, MCI_SDCR need to be reassigned. At m eL AT91RM9200 [DATASHEET] 683 Atmel-1768J-ATARM-ATQ1 RM9200-Damsheet_03-Mar-16	41.3.10 STOP during a READ_MULT|PLE_BLOCK command
ARM9	Atmel	AT91RM9200	The Data Write operation with a number of bytes less than 12 is impossible.	The PDC counters must always be equal to 12 bytes for data transfers lower than 12 bytes. The BLKLEN or BCNT ï¬eld are used to specify the real count number. 41.4 PIO	41.3.11 Data write operation and number of bytes
ARM9	Atmel	AT91RM9200	NWAIT activity depends on use of P06. The P06 line multiplexes with the NWAIT function. As the PIO Controller is transparent in input, the level on the P06 line has direct impact on the behavior of the EBI. In particular, driving the P06 line to 0 might lead to a deadlock of the system.	Use P06 carefully. In general, it is recommended to not use P06 and to make sure the pull-up is enabled.	41.4.1 NWAIT activity depends on use of P06
ARM9	Atmel	AT91RM9200	The programming of the register P|O_OWSR has no effect on the read/write features of PIO_ODSR, which is always read/write accessible.	None. 41.5 PMC	41.4.2 Output Data Status Register is always Readerite
ARM9	Atmel	AT91RM9200	The PMC_MCKR register must not be programmed in a single write operation.	The preferred programming sequence for the PMC_MCKR register is as follows: 1. Program the 088 ï¬eld in the PMC_MCKR. 2. Wait for the MCKRDY bit to be set in the PMC_SR register. 3. Program the PRES ï¬eld (in the PMC_MCKR). An exception to this sequence occurs when the processor clock frequency is greater than the master clock frequency. In this case, the PRES ï¬eld should be written first.	41.5.1 Constraints on the Master Clock selection sequence
ARM9	Atmel	AT91RM9200	When re-programming the Master Clock Register, if both ï¬elds PRES and 083 are written with the same values as the ones already stored, or if both ï¬elds are written with different values than the ones already stored, the status bit MCKRDY does not rise. When one and only one of the ï¬elds PRES and CSS is changed, the MCKRDY bit operates normally.	If both ï¬elds must be re-programmed, carry out the change in two steps.	41.5.2 MCKRDY does not rise in some cases
ARM9	Atmel	AT91RM9200	When the fields MUL and DIV in the CKGR_PLLBR register are written with the same values as already programmed, the Master Clock signal switches to Main Clock (output of the Main Oscillator) until a different value is programmed in the register. AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G When the fields MUL and DIV in the CKGR_PLLAR register are written with the same values as already programmed, the Master Clock signal switches to Slow Clock (output of the 32.768 kHz Oscillator) until a different value is programmed in the register.	The user must be sure that either the DIV or MUL ï¬eld changes when setting the CKGR_PLLBR or CKGR_PLLAR register. 684	41.5.3 PMC, Clock Generator: Bad switching when writing PLL registers with same MUL and DIV values
ARM9	Atmel	AT91RM9200	With PLLA, it is not possible to have an MCKRDY ï¬ag raised.	Even if MCKRDY ï¬ag does not raise with PLLA, it will not prevent you from switching on it. You just need to wait for the PLLA lock time; for that program, PLLA then PLLB. When PLLB is ready, PLLA is ready too. Main Oscillator in Bypass Mode: CKGR_MOR = 0x00000002 PLLA programming: CKGR_PLLAR = 0x20063E01 PLLB programming: CKGR_PLLBR = 0x10173F05 Wait PLLB LOCKB bit: PMC_SR will be 0x00000000 Switch on PLLACK clock: PMC_MCKR -> 0x00000102 PMC_SR will be 0x00000000 41.6 ROM Bootloader ROM Bootloader: Limitation with 8-bit parallel memories. Limitation with 8-bit parallel memories. In the internal Boot ROM program, version 1.0, the wait state number on 080 is set to 0 during Boot ROM initialization. This gives an access time of 20 ns at 48 MHz Master Clock Frequency. This limitation of the ROM Bootloader applies to AT91RM9200 with the product number 58A07F. Problem Fix/Workaround None. 41.7 SDRAMC	41.5.4 OSCBYPASS is not functional with PLLA
ARM9	Atmel	AT91RM9200	The Interrupt Mask Register in the SDRAM Controller is not read-only. Thus, writing to it modifies the contents instead of having no effect.	None.	41.7.1 SDRC_IMR can be written
ARM9	Atmel	AT91RM9200	In the case of SDRAM devices featuring two internal banks, when the physical address is higher than the memory size, the SDRAM controller does not wrap around. It activates virtual bank numbers three or four.	None. At m eL AT91RM9200 [DATASHEET] 685 Atmel-1768J-ATARM-ATQ1 RM9200-Damsheet_03-Mar-16	41.7.2 No wrap-around for SDRAM devices with two internal banks
ARM9	Atmel	AT91RM9200	When low-power mode is enabled and after a refresh command is sent to the SDRAM, the SDRAM Controller enters low-power mode by asserting SDCKE low. The tRc timing between Auto-refresh and Low-power mode is not respected. As SDCKE is low, the INHIBIT and NOP commands are not sent to the SDRAM. For the moment this warning has no effect on the correct functionality of the SDRAM.	None.	41.7.3 No tRc after refresh when low-power mode is enabled
ARM9	Atmel	AT91RM9200	The SDRAM controller does not support the following devices in 32-bit mode: 0 128 Mbit device: 32M*4bits: 4 banks/12 rows/11 columns 0 256 Mbit device: 64M*4bits: 4 banks/13 rows/11 columns	None.	41.7.4 Some devices are not supported
ARM9	Atmel	AT91RM9200	Writing 0 to the Interrupt Enable Register or to the Interrupt Disable Register modifies the value of Interrupt Mask Register.	None. 41.8 SMC	41.7.5 Interrupt Disable Register
ARM9	Atmel	AT91RM9200	The address bus is continuously driven with the address of the current access, even if it is an internal one.	None.	41.8.1 Address Bus continuously active
ARM9	Atmel	AT91RM9200	When at least two SMC_CSR registers are programmed as follows: â SMC_SCRx: With wait states (1 < NWS < 127), 16-bit data bus width, and byte write access (BAT ï¬eld set to 0) _ SMC_CSRy: With wait states (1 < NWS < 127), 16-bit data bus width, and byte select access (BAT field set to 1), the associated NCSx signal is not asserted for the write access.	For registers programmed with wait states and 16-bit data bus width conï¬guration, the BAT ï¬elds in these registers must be programmed with the same value. 41.9 SPI	41.8.2 16-bit write access constraints
ARM9	Atmel	AT91RM9200	If the SPI receives a frame followed by 8 bits of data, the user needs to mask the highest byte of the Receive Holding Register, as this data may be incorrect and not 0.	AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G The user should implement the PDC. If the PDC is not implemented, the user should mask the highest byte of the Receive Holding register. 686	41.9.1 Slave Mode Receiver does not mask the highest data bits
ARM9	Atmel	AT91RM9200	If the SPI is programmed in Master Mode and in Fixed Peripheral Mode, and data is being sent to a slave, the user has to wait for completion of the transfer before changing the slave number. Programming a new slave number (PCS) and/or a new DLYBCS ï¬eld locks the SPI on the current slave.	The user should use the Variable Peripheral Mode.	41.9.2 No chip select configuration change before end of current transfer
ARM9	Atmel	AT91RM9200	If the SPI has sent all the data written in the SPI_TDR, the current NPCS rises immediately. This might be inconvenient in the case of several SPI peripherals requiring their chip select line to remain active until a complete data buffer has been transmitted. The PDC channel may be late in providing data to be transmitted when bus latencies are too high.	For high-speed applications, the relevant PIO pins can be used to manage the data transmission.	41.9.3 NPCSx rises if no data is to be transmitted
ARM9	Atmel	AT91RM9200	If Mode fault is disabled, Chip Select 0 cannot be driven by a component other than the SPI otherwise the transfer does not occur.	None. 41.10 SSC	41.9.4 Mode Fault does not allow more than one Master on Chip Select 0
ARM9	Atmel	AT91RM9200	The SSC receiver does not support reception of the last data sequence of a frame that overlaps a new start of frame, regardless of the mode of detection of the start condition. For example, this prevents reception of the last data of a TDM bus.	None.	41.10.1 Receiver does not take into account a start condition while receiving data
ARM9	Atmel	AT91RM9200	The status bits RXSYN and TXSYN are active during a complete serial clock period and are not immediately cleared when SSC_SR is read.	The user must enable the interrupt relevant to RXSYN and TXSYN.	41.10.2 RXSYN and TXSYN not cleared when read
ARM9	Atmel	AT91RM9200	â If RF is programmed as input, the maximum clock frequency is MCK divided by 2. â If RF is programmed as output and RK is programmed as input, the maximum clock frequency is MCK divided by 6. â If RF and RK are both programmed as output, the maximum clock frequency is MCK divided by 4.	None. At m eL AT91RM9200 [DATASHEET] 687 Atmel-1768J-ATARM-ATQ1 RM9200-Damsheet_03-Mar-16 41 .10.4 Transmitter Speed Limitations _ If both TF and TK are programmed as output, the maximum clock frequency is MCK divided by 4. _ If TF is programmed in output and TK is programmed as input, the maximum clock frequency is MCK divided by 8. â If both TF and TK are programmed as input, the maximum clock frequency is MCK divided by 8. _ If TF is programmed in input and TK is programmed as output, the maximum clock frequency is MCK divided by 4. Problem Fix/Workaround None.	41.10.3 Receiver Speed Limitations
ARM9	Atmel	AT91RM9200	Generating RF can be stopped only by programming the FSOS ï¬eld in SSC_RFMR to 0x0. Generating TF can be stopped only by programming the FSOS ï¬eld in SSC_TFMR to 0x0.	None.	41.10.5 Disabling the SSC does not stop the Frame Synchronization signal generation
ARM9	Atmel	AT91RM9200	When transmission of data is programmed at the end of a frame and the start condition of the following frame is detected at the end of the current frame, the delay programmed by the STTDLY bit (in the SSC_RCMR and in the SSC_TCMR registers) is not performed on the next frame. Transmission starts immediately regardless of the programming of the ï¬eld STTDLY.	None.	41.10.6 No delay when start condition overlays data transmit
ARM9	Atmel	AT91RM9200	When SSC is conï¬gured with the following conditions: 0 TOMR.STI'DLY more than 0 o ROMR.START = Start on falling edge / Start on Rising edge I Start on any edge 0 RFMR.FSOS = None (input) 0 TOMR.START = Receive Start An unexpected delay of 2 or 3 system clock cycles is added to TD output.	None. 41.11 TC	41.10.7 Unexpected delay on TD output
ARM9	Atmel	AT91RM9200	If the counter was stopped or disabled, unwanted Compare RA, RB or R0 may occur at restart if the clock selected by the counter is masked by a low selected burst input when the trigger event is recognized at the selected clock active edge. All compare effects are affected, as the ï¬ags are set incorrectly and 0P0 trigger, 0P0 stop or 0P0 disable may occur.	None. 688 AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G	41.11.1 Wrong Compare at restart if burst low
ARM9	Atmel	AT91RM9200	A wrong 0 is captured in RA or RB during the last selected counter clock period if CPCTRG is active and the capture event occurred at least one Master Clock cycle after the last counter value update.	None.	41.11.2 Wrong 0 captured before Compare RC trigger
ARM9	Atmel	AT91RM9200	The value captured is not equal to the Counter Value if the selected burst input is low at capture time, i.e., at the selected clock active edge where the capture event is recognized. The captured value may be 0; othenrvise, it is the Counter Value plus one instead of the Counter Value.	None.	41.11.3 Erroneous capture with burst low
ARM9	Atmel	AT91RM9200	The captured value is not zero if burst is low when the preceding trigger event is recognized. Instead, the captured value is the Counter Value before the trigger.	None.	41.11.4 Bad capture at restart if burst low
ARM9	Atmel	AT91RM9200	In the register TC_CMR, if at least one of the fields ASWTRG or AEEVT or ACPC is set to 0x0 (none), the event programmed by ACPA is not carried out. In the register TC_CMR, if at least one of the fields ASWTRG or AEEVT is set to 0x0 (none), the event programmed by ACPC is not carried out. In the register TC_CMR, if the ï¬eld ASWTRG is set to 0x0 (none), the event programmed by AEEVT is not carried out. The same problem exists on the TIOB output with the ï¬elds BSWTRG, BEEVT, BCPC and BCPB.	An order of priority for TIOA and/or TIOB events must be deï¬ned depending on the user application.	41.11.5 TIOA and TIOB outputs stuck in case of simultaneous events
ARM9	Atmel	AT91RM9200	TIMER_CLOCK2/TIMER_CLOCK5 is sampled on the system clock falling edge of Master Clock, whereas TIMER_0LOCKO/TIMER_CLOCK3 and TIMER_CLOCK1/TIMER_CLOCK4 are sampled on the rising edge of Master Clock. This should not have any effect on the functional operations of the Timer Counter unless the Timer Counter is used at its speed limit.	None.	41.11.6 TIMER_CLOCK2 not sampled on same edge as TIMER_CLOCKO and TIMER_CLOCK1
ARM9	Atmel	AT91RM9200	When the field WAVESEL in TC_CMR is at value 0x1 or 0x3, the triggers do not reset the counter value. The counter value can be reset only by modifying the ï¬eld WAVESEL.	None. At m eL AT91RM9200 [DATASHEET] 689 Atmel-1768J-ATARM-ATQ1 RM9200-Damsheet_03-Mar-16	41.11.7 Triggers do not clear the counter in UplDown Mode
ARM9	Atmel	AT91RM9200	When the ï¬eld WAVESEL in TC_CMR is at value 0x1 or 0x3, the triggers occurring while the selected burst signal is active (clock disabled) are not taken into account.	None.	41.11.8 Triggers in UplDown Mode are lost when burst signal is active
ARM9	Atmel	AT91RM9200	Selecting the Master Clock or the Master Clock divided by 2 as the Timer Counter Clock may lead to unpredictable result when the ï¬eld WAVESEL in TC_CMR is at value 0x1 or 0x3.	None.	41.11.9 Clock Selection Limitation in UplDown Mode
ARM9	Atmel	AT91RM9200	When the ï¬eld WAVESEL in TC_CMR is at value 0x1 or 0x3 and when the counter reaches the value OxFFFF, it inverts its sense and decrements to OxFFFE. At the same time, the OVF bit in TC_SR is set.	None. 41.12 TWI	41.11.10 Spurious counter overï¬ow in UplDown Mode
ARM9	Atmel	AT91RM9200	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	41.12.1 Disabling Does not Operate Correctly
ARM9	Atmel	AT91RM9200	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. Note: TXCOMP and NACK ï¬elds are set simultaneously and the NACK ï¬eld is reset after the read of the TWI_SR.	41.12.2 NACK Status Bit Lost
ARM9	Atmel	AT91RM9200	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the ï¬rst subsequent transmit data byte. Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data.	41.12.3 Possible Receive Holding Register Corruption
ARM9	Atmel	AT91RM9200	The value of CLDIV x 2â3"âV must be less than or equal to 8191; the value of CHDIV x 2â3"âV must be less than or equal to 8191.	None. 690 AT91RM9200 [DATASHEET] AtmeL Almel-1768J-ATARM-AT91 RM9200-Datasheet_03-Marâ1 G	41.12.4 Clock Divider
ARM9	Atmel	AT91RM9200	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	41.12.5 Software reset
ARM9	Atmel	AT91RM9200	TXCOMP and TXRDY are not reset by MSDIS.	None.	41.12.6 TXCOMP and TXRDY reset
ARM9	Atmel	AT91RM9200	In case of high latency to process the RXRDY interrupt, with RXRDY set, if the receive data register is read at the same time as new data is captured into the register, the RXRDY ï¬ag is cleared and the new data is lost because the associated RXRDY is not set.	None. 41.13 USART	41.12.7 Data lost on high latency
ARM9	Atmel	AT91RM9200	Internally, the RTSO signal of the USARTO is not connected to PA21.	The RTSO signal of the USARTO is connected to the PIO Controller D. The PIOD can be used to control the RTSO signal. The PIOD is only available in the AT91RM9200 LFBGA package.	41.13.1 RTSO not connected
ARM9	Atmel	AT91RM9200	US_IF must be initialized even in transmission mode.	None.	41.13.2 US_IF must be initialized
ARM9	Atmel	AT91RM9200	The TXD signal should be pulled up in Modern and Hardware Handshaking modes.	TXD is multiplexed with PIO which integrates a pull-up resistor. This internal pull-up needs to be enabled.	41.13.3 TXD signal is ï¬oating in Modem and Hardware Handshaking modes
ARM9	Atmel	AT91RM9200	The DCD signal is active at 'High' level into the USART block (Modem mode). DCD should be active at 'Low' level.	Add an inverter. At m eL AT91RM9200 [DATASHEET] 691 Atmel-1768J-ATARM-ATQ1 RM9200-Betasheet_03-Mar-16	41.13.4 DCD is active High instead of Low
ARM9	Atmel	AT91RM9200	The Number of Errors Register always returns 0 instead of the ISO7816 error number.	None. 41.14 USB Host Port	41.13.5 Bad value in Number of Errors Register
ARM7	Atmel	SAM7S512	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S512	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S512	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S512	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S512	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S512	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 599 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S512	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S512	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S512	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S512	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	ADC: Spurious Clear of EOC Flag
ARM7	Atmel	SAM7S512	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.4.2 Embedded Flash Controller (EFC)	ADC: Sleep Mode
ARM7	Atmel	SAM7S512	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 600 The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and until 55 MHz, two Wait States (FWS = 2) are required.	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.4.3 Parallel Input/Output Controller (PIO)	EFC: Embedded Flash Access Time 1
ARM7	Atmel	SAM7S512	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S512	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S512	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.4.4 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S512	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 601	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S512	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S512	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S512	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S512	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.4.5 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S512	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.4.6 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S512	SPI: Software Reset Must be Written Twice If a software reset (SWRST in the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select).	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	SPI: Software Reset Must be Written Twice
ARM7	Atmel	SAM7S512	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT = 1 and SCBR = 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 602	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1
ARM7	Atmel	SAM7S512	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) Behavior
ARM7	Atmel	SAM7S512	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S512	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S512	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S512	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S512	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 603 Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.4.7 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S512	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S512	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S512	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.4.8 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S512	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 604 None.	TWI: Clock Divider
ARM7	Atmel	SAM7S512	TWI: Software Reset when a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S512	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S512	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S512	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.4.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S512	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes high near the end of the start bit, a character can be lost. CTS must not go high during a time slot occurring between 2 Master Clock periods before and 16 Master Clock periods after the rising edge of the start bit.	None.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S512	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 605	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S512	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S512	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	USART: RXBRK Flag Error in Asynchronous Mode
ARM7	Atmel	SAM7S512	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.5 SAM7S512 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S512 Revision B chip ID is: 0x270B 0A4F. 40.5.1 Analog-to-Digital Converter (ADC)	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S512	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S512	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S512	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 606	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S512	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S512	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S512	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S512	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S512	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S512	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled). SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 607	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S512	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	ADC: Spurious Clear of EOC Flag
ARM7	Atmel	SAM7S512	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.5.2 Embedded Flash Controller (EFC)	ADC: Sleep Mode
ARM7	Atmel	SAM7S512	EFC: Embedded Flash Access Time 2 The Flash memory access time has been reduced as per the table below: Flash Wait State (FWS) Read Operations Maximum Operating Frequency (MHz) 0 1 cycle 16 1 2 cycles 32 2 3 cycles 48 3 4 cycles 55	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.5.3 Parallel Input/Output Controller (PIO)	EFC: Embedded Flash Access Time 2
ARM7	Atmel	SAM7S512	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	Set the I/O to VDDIO by internal or external pull-up. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 608	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S512	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S512	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.5.4 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S512	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S512	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S512	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S512	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 609 Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S512	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.5.5 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S512	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.5.6 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S512	SPI: Software Reset Must be Written Twice If a software reset (SWRST in the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select).	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	SPI: Software Reset Must be Written Twice
ARM7	Atmel	SAM7S512	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT = 1 and SCBR = 1.	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1
ARM7	Atmel	SAM7S512	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) Behavior
ARM7	Atmel	SAM7S512	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 610	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S512	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S512	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S512	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S512	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.5.7 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S512	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 611	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S512	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S512	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.5.8 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S512	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S512	TWI: Software Reset when a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S512	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 612	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S512	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S512	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.5.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S512	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes high near the end of the start bit, a character can be lost. CTS must not go high during a time slot occurring between 2 Master Clock periods before and 16 Master Clock periods after the rising edge of the start bit.	None.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S512	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S512	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S512	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	Constraints on the transmitter device connected to the SAM7S USART receiver side: SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 613 The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	USART: RXBRK Flag Error in Asynchronous Mode
ARM7	Atmel	SAM7S512	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.6 SAM7S256 Errata - Manufacturing Number 58818C Refer to Section 40.1 âMarkingâ on page 595. Important: Section 40.6.14.1 âWDT: The Watchdog Timer May Lock the Device in a Reset Stateâ 40.6.1 Chip ID	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S256	Wrong Chip ID Value The Chip ID is 0x270D0940 instead of 0x270B0940.	None. 40.6.2 Analog-to-Digital Converter (ADC)	Wrong Chip ID Value
ARM7	Atmel	SAM7S256	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S256	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S256	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S256	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 614	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S256	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S256	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 615	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S256	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	ADC: Spurious Clear of EOC Flag
ARM7	Atmel	SAM7S256	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.6.3 Master Clock (MCK)	ADC: Sleep Mode
ARM7	Atmel	SAM7S256	MCK: Limited Master Clock Frequency Ranges If the Flash is operating without wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with one wait state, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with two wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 25 MHz. If the Flash is operating with three wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 38 MHz. If these constraints are not respected, the correct operation of the system cannot be guaranteed and either data or prefetch abort might occur. The maximum operating frequencies (at 30 MHz @ 0 Wait States and 55 MHz @ 1 Wait State) as stated in Table 37-24, âEmbedded Flash Wait States,â on page 582, are still applicable. Note: It is not necessary to use 2 o 3 wait states because t he Flash can operate at maximum frequency with only 1 wait state.	The user must ensure that the device is running at the authorized frequency by programming the PLL properly to not run within the forbidden frequency range. 40.6.4 Non Volatile Memory Bits (NVM Bits)	MCK: Limited Master Clock Frequency Ranges
ARM7	Atmel	SAM7S256	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applic able to 256 KB Flash memory, it remains at 10K for the Flash memory.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 616 40.6.5 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S256	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.6.6 Power Management Controller (PMC)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S256	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1 Under certain rare circumstances, when CSS = 00 in PMC_MCKR, and PA1 is set as an input and a transition occurs on PA1, device malfunction might occur.	Do not transition PA1 as an input when CSS = 00 in PMC_MCKR.	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1
ARM7	Atmel	SAM7S256	PMC: Programming CSS in PMC_MCKR Register Under certain rare circumstances, reprogramming the CSS value in the PMC_MCKR register (i.e switching the main clock source) might generate malfunction of the device if the following two actions occur simultaneously. 1. Switching from: â PLL Clock to Slow Clock or SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 617 â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock And 2. Program code is being executed out of flash, or a transition is occurring on PA1, either as an input or output. Note: This issue does not occur when transitioning from slow clock to main clock or from slow clock to PLL clock.	When changing CSS in the PMC_MCKR to switch from â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock Ensure that the processor is executing out of SRAM and ensure no transition occurs on PA1, either as an input or output, starting from writing to the PMC_MCKR register until MCKRDY = 1. 40.6.7 Pulse Width Modulation Controller (PWM)	PMC: Programming CSS in PMC_MCKR Register
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S256	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S256	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 618	Do not disable a channel before completion of one period of the selected clock. 40.6.8 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR.	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S256	RTT: RTT_VR May be Corrupted Under certain rare circumstances, the Real-time Timer Value (RTT_VR) may be corrupted.	Use RTTINC as an increment for a software counter. 40.6.9 Serial Peripheral Interface (SPI)	RTT: RTT_VR May be Corrupted
ARM7	Atmel	SAM7S256	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT = 1 and SCBR = 1.	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1
ARM7	Atmel	SAM7S256	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) Behavior
ARM7	Atmel	SAM7S256	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S256	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 619	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S256	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S256	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S256	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.6.10 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S256	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 620	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.6.11 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S256	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S256	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S256	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S256	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 621 TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S256	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.6.12 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S256	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S256	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S256	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S256	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	USART: RXBRK Flag Error in Asynchronous Mode
ARM7	Atmel	SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 622 40.6.13 Voltage Regulator	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S256	Voltage Regulator: Current Consumption in Deep Mode Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Voltage Regulator: Current Consumption in Deep Mode
ARM7	Atmel	SAM7S256	Voltage Regulator: Load Versus Temperature Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. 40.6.14 Watchdog Timer (WDT)	Voltage Regulator: Load Versus Temperature
ARM7	Atmel	SAM7S256	WDT: The Watchdog Timer May Lock the Device in a Reset State Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN set at 1), the Watchdog Timer may lock the device in a reset state when the user restarts the watchdog (WDDRSTT). The only way to recover from this state is a power-on reset. The issue depends on the values of WDD and WDV in the WDT_MR register.	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog Reset enabled (WDRSTEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F.	WDT: The Watchdog Timer May Lock the Device in a Reset State
ARM7	Atmel	SAM7S256	WDT: The Watchdog Timer Status Register and Interrupt Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled (WDFIEN set at 1), the Watchdog Timer may trigger the interrupt (wdt_fault) erroneously. The Watchdog Timer Status Register may be wrong also (WDERR and WDUNF). The issue depends on the values of WDD and WDV in the WDT_MR register.	Two workarounds are possible. 1. Either do not us the Watchdog Timer with the Watchdog fault Interrupt enabled (WDFIEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 623 40.7 SAM7S256 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Important: Section 40.7.13.1 âWDT: The Watchdog Timer May Lock the Device in a Reset Stateâ 40.7.1 Chip ID	WDT: The Watchdog Timer Status Register and Interrupt
ARM7	Atmel	SAM7S256	Wrong Chip ID Value The Chip ID is 0x270D 0940 instead of 0x270B 0940.	None. 40.7.2 Analog-to-Digital Converter (ADC)	Wrong Chip ID Value
ARM7	Atmel	SAM7S256	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S256	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S256	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S256	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 624	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S256	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S256	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S256	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	ADC: Spurious Clear of EOC Flag
ARM7	Atmel	SAM7S256	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 625 40.7.3 Non Volatile Memory Bits (NVM Bits)	ADC: Sleep Mode
ARM7	Atmel	SAM7S256	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applic able to 256 KB Flash memory, it remains at 10K for the Flash memory.	None. 40.7.4 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S256	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 626 40.7.5 Power Management Controller (PMC)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S256	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1 Under certain rare circumstances, when CSS = 00 in PMC_MCKR, and PA1 is set as an input and a transition occurs on PA1, device malfunction might occur.	Do not transition PA1 as an input when CSS = 00 in PMC_MCKR.	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1
ARM7	Atmel	SAM7S256	PMC: Programming CSS in PMC_MCKR Register Under certain rare circumstances, reprogramming the CSS value in the PMC_MCKR register (i.e switching the main clock source) might generate malfunction of the device if the following two actions occur simultaneously. 1. Switching from: â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock And 2. Program code is being executed out of flash, or a transition is occurring on PA1, either as an input or output. Note: This issue does not occur when transitioning from slow clock to main clock or from slow clock to PLL clock.	When changing CSS in the PMC_MCKR to switch from â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock Ensure that the processor is executing out of SRAM and ensure no transition occurs on PA1, either as an input or output, starting from writing to the PMC_MCKR register until MCKRDY = 1. 40.7.6 Pulse Width Modulation Controller (PWM)	PMC: Programming CSS in PMC_MCKR Register
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 627 None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S256	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S256	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.7.7 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR.	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S256	RTT: RTT_VR May be Corrupted Under certain rare circumstances, the Real-time Timer Value (RTT_VR) may be corrupted.	Use RTTINC as an increment for a software counter. 40.7.8 Serial Peripheral Interface (SPI)	RTT: RTT_VR May be Corrupted
ARM7	Atmel	SAM7S256	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT = 1 and SCBR = 1.	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1
ARM7	Atmel	SAM7S256	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) Behavior
ARM7	Atmel	SAM7S256	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 628	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S256	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S256	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S256	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S256	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.7.9 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S256	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 629 None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.7.10 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S256	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S256	TWI: Software Reset when a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 630	TWI: Software Reset
ARM7	Atmel	SAM7S256	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S256	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S256	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.7.11 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S256	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S256	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S256	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S256	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 631 Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	USART: RXBRK Flag Error in Asynchronous Mode
ARM7	Atmel	SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.7.12 Voltage Regulator	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S256	Voltage Regulator: Current Consumption in Deep Mode Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Voltage Regulator: Current Consumption in Deep Mode
ARM7	Atmel	SAM7S256	Voltage Regulator: Load Versus Temperature Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. 40.7.13 Watchdog Timer (WDT)	Voltage Regulator: Load Versus Temperature
ARM7	Atmel	SAM7S256	WDT: The Watchdog Timer May Lock the Device in a Reset State Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN set at 1), the Watchdog Timer may lock the device in a reset state when the user restarts the watchdog (WDDRSTT). The only way to recover from this state is a power-on reset. The issue depends on the values of WDD and WDV in the WDT_MR register.	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog Reset enabled (WDRSTEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F.	WDT: The Watchdog Timer May Lock the Device in a Reset State
ARM7	Atmel	SAM7S256	WDT: The Watchdog Timer Status Register and Interrupt Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled (WDFIEN set at 1), the Watchdog Timer may trigger the interrupt (wdt_fault) erroneously. The Watchdog Timer Status Register may be wrong also (WDERR and WDUNF). The issue depends on the values of WDD and WDV in the WDT_MR register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 632	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog fault Interrupt enabled (WDFIEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 633 40.8 SAM7S256 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S256 Revision B chip ID is 0x270B 0941. 40.8.1 Analog-to-Digital Converter (ADC)	WDT: The Watchdog Timer Status Register and Interrupt
ARM7	Atmel	SAM7S256	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S256	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S256	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S256	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 634 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S256	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S256	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S256	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S256	ADC: Spurious Clear of EOC Flag If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	ADC: Spurious Clear of EOC Flag
ARM7	Atmel	SAM7S256	ADC: Sleep Mode If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.8.2 Non Volatile Memory Bits (NVM Bits)	ADC: Sleep Mode
ARM7	Atmel	SAM7S256	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 635 This maximum number of write/erase cycles is not applic able to 256 KB Flash memory, it remains at 10K for the Flash memory.	None. 40.8.3 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.8.4 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 636	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S256	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S256	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.8.5 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.8.6 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S256	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	SPI: Software Reset Must be Written Twice
ARM7	Atmel	SAM7S256	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT = 1 and SCBR = 1.	SPI: Bad tx_ready Behavior when CSAAT = 1 and SCBR = 1
ARM7	Atmel	SAM7S256	SPI: LASTXFER (Last Transfer) Behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 637	SPI: LASTXFER (Last Transfer) Behavior
ARM7	Atmel	SAM7S256	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S256	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S256	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S256	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S256	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 638 40.8.7 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S256	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S256	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.8.8 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S256	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 639	TWI: Clock Divider
ARM7	Atmel	SAM7S256	TWI: Software Reset when a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S256	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S256	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S256	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.8.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S256	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S256	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S256	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 640 None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S256	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	USART: RXBRK Flag Error in Asynchronous Mode
ARM7	Atmel	SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.8.10 Voltage Regulator	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S256	Voltage Regulator: Current Consumption in Deep Mode Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Voltage Regulator: Current Consumption in Deep Mode
ARM7	Atmel	SAM7S256	Voltage Regulator: Load Versus Temperature Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 641 40.9 SAM7S256 Errata - Revision C Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S256 Revision C chip ID is 0x270B 0942. 40.9.1 Embedded Flash Controller (EFC)	Voltage Regulator: Load Versus Temperature
ARM7	Atmel	SAM7S256	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and up to 55 MHz, two Wait States (FWS = 2) are required.	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.9.2 Parallel Input/Output Controller (PIO)	EFC: Embedded Flash Access Time 1
ARM7	Atmel	SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.9.3 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 642	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None. 40.9.4 Real Time Timer (RTT)	PWM: Counter Start Value
ARM7	Atmel	SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.9.5 USART: Universal Synchronous Asynchronous Receiver Transmitter	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 643 40.10 SAM7S256 Errata - Revision D Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S256 Revision D chip ID is 0x270B0943. 40.10.1 Embedded Flash Controller (EFC)	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S256	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and up to 55 MHz, two Wait States (FWS = 2) are required.	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.10.2 Parallel Input/Output Controller (PIO)	EFC: Embedded Flash Access Time 1
ARM7	Atmel	SAM7S256	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S256	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.10.3 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 644	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S256	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S256	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None. 40.10.4 Real Time Timer (RTT)	PWM: Counter Start Value
ARM7	Atmel	SAM7S256	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.10.5 USART: Universal Synchronous Asynchronous Receiver Transmitter	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S256	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 645 40.11 SAM7S128 Errata - Manufacturing Number 58818C Refer to Section 40.1 âMarkingâ on page 595. Important: Section 40.11.14.1 âWDT: The Watchdog Timer May Lock the Device in a Reset Stateâ 40.11.1 Chip ID	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S128	Wrong Chip ID Value The Chip ID is 0x270C0740 instead of 0x270A0740.	None. 40.11.2 Analog-to-Digital Converter (ADC)	Wrong Chip ID Value
ARM7	Atmel	SAM7S128	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S128	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S128	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S128	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 646	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S128	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S128	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S128	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S128	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 647 40.11.3 Master Clock (MCK)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S128	MCK: Limited Master Clock Frequency Ranges If the Flash is operating without wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with one wait state, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with two wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 25 MHz. If the Flash is operating with three wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 38 MHz. If these constraints are not respected, the correct operation of the system cannot be guaranteed and either data or prefetch abort might occur. The maximum operating frequencies (at 30 MHz @ 0 Wait States and 55 MHz @ 1 Wait State) as stated in Table 37-24, âEmbedded Flash Wait States,â on page 582, are still applicable. Note: It is not necessary to use 2 o 3 wait states because t he Flash can operate at maximum frequency with only 1 wait state.	The user must ensure that the device is running at the authorized frequency by programming the PLL properly to not run within the forbidden frequency range. 40.11.4 Non Volatile Memory Bits (NVM Bits)	MCK: Limited Master Clock Frequency Ranges
ARM7	Atmel	SAM7S128	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applic able to 128 KB Flash memory, it remains at 10K for the Flash memory.	None. 40.11.5 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S128	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 648 This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.11.6 Power Management Controller (PMC)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S128	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1 Under certain rare circumstances, when CSS = 00 in PMC_MCKR, and PA1 is set as an input and a transition occurs on PA1, device malfunction might occur.	Do not transition PA1 as an input when CSS = 00 in PMC_MCKR.	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1
ARM7	Atmel	SAM7S128	PMC: Programming CSS in PMC_MCKR Register Under certain rare circumstances, reprogramming the CSS value in the PMC_MCKR register (i.e switching the main clock source) might generate malfunction of the device if the following two actions occur simultaneously. 1. Switching from: â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock And 2. Program code is being executed out of flash, or a transition is occurring on PA1, either as an input or output. Note: This issue does not occur when transitioning from slow clock to main clock or from slow clock to PLL clock.	When changing CSS in the PMC_MCKR to switch from â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock Ensure that the processor is executing out of SRAM and ensure no transition occurs on PA1, either as an input or output, starting from writing to the PMC_MCKR register until MCKRDY = 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 649 40.11.7 Pulse Width Modulation Controller (PWM)	PMC: Programming CSS in PMC_MCKR Register
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S128	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S128	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.11.8 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR.	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S128	RTT: RTT_VR May be Corrupted Under certain rare circumstances, the Real-time Timer Value (RTT_VR) may be corrupted.	Use RTTINC as an increment for a software counter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 650 40.11.9 Serial Peripheral Interface (SPI)	RTT: RTT_VR May be Corrupted
ARM7	Atmel	SAM7S128	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT = 1 and SCBR = 1.	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1
ARM7	Atmel	SAM7S128	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S128	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S128	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S128	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S128	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S128	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 651 This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.11.10 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S128	If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.
ARM7	Atmel	SAM7S128	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge
ARM7	Atmel	SAM7S128	If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 652 40.11.11 Two-wire Interface (TWI)	If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during
ARM7	Atmel	SAM7S128	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or
ARM7	Atmel	SAM7S128	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.
ARM7	Atmel	SAM7S128	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1.
ARM7	Atmel	SAM7S128	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 653	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit
ARM7	Atmel	SAM7S128	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.11.12 USART: Universal Synchronous Asynchronous Receiver Transmitter	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if
ARM7	Atmel	SAM7S128	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.
ARM7	Atmel	SAM7S128	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.
ARM7	Atmel	SAM7S128	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote
ARM7	Atmel	SAM7S128	In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken
ARM7	Atmel	SAM7S128	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.11.13 Voltage Regulator	The DCD signal is active at High level in the USART Modem Mode.
ARM7	Atmel	SAM7S128	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 654 Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.
ARM7	Atmel	SAM7S128	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. 40.11.14 Watchdog Timer (WDT)	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).
ARM7	Atmel	SAM7S128	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN set at 1), the Watchdog Timer may lock the device in a reset state when the user restarts the watchdog (WDDRSTT). The only way to recover from this state is a power-on reset. The issue depends on the values of WDD and WDV in the WDT_MR register.	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog Reset enabled (WDRSTEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F.	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN
ARM7	Atmel	SAM7S128	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled (WDFIEN set at 1), the Watchdog Timer may trigger the interrupt (wdt_fault) erroneously. The Watchdog Timer Status Register may be wrong also (WDERR and WDUNF). The issue depends on the values of WDD and WDV in the WDT_MR register.	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog fault Interrupt enabled (WDFIEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 655 40.12 SAM7S128 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Important: Section 40.12.13.1 âWDT: The Watchdog Timer May Lock the Device in a Reset Stateâ 40.12.1 Chip ID	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled
ARM7	Atmel	SAM7S128	Wrong Chip ID Value The Chip ID is 0x270C 0740 instead of 0x270A 0740.	None. 40.12.2 Analog-to-Digital Converter (ADC)	Wrong Chip ID Value
ARM7	Atmel	SAM7S128	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S128	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S128	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S128	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 656	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S128	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S128	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S128	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S128	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 657 40.12.3 Non Volatile Memory Bits (NVM Bits)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S128	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applic able to 128 KB Flash memory, it remains at 10K for the Flash memory.	None. 40.12.4 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S128	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 5 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 658 40.12.5 Power Management Controller (PMC)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S128	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1 Under certain rare circumstances, when CSS = 00 in PMC_MCKR, and PA1 is set as an input and a transition occurs on PA1, device malfunction might occur.	Do not transition PA1 as an input when CSS = 00 in PMC_MCKR.	PMC: Slow Clock Selected in PMC and a Transition Occurs on PA1
ARM7	Atmel	SAM7S128	PMC: Programming CSS in PMC_MCKR Register Under certain rare circumstances, reprogramming the CSS value in the PMC_MCKR register (i.e switching the main clock source) might generate malfunction of the device if the following two actions occur simultaneously. 1. Switching from: â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock And 2. Program code is being executed out of flash, or a transition is occurring on PA1, either as an input or output. Note: This issue does not occur when transitioning from slow clock to main clock or from slow clock to PLL clock.	When changing CSS in the PMC_MCKR to switch from â PLL Clock to Slow Clock or â PLL Clock to Main Clock or â Main Clock to PLL Clock or â Main Clock to Slow Clock Ensure that the processor is executing out of SRAM and ensure no transition occurs on PA1, either as an input or output, starting from writing to the PMC_MCKR register until MCKRDY = 1. 40.12.6 Pulse Width Modulation Controller (PWM)	PMC: Programming CSS in PMC_MCKR Register
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 659 None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S128	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S128	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.12.7 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR.	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S128	RTT: RTT_VR May be Corrupted Under certain rare circumstances, the Real-time Timer Value (RTT_VR) may be corrupted.	Use RTTINC as an increment for a software counter. 40.12.8 Serial Peripheral Interface (SPI)	RTT: RTT_VR May be Corrupted
ARM7	Atmel	SAM7S128	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT = 1 and SCBR = 1.	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1
ARM7	Atmel	SAM7S128	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S128	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 660	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S128	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S128	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S128	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S128	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.12.9 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S128	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 661	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S128	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S128	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.12.10 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S128	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or
ARM7	Atmel	SAM7S128	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 662	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.
ARM7	Atmel	SAM7S128	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1.
ARM7	Atmel	SAM7S128	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit
ARM7	Atmel	SAM7S128	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.12.11 USART: Universal Synchronous Asynchronous Receiver Transmitter	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if
ARM7	Atmel	SAM7S128	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.
ARM7	Atmel	SAM7S128	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.
ARM7	Atmel	SAM7S128	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote
ARM7	Atmel	SAM7S128	In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 663 Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken
ARM7	Atmel	SAM7S128	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.12.12 Voltage Regulator	The DCD signal is active at High level in the USART Modem Mode.
ARM7	Atmel	SAM7S128	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.
ARM7	Atmel	SAM7S128	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. 40.12.13 Watchdog Timer (WDT)	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).
ARM7	Atmel	SAM7S128	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN set at 1), the Watchdog Timer may lock the device in a reset state when the user restarts the watchdog (WDDRSTT). The only way to recover from this state is a power-on reset. The issue depends on the values of WDD and WDV in the WDT_MR register.	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog Reset enabled (WDRSTEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F.	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Reset enabled (WDRSTEN
ARM7	Atmel	SAM7S128	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled (WDFIEN set at 1), the Watchdog Timer may trigger the interrupt (wdt_fault) erroneously. The Watchdog Timer Status Register may be wrong also (WDERR and WDUNF). The issue depends on the values of WDD and WDV in the WDT_MR register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 664	Two workarounds are possible. 1. Either do not use the Watchdog Timer with the Watchdog fault Interrupt enabled (WDFIEN set at 1), 2. or set WDD to 0xFFF and in addition use only one of the following values for WDV: 0xFFF, 0xDFF, 0xBFF, 0x9FF, 0x7FF, 0x77F, 0x6FF, 0x67F, 0x5FF, 0x57F, 0x4FF, 0x47F, 0x3FF, 0x37F, 0x2FF, 0x27F, 0x1FF, 0x1BF, 0x17F, 0x13F, 0x0FF, 0x0DF, 0x0BF, 0x09F, 0x07F, 0x06F, 0x05F, 0x04F, 0x03F, 0x037, 0x02f, 0x027, 0x01F, 0x01B, 0x017, 0x013 and 0x00F. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 665 40.13 SAM7S128 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S128 Revision B chip ID is: 0x270A 0741. 40.13.1 Analog-to-Digital Converter (ADC)	Under certain rare circumstances, if the Watchdog Timer is used with the Watchdog Fault Interrupt enabled
ARM7	Atmel	SAM7S128	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S128	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S128	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S128	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 666 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S128	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S128	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S128	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S128	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S128	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.13.2 Non Volatile Memory Bits (NVM Bits)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S128	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 667 This maximum number of write/erase cycles is not applic able to 128 KB Flash memory, it remains at 10K for the Flash memory.	None. 40.13.3 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.13.4 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 668	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S128	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S128	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.13.5 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.13.6 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S128	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	SPI: Software Reset Must be Written Twice
ARM7	Atmel	SAM7S128	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT = 1 and SCBR = 1.	SPI: Bad tx_ready behavior when CSAAT = 1 and SCBR = 1
ARM7	Atmel	SAM7S128	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 669 Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S128	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S128	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S128	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S128	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S128	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 670 40.13.7 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S128	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S128	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S128	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.13.8 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S128	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 671	TWI: Clock Divider
ARM7	Atmel	SAM7S128	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S128	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S128	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S128	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.13.9 USART: Universal Synchronous Asynchronous Receiver Transmitter	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S128	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S128	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S128	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 672 None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S128	USART: RXBRK Flag Error in Asynchronous Mode In receiver mode, when there are two consecutive characters (without timeguard in between), RXBRK is not taken into account. As a result, the RXBRK flag is not enabled correctly and the frame error flag is set.	Constraints on the transmitter device connected to the SAM7S USART receiver side: The transmitter may use the timeguard feature or send two STOP conditions. Only one STOP condition is taken into account by the receiver state machine. After this STOP condition, as there is no valid data, the receiver state machine will go in idle mode and enable the RXBRK flag.	USART: RXBRK Flag Error in Asynchronous Mode
ARM7	Atmel	SAM7S128	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.13.10 Voltage Regulator	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S128	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.
ARM7	Atmel	SAM7S128	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 673 40.14 SAM7S128 Errata - Revision C Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S128 Revision C chip ID is 0x270A 0742. 40.14.1 Embedded Flash Controller (EFC)	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).
ARM7	Atmel	SAM7S128	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and up to 55 MHz, two Wait States (FWS = 2) are required.	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.14.2 Parallel Input/Output Controller (PIO)	EFC: Embedded Flash Access Time 1
ARM7	Atmel	SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.14.3 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 674	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None. 40.14.4 Real Time Timer (RTT)	PWM: Counter Start Value
ARM7	Atmel	SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.14.5 USART: Universal Synchronous Asynchronous Receiver Transmitter	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S128	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 675 40.15 SAM7S128 Errata - Revision D Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S128 Revision C chip ID is 0x270A0743. 40.15.1 Embedded Flash Controller (EFC)	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S128	EFC: Embedded Flash Access Time 1 The embedded Flash maximum access time is 20 MHz (instead of 30 MHz) at zero Wait State (FWS = 0). The maximum operating frequency with one Wait State (FWS = 1) is 48.1 MHz (instead of 55 MHz). Above 48.1 MHz and up to 55 MHz, two Wait States (FWS = 2) are required.	Set the number of Wait States (FWS) according to the frequency requirements described in this errata. 40.15.2 Parallel Input/Output Controller (PIO)	EFC: Embedded Flash Access Time 1
ARM7	Atmel	SAM7S128	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S128	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.15.3 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 676	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S128	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S128	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None. 40.15.4 Real Time Timer (RTT)	PWM: Counter Start Value
ARM7	Atmel	SAM7S128	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.15.5 USART: Universal Synchronous Asynchronous Receiver Transmitter	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S128	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 677 40.16 SAM7S64 Errata - Manufacturing Number 58814G Refer to Section 40.1 âMarkingâ on page 595. 40.16.1 Analog-to-Digital Converter (ADC)	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S64	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S64	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S64	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S64	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 678 â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S64	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S64	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S64	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S64	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.16.2 JTAG	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S64	JTAG: Recommendation for TDI Pin TDI pin shows a weakness which does not effect the operation of the device. If this pin is driven over 2.0V or exposed to high electrostatic voltages, the pad might be partially destroyed and this can lead to additional continuous leakage on VDDCORE between 100 and 500 ÂµA. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 679 However, this does not prevent JTAG operations.	The JTAG port remains operational even if the failure on TDI has happened. Therefore the users can develop their applications in normal conditions, except the overall system power consumption might be higher. It is recommended to handle the devices carefully during PCB soldering and to correctly ground the manufacturing equipment. To prevent any failure on the final customer's systems, it is also recommended to tie the TDI pin at GND in the system production release and to not pull it up, as it is shown on the SAM7S-EK Evaluation Board schematics. 40.16.3 Master Clock (MCK)	JTAG: Recommendation for TDI Pin
ARM7	Atmel	SAM7S64	MCK: Limited Master Clock Frequency Ranges If the Flash is operating without wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with one wait state, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with two wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 25 MHz. If the Flash is operating with three wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 38 MHz. If these constraints are not respected, the correct operation of the system cannot be guaranteed and either data or prefetch abort might occur. The maximum operating frequencies (at 30 MHz @ 0 Wait States and 55 MHz @ 1 Wait State) as stated in Table 37-24, âEmbedded Flash Wait States,â on page 582, are still applicable. Note: It is not necessary to use 2 o 3 wait states because t he Flash can operate at maximum frequency with only 1 wait state.	The user must ensure that the device is running at the authorized frequency by programming the PLL properly to not run within the forbidden frequency range. 40.16.4 Non Volatile Memory Bits (NVM Bits)	MCK: Limited Master Clock Frequency Ranges
ARM7	Atmel	SAM7S64	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 64 KB Flash memory, it remains at10K for the Flash memory.	None. 40.16.5 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S64	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 680 Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S64	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S64	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.16.6 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S64	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S64	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S64	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S64	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 681	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S64	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.16.7 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S64	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.16.8 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S64	20. SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	None.	20. SPI: Pulse Generation on SPCK
ARM7	Atmel	SAM7S64	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT=1 and SCBR =1.	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1
ARM7	Atmel	SAM7S64	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S64	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 682	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S64	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S64	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S64	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S64	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	None.	SPI: Disable Issue
ARM7	Atmel	SAM7S64	SPI: Software Reset and SPIEN Bit The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	Send SPI disable command after a software reset.	SPI: Software Reset and SPIEN Bit
ARM7	Atmel	SAM7S64	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then
ARM7	Atmel	SAM7S64	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 683 â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.16.9 Synchronous Serial Controller (SSC)	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.
ARM7	Atmel	SAM7S64	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 684 40.16.10 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S64	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or
ARM7	Atmel	SAM7S64	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.
ARM7	Atmel	SAM7S64	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1.
ARM7	Atmel	SAM7S64	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 685	During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit
ARM7	Atmel	SAM7S64	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.16.11 Universal Synchronous Asynchronous Receiver Transmitter (USART)	When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if
ARM7	Atmel	SAM7S64	The Hardware Handshake does not work at speeds higher than 750 kbauds.	None.	The Hardware Handshake does not work at speeds higher than 750 kbauds.
ARM7	Atmel	SAM7S64	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.
ARM7	Atmel	SAM7S64	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.
ARM7	Atmel	SAM7S64	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote
ARM7	Atmel	SAM7S64	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.16.12 Voltage Regulator	The DCD signal is active at High level in the USART Modem Mode.
ARM7	Atmel	SAM7S64	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 686 None.	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.
ARM7	Atmel	SAM7S64	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 687 40.17 SAM7S64 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S64 Revision A chip ID is 0x2709 0540. 40.17.1 Analog-to-Digital Converter (ADC)	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).
ARM7	Atmel	SAM7S64	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S64	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S64	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S64	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 688 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S64	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S64	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S64	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S64	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 689 40.17.2 Non Volatile Memory Bits (NVM Bits)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S64	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 64 KB Flash memory, it remains at10K for the Flash memory.	None. 40.17.3 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S64	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S64	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S64	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 690 40.17.4 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S64	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S64	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S64	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S64	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S64	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.17.5 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S64	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.17.6 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S64	20. SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0 SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 691	None.	20. SPI: Pulse Generation on SPCK
ARM7	Atmel	SAM7S64	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT=1 and SCBR =1.	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1
ARM7	Atmel	SAM7S64	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S64	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S64	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S64	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S64	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 692	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S64	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	None.	SPI: Disable Issue
ARM7	Atmel	SAM7S64	SPI: Software Reset and SPIEN Bit The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	Send SPI disable command after a software reset.	SPI: Software Reset and SPIEN Bit
ARM7	Atmel	SAM7S64	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then
ARM7	Atmel	SAM7S64	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.17.7 Synchronous Serial Controller (SSC)	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.
ARM7	Atmel	SAM7S64	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 693	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.17.8 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S64	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S64	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S64	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 694	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S64	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S64	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.17.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S64	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	None.	USART: Hardware Handshake
ARM7	Atmel	SAM7S64	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S64	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S64	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S64	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 695 40.17.10 Voltage Regulator	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S64	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.
ARM7	Atmel	SAM7S64	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 696 40.18 SAM7S64 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S64 Revision B chip ID is: 0x2709 0543. 40.18.1 Analog-to-Digital Converter (ADC)	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).
ARM7	Atmel	SAM7S64	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S64	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S64	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S64	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 697 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S64	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S64	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S64	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S64	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S64	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 698 40.18.2 Non Volatile Memory Bits (NVM Bits)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S64	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 64 KB Flash memory, it remains at10K for the Flash memory.	None. 40.18.3 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S64	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S64	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.18.4 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S64	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S64	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 699	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S64	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S64	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S64	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.18.5 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S64	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.18.6 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S64	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	SPI: Software Reset Must be Written Twice
ARM7	Atmel	SAM7S64	SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 700	SPI: Pulse Generation on SPCK
ARM7	Atmel	SAM7S64	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT=1 and SCBR =1.	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1
ARM7	Atmel	SAM7S64	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S64	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S64	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S64	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S64	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S64	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 701 None.	SPI: Disable Issue
ARM7	Atmel	SAM7S64	The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	Send SPI disable command after a software reset.	The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.
ARM7	Atmel	SAM7S64	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then
ARM7	Atmel	SAM7S64	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.18.7 Synchronous Serial Controller (SSC)	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.
ARM7	Atmel	SAM7S64	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S64	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 702	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.18.8 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S64	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S64	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S64	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S64	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 703 TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S64	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.18.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S64	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	None.	USART: Hardware Handshake
ARM7	Atmel	SAM7S64	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S64	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S64	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S64	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.18.10 Voltage Regulator	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S64	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 704	None.	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.
ARM7	Atmel	SAM7S64	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 705 40.19 SAM7S64 Errata - Revision C Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S64 Revision C chip ID is 0x27090544 40.19.1 Parallel Input/Output Controller (PIO)	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).
ARM7	Atmel	SAM7S64	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V, and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S64	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.19.2 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S64	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S64	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S64	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 706 None. 40.19.3 Real Time Timer (RTT)	PWM: Counter Start Value
ARM7	Atmel	SAM7S64	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 707 40.20 SAM7S321 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S321 Revision A chip ID is: 0x2708 0342. 40.20.1 Analog-to-Digital Converter (ADC)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S321	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S321	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S321	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S321	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S321	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S321	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 708 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S321	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S321	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S321	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S321	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S321	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 709 40.20.2 Parallel Input/Output Controller (PIO)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S321	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S321	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.20.3 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S321	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S321	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S321	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S321	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 710	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S321	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.20.4 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S321	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.20.5 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S321	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	SPI: Software Reset Must be Written Twice
ARM7	Atmel	SAM7S321	SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	None.	SPI: Pulse Generation on SPCK
ARM7	Atmel	SAM7S321	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT=1 and SCBR =1.	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1
ARM7	Atmel	SAM7S321	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 711	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S321	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S321	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S321	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S321	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S321	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 712 40.20.6 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S321	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S321	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S321	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.20.7 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S321	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S321	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 713	None.	TWI: Software Reset
ARM7	Atmel	SAM7S321	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S321	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S321	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.20.8 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S321	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	None.	USART: Hardware Handshake
ARM7	Atmel	SAM7S321	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S321	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 714	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S321	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S321	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 715 40.21 SAM7S32 Errata - Manufacturing Number 58814G Refer to Section 40.1 âMarkingâ on page 595. 40.21.1 Analog-to-Digital Converter (ADC)	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S32	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S32	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S32	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S32	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, â¢ GOVRE inactive, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 716 â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S32	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S32	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S32	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S32	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.21.2 JTAG	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S32	JTAG: Recommendation for TDI Pin TDI pin shows a weakness which does not effect the operation of the device. If this pin is driven over 2.0V or exposed to high electrostatic voltages, the pad might be partially destroyed and this can lead to additional continuous leakage on VDDCORE between 100 and 500 ÂµA. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 717 However, this does not prevent JTAG operations.	The JTAG port remains operational even if the failure on TDI has happened. Therefore the users can develop their applications in normal conditions, except the overall system power consumption might be higher. It is recommended to handle the devices carefully during PCB soldering and to correctly ground the manufacturing equipment. To prevent any failure on the final customer's systems, it is also recommended to tie the TDI pin at GND in the system production release and to not pull it up, as it is shown on the SAM7S-EK Evaluation Board schematics. 40.21.3 Master Clock (MCK)	JTAG: Recommendation for TDI Pin
ARM7	Atmel	SAM7S32	MCK: Limited Master Clock Frequency Ranges If the Flash is operating without wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with one wait state, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 19 MHz. If the Flash is operating with two wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 25 MHz. If the Flash is operating with three wait states, the frequency of the Master Clock MCK must be lower than 3 MHz or higher than 38 MHz. If these constraints are not respected, the correct operation of the system cannot be guaranteed and either data or prefetch abort might occur. The maximum operating frequencies (at 30 MHz @ 0 Wait States and 55 MHz @ 1 Wait State) as stated in Table 37-24, âEmbedded Flash Wait States,â on page 582, are still applicable. Note: It is not necessary to use 2 o 3 wait states because t he Flash can operate at maximum frequency with only 1 wait state.	The user must ensure that the device is running at the authorized frequency by programming the PLL properly to not run within the forbidden frequency range. 40.21.4 Non Volatile Memory Bits (NVM Bits)	MCK: Limited Master Clock Frequency Ranges
ARM7	Atmel	SAM7S32	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 32 KB Flash memory, it remains at10K for the Flash memory.	None. 40.21.5 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S32	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 718	Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S32	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S32	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.21.6 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S32	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S32	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S32	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 719	PWM: Counter Start Value
ARM7	Atmel	SAM7S32	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S32	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.21.7 Serial Peripheral Interface (SPI)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S32	SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	None.	SPI: Pulse Generation on SPCK
ARM7	Atmel	SAM7S32	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT=1 and SCBR =1.	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1
ARM7	Atmel	SAM7S32	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S32	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S32	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 720 selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S32	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S32	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S32	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	None.	SPI: Disable Issue
ARM7	Atmel	SAM7S32	SPI: Software Reset and SPIEN Bit The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	Send SPI disable command after a software reset.	SPI: Software Reset and SPIEN Bit
ARM7	Atmel	SAM7S32	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then
ARM7	Atmel	SAM7S32	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 721 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.21.8 Synchronous Serial Controller (SSC)	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.
ARM7	Atmel	SAM7S32	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 722 40.21.9 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S32	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S32	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S32	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S32	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S32	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte. Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.21.10 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S32	The Hardware Handshake does not work at speeds higher than 750 kbauds.	None.	The Hardware Handshake does not work at speeds higher than 750 kbauds.
ARM7	Atmel	SAM7S32	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 723 CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.
ARM7	Atmel	SAM7S32	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.
ARM7	Atmel	SAM7S32	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote
ARM7	Atmel	SAM7S32	The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. 40.21.11 Voltage Regulator	The DCD signal is active at High level in the USART Modem Mode.
ARM7	Atmel	SAM7S32	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.
ARM7	Atmel	SAM7S32	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 724 40.22 SAM7S32 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S32 Revision A chip ID is 0x2708 0340. 40.22.1 Analog-to-Digital Converter (ADC)	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).
ARM7	Atmel	SAM7S32	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S32	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S32	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S32	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 725 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S32	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S32	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S32	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S32	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 726 40.22.2 Non Volatile Memory Bits (NVM Bits)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S32	NVM Bits: Write/Erase Cycles Number The maximum number of write/erase cycles for Non Volatile Memory bits is 100. This includes Lock Bits (LOCKx), General Purpose NVM bits (GPNVMx) and the Security Bit. This maximum number of write/erase cycles is not applicable to 64 KB Flash memory, it remains at10K for the Flash memory.	None. 40.22.3 Parallel Input/Output Controller (PIO)	NVM Bits: Write/Erase Cycles Number
ARM7	Atmel	SAM7S32	PIO: Leakage on PA17 - PA20 When PA17, PA18, PA19 or PA20 (the I/O lines multiplexed with the analog inputs) are set as digital inputs with pull-up disabled, the leakage can be 9 ÂµA in worst case and 90 nA in typical case per I/O when the I/O is set externally at low level.	Set the I/O to VDDIO by internal or external pull-up.	PIO: Leakage on PA17 - PA20
ARM7	Atmel	SAM7S32	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S32	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 727 40.22.4 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S32	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S32	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S32	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S32	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S32	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.22.5 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S32	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.22.6 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S32	20. SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0 SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 728	None.	20. SPI: Pulse Generation on SPCK
ARM7	Atmel	SAM7S32	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT=1 and SCBR =1.	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1
ARM7	Atmel	SAM7S32	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S32	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S32	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S32	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S32	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 729	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S32	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	None.	SPI: Disable Issue
ARM7	Atmel	SAM7S32	SPI: Software Reset and SPIEN Bit The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	Send SPI disable command after a software reset.	SPI: Software Reset and SPIEN Bit
ARM7	Atmel	SAM7S32	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then
ARM7	Atmel	SAM7S32	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.22.7 Synchronous Serial Controller (SSC)	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.
ARM7	Atmel	SAM7S32	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 730	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. 40.22.8 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S32	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S32	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S32	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 731	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S32	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR.	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S32	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.22.9 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S32	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	None.	USART: Hardware Handshake
ARM7	Atmel	SAM7S32	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S32	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S32	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S32	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 732 40.22.10 Voltage Regulator	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S32	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA. Due to current rejection from VDDIN to VDDCORE, the current consumption in Deep Mode cannot be guaranteed. Instead, 60 ÂµA is guaranteed whatever the condition.	None.	Current consumption in Deep Mode is maximum 60 ÂµA instead of 25 ÂµA.
ARM7	Atmel	SAM7S32	Maximum load is 50 mA at 85 Â°C (instead of 100 mA). Maximum load is 100 mA at 70Â°C.	None. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 733 40.23 SAM7S32 Errata - Revision B Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S32 Revision B chip ID is 0x2708 0341. 40.23.1 Analog-to-Digital Converter (ADC)	Maximum load is 50 mA at 85 Â°C (instead of 100 mA).
ARM7	Atmel	SAM7S32	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S32	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S32	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S32	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 734 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S32	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S32	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S32	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S32	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S32	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 735 40.23.2 Parallel Input/Output Controller (PIO)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S32	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31 When NRST or PA0-PA16 or PA21-PA31 are set as digital inputs with pull-up enabled, the voltage of the I/O stabilizes at VPull-up. Vpull-up VPull-up Min VPull-up Max VDDIO - 0.65 V VDDIO - 0.45 V This condition causes a leakage through VDDIO. This leakage is 45 ÂµA per pad in worst case at 3.3 V and 25 ÂµA at 1.8V. I Leakage Parameter Typ Max I Leakage at 3,3V 2.5 ÂµA 45 ÂµA I Leakage at 1.8V 1 ÂµA 25 ÂµA	It is recommended to use an external pull-up if needed.	PIO: Electrical Characteristics on NRST and PA0-PA16 and PA21-31
ARM7	Atmel	SAM7S32	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31 When NRST or PA0-PA16 and or PA21-PA31 are set as digital inputs with pull-up enabled, driving the I/O with an output impedance higher than 500 ohms may not drive the I/O to a logical zero.	Output impedance must be lower than 500 ohms. 40.23.3 Pulse Width Modulation Controller (PWM)	PIO: Drive Low NRST, PA0-PA16 and PA21-PA31
ARM7	Atmel	SAM7S32	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register.	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S32	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S32	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S32	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 736	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S32	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.23.4 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S32	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.23.5 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S32	SPI: Software Reset Must be Written Twice If a software reset (SWRSTin the SPI Control Register) is performed, the SPI may not work properly (the clock is enabled before the chip select.	The SPI Control Register field, SWRST needs to be written twice to be set correctly.	SPI: Software Reset Must be Written Twice
ARM7	Atmel	SAM7S32	20. SPI: Pulse Generation on SPCK In Master Mode, there is an additional pulse generated on SPCK when the SPI is configured as follows: â The Baudrate is odd and different from 1 â The Polarity is set to 1 â The Phase is set to 0	None.	20. SPI: Pulse Generation on SPCK
ARM7	Atmel	SAM7S32	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1 If the SPI is programmed with CSAAT = 1, SCBR(baudrate) = 1 and two transfers are performed consecutively on the same slave with an IDLE state between them, the tx_ready signal does not rise after the second data has been transferred in the shifter. This can imply for example, that the second data is sent twice.	Do not use the combination CSAAT=1 and SCBR =1.	SPI: Bad tx_ready behavior when CSAAT=1 and SCBR = 1
ARM7	Atmel	SAM7S32	SPI: LASTXFER (Last Transfer) behavior In FIXED Mode, with CSAAT bit set, and in âPDC modeâ the Chip Select can rise depending on the data written in the SPI_TDR when the TX_EMPTY flag is set. If for example, the PDC writes a â1â in the bit 24 (LASTXFER bit) of the SPI_TDR, the chip select will rise as soon as the TXEMPTY flag is set.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 737 Use the CS in PIO mode when PDC mode is required and CS has to be maintained between transfers.	SPI: LASTXFER (Last Transfer) behavior
ARM7	Atmel	SAM7S32	SPI: SPCK Behavior in Master Mode SPCK pin can toggle out before the first transfer in Master Mode.	In Master Mode, MSTR bit must be set (in SPI_MR register) before configuring SPI_CSRx registers.	SPI: SPCK Behavior in Master Mode
ARM7	Atmel	SAM7S32	SPI: Chip Select and Fixed Mode In fixed Mode, if a transfer is performed through a PDC on a Chip select different from the Chip select 0, the output spi_size sampled by the PDC will depend on the field, BITS (Bits per Transfer) of SPI_CSR0 register, whatever the selected Chip select is. For example, if SPI_CSR0 is configured for a 10-bit transfer whereas SPI_CSR1 is configured for an 8-bit transfer, when a transfer is performed in Fixed mode through the PDC, on Chip select 1, the transfer will be considered as a HalfWord transfer.	If a PDC transfer has to be performed in 8 bits, on a Chip select y (y as different from 0), the BITS field of the SPI_CSR0 must be configured in 8 bits, in the same way as the BITS field of the CSRy Register.	SPI: Chip Select and Fixed Mode
ARM7	Atmel	SAM7S32	SPI: Baudrate Set to 1 When Baudrate is set at 1 (i.e. when serial clock frequency equals the system clock frequency) and when the BITS field of the SPI_CSR register (number of bits to be transmitted) equals an ODD value (in this case 9,11,13 or 15), an additional pulse will be generated on output SPCK. Everything is OK if the BITS field equals 8,10,12,14 or 16 and Baudrate = 1.	None.	SPI: Baudrate Set to 1
ARM7	Atmel	SAM7S32	SPI: Disable In Slave Mode The SPI disable is not possible in slave mode.	Read first the received data, then perform the software reset.	SPI: Disable In Slave Mode
ARM7	Atmel	SAM7S32	SPI: Disable Issue The SPI Command âSPI Disableâ is not possible during a transfer, it must be performed only after TX_EMPTY rising else there is everlasting dummy transfers occur.	None.	SPI: Disable Issue
ARM7	Atmel	SAM7S32	The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.	Send SPI disable command after a software reset.	The SPI Command âsoftware resetâ does not reset the SPIEN config bit. Therefore rewriting an SPI enable command does not set TX_READY, TX_EMPTY flags.
ARM7	Atmel	SAM7S32	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then if an access is requested on another slave, the NPCS bus switches from one CS to the one requested without DLYBCS. External Slaves may reach a contention on SPI_MISO line for a short period.	SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 738 Assert the Last Transfer Command (NPCS de-activation) for the last character of each slave.	If CSAAT = 1 for current access and there is no more TX request for a time greater than DLYBCT + DLYBCS, then
ARM7	Atmel	SAM7S32	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.23.6 Synchronous Serial Controller (SSC)	Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0.
ARM7	Atmel	SAM7S32	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S32	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 739 40.23.7 Two-wire Interface (TWI)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S32	TWI: Clock Divider The value of CLDIV x 2 CKDIV must be less than or equal to 8191 the value of CHDIV x 2 CKDIV must be less than or equal to 8191	None.	TWI: Clock Divider
ARM7	Atmel	SAM7S32	TWI: Software Reset When a software reset is performed during a frame and when TWCK is low, it is impossible to initiate a new transfer in READ or WRITE mode.	None.	TWI: Software Reset
ARM7	Atmel	SAM7S32	TWI: Disabling Does not Operate Correctly Any transfer in progress is immediately frozen if the Control Register (TWI_CR) is written with the bit MSDIS at 1. Furthermore, the status bits TXCOMP and TXRDY in the Status Register (TWI_SR) are not reset.	The user must wait for the end of transfer before disabling the TWI. In addition, the interrupts must be disabled before disabling the TWI.	TWI: Disabling Does not Operate Correctly
ARM7	Atmel	SAM7S32	TWI: NACK Status Bit Lost During a master frame, if TWI_SR is read between the Non Acknowledge condition detection and the TXCOMP bit rising in the TWI_SR, the NACK bit is not set.	The user must wait for the TXCOMP status bit by interrupt and must not read the TWI_SR as long as transmission is not completed. TXCOMP and NACK fields are set simultaneously and the NACK field is reset after the read of the TWI_SR. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 740	TWI: NACK Status Bit Lost
ARM7	Atmel	SAM7S32	TWI: Possible Receive Holding Register Corruption When loading the TWI_RHR, the transfer direction is ignored. The last data byte received in the TWI_RHR is corrupted at the end of the first subsequent transmit data byte . Neither RXRDY nor OVERRUN status bits are set if this occurs.	The user must be sure that received data is read before transmitting any new data. 40.23.8 Universal Synchronous Asynchronous Receiver Transmitter (USART)	TWI: Possible Receive Holding Register Corruption
ARM7	Atmel	SAM7S32	USART: Hardware Handshake The Hardware Handshake does not work at speeds higher than 750 kbauds.	None.	USART: Hardware Handshake
ARM7	Atmel	SAM7S32	USART: CTS in Hardware Handshaking When Hardware Handshaking is used and if CTS goes low near the end of the starting bit, a character can be lost.	CTS must not go low during a time slot occurring between 2 Master Clock periods before the starting bit and 16 Master Clock periods after the rising edge of the starting bit.	USART: CTS in Hardware Handshaking
ARM7	Atmel	SAM7S32	USART: Hardware Handshaking â Two Characters Sent If CTS switches from 0 to 1 during the TX of a character and if the holding register (US_THR) is not empty, the content of US_THR will also be transmitted.	Don't use the PDC in transmit mode and do not fill US_THR before TXEMPTY is set at 1.	USART: Hardware Handshaking â Two Characters Sent
ARM7	Atmel	SAM7S32	USART: XOFF Character Bad Behavior The XOFF character is sent only when the receive buffer is detected full. While the XOFF is being sent, the remote transmitter is still transmitting. As only one Holding register is available in the receiver, characters will be lost in reception. This makes the software handshaking functionality ineffective.	None.	USART: XOFF Character Bad Behavior
ARM7	Atmel	SAM7S32	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 741 40.24 SAM7S161 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S161 Revision A chip ID is 0x2705 0241. 40.24.1 Analog-to-Digital Converter (ADC)	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S161	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S161	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S161	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S161	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S161	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S161	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 742 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S161	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S161	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S161	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S161	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S161	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.24.2 Pulse Width Modulation Controller (PWM)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S161	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 743	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S161	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S161	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S161	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S161	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.24.3 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S161	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.24.4 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S161	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 744	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.24.5 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S161	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S161	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S161	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 745 40.24.6 Universal Synchronous Asynchronous Receiver Transmitter (USART)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S161	USART: DCD is active High instead of Low The DCD signal is active at High level in the USART Modem Mode. DCD should be active at Low level.	Add an inverter. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 746 40.25 SAM7S16 Errata - Revision A Parts Refer to Section 40.1 âMarkingâ on page 595. Note: AT91SAM7S16 Revision A chip ID is 0x2705 0240. 40.25.1 Analog-to-Digital Converter (ADC)	USART: DCD is active High instead of Low
ARM7	Atmel	SAM7S16	ADC: DRDY Bit Cleared The DRDY Flag should be clear only after a read of ADC_LCDR (Last Converted Data Register). A read of any ADC_CDRx register (Channel Data Register) automatically clears the DRDY flag.	None	ADC: DRDY Bit Cleared
ARM7	Atmel	SAM7S16	ADC: DRDY not Cleared on Disable When reading LCDR at the same instant as an end of conversion, with DRDY already active, DRDY is kept active regardless of the enable status of the current channel. This sets DRDY, whereas new data is not stored.	None	ADC: DRDY not Cleared on Disable
ARM7	Atmel	SAM7S16	ADC: DRDY Possibly Skipped due to CDR Read Reading CDR for channel âyâ at the same instant as an end of conversion on channel âxâ with EOC[x] already active, leads to skipping to set the DRDY flag if channel âxâ is enabled.	Use of DRDY functionality with access to CDR registers should be avoided.	ADC: DRDY Possibly Skipped due to CDR Read
ARM7	Atmel	SAM7S16	ADC: Possible Skip on DRDY when Disabling a Channel DRDY does not rise when disabling channel âyâ at the same time as an end of âxâ channel conversion, although data is stored into CDRx and LCDR.	None.	ADC: Possible Skip on DRDY when Disabling a Channel
ARM7	Atmel	SAM7S16	ADC: GOVRE Bit is not Updated Read of the Status Register at the same instant as an end of conversion leads to skipping the update of the GOVRE (general overrun) flag. GOVRE is neither reset nor set. For example, if reading the status while an end of conversion is occurring and: 1. GOVRE is active but DRDY is inactive, does not correspond to a new general overrun condition but the GOVRE flag is not reset. 2. GOVRE is inactive but DRDY is active, does correspond to a new general overrun condition but the GOVRE flag is not set.	None	ADC: GOVRE Bit is not Updated
ARM7	Atmel	SAM7S16	ADC: GOVRE Bit is not Set when Reading CDR When reading CDRy (Channel Data Register y) at the same instant as an end of conversion on channel âxâ with the following conditions: â¢ EOC[x] already active, â¢ DRDY already active, SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 747 â¢ GOVRE inactive, â¢ previous data stored in LCDR being neither data from channel âyâ, nor data from channel âxâ. GOVRE should be set but is not.	None	ADC: GOVRE Bit is not Set when Reading CDR
ARM7	Atmel	SAM7S16	ADC: GOVRE Bit is not Set when Disabling a Channel When disabling channel âyâ at the same instant as an end of conversion on channel âxâ, EOC[x] and DRDY being already active, GOVRE does not rise. Note: OVRE[x] rises as expected.	None	ADC: GOVRE Bit is not Set when Disabling a Channel
ARM7	Atmel	SAM7S16	ADC: OVRE Flag Behavior When the OVRE flag (on channel i) has been set but the related EOC status (of channel i) has been cleared (by a read of CDRi or LCDR), reading the Status register at the same instant as an end of conversion (causing the set of EOC status on channel i), does not lead to a reset of the OVRE flag (on channel i) as expected.	None	ADC: OVRE Flag Behavior
ARM7	Atmel	SAM7S16	ADC: EOC Set although Channel Disabled If a channel is disabled while a conversi on is running and if a read of CDR is performed at the same time as an end of conversion of any channel occurs, the EOC of the channel with the conversion running may rise (whereas it has been disabled).	Do not take into account the EOC of a disabled channel	ADC: EOC Set although Channel Disabled
ARM7	Atmel	SAM7S16	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ nor âyâ), reading CDR on channel âzâ at the same instant as an end of conversion on channel âyâ automatically clears EOC[x] instead of EOC[z].	None.	If âxâ and âyâ are two successively converted channels and âzâ is yet another enabled channel (âzâ being neither âxâ
ARM7	Atmel	SAM7S16	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after a conversion occurs.	To activate sleep mode as soon as possible, it is recommended to write successively, ADC Mode Register (SLEEP) then ADC Control Register (START bit field); to start an analog-to-digital conversion, in order put ADC into sleep mode at the end of this conversion. 40.25.2 Pulse Width Modulation Controller (PWM)	If Sleep mode is activated while there is no activity (no conversion is being performed), it will take effect only after
ARM7	Atmel	SAM7S16	PWM: Update when PWM_CCNTx = 0 or 1 If the Channel Counter Register value is 0 or 1, the Channel Period Register or Channel Duty Cycle Register is directly modified when writing the Channel Update Register. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 748	Check the Channel Counter Register before writing the update register.	PWM: Update when PWM_CCNTx = 0 or 1
ARM7	Atmel	SAM7S16	PWM: Update when PWM_CPRDx = 0 When Channel Period Register equals 0, the period update is not operational.	Do not write 0 in the period register.	PWM: Update when PWM_CPRDx = 0
ARM7	Atmel	SAM7S16	PWM: Counter Start Value In left aligned mode, the first start value of the counter is 0. For the other periods, the counter starts at 1.	None.	PWM: Counter Start Value
ARM7	Atmel	SAM7S16	PWM: Constraints on Duty Cycle Value Setting Channel Duty Cycle Register (PWM_CDTYx) at 0 in center aligned mode or at 0 or 1 in left aligned mode may change the polarity of the signal.	Do not set PWM_CDTYx at 0 in center aligned mode. Do not set PWM_CDTYx at 0 or 1 in left aligned mode.	PWM: Constraints on Duty Cycle Value
ARM7	Atmel	SAM7S16	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register Erratic behavior of the CHIDx status bit in the PWM_SR Register. When a channel is disabled by writing in the PWM_DIS Register just after enabling it (before completion of a Clock Period of the clock selected for the channel), the PWM line is internally disabled but the CHIDx status bit in the PWM_SR stays at 1.	Do not disable a channel before completion of one period of the selected clock. 40.25.3 Real Time Timer (RTT)	PWM: Behavior of CHIDx Status Bits in the PWM_SR Register
ARM7	Atmel	SAM7S16	RTT: Possible Event Loss when Reading RTT_SR If an event (RTTINC or ALMS) occurs within the same slow clock cycle during which the RTT_SR is read, the corresponding bit might be cleared. This can lead to the loss of this event.	The software must handle the RTT event as an interrupt and should not poll RTT_SR. 40.25.4 Serial Peripheral Interface (SPI)	RTT: Possible Event Loss when Reading RTT_SR
ARM7	Atmel	SAM7S16	SPI: Bad Serial Clock Generation on 2nd Chip Select Bad Serial clock generation on the 2nd chip select when SCBR = 1, CPOL = 1 and NCPHA = 0. This occurs using SPI with the following conditions: â¢ Master Mode â¢ CPOL = 1 and NCPHA = 0 â¢ Multiple chip selects are used with one transfer with Baud rate (SCBR) equal to 1 (i.e., when serial clock frequency equals the system clock frequency) and the other transfers set with SCBR are not equal to 1 â¢ Transmitting with the slowest chip select and then with the fastest one, then an additional on output SPCK during the second transfer. pulse is generated SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 749	Do not use a multiple Chip Select configuration where at least one SCRx register is configured with SCBR = 1 and the others differ from 1 if NCPHA = 0 and CPOL = 1. If all chip selects are configured with Baudrate = 1, the issue does not appear. 40.25.5 Synchronous Serial Controller (SSC)	SPI: Bad Serial Clock Generation on 2nd Chip Select
ARM7	Atmel	SAM7S16	SSC: Periodic Transmission Limitations in Master Mode If the Least Significant Bit is sent first (MSBF = 0), the first TAG during the frame synchro is not sent.	None.	SSC: Periodic Transmission Limitations in Master Mode
ARM7	Atmel	SAM7S16	SSC: Transmitter Limitations in Slave Mode If TK is programmed as output and TF is programmed as input, it is impossible to emit data when the start of edge (rising or falling) of synchro has a Start Delay equal to zero.	None.	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7S16	SSC: Transmitter Limitations in Slave Mode If TK is programmed as an input and TF is programmed as an output and requested to be set to low/high during data emission, the Frame Synchro signal is generated one bit clock period after the data start and one data bit is lost. This problem does not exist when generating a periodic synchro.	The data need to be delayed for one bit clock period with an external assembly. In the following schematic, TD, TK and NRST are SAM7S signals, TXD is the delayed data to connect to the device. SAM7S Series [DATASHEET] 6175MâATARMâ26-Oct-12 750 40.25.6 Universal Synchronous Asynchronous Receiver Transmitter (USART)	SSC: Transmitter Limitations in Slave Mode
ARM7	Atmel	SAM7SX	The DCD signal is active at High level in the USART Modem Mode.DCD should be active at Low level.	Add an inverter.	USART: DCD is active High instead of Low
ARM7	Atmel	AT91M55800A	The tracking time has a theoretical minimum duration. It equals one ADC Clock period and is normally ensured by the ADC Controller.It might randomly happen that this minimum duration cannot be guaranteed on the first enabled channel. When this happens, the sampling and hold process is too short and the conversion result is wrong.	To use only one channel, the user has to enable two channels and then must use the second channel only.In the event that all of the ADC channels need to be used, only three channels will be available. A software work around allows all the channels to be used. It consists of performing several conversions and averaging the samples on the first enabled channel. This method does not support fast conversion. However, signals from temperature sensors, which are slow signals, can be handled by averaging a number of samples.	ADC Characteristics and Behavior
ARM7	Atmel	AT91M55800A	An automatic switch from the main oscillator output (CSS = 1) may cause an unpredictable result in the APMC state machine. The automatic PLL to PLL transition is also effected by this problem.	The user must either wait for the PLL lock flag to be set in the APMC status register or switch to an intermediate 32 kHz oscillator output (CSS = 0).	Unpredictable Result in APMC State Machine on Switch from Oscillator to PLL
ARM7	Atmel	AT91M55800A	(PRES = 3) or 64 (PRES = 6) may lead to unpredictable results.	First, the user should switch to any other value (PRES = 1, 4 or 5) and wait for the actual switch to perform (at least 64 cycles of the selected clock). Then, the user can write the final prescaler value.	Clock Switching with the Prescaler in the APMC is not Permitted Switching from the selected clock (PRES = 0) to the selected clock divided by 4 (PRES = 2), 8
ARM7	Atmel	AT91M55800A		In order to prevent this error, the user must pull up the PA26/NPCS0/NSS pin to the V	SPI: Initializing SPI in Master Mode May Cause a Mode Fault Detection
ARM7	Atmel	AT91M55800A	In transmission, the data to be transmitted (written in SP_TDR) is transferred in the shift register and, consequently, the TDRE bit in SP_SR is set to 1. Though the transfer has not begun, when the following data are written in SP_TDR, they are also transferred into the shift register, crush-ing the precedent data and setting the bit TDRE to 1.	No problem fix/workaround to propose.	SPI in Slave Mode does not Work
ARM7	Atmel	AT91M55800A	The battery supply voltage consumption is not guaranteed in the case of internal peripheral accesses.	The user should minimally access the Advanced Peripheral Bus by using an interrupt-driven driver rather than polling methods.	V DDBU Consumption is not guaranteed
ARM7	Atmel	AT91M55800A	If the PLL is not used, an excessive current consumption can be seen on V DDPL(about 2 mA).	At start-up, set the PLL on (set MUL at 2 and PLLCOUNT at 2, for example), wait for the PLL LOCK and then disable the PLL (MUL = 0).	V DDCORE Current Consumption when PLL is not Used
ARM7	NXP	LPC2102	If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register. In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended.	In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this is would have to be done manually. ES_LPC2102 . Â© Rev. 2 â 1 March 2011 4 of 13 ES_LPC2102 LPC2102	3.1 Core.1: Incorrect update of the Abort Link register in Thumb state
ARM7	NXP	LPC2102	The Memory Accelerator Module (MAM) provides accelerated execution from the on-chip flash at higher frequencies. If code is running from on-chip Flash, a write to an SRAM location followed by an immediate read from the same SRAM location corrupts the data been read. For instance, a stack push operation immediately followed by a stack pop operation.	User code should enable the MAM after Reset and before any RAM accesses; this means MAMTIM and MAMCR should be set as follows: MAMTIM: For CPU clock frequencies slower than 20 MHz, set MAMTIM to 0x01. For CPU clock frequencies between 20 MHz and 40 MHz, set MAMTIM to 0x02, and for values above 40 MHz set MAMTIM to 0x03. MAMCR: Set MAMCR to 0x02 (MAM functions fully enabled) MAMTIM should be written before MAMCR.	3.2 MAM.1: Incorrect read of data from SRAM after Reset and MAM is not enabled or partially enabled
ARM7	NXP	LPC2102	The MAM block maximizes the performance of the ARM processor when it is running code in Flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled). Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal Flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the Flash memory.	If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1. ES_LPC2102 . Â© Rev. 2 â 1 March 2011 5 of 13 ES_LPC2102 LPC2102	3.3 MAM.2: Under certain conditions in MAM Mode 2 code execution out of internal Flash can fail
ARM7	NXP	LPC2102	In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1. Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock.	There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. ES_LPC2102 . Â© Rev. 2 â 1 March 2011 6 of 13 ES_LPC2102 LPC2102	3.4 SPI.1: Incorrect shifting of data in slave mode at lower frequencies
ARM7	NXP	LPC2102	The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30MHz and it referred to as SPI1 in the device documentation. At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases.	None. ES_LPC2102 . Â© Rev. 2 â 1 March 2011 7 of 13 ES_LPC2102 LPC2102	3.5 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies
ARM7	NXP	LPC2102	Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1. The Timer Counter reset does not trigger on the same incoming edge when the match takes place between the corresponding Match register and the Timer Counter register. The Timer Counter register will be reset only on the next incoming edge.	There are two possible workarounds: 1. Combine the Timer Counter reset feature with the âinterrupt on matchâ feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the âinterrupt on matchâ feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If ânâ edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC = 1. Match takes place. 3. Edge 3 - TC = 0. 4. Edge 4 - TC = 1. Match takes place. 5. Edge 5 - TC = 0. ES_LPC2102 . Â© Rev. 2 â 1 March 2011 8 of 13 ES_LPC2102 LPC2102	3.6 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge
ARM7	NXP	LPC2102	From the Vdd1V8 pin to the ARM7 core, there is a voltage drop. This voltage drop increases with higher currents (or higher power consumption). Higher system frequency and/or faster peripherals increase power consumption thereby increasing the voltage drop from the Vdd1V8 pin to the core. Under increased power consumption conditions, the device may not work properly. The likelihood of the problem showing up increases if the device is run at higher speeds (approaching 70MHz) and/or if the peripherals are running at close to system frequency speed (i.e If the APBDIV register is set to a value lower than 4 which would imply that the peripherals are run faster than 1/4 of the system frequency). Also, having a lower voltage on Vdd1V8 pin (e.g. below 1.8 V) can cause this issue to surface.	Increase the voltage on Vdd1V8 to 1.95 V. It is not harmful to the device if this voltage reaches 2 V.	3.7 Vdd.1: Device may not work properly under increased power consumption conditions
ARM7	NXP	LPC2102	There are two I2C interfaces, I2C0 and I2C1. I2C0 functions are shared as alternate functions on port pins P0.2 and P0.3. I2C1 functions are shared on port pins P0.17 and P0.18. I2C1 pins are currently open-drain output pins but they should be regular bi-directional GPIO pins. I2C0 pins are configured as open-drain output pins (for I2C bus compliance).	None. ES_LPC2102 . Â© Rev. 2 â 1 March 2011 9 of 13 ES_LPC2102 LPC2102	3.8 I2C1.1: I2C1 pins are not bi-directional GPIO pins
ARM7	NXP	LPC2102	In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing an ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 72 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges.	In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2102 . Â© Rev. 2 â 1 March 2011 10 of 13 ES_LPC2102 LPC2102 4. AC/DC deviations detail	3.9 ADC.1: External sync inputs not operational
ARM7	NXP	LPC2102	The LPC2102 is rated for 2 kV ESD.The RTCX1 pin is the input pin for the RTC oscillator circuit. The LPC2102 does not meet the required 2 kV ESD specified.	Observe proper ESD handling precautions for the RTCX1 pin.	4.1 ESD.1: The device does not meet the 2 kV ESD requirements on the RTCX1 pin
ARM9	NXP	LPC2102	The LPC2102 has a VDD(1V8) core pin which provides power to the internal circuitry and also, has a VBAT pin which provides power only to the RTC (Real Time Clock). VBAT pin can be to an external battery or to the 3.3 V I/O port supply (VDD(3V3) pin) used by the device. When the VDD(1V8) core pin is floated, power consumption increases on the VBAT pin.	VDD(1V8) core pin must always be connected to its power supply or to ground.	4.2 VBAT.1: Increased power consumption on the VBAT pin when the VDD(1V8) core pin is left floating
ARM7	NXP	LPC2114	The Flash memory on the LPC2114/24 offers In-Application Programming (IAP) functionality. The IAP routines are part of the on-chip boot loader software, which controls the interface between the digital logic and the Flash memory. Please note that all programming methods (JTAG, ISP, IAP) use IAP calls. Due to a timing problem in the interface between the Flash block and the digital logic the following problem may occur: If the boot loader revision in the device is previous to V1.63 then in up to 10% of the devices the Flash memory interface, at some point during an IAP programming or erase operation, may never return from the IAP call. Please note that devices that pass the IAP programming are functional and do not suffer from any long-term reliability problems. Devices with a date code prior to 0425 (manufactured before week 25 in 2004) are generally affected by this problem unless you receive devices with updated boot loader software from your distributor. Parts marked with date code 0425 or later are not affected by this problem. Please refer to page 3 of this document for details on how to identify the date code.	1. The on-chip boot-loader software can be updated via ISP to correct this issue. The boot loader update files can be downloaded here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_bl_update.zip The boot-loader version can be read out using the NXP Flash ISP Utility which can be found here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_flash_utility.zip 2. Limiting the external clock frequency to 12 MHz AND making sure the on-chip PLL is turned OFF while programming any part of the Flash memory reduces the likelihood of the occurrence significantly. During In-System-Programming the PLL is turned off by default. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 5 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	3.1 IAP.1: Flash memory programming interface timing problem
ARM7	NXP	LPC2114	In burst mode the A/D converter does repeated conversions at the rate selected by the CLKS field in the ADCR, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant 1 in the SEL field, then higher numbered 1-bits (pins) if applicable. Repeated conversions can be terminated by clearing this bit. In burst conversion mode, the first two conversions (after setting the mode) will be of the same, lowest-numbered, of the selected channels.	Ignore the first conversion, always check the CHN bits to confirm the channel converted.	3.2 ADC.1: First two ADC conversions in burst mode from same channel
ARM7	NXP	LPC2114	The ADCR SFR contains bits to enable the ADC burst mode (BURST), start the conversion in software control mode (START), and to select the channel to begin converting (SEL). In burst mode, If the BURST bit is set before or simultaneously to (using the STR instruction for example), the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. In software control mode (only when using external trigger), if the START bits are set before or simultaneously to (using the STR instruction for example) the SEL bits, then the first channel converted will correspond to the previous SEL bit settings.	Set the BURST/START bit(s) after setting the SEL bits. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 6 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	3.3 ADC.2: First conversion from channel specified by previous SEL setting
ARM7	NXP	LPC2114	In hardware scan mode multiple ADC channels may be selected as part of the scan by selecting the appropriate bits in the SEL field in the ADCR register. Certain hardware scanning patterns for the A/D Converter do not operate properly. Selecting channel 2 only leads to alternate sampling of channels 2 and 3. Selecting channels 1 and 2 leads to sampling channel 1 for the first conversion, then sampling channel 2 on every subsequent conversion.	None. Do not use the sampling patterns âchannel 2 onlyâ or âchannels 1 and 2â. This problem has no effect on software conversion, nor on any other patterns other than the two noted above.	3.4 ADC.3: Incorrect scan pattern
ARM7	NXP	LPC2114	Setting the PD bit (bit 1) in PCON stops all clocks and powers down the peripherals. The ADC is powered down by clearing the PDN bit (bit 21) in the ADCR register, setting the bit powers up (enables) the ADC. If the PDN in ADCR is set, setting the PD bit in PCON will not power down the ADC.	Clear the PDN bit in the ADCR SFR to turn off the ADC prior to setting the PD bit in PCON. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 7 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	3.5 ADC.4: Global power down does not power down the ADC
ARM7	NXP	LPC2114	When the START field of the ADCR register contains 010-111 the EDGE bit in ADCR will determine whether a conversion is started on a rising or falling edge of the selected CAP/MAT signal. EDGE=0 selects rising edge detection, EDGE=1 selects falling edge detection (On CAP/MAT pin). If the state of the selected CAP/MAT signal is 1 and EDGE is set to detect rising edges (EDGE = 0) or, if detection of falling edges is selected (EDGE = 1) and the state of the selected CAP/MAT signal is 0, an ADC conversion will immediately be initiated when the START bits are written to. So the first conversion behaves as a level triggered event rather than edge triggered.	Clear the selected CAP/MAT signal for EDGE = 0 or set the selected CAP/MAT signal for EDGE = 1 before writing 010-111 to START field. Alternatively, discard the first conversion after writing to the start bits.	3.6 ADC.5: Edge triggered ADC conversion start error
ARM7	NXP	LPC2114	Writing to ADCR while a conversion is in progress should set the DONE bit and start a new conversion. In actuality, if the ADCR is written to within 2.5 ADC_clock cycles, a new conversion is started but the DONE bit is not set. If the ADCR is written to after 2.5 ADC_clocks, but within a conversion time, the DONE bit is set within one ADC_clock and a new conversion is started.	Do not write to ADCR until the conversion is complete.	3.7 ADC.6: Writing to ADCR while conversion in progress
ARM7	NXP	LPC2114	The SPI interrupt flag is set by the SPI interface to generate an interrupt. It is cleared by writing a 1 to this bit. A write to any register associated with the SPI peripheral will clear the SPI interrupt register.	Avoid writing to SPI registers while transmissions are in progress or while SPI interrupts are pending. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 8 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	3.8 SPI.1: Unintentional clearing of SPI interrupt flag
ARM7	NXP	LPC2114	In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1. Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock.	There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue.	3.9 SPI.2: Incorrect shifting of data in slave mode at lower frequencies
ARM7	NXP	LPC2114	The VPBDIV register controls the rate of the VPB clock in relation to the processor clock. EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts. A write to either the external interrupt polarity register (EXTPOLAR) or the external interrupt mode register (EXTMODE) will corrupt the VPBDIV register. A read of either EXTPOLAR or EXTMODE will be corrupted BY the VPBDIV register. If VPBDIV is â1â or â2â prior to any write to EXTPOLAR or EXTMODE, the CPU will hang up on the write to EXTPOLAR or EXTMODE.	If VPBDIV is non-zero, write all zeroes to VPBDIV before reading or writing EXTMODE or EXTPOLAR, then write the proper value back to VPBDIV. In most applications this is a known and fixed value, but if there is a possibility of dynamic changes in VPBDIV, software will need to read VPBDIV, write zero to VPBDIV, read or write EXTMODE and/or EXTPOLAR, and then rewrite the value previously read from VPBDIV. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 9 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	3.10 EXTINT.1: Corruption of VPBDIV via EXTPOLAR or EXTMODE
ARM7	NXP	LPC2114	EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts. As an illustration, trying to set EXTMODE to 0x1 or 0xd would result in EXTMODE to be set to 0x0 instead.	This problem is related to EXTINT.1 and hence the same workaround applies with an additional step. The steps involved in the configuration of the EXTMODE and/or EXTPOLAR would be as follows: 1. Write 0x0 to VPBDIV 2. Write the desired value to EXTMODE or EXTPOLAR register 3. Write the same value to VPBDIV (additional step) 4. Restore the VPBDIV to the previously saved value or simply write to the register again with the desired value. Code sample for setting EXTMODE and EXTPOLAR to 0x1: VPBDIV = 0x0; /* EXTMODE */ EXTMODE = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* EXTPOLAR */ EXTPOLAR = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* Setting VPBDIV */ Note: While testing this in a debugger environment, please donât single-step through these steps. A breakpoint could be placed after Step 4 and you would see the EXTMODE and EXTPOLAR registers reflecting the correct values.	3.11 EXTINT.2: Incorrect setting of EXTMODE and/or EXTPOLAR register while trying to set them to desired value
ARM7	NXP	LPC2114	P0.21 and P0.19 may be configured as capture inputs via the PINSEL register. When PINSEL(11:10) is set to â11â P0.21 is not internally connected as capture 1.3	To use P0.21 as capture 1.3, PINSEL(7:6) must also be set to â11â which means that P0.19 must be selected as capture input 1.2. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 10 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	3.12 CAP.1: Problem when selecting P0.21 as a capture 1.3 input (timer1)
ARM7	NXP	LPC2114	The Peripheral Bus Divider (VPBDIV) divides the processor clock (CCLK) by one, two, or four. This is the clock that is provided to the peripheral bus. Reading the VPBDIV register may return an incorrect value.	Performing two consecutive reads of the VPBDIV assures that the correct value is returned.	3.13 VPBDIV.1: Incorrect read of VPBDIV
ARM7	NXP	LPC2114	If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register. In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended.	In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 11 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	3.14 Core.1: Incorrect update of the Abort Link register in Thumb state
ARM7	NXP	LPC2114	The Timers may be configured so that events such as Match and Capture, cause interrupts. Bits in the Interrupt Register (IR) indicate the source of the interrupt, whether from Capture or Match. If more than one interrupt for multiple Match events using the same Timer are enabled, it is possible that one of the match interrupts may not be recognized. If this occurs no more interrupts from that specific match register will be recognized. This could happen in a scenario where the match events are very close to each other. This issue also affects the Capture functionality. Specific details: Suppose that two match events are very close to each other (Say Match0 and Match1). Also assume that the Match0 event occurs first. When the Match0 interrupt occurs the 0th bit of the Interrupt Register will be set. To exit the Interrupt Service Routine of Match0, this bit has to be cleared in the Interrupt Register. The clearing of this bit might be done by using the following statement: T0_IR = 0x1; It is possible that software will be writing a 1 to bit 0 of the Interrupt Register while a Match1 event occurs, meaning that hardware needs to set the bit 1 of the Interrupt Register. In this case, since hardware is accessing the register at the same time as software, bit 1 for Match1 never gets set, causing the interrupt to be missed. In summary, while software is writing to the Interrupt Register, any Match or Capture event (which are configured to interrupt the core) occurring at the same time may result in the subsequent interrupt not being recognized. Similarly for the Capture event, if a capture event occurs while a Match event is being is serviced then the Capture event might be missed if the software and hardware accesses coincide. Affected features: 1. Interrupt on Match for Timer0/1. 2. Interrupt on Capture for Timer0/1. 3. These same features will be affected when using PWM. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 12 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	There is no clear workaround for this problem but some of the below mentioned solutions could work with some applications. Possible work-aroundâs for Match functionality: 1. If the application only needs two Match registers then distribute them between Timer 0 and Timer 1 to avoid this problem. 2. Stop the timer before accessing the Interrupt register for clearing the interrupt and then start timer again after the access is completed. 3. Polling for interrupt: Supposing that there are two Match events (Match X and Match Y). At the end of the Interrupt Service Routine (ISR) for Match X, compare the Timer Counter value with the Match Register Y value. If the Timer Counter value is more than the Match Register Y value then it is possible that this event might have been missed. In this case jump to the ISR directly and service Match event Y. Possible workarounds for Capture functionality: 1. Try to spread the capture events between both timers if there are two capture events. If the application also has a match event then one of the capture events may suffer. 2. Polling for Capture: At the end of a Match interrupt ISR or Capture event ISR compare the previous Capture value with the current Capture value. If the Capture value has changed then the Capture event might have been missed. In this case, jump to the ISR directly and service the Capture event.	3.15 TIMER.1: Missed Interrupt Potential
ARM7	NXP	LPC2114			3.16 PWM.1: Missed Interrupt Potential for the Match functionality. The description is the same as above.
ARM7	NXP	LPC2114	Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register. Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5.	Only P0.27 can be used for Match 0.1. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 13 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00	3.17 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function.
ARM7	NXP	LPC2114	Reading the contents of the IIR,LSR and MSR registers will clear certain bits in the register. 1. Reading the IIR should clear the THRE status if THRE is the highest priority pending interrupt (Only affects UART1). 2. Reading LSR should clear the OE/PE/FE/BI bits (affects both UART0 and UART1). 3. Reading MSR should clear the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits (Only affects UART1). If hardware is setting one of these above bits while the software is reading the contents of the register the reading process clears all bits in the register including the bit that got set by hardware. The software reads the old value though and the bit that got set by hardware is lost. Specific details: Suppose IIR has a modem status interrupt while the other interrupts are inactive and software reads the IIR value (polling) while hardware sets the THRE interrupt then software will read the Modem Interrupt value while the THRE interrupt is cleared i.e the THRE interrupt is lost. Suppose the LSR is all zeros and software is reading the register while hardware is generating a parity error then the parity error bit is cleared while the software reads the old value (all zeros) i.e. the parity error is lost. Suppose MSR is all zeros and software is polling the value of the register while the value of CTS is changing then the change in CTS value should result in the Delta CTS bit getting set. Instead software will read all zeros and the Delta CTS bit in the MSR register will be cleared i.e. the Delta CTS status is lost.	IIR reading: The IIR bug can be worked around by disabling the modem status interrupt effectively making THRE the lowest priority interrupt. The work-around does not work in software interrupt polling mode. Modem status has to be handled by software polling MSR. Now there are two cases: 1. A THRE interrupt is pending, software responds to the interrupt by reading the IIR while another, higher priority interrupt is set (e.g. RDA). In this case software will read the THRE status although the status will not be cleared where it should have been. After handling the THRE and RDA interrupt another dummy THRE interrupt may occur, unless in the meantime software has filled THR. This is considered an error although not fatal. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 14 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00 2. A high priority interrupt is pending, software responds to the interrupt by reading the IIR register while a THRE interrupt is set. In this case, software will read the higher priority interrupt and the THRE interrupt will be handled later. This behavior is as expected. LSR reading: A work-around for this problem is to service the OE/PE/FE/BI condition before another character is received which will trigger an LSR update. So basically, service the interrupt in one-character time. MSR reading: The MSR bug can be worked-around by not using the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits in the MSR but instead use the DCD/TRI/DSR/CTS bits in the same register. To prevent, a transition from being missed software should poll the registerâs value at a sufficiently high rate. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 15 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00 3.19 Reset.1: Device does not power up correctly under certain internal conditions Problem: If certain rare chip-internal conditions are met, the device will not start up correctly when executing a power-on reset. The crystal oscillator will be running but the device will not execute code. Work-around: Apply a second (warm) reset pulse (without power-on cycle). The minimum time requirement between the first (unsuccessful) reset and the second reset is 4105 external oscillator clock cycles, which means that the assertion of the second reset should occur 4105 cycles or more after the deassertion of the first reset. For example, at 10 MHz, this is equal to 411 ï­s; at 20 MHz, this is equal to 206 ï­s.This can be achieved by using an external watchdog timer or by any other circuitry in the application that is able to assert a second reset pulse. The root cause for this problem has been identified and will be fixed from Revision B of this device onwards. This problem will also be fixed in the LPC21x4/00 version of this device which will have a dedicated order number (LPC21x4FBD64/00). ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 16 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00 3.20 ADC.7: External sync inputs not operational Introduction: In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options Problem: The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges. Work-around: In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2114_24_00 . Â© Rev. 3 â 1 April 2011 17 of 22 ES_LPC2114/24; LPC2114/24/00 LPC2114/24, LPC2114/00, LPC2124/00 4. AC/DC deviations detail	3.18 UART.1: Coinciding VPB read and hardware register update
ARM7	NXP	LPC2114	The specified, minimum, value for VIH is 2.0 V. Any pin associated with either an external interrupt input or an analog to digital converter (ADC) input has a VIH of 2.4 V, not 2.0 V. The pins that are affected are the ones that can be configured as either an ADC input or and external interrupt input, not just the ones that are configured as such.	Make sure that high logic levels are at least 2.4 V at these pins.	4.1 VIH.1: Incompatibility of actual VIH levels as compared to those specified
ARM9	NXP	LPC2114	V3 is the power supply voltage for the I/O ports. External interrupt pins are general purpose interrupt pins which are level and edge sensitive. They can optionally wake up the device from power down mode. The ADC block can produce 10-bit samples with conversion time as low as 2.44 us. If the external interrupt and/or ADC pins are pulled higher than 1.8 V then it will lead to increased current consumption from V3. If V3 is 3.0 V and V1.8 is 1.8 V then the leakage current will increase to a typical number of 200 uA (per pin). Note: The ADC pins wonât contribute to the leakage if they are not configured as digital inputs using the PINSELx register. External interrupt pins will contribute to the leakage irrespective of their pin configuration.	None.	4.2 V3.1: Leakage current on V3 due to External Interrupt and/or Analog to Digital Converter (ADC) pins.
ARM7	NXP	LPC2220	If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register. In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended.	In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2220 . Â© Rev. 2 â 1 April 2011 4 of 11 ES_LPC2220 LPC2220	3.1 Core.1: Incorrect update of the Abort Link register in Thumb state
ARM7	NXP	LPC2220	In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1. Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock.	There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue. ES_LPC2220 . Â© Rev. 2 â 1 April 2011 5 of 11 ES_LPC2220 LPC2220	3.2 SPI.1: Incorrect shifting of data in slave mode at lower frequencies
ARM7	NXP	LPC2220	The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30 MHz and it referred to as SPI1 in the device documentation. At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases.	None.	3.3 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies
ARM7	NXP	LPC2220	Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register. Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5.	Only P0.27 can be used for Match 0.1. ES_LPC2220 . Â© Rev. 2 â 1 April 2011 6 of 11 ES_LPC2220 LPC2220	3.4 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function
ARM7	NXP	LPC2220			3.5 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge Problem: Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1. Work-around: There are two possible workarounds: 1. Combine the Timer Counter reset feature with the âinterrupt on matchâ feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the âinterrupt on matchâ feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If ânâ edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC=1. Match takes place. 3. Edge 3 - TC=0. 4. Edge 4 - TC=1. Match takes place. 5. Edge 5 - TC=0. ES_LPC2220 . Â© Rev. 2 â 1 April 2011 7 of 11 ES_LPC2220 LPC2220
ARM7	NXP	LPC2220	In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges.	In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register	3.6 ADC.1: External sync inputs not operational
ARM7	NXP	LPC2378	The LPC2378/88 has a 10-bit ADC, which can be used to measure analog signals and convert the signals into a 10-bit digital result. There are eight A/D channels and each channel has its own individual A/D Data Register (ADDR0 to ADDR7). The A/D Data Register holds the result when an A/D conversion is complete, and also includes the flags that indicate when a conversion has been completed (DONE bit) and when a conversion overrun has occurred. The DONE bit is cleared when the respective A/D Data Register is read. If a software read of ADDRx conflicts with the hardware setting of the DONE bit in the same register (once a conversion is completed) then the DONE bit gets cleared automatically, thereby clearing the indication that a conversion was completed.	For software controlled mode or burst mode with only one channel selected, the DONE bit in the A/D Global Data Register (located at 0xE003 4004) can be used instead of the individual ADDRx result register with no impact on performance. For burst mode with multiple channels selected, the DONE bit together with the CHN field in the A/D Global Data Register can be used with some impact on throughput. ES_LPC2378_88 . Â© NXP B.V. 2012. All rights reserved. Rev. 6.1 â 1 July 201	3.1 ADC.1: ADDRx read conflicts with hardware setting of the DONE bit
ARM7	NXP	LPC2119	The Flash memory on the LPC2119/29 offers In-Application Programming (IAP) functionality. The IAP routines are part of the on-chip boot loader software, which controls the interface between the digital logic and the Flash memory. Please note that all programming methods (JTAG, ISP, IAP) use IAP calls. Due to a timing problem in the interface between the Flash block and the digital logic the following problem may occur: If the boot loader revision in the device is previous to V1.63 then in up to 10 % of the devices the Flash memory interface, at some point during an IAP programming or erase operation, may never return from the IAP call. Please note that devices that pass the IAP programming are functional and do not suffer from any long-term reliability problems. LPC2119 devices with a date code prior to 0423 (manufactured before week 23 in 2004) or LPC2129 devices with a date code prior to 0425 (manufactured before week 25 in 2004) are generally affected by this problem unless you receive devices with updated boot loader software from your distributor. Parts marked with a date code later than 0423 (LPC2119) or 0425 (LPC2129) are not affected by this problem. Please refer to page 3 of this document for details on how to identify the date code.	1. The on-chip boot-loader software can be updated via ISP to correct this issue. The boot loader update files can be downloaded here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_bl_update.zip The boot-loader version can be read out using the NXP Flash ISP Utility which can be found here: http://www.nxp.com/files/products/standard/microcontrollers/utilities/lpc2000_flash_utility.zip 2. Limiting the external clock frequency to 12 MHz AND making sure the on-chip PLL is turned OFF while programming any part of the Flash memory reduces the likelihood of the occurrence significantly. During In-System-Programming the PLL is turned off by default. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 5 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.1 IAP.1: Flash memory programming interface timing problem
ARM7	NXP	LPC2119	In burst mode the A/D converter does repeated conversions at the rate selected by the CLKS field in the ADCR, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant 1 in the SEL field, then higher numbered 1-bits (pins) if applicable. Repeated conversions can be terminated by clearing this bit. In burst conversion mode, the first two conversions (after setting the mode) will be of the same, lowest-numbered, of the selected channels.	Ignore the first conversion, always check the CHN bits to confirm the channel converted.	3.2 ADC.1: First two ADC conversions in burst mode from same channel
ARM7	NXP	LPC2119	The ADCR SFR contains bits to enable the ADC burst mode (BURST), start the conversion in software control mode (START), and to select the channel to begin converting (SEL). In burst mode, If the BURST bit is set before or simultaneously to (using the STR instruction for example), the SEL bits, then the first channel converted will correspond to the previous SEL bit settings. In software control mode (only when using external trigger), if the START bits are set before or simultaneously to (using the STR instruction for example) the SEL bits, then the first channel converted will correspond to the previous SEL bit settings.	Set the BURST/START bit(s) after setting the SEL bits. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 6 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.3 ADC.2: First conversion from channel specified by previous SEL setting
ARM7	NXP	LPC2119	In hardware scan mode multiple ADC channels may be selected as part of the scan by selecting the appropriate bits in the SEL field in the ADCR register. Certain hardware scanning patterns for the A/D Converter do not operate properly. Selecting channel 2 only leads to alternate sampling of channels 2 and 3. Selecting channels 1 and 2 leads to sampling channel 1 for the first conversion, then sampling channel 2 on every subsequent conversion.	None. Do not use the sampling patterns âchannel 2 onlyâ or âchannels 1 and 2â. This problem has no effect on software conversion, nor on any other patterns other than the two noted above.	3.4 ADC.3: Incorrect scan pattern
ARM7	NXP	LPC2119	Setting the PD bit (bit 1) in PCON stops all clocks and powers down the peripherals. The ADC is powered down by clearing the PDN bit (bit 21) in the ADCR register, setting the bit powers up (enables) the ADC. If the PDN in ADCR is set, setting the PD bit in PCON will not power down the ADC.	Clear the PDN bit in the ADCR SFR to turn off the ADC prior to setting the PD bit in PCON. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 7 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.5 ADC.4: Global power down does not power down the ADC
ARM7	NXP	LPC2119	When the START field of the ADCR register contains 010-111 the EDGE bit in ADCR will determine whether a conversion is started on a rising or falling edge of the selected CAP/MAT signal. EDGE=0 selects rising edge detection, EDGE=1 selects falling edge detection (On CAP/MAT pin). If the state of the selected CAP/MAT signal is 1 and EDGE is set to detect rising edges (EDGE = 0) or, if detection of falling edges is selected (EDGE = 1) and the state of the selected CAP/MAT signal is 0, an ADC conversion will immediately be initiated when the START bits are written to. So the first conversion behaves as a level triggered event rather than edge triggered.	Clear the selected CAP/MAT signal for EDGE = 0 or set the selected CAP/MAT signal for EDGE = 1 before writing 010-111 to START field. Alternatively, discard the first conversion after writing to the start bits.	3.6 ADC.5: Edge triggered ADC conversion start error
ARM7	NXP	LPC2119	Writing to ADCR while a conversion is in progress should set the DONE bit and start a new conversion. In actuality, if the ADCR is written to within 2.5 ADC_clock cycles, a new conversion is started but the DONE bit is not set. If the ADCR is written to after 2.5 ADC_clocks, but within a conversion time, the DONE bit is set within one ADC_clock and a new conversion is started.	Do not write to ADCR until the conversion is complete.	3.7 ADC.6: Writing to ADCR while conversion in progress
ARM7	NXP	LPC2119	The SPI interrupt flag is set by the SPI interface to generate an interrupt. It is cleared by writing a 1 to this bit. A write to any register associated with the SPI peripheral will clear the SPI interrupt register.	Avoid writing to SPI registers while transmissions are in progress or while SPI interrupts are pending. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 8 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.8 SPI.1: Unintentional clearing of SPI interrupt flag
ARM7	NXP	LPC2119	In slave mode, the SPI can set the clock phase (CPHA) to 0 or 1. Consider the following conditions: 1. SPI is configured as a slave (with CPHA=0). 2. SPI is running at a low frequency. In slave mode, the SPIF (SPI Transfer Complete Flag) bit is set on the last sampling edge of SCK. If CPHA is set to 0 then the last sampling edge of SCK would be the rising edge. Under the above conditions, if the SPI Data Register (SPDR) is written to less than a half SCLK cycle after the SPIF bit is set (this would happen if the SPI frequency is low) then the SPDR will shift data one clock early for the upcoming transfers. Lowering the SPI frequency would increase the likelihood of the SPDR write happening in the first half SCK cycle of the last sampling clock.	There are two possible workarounds: 1. Use CPHA=1. 2. If the data is shifted incorrectly when CPHA is set to 0 then delaying the write to SPDR after the half SCK cycle of the last sampling clock would resolve this issue.	3.9 SPI.2: Incorrect shifting of data in slave mode at lower frequencies
ARM7	NXP	LPC2119	The VPBDIV register controls the rate of the VPB clock in relation to the processor clock. EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts. A write to either the external interrupt polarity register (EXTPOLAR) or the external interrupt mode register (EXTMODE) will corrupt the VPBDIV register. A read of either EXTPOLAR or EXTMODE will be corrupted BY the VPBDIV register. If VPBDIV is â1â or â2â prior to any write to EXTPOLAR or EXTMODE, the CPU will hang up on the write to EXTPOLAR or EXTMODE.	If VPBDIV is non-zero, write all zeroes to VPBDIV before reading or writing EXTMODE or EXTPOLAR, then write the proper value back to VPBDIV. In most applications this is a known and fixed value, but if there is a possibility of dynamic changes in VPBDIV, software will need to read VPBDIV, write zero to VPBDIV, read or write EXTMODE and/or EXTPOLAR, and then rewrite the value previously read from VPBDIV. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 9 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.10 EXTINT.1: Corruption of VPBDIV via EXTPOLAR or EXTMODE
ARM7	NXP	LPC2119	EXTPOLAR and EXTMODE determine the operating parameters of the external interrupts. As an illustration, trying to set EXTMODE to 0x1 or 0xd would result in EXTMODE to be set to 0x0 instead.	This problem is related to EXTINT.1 and hence the same workaround applies with an additional step. The steps involved in the configuration of the EXTMODE and/or EXTPOLAR would be as follows: 1. Write 0x0 to VPBDIV 2. Write the desired value to EXTMODE or EXTPOLAR register 3. Write the same value to VPBDIV (additional step) 4. Restore the VPBDIV to the previously saved value or simply write to the register again with the desired value. Code sample for setting EXTMODE and EXTPOLAR to 0x1: VPBDIV = 0x0; /* EXTMODE */ EXTMODE = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* EXTPOLAR */ EXTPOLAR = 0x1; VPBDIV = 0x1; VPBDIV = 0x0; /* Setting VPBDIV */ Note: While testing this in a debugger environment, please donât single-step through these steps. A breakpoint could be placed after Step 4 and you would see the EXTMODE and EXTPOLAR registers reflecting the correct values.	3.11 EXTINT.2: Incorrect setting of EXTMODE and/or EXTPOLAR register while trying to set them to desired value
ARM7	NXP	LPC2119	P0.21 and P0.19 may be configured as capture inputs via the PINSEL register. When PINSEL(11:10) is set to â11â P0.21 is not internally connected as capture 1.3	To use P0.21 as capture 1.3, PINSEL(7:6) must also be set to â11â which means that P0.19 must be selected as capture input 1.2. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 10 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.12 CAP.1: Problem when selecting P0.21 as a capture 1.3 input (timer1)
ARM7	NXP	LPC2119	The Peripheral Bus Divider (VPBDIV) divides the processor clock (CCLK) by one, two, or four. This is the clock that is provided to the peripheral bus. Reading the VPBDIV register may return an incorrect value.	Performing two consecutive reads of the VPBDIV assures that the correct value is returned.	3.13 VPBDIV.1: Incorrect read of VPBDIV
ARM7	NXP	LPC2119	If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register. In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended.	In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 11 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.14 Core.1: Incorrect update of the Abort Link register in Thumb state
ARM7	NXP	LPC2119	The Timers may be configured so that events such as Match and Capture, cause interrupts. Bits in the Interrupt Register (IR) indicate the source of the interrupt, whether from Capture or Match. If more than one interrupt for multiple Match events using the same Timer are enabled, it is possible that one of the match interrupts may not be recognized. If this occurs no more interrupts from that specific match register will be recognized. This could happen in a scenario where the match events are very close to each other. This issue also affects the Capture functionality. Specific details: Suppose that two match events are very close to each other (Say Match0 and Match1). Also assume that the Match0 event occurs first. When the Match0 interrupt occurs the 0th bit of the Interrupt Register will be set. To exit the Interrupt Service Routine of Match0, this bit has to be cleared in the Interrupt Register. The clearing of this bit might be done by using the following statement: T0_IR = 0x1; It is possible that software will be writing a 1 to bit 0 of the Interrupt Register while a Match1 event occurs, meaning that hardware needs to set the bit 1 of the Interrupt Register. In this case, since hardware is accessing the register at the same time as software, bit 1 for Match1 never gets set, causing the interrupt to be missed. In summary, while software is writing to the Interrupt Register, any Match or Capture event (which are configured to interrupt the core) occurring at the same time may result in the subsequent interrupt not being recognized. Similarly for the Capture event, if a capture event occurs while a Match event is being is serviced then the Capture event might be missed if the software and hardware accesses coincide. Affected features: 1. Interrupt on Match for Timer0/1. 2. Interrupt on Capture for Timer0/1. 3. These same features will be affected when using PWM. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 12 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	There is no clear workaround for this problem but some of the below mentioned solutions could work with some applications. Possible work-aroundâs for Match functionality: 1. If the application only needs two Match registers then distribute them between Timer 0 and Timer 1 to avoid this problem. 2. Stop the timer before accessing the Interrupt register for clearing the interrupt and then start timer again after the access is completed. 3. Polling for interrupt: Supposing that there are two Match events (Match X and Match Y). At the end of the Interrupt Service Routine (ISR) for Match X, compare the Timer Counter value with the Match Register Y value. If the Timer Counter value is more than the Match Register Y value then it is possible that this event might have been missed. In this case jump to the ISR directly and service Match event Y. Possible workarounds for Capture functionality: 1. Try to spread the capture events between both timers if there are two capture events. If the application also has a match event then one of the capture events may suffer. 2. Polling for Capture: At the end of a Match interrupt ISR or Capture event ISR compare the previous Capture value with the current Capture value. If the Capture value has changed then the Capture event might have been missed. In this case, jump to the ISR directly and service the Capture event.	3.15 TIMER.1: Missed Interrupt Potential
ARM7	NXP	LPC2119			3.16 PWM.1: Missed Interrupt Potential for the Match functionality. The description is the same as above.
ARM7	NXP	LPC2119	Timer0 has four external match outputs corresponding to match registers with various capabilities. Match 0.0 can be configured as an alternate function on P0.3 and P0.22. Match 0.1 can be configured as an alternate function on Port 0.5 and P0.27. The alternate functions can be configured by using the respective PINSELx register. Match 0.0 should have been only connected to P0.3 and P0.22 but it is also connected to P0.5. Match 0.1 is only connected to P0.27. Hence if the application configures the External Match alternate function on both P0.3 (Match 0.0) and P0.5 (Match 0.1) then the Match 0.0 output can be seen on two port pins, namely P0.3 and P0.5.	Only P0.27 can be used for Match 0.1. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 13 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.17 Timer0.1: Match 0.1 output cannot be seen on port pin P0.5 if configured as an alternate function.
ARM7	NXP	LPC2119	Reading the contents of the IIR,LSR and MSR registers will clear certain bits in the register. 1. Reading the IIR should clear the THRE status if THRE is the highest priority pending interrupt (Only affects UART1). 2. Reading LSR should clear the OE/PE/FE/BI bits (affects both UART0 and UART1). 3. Reading MSR should clear the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits (Only affects UART1). If hardware is setting one of these above bits while the software is reading the contents of the register the reading process clears all bits in the register including the bit that got set by hardware. The software reads the old value though and the bit that got set by hardware is lost. Specific details: Suppose IIR has a modem status interrupt while the other interrupts are inactive and software reads the IIR value (polling) while hardware sets the THRE interrupt then software will read the Modem Interrupt value while the THRE interrupt is cleared i.e the THRE interrupt is lost. Suppose the LSR is all zeros and software is reading the register while hardware is generating a parity error then the parity error bit is cleared while the software reads the old value (all zeros) i.e. the parity error is lost. Suppose MSR is all zeros and software is polling the value of the register while the value of CTS is changing then the change in CTS value should result in the Delta CTS bit getting set. Instead software will read all zeros and the Delta CTS bit in the MSR register will be cleared i.e. the Delta CTS status is lost.	IIR reading: The IIR bug can be worked around by disabling the modem status interrupt effectively making THRE the lowest priority interrupt. The work-around does not work in software interrupt polling mode. Modem status has to be handled by software polling MSR. Now there are two cases: 1. A THRE interrupt is pending, software responds to the interrupt by reading the IIR while another, higher priority interrupt is set (e.g. RDA). In this case software will read the THRE status although the status will not be cleared where it should have been. After handling the THRE and RDA interrupt another dummy THRE interrupt may occur, unless in the meantime software has filled THR. This is considered an error although not fatal. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 14 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00 2. A high priority interrupt is pending, software responds to the interrupt by reading the IIR register while a THRE interrupt is set. In this case, software will read the higher priority interrupt and the THRE interrupt will be handled later. This behavior is as expected. LSR reading: A work-around for this problem is to service the OE/PE/FE/BI condition before another character is received which will trigger an LSR update. So basically, service the interrupt in one-character time. MSR reading: The MSR bug can be worked-around by not using the Delta DCD/Trailing Edge RI/Delta DSR/Delta CTS bits in the MSR but instead use the DCD/TRI/DSR/CTS bits in the same register. To prevent, a transition from being missed software should poll the registerâs value at a sufficiently high rate.	3.18 UART.1: Coinciding VPB read and hardware register update
ARM7	NXP	LPC2119	The CAN interface may be configured such that activity on the CAN bus lines will wake the part from power-down mode. CAN bus activity fails to wake the part from power-down.	CAN bus pins may be tied to external interrupt inputs which will wake the part from power-down.	3.19 CAN.1: CAN bus activity does not wake from power-down mode
ARM7	NXP	LPC2119	The CAN Controller will enter sleep mode if the SM bit in the CAN Mode register is set to 1, no CAN interrupt is pending, and there is no activity on the CAN bus. The CAN Controller wakes up (and sets the WUI bit in the CAN Interrupt register if the WUIE bit in the CAN Interrupt Enable register is set to 1), in response to a dominant bit on the CAN bus or software clearing the SM bit in the CAN Mode register. Clearing the SM bit does not cause the CAN module to wakeup from CAN sleep mode.	None, the SM bit cannot be used as a source of CAN wakeup. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 15 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.20 CAN.2: No wake-up from CAN sleep mode using SM bit
ARM7	NXP	LPC2119	In FullCAN mode, CAN messages are automatically stored in a special section of the LUT RAM. In the Acceptance filter Look-Up Table, CAN message identifiers can be enabled/disabled by clearing/setting the Message Disable bit. When the CPU accesses the LUT while a message is being received, the Acceptance Filter may not work correctly and messages can be lost.	1. The CPU should not access the LUT during operation. Since the FullCAN mode would cause the CPU to access the LUT during operation, the problem does not occur when the FullCAN mode is not used. 2. Do not enable/disable the Message Identifiers in the LUT while the CAN module is enabled.	3.21 CAN.3: Shared access for Identifier Look-Up Table (LUT)
ARM7	NXP	LPC2119	The CAN block provides three transmit buffers. Each of them has a length of four 32-bit words and is able to store one complete CAN message. The Triple Transmit Buffer function cannot be used.	Use any one Transmit buffer only (Use either Transmit Buffer 1, Transmit Buffer 2 or Transmit Buffer 3 exclusively). The buffer you decided to use should be loaded only when there is no pending transmission.	3.22 CAN.4: Triple Transmit Buffer function not working correctly
ARM7	NXP	LPC2119	In Reset Mode, the CAN operations are disabled and writable registers can be written. If an Abort Transmission command is issued then a pending transmission request is cancelled if not already in progress. Normal operation cannot be resumed after reset or abort transmission without using one of the workarounds below.	Two possible workarounds are possible: ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 16 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00 1. After exiting the Reset Mode, before sending the first actual message, a dummy message should be transmitted with identifier 0x0 (Standard Frame Format). This message should be transmitted by setting both the Self Reception Request bit and the Abort Transmission bit in the Command register simultaneously. (Note: CAN Identifier 0x0 should not be used in the application) 2. If CAN Identifier 0x0 is used by the application then the above workaround cannot be used. This second workaround is not applicable to CAN Controller 1 since this solution needs the TDx pin to be shared with a port pin. Before normal operation is started: 1. Initialize the CAN Controller and Acceptance Filter. 2. Load CAN Transmit Buffer with a CAN message. Make sure that the Acceptance filter is configured to receive this message. 3. Switch P0.xx/TD pin to Port function by configuring the appropriate bits in the PINSELx register. 4. Start transmission of a message with the Single Shot Transmission and Self Reception Command (Command=0x12). 5. Wait until message is received (configure Receive Interrupt). 6. Switch P0.xx/TD pin function back to TD function. Continue with normal operation. Please note that the Transmit Buffer used for initial message must be used for all further CAN transmissions (see CAN.4).	3.23 CAN.5: Handling Reset Mode and Abort Transmission
ARM7	NXP	LPC2119	When a syntax error in the LUT is encountered, the LUT address of the incorrect line is reported in the LUTerrAd register If there is a syntax error then the address line is not reported and the acceptance filtering is disabled.	Add two disabled dummy message identifiers to the last possible address of the 2K LUT RAM (address 0xE003 87FC). Also, if an explicit Standard Frame Format section is enabled, add two disabled dummy message identifiers at the end of that section.	3.24 CAN.6: Look-up Table Error Address (LUTerrAd) register does not function.
ARM7	NXP	LPC2119	The CAN module can lose arbitration to another CAN node during an attempt to transmit a CAN message. The message of the CAN node the arbitration was lost to is supposed to be received correctly by the CAN module. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 17 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00 Messages might not be received correctly if during a CAN Transmission the CAN bus arbitration is lost to another CAN node.	Use the Self Reception Request command instead of the Transmission Request command. However, it has to be taken into account that now all transmitted messages may be received if not prevented by appropriate Acceptance Filter settings. (Donât set up Acceptance Filter Message Identifiers for the messages you are transmitting yourself.) ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 18 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00	3.25 CAN.7: Receiving messages while arbitration is lost.
ARM7	NXP	LPC2119			3.26 Reset.1: Device does not power up correctly under certain internal conditions Problem: If certain rare chip-internal conditions are met, the device will not start up correctly when executing a power-on reset. The crystal oscillator will be running but the device will not execute code. Work-around: Apply a second (warm) reset pulse (without power-on cycle). The minimum time requirement between the first (unsuccessful) reset and the second reset is 4105 external oscillator clock cycles, which means that the assertion of the second reset should occur 4105 cycles or more after the deassertion of the first reset. For example, at 10 MHz, this is equal to 411 ï­s; at 20 MHz, this is equal to 206 ï­s. This can be achieved by using an external watchdog timer or by any other circuitry in the application that is able to assert a second reset pulse. The root cause for this problem has been identified and will be fixed from Revision B of this device onwards. This problem will also be fixed in the LPC21x9/00 version of this device which will have a dedicated order number (LPC21x9FBD64/00). ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 19 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00
ARM7	NXP	LPC2119	In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges.	In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2109_19_29_00 . Â© Rev. 3 â 1 April 2011 20 of 25 ES_LPC21x9; LPC21x9/00 LPC21x9; LPC21x9/00 4. AC/DC deviations detail	3.27 ADC.7: External sync inputs not operational
ARM7	NXP	LPC2119	The specified, minimum, value for VIH is 2.0 V. Any pin associated with either an external interrupt input or an analog to digital converter (ADC) input has a VIH of 2.4 V, not 2.0 V. The pins that are affected are the ones that can be configured as either an ADC input or and external interrupt input, not just the ones that are configured as such.	Make sure that high logic levels are at least 2.4 V at these pins.	4.1 VIH.1: Incompatibility of actual VIH levels as compared to those specified
ARM9	NXP	LPC2119	V3 is the power supply voltage for the I/O ports. External interrupt pins are general purpose interrupt pins which are level and edge sensitive. They can optionally wake up the device from power down mode. The ADC block can produce 10-bit samples with conversion time as low as 2.44 us. If the external interrupt and/or ADC pins are pulled higher than 1.8 V then it will lead to increased current consumption from V3. If V3 is 3.0 V and V1.8 is 1.8 V then the leakage current will increase to a typical number of 200 uA (per pin). Note: The ADC pins wonât contribute to the leakage if they are not configured as digital inputs using the PINSELx register. External interrupt pins will contribute to the leakage irrespective of their pin configuration.	None.	4.2 V3.1: Leakage current on V3 due to External Interrupt and/or Analog to Digital Converter (ADC) pins.
ARM7	NXP	LPC2470	In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P2.10 or P1.27 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 72 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges.	In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved. Rev. 8.1 â 1 July 2012 5 of 13 ES_LPC2470_78 LPC2470/78	3.1 ADC.1: External sync inputs not operational
ARM7	NXP	LPC2470	If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register. In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended.	In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved. Rev. 8.1 â 1 July 2012 6 of 13 ES_LPC2470_78 LPC2470/78	3.2 Core.1: Incorrect update of the Abort Link register in Thumb state
ARM7	NXP	LPC2470	The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors. The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached)	Software can correct this situation in many ways; for example, sending a dummy frame after initialization. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved. Rev. 8.1 â 1 July 2012 7 of 13 ES_LPC2470_78 LPC2470/78	3.3 Ethernet.1: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent
ARM7	NXP	LPC2470	Full-/low-speed signaling uses bit stuffing throughout the packet without exception. If the receiver sees seven consecutive ones anywhere in the packet, then a bit stuffing error has occurred and the packet should be ignored. The time interval just before an EOP is a special case. The last data bit before the EOP can become stretched by hub switching skews. This is known as dribble and can lead to a situation where dribble introduces a sixth bit that does not require a bit stuff. Therefore, the receiver must accept a packet for which there are up to six full bit times at the port with no transitions prior to the EOP. The USB host controller will hang indefinitely if it sees a dribble bit on the USB bus. It will hang the first time a dribble bit is seen. Once it is in this state there is no recovery other than a hard chip reset. This problem has no effect on the USB device controller.	None. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved. Rev. 8.1 â 1 July 2012 8 of 13 ES_LPC2470_78 LPC2470/78	3.4 USB.1: USB host controller hangs on a dribble bit
ARM7	NXP	LPC2470	The device has a VBAT pin which provides power only to the Real Time Clock (RTC) and Battery RAM. VBAT can be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). The input voltage range on the VBAT pin is 2.0 V minimum to 3.6 V maximum for temperature ï­40 ï°C to +85 ï°C. Normally, if the RTC and the Battery RAM are not used, the VBAT pin can be left floating. If the VBAT pin is left floating, the internal reset signal within the RTC domain may get corrupted and as a result, prevents the device from starting-up.	The VBAT should be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved. Rev. 8.1 â 1 July 2012 9 of 13 ES_LPC2470_78 LPC2470/78 4. AC/DC deviations detail	3.5 VBAT.1: The VBAT pin cannot be left floating
ARM9	NXP	LPC2470	The device has a 4 MHz internal RC oscillator (IRC) which can be optionally used as the clock source for the Watch Dog Timer (WDT), and/or as the clock that drives the PLL and subsequently the CPU. The IRC frequency spec is 4 MHz +/ï­ 1 % accuracy over the entire voltage and temperature range. During In-System Programming (ISP), the auto-baud routine is expecting the IRC frequency to be 4 MHz +/ï­ 1 % and is used to synchronize with the host via serial port 0. On the LPC247X Rev C device only, the accuracy of internal RC oscillator (IRC) frequency meets 4 MHz +/ï­ 1 % specification only at room temperature however, at extreme temperatures, the accuracy of internal RC oscillator (IRC) frequency may be 4 MHz +/ï­ 10 %. As a result, at extreme temperatures, this may affect the auto-baud routine's ability to synchronize with the host via serial port 0 during In-System Programming (ISP) at higher baud rates.	None ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved. Rev. 8.1 â 1 July 2012 10 of 13 ES_LPC2470_78 LPC2470/78 4.2 IRC.2: Accuracy of the Internal RC Oscillator (IRC) frequency for devices only with date codes 0949 and before are outside of the 4 MHz +/ï­ 1 % specification only at temperatures between ï­20 ï°C and ï­40 ï°C Introduction: The device has a 4 MHz internal RC oscillator (IRC) which can be optionally used as the clock source for the Watch Dog Timer (WDT), and/or as the clock that drives the PLL and subsequently the CPU. The IRC frequency spec is 4 MHz +/ï­ 1 % accuracy over the entire voltage and temperature range. During In-System Programming (ISP), the auto-baud routine is expecting the IRC frequency to be 4 MHz +/ï­ 1 % and is used to synchronize with the host via serial port 0. Problem: On the LPC247X Rev D device (only with date codes 0949 and before), the accuracy of internal RC oscillator (IRC) frequency does not meet the 4 MHz +/ï­ 1 % specification for temperatures between ï­20 ï°C and ï­40 ï°C and the accuracy of internal RC oscillator (IRC) frequency is 4 MHz +/ï­ 5 % instead. As a result, only at these temperatures, this may affect the auto-baud routine's ability to synchronize with the host via serial port 0 during In-System Programming (ISP) at higher baud rates. For temperatures above ï­20 ï°C, the accuracy of internal RC oscillator (IRC) frequency meets the 4 MHz +/ï­ 1 % specification. Work-around: None 5. Errata notes detail 5.1 Note.1 On each of the following port pins P0.23, P0.24, P0.25, P0.26, P1.30, P1.31, P0.12, and P0.13 (when configured as general purpose input pin (s)), leakage current increases when the input voltage is Vi ï³ VDD I/O + 0.5 V. Care must be taken to limit the current to less than 4 mA by using a series limiting resistor. 5.2 Note.2 On the LPC2470/78 Rev D, design changes to the Memory Accelerator Module were made to enhance timing and general performance. Design changes are intended to enhance performance in general and will result in minor differences in the code execution timing between the previous device revisions and rev D. Actual performance impact is code dependent, some code sequences may speed up while other code sequences may slow down between the previous device revisions and rev D. This might be observed when using software delays and in such cases, a hardware timer should be used to generate a delay instead of a software delay. ES_LPC2470_78 . Â© NXP B.V. 2012. All rights reserved. Rev. 8.1 â 1 July 2012 11 of 13	4.1 IRC.1: Accuracy of the Internal RC oscillator (IRC) frequency may be outside of the 4 MHz +/ï­ 1 % specification only at extreme temperatures
ARM7	NXP	LPC2109	If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register. In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended.	In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC21X9/01 . Â© Rev. 3 â 1 October 2011 4 of 9 ES_LPC21x9/01 LPC2109/01, LPC2119/01, LPC2129/01	3.1 CORE.1: Incorrect update of the Abort Link register in Thumb state
ARM7	NXP	LPC2109	Each CAN controller provides a double Receive Buffer (RBX) per CAN channel to store incoming messages until they are processed by the CPU. Software task should read and save received data as soon as a message reception is signaled. In cases where both receive buffers are filled and the contents are not read before the third message comes in, a CAN Data Overrun situation is signaled. This condition is signaled via the Status register and the Data Overrun Interrupt (if enabled). In a Data Overrun condition, the CAN controller is locked from further message reception.	1. Recovering from this situation is only possible with a soft reset to the CAN controller. 2. If software cannot read all messages in time before a third message comes in, it is recommend to change the acceptance filtering by adding further acceptance filter group(s) for messages, which are normally rejected. With this approach, the third incoming message is accepted and the Data Overrun condition is avoided. These additional messages are received with the corresponding group index number can be easily identified and rejected by software. ES_LPC21X9/01 . Â© Rev. 3 â 1 October 2011 5 of 9 ES_LPC21x9/01 LPC2109/01, LPC2119/01, LPC2129/01	3.2 CAN.1: Data Overrun condition can lock the CAN controller
ARM9	NXP	LPC2109	In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options The external start conversion feature, ADCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges.	In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register.	3.3 ADC.1: External sync inputs not operational
ARM7	NXP	LPC2131	If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register. In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended.	In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this would have to be done manually. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved. Rev. 2.1 â 1 May 2012 5 of 13 ES_LPC2131/01 LPC2131/01	3.1 Core.1: Incorrect update of the Abort Link register in Thumb state
ARM7	NXP	LPC2131	Timer0 and Timer1 can be used in a counter mode. In this mode, the Timer Counter register can be incremented on rising, falling or both edges which occur on a selected CAP input pin. This counter mode can be combined with the match functionality to provide additional features. One of the features would be to reset the Timer Counter register on a match. The same would also apply for Timer1. The Timer Counter reset does not trigger on the same incoming edge when the match takes place between the corresponding Match register and the Timer Counter register. The Timer Counter register will be reset only on the next incoming edge. Workaround: There are two possible workarounds: 1. Combine the Timer Counter reset feature with the âinterrupt on matchâ feature. The interrupt on match occurs on the correct incoming edge. In the ISR, the Timer Counter register can also be reset. This solution can only work if no edges are expected during the duration of the ISR. 2. In this solution, the âinterrupt on matchâ feature is not used. Instead, the following specific initialization can achieve the counting operation: a. Initialize the Timer Counter register to 0xFFFFFFFF. b. If ânâ edges have to be counted then initialize the corresponding Match register with value n-1. For instance, if 2 edges need to be counted then load the Match register with value 1. More details on the above example: 1. Edge 1 - Timer overflows and Timer Counter (TC) is set to 0. 2. Edge 2 - TC = 1. Match takes place. 3. Edge 3 - TC = 0. 4. Edge 4 - TC = 1. Match takes place. 5. Edge 5 - TC = 0. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved. Rev. 2.1 â 1 May 2012 6 of 13 ES_LPC2131/01 LPC2131/01		3.2 Timer.1: In counter mode, the Timer Counter reset does not occur on the correct incoming edge
ARM7	NXP	LPC2131	The SSP is a Synchronous Serial Port (SSP) controller capable of operation on a SPI, 4-wire SSI or a Microwire bus. The SSP can operate at a maximum speed of 30 MHz and is referred to as SPI1 in the device documentation. At high SSP frequencies, it is found that the first four pulses are shorter than the subsequent pulses. At 30 MHz, the first pulse can be expected to be approximately 10 ns shorter and the second pulse around 5 ns shorter. The remaining two pulses are around 2 ns shorter than subsequent pulses. At 25 MHz, the length of the first pulse would be around 7 ns shorter. The subsequent three pulses are around 2 ns shorter. At 20 MHz only the first pulse is affected and it is around 2 ns shorter. All subsequent pulses are fine. The deviation of the initial data bits/clocks will decrease as the SSP frequency decreases.	None. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved. Rev. 2.1 â 1 May 2012 7 of 13 ES_LPC2131/01 LPC2131/01	3.3 SSP.1: Initial data bits/clocks of the SSP transmission are shorter than subsequent pulses at higher frequencies
ARM7	NXP	LPC2131	The device operating voltage range is 3.0 V to 3.6 V and it is an internal DC/DC converter that provides 1.8 V to the ARM7 Core. If during a power-on reset the voltage on Vdd takes longer than 200 ms to ramp from below 0.8 V to above 2.0 V, the chip-internal DC/DC converter might not start up correctly. If this happens, the crystal oscillator will not be running, resulting in no code execution. As an example, having a Vdd rise time of less than 10 V/s might trigger this problem. The same problem might occur during a supply voltage drop during which Vdd remains between 300 mV and 80 mV for more than 200 ms before going back to the specified Vdd level. As an example, having a residual battery voltage of less than 0.3 V but more than 0.08 V in a rechargeable battery application might trigger this problem when the charger providing the 3 V supply is being connected.	Apply another power-on Reset during which Vdd rises from below 0.8 V to above 2.0 V in less than 200 ms.	3.4 DC/DC.1: DC/DC converter start-up issue
ARM7	NXP	LPC2131	The MAM block maximizes the performance of the ARM processor when it is running code in Flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled). Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal Flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the Flash memory.	If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved. Rev. 2.1 â 1 May 2012 8 of 13 ES_LPC2131/01 LPC2131/01	3.5 MAM.1: Under certain conditions in MAM Mode 2 code execution out of internal Flash can fail
ARM7	NXP	LPC2131	The Watchdog timer can reset the microcontroller within a reasonable amount of time if it enters an erroneous state. After writing 0xAA to WDFEED, any APB register access other than writing 0x55 to WDFEED may cause an immediate reset.	Avoid APB accesses in the middle of the feed sequence. This implies that interrupts and the GPDMA should be disabled while feeding the Watchdog. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved. Rev. 2.1 â 1 May 2012 9 of 13 ES_LPC2131/01 LPC2131/01	3.6 WDT.1: Accessing non-Watchdog APB registers during the feed sequence causes a reset
ARM7	NXP	LPC2131	In software-controlled mode (BURST bit is 0), the 10-bit ADCs can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options The external start conversion feature, ADxCR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P0.16 or P0.22 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing an ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 60 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges.	In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2131_01 . Â© NXP B.V. 2012. All rights reserved. Rev. 2.1 â 1 May 2012 10 of 13 ES_LPC2131/01 LPC2131/01 4. AC/DC deviations detail	3.7 ADC.1: External sync inputs not operational
ARM9	NXP	LPC2131	The LPC2131/01 is rated for 2 kV ESD. The RTCX1 pin is the input pin for the RTC oscillator circuit. The LPC2131/01 does not meet the required 2 kV ESD specified.	Observe proper ESD handling precautions for the RTCX1 pin.	4.1 ESD.1: The device does not meet the 2 kV ESD requirements on the RTCX1 pin
ARM7	NXP	LPC2364	The LPC2364/66/68 has a 10-bit ADC, which can be used to measure analog signals and convert the signals into a 10-bit digital result. There are eight A/D channels and each channel has its own individual A/D Data Register (ADDR0 to ADDR7). The A/D Data Register holds the result when an A/D conversion is complete, and also includes the flags that indicate when a conversion has been completed (DONE bit) and when a conversion overrun has occurred. The DONE bit is cleared when the respective A/D Data Register is read. If a software read of ADDRx conflicts with the hardware setting of the DONE bit in the same register (once a conversion is completed) then the DONE bit gets cleared automatically, thereby clearing the indication that a conversion was completed.	For software controlled mode or burst mode with only one channel selected, the DONE bit in the A/D Global Data Register (located at 0xE003 4004) can be used instead of the individual ADDRx result register with no impact on performance. For burst mode with multiple channels selected, the DONE bit together with the CHN field in the A/D Global Data Register can be used with some impact on throughput. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 5 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.1 ADC.1: ADDRx read conflicts with hardware setting of the DONE bit
ARM7	NXP	LPC2364	In software-controlled mode (BURST bit is 0), the 10-bit ADC can start conversion by using the following options in the A/D Control Register: Fig 1. A/D control register options The external start conversion feature, AD0CR:START = 0x2 or 0x3, may not work reliably and ADC external trigger edges on P2.10 or P1.27 may be missed. The occurrence of this problem is peripheral clock (pclk) dependent. The probability of error (missing a ADC trigger from GPIO) is estimated as follows: â¢ For PCLK_ADC = 72 MHz, probability error = 12 % â¢ For PCLK_ADC = 50 MHz, probability error = 6 % â¢ For PCLK_ADC = 12 MHz, probability error = 1.5 % The probability of error is not affected by the frequency of ADC start conversion edges.	In software-controlled mode (BURST bit is 0), the START conversion options (bits 26:24 set to 0x1 or 0x4 or 0x5 or 0x6 or 0x7) can be used. The user can also start a conversion by connecting an external trigger signal to a capture input pin (CAPx) from a Timer peripheral to generate an interrupt. The timer interrupt routine can then start the ADC conversion by setting the START bits (26:24) to 0x1. The trigger can also be generated from a timer match register. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 6 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.2 ADC.2: External sync inputs not operational
ARM7	NXP	LPC2364	Each CAN controller provides a double Receive Buffer (RBX) per CAN channel to store incoming messages until they are processed by the CPU. Software task should read and save received data as soon as a message reception is signaled. In cases where both receive buffers are filled and the contents are not read before the third message comes in, a CAN Data Overrun situation is signaled. This condition is signaled via the Status register and the Data Overrun Interrupt (if enabled). If both receive buffers are full and a third message arrives which is rejected by the CAN Acceptance Filter, the CAN controller is locked from further message reception.	1. Recovering from this situation is only possible with a soft reset to the CAN controller. 2. If software cannot read all messages in time before a third message comes in, it is recommend to change the acceptance filtering by adding further acceptance filter group(s) for messages which are normally rejected. With this approach, the third incoming message is accepted, and while it does cause a Data Overrun condition, the lockup condition is avoided. These additional messages are received with the corresponding group index number can be easily identified and rejected by software. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 7 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.3 CAN.1: Data Overrun condition can lock the CAN controller
ARM7	NXP	LPC2364	If the processor is in Thumb state and executing the code sequence STR, STMIA or PUSH followed by a PC relative load, and the STR, STMIA or PUSH is aborted, the PC is saved to the abort link register. In this situation the PC is saved to the abort link register in word resolution, instead of half-word resolution. Conditions: The processor must be in Thumb state, and the following sequence must occur: <any instruction> <STR, STMIA, PUSH> <---- data abort on this instruction LDR rn, [pc,#offset] In this case the PC is saved to the link register R14_abt in only word resolution, not half-word resolution. The effect is that the link register holds an address that could be #2 less than it should be, so any abort handler could return to one instruction earlier than intended.	In a system that does not use Thumb state, there will be no problem. In a system that uses Thumb state but does not use data aborts, or does not try to use data aborts in a recoverable manner, there will be no problem. Otherwise the workaround is to ensure that a STR, STMIA or PUSH cannot precede a PC-relative load. One method for this is to add a NOP before any PC-relative load instruction. However this is would have to be done manually. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 8 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.4 Core.1: Incorrect update of the Abort Link register in Thumb state
ARM7	NXP	LPC2364	Deep power-down mode is like Power-down mode, but the on-chip regulator that supplies power to internal logic is also shut off. This produces the lowest possible power consumption without actually removing power from the entire chip. The power consumption in Deep power-down mode does not meet the specifications.	None.	3.5 Deep power-down.1: Deep power-down mode is not functional
ARM7	NXP	LPC2364	The LPC2364/66/68 has an Ethernet interface, which can be interfaced with an off-chip PHY using the RMII interface. The default configuration of the device does not enable the RMII interface.	To use the Ethernet interface in RMII mode write a 1 to bit 12 (P1.16) in PINSEL2 register (located at 0xE002 C008). This workaround only applies for Rev â-â devices and does not apply for Rev âAâ and newer devices. In order to have both Rev â-â and other revisions coexist in the same piece of software, the MAC module ID can be used to identify the part and determine if port pin P1.6 needs to be set or not. Here are the steps (along with some sample code) to initialize the MAC based on the module ID: 1. In master header file lLPC24xx.h, make sure Module ID is defined (Please note, this ID register is not documented in the User's Manual). #define MAC_BASE_ADDR 0xFFE00000 #define MAC_MODULEID (*(volatile unsigned long *)(MAC_BASE_ADDR + 0xFFC)) /* Module ID reg (RO) */ 2. In the beginning of the MAC initialization file, add below definition: #define OLD_EMAC_MODULE_ID 0x3902 << 16) | 0x2000) 3. In MAC initialization routine, right after setting the EMAC clock in the PCONP register, add a few lines as below: /* Turn on the ethernet MAC clock in PCONP, bit 30 */ regVal = PCONP; regVal |= PCONP_EMAC_CLOCK; PCONP = regVal; /*------------------------------------------------------ * Write to PINSEL2/3 to select the PHY functions on P1[17:0] ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 9 of 20 ES_LPC2364_66_68 LPC2364/66/68 * P1.6, ENET-TX_CLK, has to be set for Rev '-' devices and it * must not be set for Rev 'Aâ and newer devices *------------------------------------------------------*/ regVal = MAC_MODULEID; if ( regVal == OLD_EMAC_MODULE_ID ) { /* On Rev. '-', MAC_MODULEID should be equal to OLD_EMAC_MODULE_ID, P1.6 should be set. */ PINSEL2 = 0x50151105; /* selects P1[0,1,4,6,8,9,10,14,15] */ } else { /* on rev. 'A', MAC_MODULEID should not equal to OLD_EMAC_MODULE_ID, P1.6 should not be set. */ PINSEL2 = 0x50150105; /* selects P1[0,1,4,8,9,10,14,15] */ } PINSEL3 = 0x00000005; /* selects P1[17:16] */	3.6 Ethernet.1: Setting up the Ethernet interface in RMII mode
ARM7	NXP	LPC2364	The LPC2364/66/68 has an Ethernet interface, which has a dedicated 16 kB SRAM. When the Ethernet block is disabled (in the PCONP register located at 0xE01F C0C4), the Ethernet SRAM is also disabled.	Enable the Ethernet block by setting the PCENET bit (bit no. 30) in the PCONP register. The Ethernet SRAM is now enabled.	3.7 Ethernet.2: Ethernet SRAM disabled
ARM7	NXP	LPC2364	The Receive number of Descriptors register (RxDescriptor-0xFFE0 0110) defines the number of descriptors in the Descriptor array. Each receive descriptor element in the Descriptor array has an associated status field which consists of the HashCRC word and Status Information word. The status words are updated incorrectly if the number of Descriptors set in the Receive number of Descriptors register is greater than or equal to 5.	Define 4 or less in the Receive number of Descriptors register. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 10 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.8 Ethernet.3: Receive Status registers will not function correctly if RxDescriptor number is greater than 4
ARM7	NXP	LPC2364	The transmit consume index register defines the descriptor that is going to be transmitted next by the hardware transmit process. After a frame has been transmitted hardware increments the index, wrapping the value to 0 once the value of TxDescriptorNumber has been reached. If the TxConsumeIndex equals TxProduceIndex the descriptor array is empty and the transmit channel will stop transmitting until software produces new descriptors. The TxConsumeIndex register is not updated correctly (from 0 to 1) after the first frame is sent. After the next frame sent, the TxConsumeIndex register is updated by two (from 0 to 2). This only happens the very first time, so subsequent updates are correct (even those from 0 to 1, after wrapping the value to 0 once the value of TxDescriptorNumber has been reached)	Software can correct this situation in many ways; for example, sending a dummy frame after initialization. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 11 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.9 Ethernet.4: Ethernet TxConsumeIndex register does not update correctly after the first frame is sent
ARM7	NXP	LPC2364	The operating speed of this device out of internal flash/SRAM is specified at 72 MHz. Code execution from internal flash is restricted depending upon the device revision: 1. Rev âAâ devices: Code execution from internal flash is restricted to a maximum of 60 MHz. For example, use a PLL output frequency of FCCO = 360 MHz and divide it by 6 (CCLKSEL = 5) to generate 60 MHz CPU clock (do not use even values for CCLKSEL). 2. Rev â-â devices: Code execution from internal flash is restricted to a maximum of 60 MHz also. However, this device revision has one more restriction in terms of the PLL output frequency (FCCO - Please refer to PLL.1 above). FCCO is limited to 290 MHz. Considering the same example in PLL.1 (Input crystal-12 MHz, N = 1, M = 12): FCCO = 288 MHz The CPU Clock Configuration register (located at 0xE01F C104) can then be used to divide this frequency by 6 (CCLKSEL = 5) to achieve 48 MHz. Since this register only accepts odd values for CCLKSEL, a division by 5 (CCLKSEL = 4) is not a valid option. In both the above revisions, code can still execute out of SRAM at up to 72 MHz.	None.	3.10 Flash.1: Operating speed out of on-chip flash is restricted
ARM7	NXP	LPC2364	The LPC2364/66/68 has an I2S interface, which can be used for audio devices. The I2S interface was initially designed to operate with the general purpose DMA controller. The DMA controller cannot access the I2S interface.	No known workaround. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 12 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.11 I2S.1: I2S DMA interface is non-operational
ARM7	NXP	LPC2364	The MAM block maximizes the performance of the ARM processor when it is running code in flash memory. It includes three 128-bit buffers called the Prefetch Buffer, the Branch Trail Buffer and the data buffer. It can operate in 3 modes; Mode 0 (MAM off), Mode 1 (MAM partially enabled) and Mode 2 (MAM fully enabled). Under certain conditions when the MAM is fully enabled (Mode 2) code execution from internal flash can fail. The conditions under which the problem can occur is dependent on the code itself along with its positioning within the flash memory.	If the above problem is encountered then Mode 2 should not be used. Instead, partially enable the MAM using Mode 1.	3.12 MAM.1: Under certain conditions in MAM Mode 2 code execution out of internal flash can fail
ARM7	NXP	LPC2364	The PLL input, in the range of 32 KHz to 50 MHz, may initially be divided down by a value âNâ, which may be in the range of 1 to 256. Following the PLL input divider is the PLL multiplier. This can multiply the input divider output through the use of a Current Controlled Oscillator (CCO) by a value âMâ, in the range of 1 through 32768. The resulting frequency, FCCO must be in the range of 275 MHz to 550 MHz.This frequency can be divided down (using the Clock Divider registers) to get the desired clock frequencies for the core and peripherals. The maximum output of the CCO within the PLL block is limited to 290 MHz.	Care should be taken while programming the PLL so that FCCO resides in the desired range. The suggested setting is to use a 12 MHz external crystal. Use a PLLdivider (N) of 1 and PLL multiplier (M) of 12. Putting the values in the equation: FCCO = (2 ï´ M ï´ FIN) / N FCCO = 288 MHz The CPU Clock Configuration register (located at 0xE01F C104) can then be used to divide this frequency by 4 to produce the maximum CPU speed of 72 MHz (except on Rev â-â and Rev âAâ, see Flash.1). ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 13 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.13 PLL.1: PLL output (FCCO) is limited to 290 MHz
ARM7	NXP	LPC2364	The LPC2364/66/68 has 16 kB of SRAM on the AHB2 bus, which would generally be used by the Ethernet block. The 16 kB of SRAM can only be used as data RAM. Code can not be executed from this memory.	No known workaround.	3.14 SRAM.1: 16 kB SRAM cannot be used for code execution
ARM7	NXP	LPC2364	The USB_NEED_CLK signal is used to facilitate going into and waking up from chip Power Down mode. USB_NEED_CLK is asserted if any of the bits of the USBClkSt register are asserted. The USB_NEED_CLK bit of the USBIntSt register (located at 0xE01F C1C0) is always asserted, preventing the chip from entering Power Down mode when the USBWAKE bit is set in the INTWAKE register (located at 0xE01F C144).	After setting the PCUSB bit in PCONP (located at 0xE01F C0C4), write 0x1 to address 0xFFE0C008. The USB_NEED_CLK signal will now function correctly. Writing to address 0xFFE0C008 only needs to be done once after each chip reset.	3.15 USB.1: USB_NEED_CLK is always asserted
ARM7	NXP	LPC2364	U1CONNECT Signal (alternate function of P2.9) is part of the SoftConnect USB feature, which is used to switch an external 1.5 KW resistor under the software control. The USB U1CONNECT alternate function does not work as expected.	Configure P2.9 as a GPIO pin, and use it to enable the pull-up resistor on the U1D+ pin. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 14 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.16 USB.2: U1CONNECT signal is not functional
ARM7	NXP	LPC2364	The VBUS signal indicates the presence of USB bus power. The VBUS status input is not functional.	Configure P1.30 as a GPIO pin, and poll it to determine when VBUS goes to 0, signalling a disconnect event.	3.17 USB.3: VBUS status input is not functional
ARM7	NXP	LPC2364	The device has a VBAT pin which provides power only to the RTC and Battery RAM. VBAT can be connected to a battery or the same 3.3 V supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). If VBAT is powered before the 3.3 V supply, VBAT is unable to source the start-up current required for the Battery RAM. Therefore, power consumption on the VBAT pin will be high and will remain high until 3.3 V supply is powered up. Once 3.3 V supply is powered up, power consumption on the VBAT pin will reduce to normal and subsequent power cycle on the 3.3 V supply will not cause an increased power consumption on the VBAT pin.	Provide 3.3 V supply used by rest of the device first and then provide VBAT voltage.	3.18 VBAT.1: Increased power consumption on VBAT when VBAT is powered before the 3.3 V supply used by rest of the device
ARM7	NXP	LPC2364	The device has a VBAT pin which provides power only to the Real Time Clock (RTC) and Battery RAM. VBAT can be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). The input voltage range on the VBAT pin is 2.0 V minimum to 3.6 V maximum for temperature ï­40 ï°C to +85 ï°C. Normally, if the RTC and the Battery RAM are not used, the VBAT pin can be left floating. If the VBAT pin is left floating, the internal reset signal within the RTC domain may get corrupted and as a result, prevents the device from starting-up.	The VBAT should be connected to a battery or the same supply used by rest of the device (VDD(3V3) pin, VDD(DCDC)(3V3) pin). ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 15 of 20 ES_LPC2364_66_68 LPC2364/66/68	3.19 VBAT.2: The VBAT pin cannot be left floating
ARM7	NXP	LPC2364	The Watchdog timer can reset the microcontroller within a reasonable amount of time if it enters an erroneous state. After writing 0xAA to WDFEED, any APB register access other than writing 0x55 to WDFEED may cause an immediate reset.	Avoid APB accesses in the middle of the feed sequence. This implies that interrupts and the GPDMA should be disabled while feeding the Watchdog. ES_LPC2364_66_68 . Â© NXP B.V. 2012. All rights reserved. Rev. 9.1 â 1 July 2012 16 of 20 ES_LPC2364_66_68 LPC2364/66/68 4. AC/DC deviations detail	3.20 WDT.1: Accessing non-Watchdog APB registers in the middle of the feed sequence causes a reset
ARM9	NXP	LPC2364	The LPC2364/66/68 is rated for 2 kV ESD. The RTCX1 pin is the input pin for the RTC oscillator circuit. The LPC2364/66/68 does not meet the required 2 kV ESD specified.	Observe proper ESD handling precautions for the RTCX1 pin.	4.1 ESD.1: The LPC2364/66/68 does not meet the 2 kV ESD requirements on the RTCX1 pin
ARM9	TI	OMAP-L137	Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port. The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests. Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of successive CPU requests, it is possible for the CPU to block all DMA requests until CPU traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 2 shows a high level diagram of the arbitration scheme used for L2 RAM requests. C674x Megamodule EDMA SHAREDRESOURCE ExternalSystemMasters Programmable Priority ARBITRA MasterPriority C674x CPU EMAC ARBITRA Programmable Priority IDMA L2 RAM TION LCDC Inherit TION Priority SDMA UHPI USB Highest Priority Master Granted Access. Contention counters implemented to not starve low priority requestors Figure 2. Priority Arbitration Scheme for L2 RAM	Configure DMA and CPU requests to different priority levels. The CPU should not be set to priority level 7. There is no penalty for setting the IDMA and SDMA priorities equal to each other. CPU request priority is programmed within the CPUARBU register: /** Pseudo code only **/ Uint32 *CPUARBU; CPUARBU = ( Uint32 * ) ( 0x01841000 ); /* Set priority different from IDMA/SDMA */ *CPUARBU = [CPU_PRIORITY]; 8 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications IDMA request priority is programmed within the IDMA1_COUNT register /** Pseudo code only **/ Uint32 *IDMA1_SRC, *IDMA1_DST; Uint32 *IDMA1_CNT; IDMA1_SRC = ( Uint32 * ) ( 0x01820108 ); IDMA1_DST = ( Uint32 * ) ( 0x0182010C ); IDMA1_CNT = ( Uint32 * ) ( 0x01820110 ); *IDMA1_SRC = sourceAddress; *IDMA1_DST = destinationAddress; /* Set IDMA priority different from CPU */ *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ; SDMA request priority is inherited from the MSTPRIn registers /** Pseudo code only **/ Uint32 *MSTPRI1, *MSTPRI2; MSTPRI1 = ( Uint32 * ) ( 0x01C14114 ); MSTPRI2 = ( Uint32 * ) ( 0x01C14118 ); /* Set SDMA master priorities different from CPU */ *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT]; *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT]; SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 9 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	3.0.4 DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities are Equal
ARM9	TI	OMAP-L137	When the USB controller is operating as a device and an attached host resets the device after the completion of the “Device Attached” state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.	Software must service every USB RESET interrupt received. Software should not proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling. 10 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications	3.0.6 USB0: Extraneous RESET Interrupt
ARM9	TI	OMAP-L137	During LCDC initialization, there is the potential for a FIFO underflow condition to occur. A FIFO underflow condition occurs when the input FIFO is completely empty and the LCDC raster controller logic that drives data to the output pins attempts to fetch data from the FIFO. When a FIFO underflow condition occurs, incorrect data will be driven out on the LCDC data pins. An underflow condition will occur if the EMIFB issues a refresh command to the SDRAM memory during LCDC start up/initialization. The error condition will be captured in the LCD Status register (LCD_STAT) in the FIFO underflow status (FUF) bit field. If the FUF_EN bit is enabled in Raster Control Register (RASTER_CTRL), the LCDC will send an interrupt to the CPU. The FIFO underflow described above is not expected to be a common occurrence because of the unlikely alignment of events required to produce the underflow condition.	The EMIFB hardware automatically schedules refresh commands to the SDRAM memory. Therefore, it is not possible for the user/application code to schedule EMIF refresh commands to prevent them from being initiated during LCDC start up. This means that it is not possible to prevent an EMIFB refresh occurrence during the start up of the LCDC. Software should poll the FUF bit field in the LCD_STAT register to check if an error condition has occurred or service the interrupt if FUF_EN is enabled when FUF occurs. If the FUF bit field has been set to 1, this will indicate an underflow condition has occurred and then the software should execute a reset of the LCDC via the LPSC. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 11 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	3.0.7 LCDC Underflow During Initialization
ARM9	TI	OMAP-L137	In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT input does not go inactive within maximum extended wait cycles programmed in the Async Wait Cycle Config register, the EMIFA will report a time-out error. The data returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out error but with the correct data for the MMR read. The EMIFA will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is performed. This issue is only applicable if all of the following are true: • The EMIFA is used for asynchronous memory accesses in Extended Wait mode. • There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input. • If asynchronous memory read with time-out error is followed by an MMR read.	If a time-out occurs, perform any of the following: • A dummy read to another asynchronous memory chip select that is not configured to be in Extended Wait mode. • A dummy read to the same asynchronous memory chip select after disabling the Extended Wait mode on that chip select. • A dummy read to SDRAM 12 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications	3.0.13 EMIFA: Asynchronous Memory Timeout Error Persistence
ARM9	TI	OMAP-L137	The C674x DSP megamodule supports twelve maskable hardware interrupt signals (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a CPUINTn hardware interrupt, or multiple system interrupts may be combined by the ECM into a single signal before mapping to a CPUINTn interrupt. See SPRUFK5 - TMS320C674x DSP Megamodule Reference Guide for more information on how DSP interrupts are handled. The ECM expects all incoming interrupts to be pulse interrupts, however the [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.	The CPUINTn hardware interrupts can support both pulse and level interrupts so CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts. Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 13 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	3.0.14 A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event Combiner Module (ECM)
ARM9	TI	OMAP-L137	When a soft reset is invoked by setting the RESET bit of the USB CTRLR register ( CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists. USB resets initiated by system-reset and power-on-reset are immune from the timing violation. There is no plan to fix this issue in future silicon revisions because: 1. No functional problems have been observed to date 2. A software workaround has been developed to avoid the problem	The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below: 1. Enable the USB controller module clock 2. Perform a soft USB reset 3. Wait for the USB soft reset bit to clear 4. Disable the USB controller module clock 5. Configure the USB PHY parameters 6. Enable the PHY 7. Enable the USB controller module clock 14 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications	3.0.15 Potential USB2.0 Soft Reset Timing Violation
ARM9	TI	OMAP-L137	The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).	The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 15 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	3.0.17 ARM Interrupt Controller Vector Size Register (VSR) Initialization
ARM9	TI	OMAP-L137	Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device Technical Reference Manual SPRUH92 for additional information about the AINTC. The AINTC module expects all incoming interrupts to be pulse interrupts, however the [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected. If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.	Method 1 Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts. /** Pseudo code only **/ void CHIPINT0_ISR(void) { /* Exit immediately if CHIPSIG0 is not set */ if( (SYSCFG->CHIPSIG & 0x1) == 0 ) { return; } /* Intended service routine code */ SYSCFG->CHIPSIG_CLR = 0x1; printf(“Hello World!\n”); } Method 2 Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been cleared. This method will eliminate false interrupts, but requires changes to the AINTC interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application. /** Pseudo code only **/ /* Sequence that is susceptible to false CHIPINTn interrupts */ void AINTC_ISR_DISPATCH_1(void) { Get_Interrupt_Information(); /* CHIPINTn interrupts continue to be generated after */ /* AINTC CHIPINTn flag is cleared. */ Clear_AINTC_Interrupt_Flag(); /* CHIPINTn interrupts are only stopped after ISR clears */ /* the status flag. */ Branch_To_ISR(); } 16 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications /* Sequence that is not susceptible to false CHIPINTn interrupts */ void AINTC_ISR_DISPATCH_2(void) { Get_Interrupt_Information(); /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */ /* interrupts to AINTC. */ Branch_To_ISR(); /* Ok to clear AINTC CHIPINTn flag now. */ Clear_AINTC_Interrupt_Flag(); } SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 17 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	3.0.18 A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC
ARM9	TI	OMAP-L137	The C674x CPU supports a Saturation feature for key arithmetic operations. If an operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit. In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit. All of the following must take place in order for an application to be affected by this advisory: 1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued simultaneously 2. Both instructions are processed on the same side 3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle 4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction 5. The application checks for the saturation flag and uses the saturation result of the 4 cycle instruction	Perform one of the following: • For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together. • Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit instructions. 18 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications	3.0.19 Incorrect Masking of the C674x CSR:SAT Bit
ARM9	TI	OMAP-L137	Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 3). SDMA requests are defined as external system bus master requests handled via this port. The C674x Megamodule uses a two-way set associative cache for L1D. This means that every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide (Literature Number SPRUFK5) for more information on the L1D cache architecture and related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software. An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 3): 1. L1D cache Lines 1, 2, and 3 have the following characteristics: • Line 1 is associated with L2 SRAM (Line A in Figure 3), was previously read by CPU, and is clean. (CPU has not updated the data.) • Line 2 is associated with L2 SRAM (Line B in Figure 3), was previously read by CPU, and is clean. (CPU has not updated the data.) • Line 3 was previously read by the CPU and may be either clean or dirty. 2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D cache Lines 1 and 2. 3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes, the CPU performs two reads within the same clock cycle: • Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in L1D Cache, which also has a snoop write pending for the updated Line B content. • Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache. 4. When the snoop write operation completes, Line 2 in L1D cache now contains the updated L2 SRAM Line B data instead of the L2 cache Line E data. The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 19 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Time Line System View Line A Line E and Line B Map to STEP 1 STEP 2 STEP 3 STEP 4 same L1D Cache line. Line A B C674x subsystem Line A C C6xCPU Read Line D L2 Line A D Activity Read Line E C6X CPU Controller L2 SRAM SDMA Write Line A Snoop Write Line A E Activity Write Line B Initiated L1D EMC L2 CACHE L1D Cache Clean Line A Clean Line A IN FLUX Clean Line A Controller SDMA PORT Line 1 (New Data) L1D Cache Clean Line B Clean Line B IN FLUX CORRUPT EMAC Line 2 Line E replaces Line B due Line Line 1 A [A] PRU L1D Cache Clean/Dirty Clean/Dirty IN FLUX Clean Line D to CPU read. Line 3 Line C Line C Line Line 2 A [B/E] Delayed snoop wrtie to Line EDMA SYSTEMMASTERS Line Line 3 A [C/D] B corrupts Line E in L1D$ L1D Corruption happens CACHE UHPI because of this state EXTERNAL Figure 3. Example of L1D Cache Corruption	Method 1: Do not perform two CPU read operations in the same clock cycle. For C code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000 Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the -- c64p_dma_l1d_workaround flag will only issue a warning. Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial segments which overlap into the same L1D cache line. /** Pseudo code only **/ Uint8 *SDMA_BUFF, *CPU_BUFF; /* 64-byte aligned allocation Option 1 */ SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 ); CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 ); SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 ); CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 ); /* 64-byte aligned allocation Option 2 with BIOS Call */ SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 ); CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 ); 20 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if there are CPU writes. With this method, the semaphore ensures that there is clear ownership of the buffer between CPU and SDMA, and the CPU manages cache coherence by using explicit cache writeback operations. /** Pseudo code only **/ /* Example with EDMA as the external master */ EDMA_ISR() { /* EDMA releases ownership of buffer */ SEM_post(SyncSemaphore); return; } main() { while(COND) { /* CPU waits for ownership of buffer */ SEM_pend(SyncSemaphore); /**********************/ /*** CPU Processing ***/ /**********************/ /* Cache writeback for shared block */ /* Buffer must be 64-byte aligned */ BCACHE_wbInv( blockPtr, blockSize, WAIT ); /* Initiate EDMA */ EDMA_Event_Generate(); } } Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or Shared RAM instead of L2 RAM. Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM or Shared RAM instead of L2 RAM. Method 6 Configure the entire L2 RAM as normal SRAM (no cache). Method 7 Configure the entire L1D RAM as normal SRAM (no cache). SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 21 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	3.0.21 SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/C ache/SRAM
ARM9	TI	OMAP-L137	The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB- peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported. The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles between host and peripheral, is supported.	None 22 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications	3.0.22 USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported
ARM9	TI	OMAP-L137	Under conditions in which the device is subjected to large variations in operating temperatures, the USB0 PLL temperature compensation circuitry does not have enough margin to guarantee compensation for PLL drift across all temperature ranges. As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized). Once the onset of the PLL drift occurs, the mean frequency will continue to drift outside the expected frequency eventually resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset. If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation circuitry is expected to provide the proper compensation to prevent the mean PLL frequency from losing lock and beginning to drift. More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature space (0˚C-90˚C). TI has identified a point-to-point device temperature range of 0˚C-65˚C in which there is very high confidence in which the compensation circuitry will properly compensate for all variations in temperature provided that the USB0 PHY was most recently initialized (calibrated) within this same temperature range. Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always experience a failure in USB transmission. Root Cause The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY was not designed with a large enough range to compensate for all variations in temperature across the specified operating range of the device. How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps: 1. Allowing the unit to soak in an ambient temperature of -35˚C until the device temperature reaches approximately the same temperature. 2. Power up the device and provide the necessarily software programming in order to invoke the USB Signal Quality Test Pattern. 3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C. Record the measured mean frequency by the compliance software. NOTE: The set points can be varied to obtain finer temperature resolution of when the PLL begins to drift a per platform basis. The above temperature profile is provided for reference. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 23 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0 PHY without a re-enumeration. In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to determine when the issue is present. One such approach is to look for an absence of USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application. As an additional safeguard, an application can also intentionally schedule pre- determined USB PHY resets at specific temperature points if operation over a broad range is expected. Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module: #define CFGCHIP2 *((volatile unsigned int *) 0x01C14184) #define USBPHY_PHYPDWN 0x00000200 Void phy_reset(void) { CFGCHIP2 |= USBPHY_PHYPDWN; /* Power down the USB PHY */ mdelay(1); /* Wait 500ms */ CFGCHIP2 &= ~USBPHY_PHYPDWN; /* Power up the USB PHY */ } 24 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications	3.0.24 USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings
ARM9	TI	OMAP-L137	When CPPI DMA completes a receive data transaction it posts a write to the Rx data buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.	Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred procedure calls (whose schedule can be delayed depending on OS load), the latency sensitive application (like ISO Audio) might be affected by delay in notification to the application. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 25 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	3.0.25 USB0: CPU gets Stale Receive Data from the Data Buffer located in External Memory
ARM9	TI	OMAP-L137	The erroneous short packet status can be detected on current endpoint and XDMA closes the Rx transfer in current endpoint. When more than one endpoint have been processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints. This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA mode.	The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different. Software must keep tracking every endpoint data transferring size. When DMA completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data. 26 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 3.0 Usage Notes and Known Design Exceptions to Functional Specifications	3.0.26 USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint is Transferring Data
ARM9	TI	OMAP-L137	Teardown receive DMA is not working perfectly. This happens when a teardown is initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.	Software should make sure that DMA does not get to an unknown state during teardown by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure can be initiated. Software should also add 250 ms delay during teardown. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 27 Submit Documentation Feedback 2.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 3 Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 2.1 of the OMAP-L137. 3.1 Usage Notes for Silicon Revision 2.1 Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions. Silicon revision 2.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1 Usage Notes for Silicon Revision 3.0. 3.2 Silicon Revision 2.1 Known Design Exceptions to Functional Specifications Silicon revision 2.1 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2 Silicon Revision 3.0 Known Design Exceptions to Functional Specifications Table 3. Silicon Revision 2.1 Advisory List Title ................................ Page	3.0.27 USB0: DMA Hung up in Frequent Teardowns
ARM9	TI	OMAP-L137	The 3.3 V digital I/O buffers on the device exhibit accelerated aging under use conditions with heavy switching activity. As a result, the recommended Power-On Hours (POH) listed in the device-specific data manual may not apply in all cases. For examples of representative lifetimes, see Examples of Representative Lifetimes (Power-On Hours) . In a typical use case, the EMIFB clock pin (EMB_CLK) may be impacted due to the high switching rate and may eventually lead to SDRAM-related failures. NOTE: The information in Examples of Representative Lifetimes (Power-On Hours) and Examples of Representative Lifetimes (Power-On Hours) is provided solely for user convenience and does not extend or modify the warranty provided under any terms and conditions, including TI’s Standard Terms and Conditions of Sale for Semiconductor Products. Examples of Representative Lifetimes (Power-On Hours) NOMINAL I/O LIFETIME ESTIMATES (YEARS) FAIL DVDD SWITCHING DPPM(1) RATE HOURS (HRS) PER DAY OF USE PERIPHERAL VOLTAGE FREQUENCY ESTIMATE (%) (V) (MHz) 2 HRS 3 HRS 7 HRS 12 HRS 24 HRS 1000 0.1 8.9 5.9 2.5 1.5 0.7 3.30 133 2500 0.25 >15 11.7 5.0 2.9 1.5 EMIFB 5000 0.5 > 15 > 15 7.3 4.3 2.1 1000 0.1 > 15 > 15 > 15 11.6 5.8 3.30 16.94 2500 0.25 > 15 > 15 > 15 > 15 11.5 McASP 5000 0.5 > 15 > 15 > 15 > 15 > 15 (1) Defective parts per million. Accelerated aging of buffers depends on I/O switching frequency and I/O voltage. Prolonged high frequency switching and operating at higher voltages causes buffer performance to degrade more rapidly.	The following methods should be used to prolong the lifetime of the device. METHOD 1 The 3.3 V output signals should only toggle when required for system functionality. The options are to tristate output buffers when not in use, or to run at the minimum frequency required for the specific application. METHOD 2 Reduce the I/O voltage, DVDD. Note: Do not reduce I/O voltage on devices already deployed or showing premature aging effects. To see the effects of premature aging on output signals, See the IO Buffer Premature Aging Assessment Wiki page. Examples of Representative Lifetimes (Power-On Hours) depicts the subsequent performance improvements by reducing the I/O voltage. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 29 Submit Documentation Feedback 2.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Examples of Representative Lifetimes (Power-On Hours) NOMINAL I/O LIFETIME ESTIMATES (YEARS) FAIL DVDD SWITCHING DPPM(1) RATE HOURS (HRS) PER DAY OF USE PERIPHERAL VOLTAGE FREQUENCY ESTIMATE (%) (V) (MHz) 2 HRS 3 HRS 7 HRS 12 HRS 24 HRS 1000 0.1 > 15 > 15 7.7 4.5 2.2 3.15 133 2500 0.25 > 15 > 15 > 15 8.8 4.4 EMIFB 5000 0.5 > 15 > 15 > 15 12.9 6.4 1000 0.1 > 15 > 15 > 15 > 15 > 15 3.15 16.94 2500 0.25 > 15 > 15 > 15 > 15 > 15 McASP 5000 0.5 > 15 > 15 > 15 > 15 > 15 (1) Defective parts per million. The Recommended Operating Conditions range for DVDD Supply Voltage, I/O, 3.3V, has been expanded to allow for a minimum voltage of 3.0V for Silicon Revision 2.1 and 2.0 parts with the "3V" marking only (for more details on the die symbolization and device revision codes, see Section 1.2, Package Symbolization and Revision Identification). Recommended Operating Conditions MIN NOM MAX UNIT DVDD Supply voltage, I/O, 3.3V 3.0 3.3 3.45 V The Absolute Maximum Ratings requirement for the Input voltage ranges, V I/O, 3.3V I (Steady State) has been modified. Absolute Maximum Ratings Over Operating Case Temperature Range V I/O, 3.3V I Input voltage ranges –0.3V to DVDD + 0.350V (Steady State) See the IO Buffer Premature Aging Assessment Wiki page for more details on the implementation of the above workarounds. 30 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 2.0 Usage Notes and Known Design Exceptions to Functional Specifications 4 Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 2.0 of the OMAP-L137. 4.1 Usage Notes for Silicon Revision 2.0 Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions. Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1 Usage Notes for Silicon Revision 3.0. 4.2 Silicon Revision 2.0 Known Design Exceptions to Functional Specifications Some silicon revision 2.0 applicable advisories have been found on a later silicon revision. For more details, see • Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications • Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications Table 4. Silicon Revision 2.0 Advisory List Title ................................ Page	2.1.23 Digital I/O Buffers Age Prematurely
ARM9	TI	OMAP-L137	For affected silicon revisions, the DSP initiates the system boot sequence when the device is released from reset. To prepare the ARM for the user, the DSP will first initialize the ARM reset vector table with an infinite “idle” loop. The ARM reset vector table is located in the ARM’s local RAM, however the ARM local RAM can only be accessed by two bus masters: ARM and PRU0. Therefore, the DSP must program PRU0 to copy the desired reset vector table into the ARM’s local RAM. The PRU instructions are located inside of an instruction RAM (IRAM) which is initialized by the DSP during ROM boot (see Figure 4). After the instructions are stored to IRAM, the PRU is reset and enabled to execute its instructions. In this case, the PRU is instructed to initialize the ARM reset vector table. Read PRU Core PRU IRAM Write Enable Bit Reset Bit External Master (DSP) Figure 4. PRU and DSP Block Diagram When the device is first powered-on, the read bus from the PRU IRAM is not initialized and will contain random values (see Figure 5). Under unpredictable circumstances, the random value on the read bus may resemble a reserved instruction which can be interpreted by the PRU when the core is reset and not enabled. If the PRU core executes this reserved instruction, it will not be able to properly execute the first functional op-code in the PRU IRAM when the core is later enabled. In this fail state, the PRU will never acknowledge to the DSP that the reset vector table was successfully initialized and the DSP will be stuck in a polling loop waiting for the PRU to complete its task. Read Rsvd Inst PRU Core Fail State! PRU IRAM Write Enable Bit Reset Bit External Master (DSP) Figure 5. Boot Failure on Power-On Although the PRU core execution is stuck, the PRU IRAM read bus is now initialized with a non-reserved instruction that was fetched from the IRAM by the PRU core (see 32 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 2.0 Usage Notes and Known Design Exceptions to Functional Specifications Figure 6). If a secondary reset is provided to the device (either POR or WARM), the PRU will be able to execute its functional instructions as expected. Read Good Inst PRU Core Pass State! PRU IRAM Write Enable Bit Reset Bit External Master (DSP) Figure 6. Secondary Reset Note that in order to recover from this fail state with a secondary reset, the DSP must be allowed to execute its boot ROM up to the point where the PRU has fetched a known instruction from the PRU IRAM. The approximate count of 15k cycles into the boot ROM is sufficient. The 15k clock cycle count does not include the 6192 clock cycles required to complete a device POR reset (see Figure 7). With a 24MHz crystal, the first RESET signal must be asserted high for at least 883us (or approximately 1ms). Greater than 15k Cycles RESET RESETOUT 6192 Cycles Figure 7. First POR Reset Timing The long-term solution for this problem is to update the DSP boot ROM with a new PRU initialization sequence that is immune to the described fail mode (see Figure 8): 1. Before resetting the PRU, the DSP will perform a read-back-verify of the PRU IRAM so that the IRAM read bus will be initialized with a known and safe state. 2. The PRU will be reset and enabled in the same clock cycle by using a single register write so that the core does not have the opportunity to interpret reserved instructions. 3. The DSP will write additional, non-critical op-codes at the beginning of the PRU IRAM so that the PRU can self-recover even if it interprets a reserved instruction. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 33 Submit Documentation Feedback 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Read Good Inst PRU Core Pass State! PRU IRAM Write Enable Bit Reset Bit DSP Read External Master (DSP) Figure 8. New Initialization Sequence The following symptoms are all observable for this fail mode at power-on: 1. The RESETOUT signal toggles as expected 6192 cycles after the RESET signal is asserted high. 2. The device produces no boot-mode related activity and the user’s boot program will not be loaded or executed. 3. Connecting to the DSP through JTAG emulation will show that the DSP is stuck in a loop inside of the DSP boot ROM (0x00700000 – 0x007FFFFF memory space). 4. A subsequent reset (either POR or WARM) which is initiated at least 1ms after the first POR reset is asserted high will always produce a successful boot. 5. Following a secondary reset, the device will function as expected without fail until the device is powered-off again.	Modify the target board so that the affected device is given a secondary reset on power-up as shown in Figure 6. Two example methods are described in the sections that follow. Although secondary resets are compatible with future silicon revisions, they are not required for devices where the root cause has been fixed via an updated DSP boot ROM. In order to reduce BOM costs, board designers may want to route a reset signal bypass path so that the workaround circuit can be depopulated on future PCB builds. ❏Use a reset supervisor device that includes a watchdog timeout function so that the reset supervisor will issue a secondary reset if the device fails to boot. The watchdog should be serviced with a device signal that is controlled by software. Options for servicing the watchdog timeout include GPIO, unused clock sources such as OBSCLK or a periodic output peripheral like TIMER and ePWM. Some TPS382x reset supervisors include a watchdog function (shown in Figure 9). 34 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback Copyright © 2008–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications TPS3820 3.3V OMAP-L137 VDD DVDD GND GND Board Reset MR WDI GPIO RESET RESET 0-W Not Populated Figure 9. Reset Supervisor with Watchdog Function The watchdog supervisor workaround is easy to implement, however the watchdog timeout period may exceed application boot-up time requirements. For example, the TPS3820 has a typical watchdog timeout period of 200ms. The second workaround can speed up the reset process. ❏Implement a logic-based secondary reset circuit which is timed using RC components. For the circuit shown in Figure 10, a single board reset control signal can trigger three logic transitions in a dual XOR gate device. Not Populated 0-W 1A R1 1Y 1B Board Reset 1 C1 1A RESET R2 1Y 1B 2 R3 SN74LVC2G86 C2 Dual XOR Gate SN74LVC2G17 Dual Schmitt Buffer Figure 10. RC-Timed Secondary Reset This is possible because each RC load connected to the board reset control signal can output a different rising-edge waveform. With increasing RC load, the resulting control signal will reach the Schmitt buffers’ Vih level at a later point in time. Figure 11 shows the relationship between the board reset signal and the RESET signal produced by the circuit. The blue and green lines represent the voltage as seen by the Schmitt buffers. The output voltage of a charging RC circuit is defined as: Vo = Vi * (1 - e^[-t / RC]) SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 35 Submit Documentation Feedback 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com R1C1 RESET R2C2 Vih Board Reset Figure 11. RESET Signal vs Board Reset Given ideal conditions, a 3.3V board reset signal, and an input buffer Vih of 1.4V, the following set of component values would generate an initial RESET high period (R1C1 region) of approximately 2ms and a RESET low period (R2C2 region) of approximately 0.5ms: • R1 = 36k, C1 = 100nF • R2 = 45k, C2 = 100nF • R3 = 450k When implementing this workaround, some important aspects should be kept in mind: (a) The dual Schmitt buffer is included because the dual XOR gate has an input rise-time requirement that is violated by the RC circuits. (b) The Board Reset signal must meet the XOR gate input rise-time requirement and must provide enough output current to charge the RC circuits to the target Vih level. (c) It is critical for the Vih level of the two input buffers to be very close together so only single-device buffers should be considered for this circuit (such as the 2-in-1 dual Schmitt buffer device used in this example). (d) Variations in the electrical characteristics of the circuit components may produce waveforms that deviate from ideal calculations. (e) The sole purpose of the R3 pull-down resistor is to discharge the RC components before the board reset signal is driven high. Therefore, the value selected for R3 should be sufficiently large enough to not interfere with the RC circuits as they are charging. 36 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications 5 Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 1.1 of the OMAP-L137 device . 5.1 Usage Notes for Silicon Revision 1.1 Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions. Silicon revision 1.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1, Usage Notes for Silicon Revision 3.0. 5.1.1 RTC Standby Power Consumption Is Elevated if the Module Is Not Configured Correctly On Silicon Revision 1.1 and earlier, the RTC module is designed with the ability to keep time while the rest of the device is power cycled off and on. This ability is achieved by placing the RTC in its own power domain and isolating it from the device reset signal. When the CVDD supply is powered down, the RTC_CVDD supply will experience elevated standby power consumption because of leakage between the RTC and core power domains. The RTC module includes circuitry that eliminates the leakage paths between the two domains when the SPLITPOWER bit is set to 1 in the control register (CTRL). The SPLITPOWER bit is a write-only bit that will always read back 0. Therefore, typical read-modify-write sequences should not be used when writing to the CTRL register because the SPLITPOWER bit will be cleared back to 0. Also note that the SPLITPOWER bit has a default value of 0 after RTC module reset, and the only reset available to the RTC module is a software reset, therefore RTC is in an indeterminate state when the RTC_CVDD supply is first powered on. The RTC module should be reset, and the SPLITPOWER bit should be set to 1 before placing the device in a CVDD powered down standby state. The SPLITPOWER bit is permanently set to 1 inside the RTC module beginning with Silicon Revision 2.0 of the device. 5.1.2 SYSCFG: Possible Race Condition When Using KICK Registers On Silicon Revision 1.1 and earlier, when two or more threads are simultaneously accessing the SYSCFG registers, there is the potential for one thread to lock the SYSCFG registers while another thread is still accessing them. There is no hardware semaphore to prevent this from occurring. For example, the race condition can occur in the following situation 1. Thread 1 unlocks the SYSCFG register by writing to the KICK registers 2. An interrupt occurs and Thread 2 unlocks the SYSCFG registers as well 3. Thread 2 finishes and locks the SYSCFG registers 4. Thread 1 is locked out of the SYSCFG registers and is unable to complete its task To prevent the SYSCFG lockout race condition, the application should unlock the SYSCFG registers via the KICK registers and leave them permanently unlocked. Starting with silicon revision 2.0, the KICK registers will be disabled and the SYSCFG registers will be permanently accessible. Writes to the disabled KICK registers will have no effect. 5.2 Silicon Revision 1.1 Known Design Exceptions to Functional Specifications Some silicon revision 1.1 applicable advisories have been found on a later silicon revision. For more details, see • Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications • Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 37 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com • Section 4.2, Silicon Revision 2.0 Known Design Exceptions to Functional Specifications Table 5. Silicon Revision 1.1 Advisory List Title ................................ Page	2.0.20 Intermittent Boot Failures
ARM9	TI	OMAP-L137	The ARM926 subsystem allows data memory regions to be write-back cachable, write- through cachable, or non-cached. On this device revision, the Write-Back mode is not functional; therefore, Write-Through or Non-Cached mode must always be used.	Only the Write-Through or Non-Cached mode can be used. Write-Through mode is preferred for better performance. The cache operation is controlled using the C and B bits in page or section descriptors. For operation in Write-Through mode, the C and B bits (bits 3:2 in the descriptor) must be set to a value of 10b. The following is example code using a section descriptor to create a table entry for the first 1MB of external SDRAM on EMIFB as write-through cachable: LDR r1, SDRAM0_ADDR ; table offset for SDRAM0 region LDR r2, SDRAM0_DATA ; descriptor pattern for SDRAM0 region STR r2, [r0, r1, LSL#2] ; store the table entry at TTB base + table offset * 4 SDRAM0_ADDR .word 0x00000C00 SDRAM0_DATA .word 0xC0000CFA For more information on ARM data cache modes and how to configure them, refer to the ARM926EJ-S™ Technical Reference Manual available at www.arm.com/documentation. Chapter 4 of the ARM926EJ-S™ Technical Reference Manual provides details about cache operations on the ARM926EJ-S processor. Section descriptor: A section descriptor provides the base address of a 1MB block of memory. Figure 12 shows the format of a section descriptor. 31 20 19 12 11 10 9 8 5 4 3 2 1 0 section base address AP SBZ AP Domain 1 C B 1 0 Figure 12. Section Descriptor Table 6 shows the Section Descriptor bit assignments. Table 7 shows the Page Table C and B bit settings for the DCache. Table 6. Section Descriptor Bits BITS DESCRIPTION 31:20 Form the corresponding bits of the physical address for a section. 19:12 Always written as 0. 11:10 Specify the access permissions for this section. 9 Always written as 0. Specify one of the 16 possible domains, held in the domain access control register, that contain the primary 8:5 access controls. 4 Should be written as 1, for backwards compatibility. Indicate if the area of memory mapped by this section is treated as write-back cacheable, write-through 3:2 cacheable, noncached buffered, or noncached nonbuffered. 1:0 These bits must be 10 to indicate a section descriptor SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 39 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Table 7. Page Table C and B Bit Settings for the DCache C BIT B BIT DESCRIPTION ARM926EJ-S BEHAVIOR DCache disabled. Read from external memory. Write as a nonbuffered 0 0 Noncacheable, nonbufferable store(s) to external memory. DCache is not updated. DCache disabled. Read from external memory. Write as a buffered 0 1 Noncacheable, bufferable store(s) to external memory. DCache is not updated. DCache enabled: • Read hit - Read from DCache • Read miss - Linefill 1 0 Write-through • Write hit - Write to the DCache, and buffered store to external memory • Write miss - Buffered store to external memory DCache enabled: • Read hit - Read from DCache 1 1 Write-back • Read miss - Linefill • Write hit - Write to the DCache only • Write miss - Buffered store to external memory 40 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications	1.1.1 ARM Data Cache in Write-Back Mode Is Not Functional: Must Use Write-Through or Non-Cached Mode
ARM9	TI	OMAP-L137	When an endpoint is enabled for receive transfer(s) that will be serviced via DMA and data has been received prior to allocating DMA resource, the DMA will generate a starvation interrupt to notify the application a lack of resource (starvation) in anticipation that the application will furnish the required resource. The CPPI DMA is supposed to generate a single interrupt. But, in this case it continues generating interrupt periodically, until application furnishes a resource. In some use cases, it has been observed that the application may desire to differ the time as to when to service the starvation request due to the CPU handling other urgent task(s). Since the DMA keeps on generating the starvation interrupt periodically and there exists no capability to mask the starvation interrupt at the USB controller level, the CPU is forced either to fully service the DMA interrupt as it is received or disable all USB interrupt at the CPU level. Disabling the entire USB interrupt might not be the desired option since the CPU needs to be aware of other USB interrupts that are more critical.	The user can remove the associated channel number entry from the DMA scheduler Tables (scheduler array) for that endpoint when not expecting data from a host. Whenever data transfer is initiated by the host, the endpoint interrupt will be generated by the USB controller, which can be used as an indication for an application to secure required resources prior to adding the DMA channel entry for the endpoint onto the scheduler array. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 41 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	1.1.2 USB0: CPPI Receive Starvation Interrupt
ARM9	TI	OMAP-L137	When the SPI is in master mode, the generated SPICLK signal is derived from the internal SPI module clock. This SPICLK signal duty cycle is not 50% when the SPIFMTn.PRESCALE is set to an even number. With an even prescale value, the falling edge of the SPICLK is delayed 1-2 ns regardless of the SPICLK frequency. Therefore, the high side is wider than the low side.	Use the SPIFMTn.PRESCALE with an odd value if possible. 42 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications	1.1.3 SPI: Internally Generated SPI Clock Is Not 50% Duty Cycle
ARM9	TI	OMAP-L137	Note: DMA refers to all non-CPU requests. SDMA refers to external system DMA master requests handled via the Slave Direct Memory Access port. The C674x Megamodule uses a two-way set associative cache for L1D. This means that every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on the L1D cache architecture. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by the application. An L1D cache-line corruption event occurs when all of the following conditions are met: 1. L1D cache evicts a dirty line (Line A) while allocating a new line (Line B) in the same set/way (cache Lines A and B consist of 64-bytes each). In order for this to happen, the following will have taken place: (a) Line A was previously read by CPU because L1D is a read-allocate cache, (b) Line A is dirty because its value was modified by CPU, and (c) Line B is read by CPU 2. Both Line A and Line B are associated with L2 RAM, and 3. While the original L1D victim write-back from condition (1) is in progress, the SDMA performs both: (a) a read or write operation to Line A in L2 RAM and (b) a write operation to Line B in L2 RAM. If all of the above conditions are met, the L2 RAM data associated with the Line A victim writeback will become corrupt. Additionally, the Line B data originating from the SDMA write will also become corrupt in L1D cache. Figure 13 shows an example scenario of L1D cache and L2 RAM corruption. Line A and Line B Map to LINE A same L1D Cache line. INITIAL STEP 1 STEP 2 STEP 3 STATE C674x Megamodule LINE B C674x CPU CPU Request Request L2 C674x CPU EXTERNAL Activity Line B Pending Controller L2 SRAM SDMA SDMA Requests Activity Writes to both LineA and LineB L1D EMC L1D Cache Dirty Line A Dirty Line A IN-FLUX Corrupt Controller SDMA PORT EDMA SYSTEMMASTERS Line Status in L1D Cache in L1D Cache Line A Old Data Old Data Old Data Corrupt L2 SRAM Line B tries to replace EMAC CACHE LINE Line B Old Data Old Data Old Data NEW DATA Dirty Line A in the L1D L2 SRAM Cache L1D CACHE Corruption happens because of this state TIME LINE SYSTEM VIEW Figure 13. Example of L1D Cache and L2 RAM Corruption SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 43 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	Method 1 In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial segments which overlap into the same L1D cache line. /** Pseudo code only **/ Uint8 *SDMA_BUFF, *CPU_BUFF; /* 64-byte aligned allocation Option 1 */ SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 ); CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 ); SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 ); CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 ); /* 64-byte aligned allocation Option 2 with BIOS Call */ SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 ); CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 ); Method 2 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations after CPU writes. With this method, the semaphore ensures that there is clear ownership of the buffer between CPU and SDMA, and the CPU manages cache coherence by using explicit cache writeback operations. /** Pseudo code only **/ /* Example with EDMA as the external master */ EDMA_ISR() { /* EDMA releases ownership of buffer */ SEM_post(SyncSemaphore); return; } main() { while(COND) { /* CPU waits for ownership of buffer */ SEM_pend(SyncSemaphore); /**********************/ /*** CPU Processing ***/ /**********************/ /* Cache writeback for shared block */ /* Buffer must be 64-byte aligned */ BCACHE_wbInv( blockPtr, blockSize, WAIT ); /* Initiate EDMA */ EDMA_Event_Generate(); } } Method 3 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM or L3 RAM instead of L2 RAM. Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or L3 RAM instead of L2 RAM. Method 5 Do not configure L1D memory as cache - use the entire address space as RAM. 44 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications	1.1.5 Under Specific Conditions, SDMA Activity Can Corrupt the L1D Cache and L2 RAM
ARM9	TI	OMAP-L137	USB 1.1 requires a 15 KΩ pull down on the DP/DM lines. The USB 1.1 Phy does not include the internal pull down.	The 15 KΩ pull downs should be added to the DP/DM lines externally to the device. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 45 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	1.1.8 USB 1.1 Phy Does Not Have Internal Pull Down on DP/DM Lines Enabled
ARM9	TI	OMAP-L137	There is the potential for the 1.8V and 3.3V USB power supplies to experience a latchup condition. The potential for latchup on these supplies is related to the power-on voltage slew rate and the likelihood for latchup with a rapid voltage supply slew rate gradually increases over the device lifetime.	To prevent a latch up condition from occurring over the life of the device, the following recommendations should be followed: • USB0_VDDA18 and USB1_VDDA18 power supply rails must have greater than 1ms (10%-90%) slew • USB0_VDDA33 and USB1_VDDA33 power supply rails must have less than 100-mv pk-pk noise • USB0_VBUS power supply rail must have less than 100-mv pk-pk noise sustained and must have greater than 1ms (10%-90%) slew 46 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications	1.1.9 USB2.0 (USB0) and USB1.1 (USB1) Power Supply
ARM9	TI	OMAP-L137	The timing parameters in Table 8 and Table 9 differ from those specified in the OMAP-L137 C6000 DSP+ARM Processor data manual (literature number SPRS563 or later). Table 8 list the AC timing parameters that should be used on silicon revision 1.1 and earlier.	During PCB board design and layout, the AC timings specified in Table 8 and Table 9 should be considered when designing interfaces to the EMIFB. Table 8. Timing requirements Over Recommended Operating Conditions NO. PARAMETER MIN MAX UNIT Input setup time, read data valid on EMB_D[ 31 19 t 1.26 ns su(DV-CLKH) :0] before EMB_CLK rising For the parameter t , Table 9 and Table 10 are valid under the conditions OH(CLKH-DQMIV) described in their respective notes: Table 9. Switching Characteristics Over Recommended Operating Conditions NO. PARAMETER MIN MAX UNIT Output hold time, EMB_CLK rising to 6 t 0.8(1) (2) ns OH(CLKH-DQMIV) EMB_WE_DQM[3:2] invalid (1) This timing requires CVDD = 1.15V ± 1% and DVDD = 3.3V ± 2%. (2) This timing parameter ONLY applies to the signals EMB_WE_DQM[3:2]; EMB_WE_DQM [1:0] timings are as shown in the device data manual. Table 10. Switching Characteristics Over Recommended Operating Conditions NO. PARAMETER MIN MAX UNIT Output hold time, EMB_CLK rising to 6 t 0.7(1) (2) ns OH(CLKH-DQMIV) EMB_WE_DQM[3:2] invalid (1) This timing requires CVDD= 1.2V +/- 1% and DVDD= 3.3V +/- 2%. (2) This timing parameter ONLY applies to the signals EMB_WE_DQM[3:2]; EMB_WE_DQM [1:0] timings are as shown in the device data manual. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 47 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	1.1.10 EMIFB: AC Timings Differ From Data Manual Specifications
ARM9	TI	OMAP-L137	Details	Workaround(s)	1.1.11 Electrostatic Discharge Charged-Device Model Performance
ARM9	TI	OMAP-L137	The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven at or below 0.4V to limit impact on AC timings. The timing effect on the input buffers is dependent on the Vil level: • Case 1: For signals driven with Vil < = 0.2V, the input timings will be unaffected. • For signals driven with 0.2V < Vil < = 0.4V, there may be as much as 0.5 ns degradation to input timings. This issue applies only to 3.3V LVCMOS inputs or IOs used as inputs. Signals operated at 1.8V are not affected.	Although there is no specific workaround, the following recommendations can be used to help prevent this issue: • Minimize loads as much as possible, especially DC loads that could cause the Vil to rise. Point-to-point (single-load) connections are unlikely to be affected. • Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 49 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	1.1.16 Vil on 3.3V LVCMOS Input Buffers
ARM9	TI	OMAP-L137	Note: This advisory is not applicable if DSP L2 memory is configured as 100% cache or L2 RAM is not accessed by IDMA or SDMA during run-time. The C674x Megamodule has a Master Direct Memory Access (MDMA) bus interface and a Slave Direct Memory Access (SDMA) bus interface. The MDMA interface provides DSP access to resources outside the C674x Megamodule. The MDMA interface is typically used for CPU/cache accesses to memory beyond the Level 2 (L2) memory level. These accesses include cache line allocates, write-backs, and non-cacheable loads and stores to/from system memories. The cacheable memories external to the C674x Megamodule are listed in Table 11. Table 11. Cacheable External Memory Resources External Memory Address Range Shared Ram 0x8000 0000 – 0x8001 FFFF EMIFA 0x4000 0000 – 0x67FF FFFF EMIFB 0xC000 0000 – 0xCFFF FFFF The SDMA interface allows other DMA master peripherals (listed in Table 12 ) to access Level 1 Data (L1D), Level 1 Program (L1P), and L2 RAM DSP memories. Table 12. DMA Master Peripherals Peripheral Group EDMA TC0 RD A EDMA TC0 WR B EDMA TC1 RD C EDMA TC1 WR D EMAC E USB1 E USB0 F UHPI F ARM G The C674x Megamodule has an L1D cache and L2 cache both implementing write-back data caches– it keeps updated values for external memory in cache for as long as possible. It writes these updated values, called "victims", to external memory when it needs to make room for new data or when requested to do so by the application. The L1D sends its victims to L2. The caching architecture has pipelining, meaning multiple requests could be pending between L1, L2, and MDMA. For more details on the C674x Megamodule and its MDMA and SDMA ports, see the TMS320C674x Megamodule Reference Guide (literature number SPRUFK5). Ideally, the MDMA (dashed-dotted line in Figure 14) and SDMA/IDMA paths (dashed lines in Figure 14) operate independently with minimal interference. Normally MDMA accesses may stall for extended periods of time due to expected system level delays (for example, bandwidth limitations). However, when using L2 as RAM, SDMA and IDMA accesses to L2/L1 may experience unexpected stalling in addition to the normal stalls seen by the MDMA interface. For latency-sensitive traffic, the SDMA stall can result in missing real-time deadlines. In a more severe case, the SDMA stall can produce a deadlock condition in the device. An IDMA stall cannot produce a deadlock condition. 50 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications Note: SDMA/IDMA accesses to L1P/D will not experience an unexpected stall if there are no SDMA/IDMA accesses to L2. Unexpected SDMA/IDMA stalls to L1 happen only when they are pipelined behind L2 accesses. Additionally, the deadlock scenario will be avoided if there are no SDMA accesses to L2. Figure 14 is provided for illustrative purposes and is incomplete because of simplification. The IDMA/SDMA (dashed-lines) path could also go to L1D/L1P memories, and IDMA can go to DSP CFG peripherals. MDMA transactions can originate also from L1P or L1D through the L2 controller or directly from DSP). 32K bytes 256K bytes 1M bytes L1P RAM/ L2 RAM L2 ROM cache 256 256 256 256 Cache control Cache control Memory protect L1P Memory protect L2 Bandwidth Mgmt Bandwidth Mgmt 256 256 256 Instruction fetch 256 Power down C674x Interrupt Fixed/floating point CPU Controller Register Register IDMA file A file B 64 64 256 CFG Bandwidth Mgmt 32 Configuration EMC Memory protect L1D peripherals Cache control bus MDMA SDMA 8x32 64 64 64 64 32K bytes High performance L1D RAM/ switch fabric SDMA/IDMA Paths cache (SCR1) MDMA Path Figure 14. C674x Megamodule The duration of the SDMA/IDMA stalls depend on the quantity/characteristics of the L1/L2 cache and the MDMA traffic in the system. Therefore, it is difficult to predict if stalling will occur and for how long. IDMA/SDMA stalling and any system impact is most likely in systems with excessive context switching, L1/L2 cache miss/victim traffic, and heavy access to external memory. Use the following procedure to determine if SDMA/IDMA stalling is the cause of real-time deadline misses for existing applications. Situations where real-time deadlines may be missed include loss of McASP samples and poor peripheral throughput. 1. Determine if the transfer that is missing the real-time deadline is accessing L2 or L1D memory. If not, then SDMA/IDMA stalling is not the source of the real-time deadline miss. 2. Identify all SDMA transfers to/from L2 memory (for example, EDMA transfer to/from L2 from/to a UART, HPI block transfer to/from L2). If there are no SDMA transfers to/from L2, then SDMA/IDMA stalling is not the source of the problem. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 51 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 3. Redirect all SDMA transfers to L2 memory to other memories using one of the following methods: (a) Temporarily transfer all the L2 SDMA transfers to L1D SRAM. (b) If not all L2 SDMA transfers can be moved to L1D memory, temporarily direct some of the transfers to memory in Table 1 and keep the rest in L1D memory. There should be no L2 SDMA transfers. If real-time deadline misses are solved using any of the options in Step 3, then IDMA/SDMA stalling is likely the source of the problem. A deadlock situation may arise if the following sequence of events occurs: Step 1: A DMA master from any group (listed in Table 12) issues a write command to the DSP’s SDMA, and a DMA master from the same group issues a subsequent write command to cacheable memory outside of the C674x Megamodule (listed in Table 1). All write commands pass through Switched Central Resource 1 (SCR1). For more details on SCRs, see the device Technical Reference Guide SPRUH93. Step 2: The DSP’s SDMA asserts itself as not ready and is unable to accept the write data from Step 1, and a cache line writeback is initiated from DSP memory to the same cacheable memory from Step 1. The cache line writeback command also passes through SCR1. With the above scenario, it is possible for SCR1 to order the write commands from Step 1 in front of the write commands from Step 2. Due to the MDMA/SDMA blocking behavior, the SDMA commands from Step 2 will be waiting for the MDMA traffic from Step 1 to finish, resulting in a deadlock situation at SCR1. Figure 15 is provided for illustrative purposes and is incomplete because of simplification. DMA Group A C674x SDMA (L2/L1D) DMA Group B SCR1 DMA Group xx Cacheable Memory C674x MDMA Figure 15. SCR1 System Interconnect	Entirely eliminate IDMA/SDMA stalling and potential for a deadlock condition using one of the following two methods: 1. Configure the entire L2 RAM as 100% cache (for example, move all data buffers from L2 to L1D or other memory). Note: Some throughput degradation is expected when the buffers are moved out to external memo 2. Eliminate all IDMA/SDMA access to L2 RAM when IDMA/SDMA stalling would have an impact by performing one of the following: (a) Constrain each DMA master group to perform writes to either DSP memory space or external memory space, but not to both, or 52 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 SPRZ291I – October 2008 – Revised June 2014 Submit Documentation Feedback 1.1 Usage Notes and Known Design Exceptions to Functional Specifications (b) Force each DMA master group to complete pending write commands to either DSP memory space or cacheable memory space before initiating writes to a different destination. Pending write commands from DMA masters are forced to complete when the DMA master initiates a read from the same destination memory. Note that in the case of off-chip memory, a read command only forces the completion of write commands within a 2KB-aligned window. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 53 Submit Documentation Feedback 1.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 6 Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 1.0 of the OMAP-L137 device. 6.1 Usage Notes for Silicon Revision 1.0 Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions. Silicon revision 1.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 4.1, Usage Notes for Silicon Revision 3.0 and see Section 5.1, Usage Notes for Silicon Revision 1.1. 6.2 Silicon Revision 1.0 Known Design Exceptions to Functional Specifications Some silicon revision 1.0 applicable advisories have been found on a later silicon revision. For more details, see • Section 2.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications • Section 3.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications • Section 4.2, Silicon Revision 2.0 Known Design Exceptions to Functional Specifications • Section 5.2, Silicon Revision 1.1 Known Design Exceptions to Functional Specifications Table 13. Silicon Revision 1.0 Advisory List Title ................................ Page	1.1.17 DSP SDMA/IDMA: Unexpected Stalling and Potential Deadlock Condition
ARM9	TI	OMAP-L137	There is a potential SPI communication failure on data receipt. When the communication failure occurs, the data received in the SPIBUF register is not correct. The data error pattern is not consistent between failures. The failure impacts both master and slave mode. This issue is caused by un-matched delays between the clock and data paths of the shift register. The non-matched delays cause the clock edge to be detected earlier than the appropriate data. This results in inconsistent/incorrect receive data being copied into the SPIBUF register.	There is no recommended workaround. Adjusting the following settings may allow you to find a working region: • Adjust the SPI settings of prescale, phase, and polarity • Increase the core VDD to a range between 1.25V and 1.32V • Decrease the CPU operating frequency Increasing the core VDD or slowing down the CPU operating frequency is ideal to work across a variety of conditions. Although the adjustments recommended above may be used to find a working setup and allow further development to take place, these adjustments cannot be guaranteed to alleviate the issue across devices, hardware platforms, and temperature. SPRZ291I – October 2008 – Revised June 2014 OMAP-L137 Silicon Revisions 3.0, 2.1, 2.0, 1.1, and 1.0 55 Submit Documentation Feedback Copyright © 2008–2014, Texas Instruments Incorporated	1.0.12 SPI Communication Failure for Data Receipt
ARM9	TI	OMAP-L138	Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port. The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests. Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of successive CPU requests, it is possible for the CPU to block all DMA requests until CPU traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 3 shows a high level diagram of the arbitration scheme used for L2 RAM requests. C674x Megamodule EDMA SHAREDRESOURCE ExternalSystemMasters Programmable Priority ARBITRA MasterPriority C674x CPU EMAC ARBITRA Programmable Priority IDMA L2 RAM TION LCDC Inherit TION Priority SDMA UHPI USB Highest Priority Master Granted Access. Contention counters implemented to not starve low priority requestors Figure 3. Priority Arbitration Scheme for L2 RAM	Configure DMA and CPU requests to different priority levels. There is no penalty for setting the IDMA and SDMA priorities equal to each other. CPU request priority is programmed within the CPUARBU register: /** Pseudo code only **/ Uint32 *CPUARBU; CPUARBU = ( Uint32 * ) ( 0x01841000 ); /* Set priority different from IDMA/SDMA */ *CPUARBU = [CPU_PRIORITY]; SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 9 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com IDMA request priority is programmed within the IDMA1_COUNT register /** Pseudo code only **/ Uint32 *IDMA1_SRC, *IDMA1_DST; Uint32 *IDMA1_CNT; IDMA1_SRC = ( Uint32 * ) ( 0x01820108 ); IDMA1_DST = ( Uint32 * ) ( 0x0182010C ); IDMA1_CNT = ( Uint32 * ) ( 0x01820110 ); *IDMA1_SRC = sourceAddress; *IDMA1_DST = destinationAddress; /* Set IDMA priority different from CPU */ *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ; SDMA request priority is inherited from the MSTPRIn registers /** Pseudo code only **/ Uint32 *MSTPRI1, *MSTPRI2; MSTPRI1 = ( Uint32 * ) ( 0x01C14114 ); MSTPRI2 = ( Uint32 * ) ( 0x01C14118 ); /* Set SDMA master priorities different from CPU */ *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT]; *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT]; 10 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.1 DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities Are Equal
ARM9	TI	OMAP-L138	When the USB controller is operating as a device and an attached host resets the device after the completion of the Device Attached state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.	Software must service every USB RESET interrupt received. Software should not proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 11 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.3 USB0: Extraneous RESET Interrupt
ARM9	TI	OMAP-L138	In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT input does not go inactive within maximum extended wait cycles programmed in the Async Wait Cycle Config register, the EMIF will report a time-out error. The data returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out error but with the correct data for the MMR read. The EMIF will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is performed. This issue is only applicable if all of the following are true: • The EMIF is used for asynchronous memory accesses in Extended Wait mode. • There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input. • If asynchronous memory read with time-out error is followed by an MMR read.	If a time-out occurs, perform any of the following: • A dummy read to another asynchronous memory chip select that is not configured to be in Extended Wait mode. • A dummy read to the same asynchronous memory chip select after disabling the Extended Wait mode on that chip select. • A dummy read to SDRAM 12 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.4 EMIFA: Asynchronous Memory Timeout Error Persistence
ARM9	TI	OMAP-L138	The C674x DSP megamodule supports twelve maskable hardware interrupt signals (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a CPUINTn hardware interrupt, or multiple system interrupts may be combined by the ECM into a single signal before mapping to a CPUINTn interrupt. See [SPRUFK5; TMS320C674x DSP Megamodule] for more information on how DSP interrupts are handled. The ECM expects all incoming interrupts to be pulse interrupts, however the [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.	The CPUINTn hardware interrupts can support both pulse and level interrupts so CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts. Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 13 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.5 A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event Combiner Module (ECM)
ARM9	TI	OMAP-L138	When a soft reset is invoked by setting the RESET bit of the USB CTRLR register ( CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists. USB resets initiated by system-reset and power-on-reset are immune from the timing violation. There is no plan to fix this issue in future silicon revisions because: 1. No functional problems have been observed to date 2. A software workaround has been developed to avoid the problem	The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below: 1. Enable the USB controller module clock through the Power and Sleep Controller (PSC) 2. Perform a soft USB reset 3. Wait for the USB soft reset bit to clear 4. Disable the USB controller module clock through the PSC 5. Configure the USB PHY parameters 6. Enable the PHY 7. Enable the USB controller module clock through the PSC 14 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.6 Potential USB2.0 Soft Reset Timing Violation
ARM9	TI	OMAP-L138	The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven to 0.5V or below on all dual-voltage LVCMOS input signals (signals associated with supplies DVDD1833_A, DVDD1833_B or DVDD1833_C). Vil driven at or below 0.4V will cause no timing degradation. Vil driven up to 0.5V will cause up to 750 ps degradation in input timings. The following datasheet parameters will be affected by Vil driven up to 0.5V. Their values adjusted for 0.75 ns degradation are shown. Table 3. Timing Requirements for the EMIFA SDRAM Interface 1.2V NO. PARAMETER UNIT MIN MAX Input Setup time, read data valid on 19 t 2.75 ns su(EMA_DV-EM_CLKH) EMA_D[31:0] Table 4. Timing Requirements for the EMIFA Asynchronous Memory Interface 1.2V NO. PARAMETER UNIT MIN MAX Setup time, EMA_D[31:0] valid before EMA_OE 12 t 3.75 ns su(EMDV-EMOEH) high Table 5. Timing Requirements for McASP0 1.2V NO. PARAMETER UNIT MIN MAX AHCLKR/X ext input 1.15 Hold time, AFSR/X input after ACLKR/X 6 th(ACLKRX-AFSRX) (1) AHCLKR/X ext output 1.15 ns AHCLKR/X ext input 1.15 Hold time, AXR0[n] input after 8 th(ACLKRX-AXR) ACLKR/X (1) (2) AHCLKR/X ext output 1.15 (1) McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0 (2) McASP0 ACLKXCTL.ASYNC=0: Receiver is clocked by transmitter's ACLKX0 Table 6. Switching Characteristics for McASP0 1.2V NO. PARAMETER UNIT MIN MAX ACLKR/X ext input 3.5 Delay time, ACLKR/X transmit edge to 13 td(ACLKRX-AFSRX) AFSX/R output valid (1) ACLKR/X ext output 3.5 ACLKR/X ext input 3.5 Delay time, ACLKX transmit edge to 14 td(ACLKX-AXRV) ns AXR output valid (1) ACLKR/X ext output 3.5 Disable time, ACLKR/X transmit edge 15 t to AXR high impedance following last ACLKR/X ext 3.5 dis(ACLKX-AXRHZ) data bit (1) McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0 SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 15 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Table 7. Timing Requirements for McBSP0 1.2V NO. PARAMETER UNIT MIN MAX Setup time, external FSR high before 5 t CLKR ext 5.5 su(FRH-CKRL) CLKR low 7 t Setup time, DR valid before CLKR low CLKR ext 5.5 ns su(DRV-CKRL) Setup time, external FSX high before 10 t CLKR ext 5.5 su(FXH-CKXL) CLKX low Table 8. Switching Characteristics for McBSP0 1.2V NO. PARAMETER UNIT MIN MAX Delay time, CLKR high to internal FSR 4 t CLKR ext 2.75 d(CKRH-FRV) valid Delay time, CLKX high to internal FSX 9 t CLKR ext 2.75 ns d(CKXH-FXV) valid 2.75 + D1 13 t Delay time, CLKX high to DX valid CLKR ext d(CKXH-DXV) (1) (1) Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR. If DXENA = 0, then D1 = D2 = 0 If DXENA = 1, then D1 = 6P, D2 = 12P Table 9. Switching Characteristics for McBSP1 1.2V NO. PARAMETER UNIT MIN MAX Delay time, CLKR high to internal FSR 4 t CLKR ext 3.25 d(CKRH-FRV) valid Delay time, CLKX high to internal FSX 9 t CLKR ext 3.25 ns d(CKXH-FXV) valid 3.25 + D1 13 t Delay time, CLKX high to DX valid CLKR ext d(CKXH-DXV) (1) (1) Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR. If DXENA = 0, then D1 = D2 = 0 If DXENA = 1, then D1 = 6P, D2 = 12P Table 10. Timing Requirements for Universal Parallel Port (uPP) 1.2V NO. PARAMETER UNIT MIN MAX Setup time, CHn_START valid before CHn_CLK 4 t 4.75 su(STV-INCLKH) high Setup time, CHn_ENABLE valid before CHn_CLK 6 t 4.75 su(ENV-INCLKH) high Setup time, CHn_DATA/XDATA valid before 8 t 4.75 ns su(DV-INCLKH) CHn_CLK high Setup time, CHn_DATA/XDATA valid before 10 t 4.75 su(DV-INCLKL) CHn_CLK low Setup time, CHn_WAIT valid before CHn_CLK 19 t 4.75 su(WTV-INCLKL) high 16 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 11. Timing Requirements for Video Port Interface (VPIF) 1.2V NO. PARAMETER UNIT MIN MAX Setup time, VP_DINx valid before VP_CLKIN0/1 1 t 4.75 ns su(VDINV-VKIH) high	Although there is no specific workaround, the following recommendations can be used to help prevent this issue: • Minimize loads as much as possible, especially DC loads that could cause the Vil to rise. Point-to-point (single-load) connections are unlikely to be affected. • Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 17 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.9 Vil on Dual-Voltage LVCMOS Input Buffers Operated at 3.3V
ARM9	TI	OMAP-L138	The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).	The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller. 18 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.10 ARM Interrupt Controller Vector Size Register (VSR) Initialization
ARM9	TI	OMAP-L138	Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device System Reference Guide for additional information about the AINTC. The AINTC module expects all incoming interrupts to be pulse interrupts, however the [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected. If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.	Method 1 Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts. /** Pseudo code only **/ void CHIPINT0_ISR(void) { /* Exit immediately if CHIPSIG0 is not set */ if( (SYSCFG->CHIPSIG & 0x1) == 0 ) { return; } /* Intended service routine code */ SYSCFG->CHIPSIG_CLR = 0x1; printf("Hello World!\n"); } SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 19 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Method 2 Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been cleared. This method will eliminate false interrupts, but requires changes to the AINTC interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application. /** Pseudo code only **/ /* Sequence that is susceptible to false CHIPINTn interrupts */ void AINTC_ISR_DISPATCH_1(void) { Get_Interrupt_Information(); /* CHIPINTn interrupts continue to be generated after */ /* AINTC CHIPINTn flag is cleared. */ Clear_AINTC_Interrupt_Flag(); /* CHIPINTn interrupts are only stopped after ISR clears */ /* the status flag. */ Branch_To_ISR(); } /* Sequence that is not susceptible to false CHIPINTn interrupts */ void AINTC_ISR_DISPATCH_2(void) { Get_Interrupt_Information(); /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */ /* interrupts to AINTC. */ Branch_To_ISR(); /* Ok to clear AINTC CHIPINTn flag now. */ Clear_AINTC_Interrupt_Flag(); } 20 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.12 A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC
ARM9	TI	OMAP-L138	The C674x CPU supports a Saturation feature for key arithmetic operations. If an operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit. In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit. All of the following must take place in order for an application to be affected by this advisory: 1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued simultaneously 2. Both instructions are processed on the same side 3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle 4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction 5. The application checks for the saturation flag and uses the saturation result of the 4 cycle instruction	Perform one of the following: • For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together. • Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit instructions. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 21 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.13 Incorrect Masking of the C674x CSR:SAT Bit
ARM9	TI	OMAP-L138	Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 4). SDMA requests are defined as external system bus master requests handled via this port. The C674x Megamodule uses a two-way set associative cache for L1D. This means that every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide (Literature Number SPRUFK5) for more information on the L1D cache architecture and related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software. An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 4): 1. L1D cache Lines 1, 2, and 3 have the following characteristics: • Line 1 is associated with L2 SRAM (Line A in Figure 4), was previously read by CPU, and is clean. (CPU has not updated the data.) • Line 2 is associated with L2 SRAM (Line B in Figure 4), was previously read by CPU, and is clean. (CPU has not updated the data.) • Line 3 was previously read by the CPU and may be either clean or dirty. 2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D cache Lines 1 and 2. 3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes, the CPU performs two reads within the same clock cycle: • Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in L1D Cache, which also has a snoop write pending for the updated Line B content. • Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache. 4. When the snoop write operation completes, Line 2 in L1D cache now contains the updated L2 SRAM Line B data instead of the L2 cache Line E data. The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data. 22 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Time Line System View Line A Line E and Line B Map to STEP 1 STEP 2 STEP 3 STEP 4 same L1D Cache line. Line A B C674x subsystem Line A C C6xCPU Read Line D L2 Line A D Activity Read Line E C6X CPU Controller L2 SRAM SDMA Write Line A Snoop Write Line A E Activity Write Line B Initiated L1D EMC L2 CACHE L1D Cache Clean Line A Clean Line A IN FLUX Clean Line A Controller SDMA PORT Line 1 (New Data) L1D Cache Clean Line B Clean Line B IN FLUX CORRUPT EMAC Line 2 Line E replaces Line B due Line Line 1 A [A] PRU L1D Cache Clean/Dirty Clean/Dirty IN FLUX Clean Line D to CPU read. Line 3 Line C Line C Line Line 2 A [B/E] Delayed snoop wrtie to Line EDMA SYSTEMMASTERS Line Line 3 A [C/D] B corrupts Line E in L1D$ L1D Corruption happens CACHE UHPI because of this state EXTERNAL Figure 4. Example of L1D Cache Corruption	Method 1: Do not perform two CPU read operations in the same clock cycle. For C code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000 Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the -- c64p_dma_l1d_workaround flag will only issue a warning. Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial segments which overlap into the same L1D cache line. /** Pseudo code only **/ Uint8 *SDMA_BUFF, *CPU_BUFF; /* 64-byte aligned allocation Option 1 */ SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 ); CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 ); SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 ); CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 ); /* 64-byte aligned allocation Option 2 with BIOS Call */ SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 ); CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 ); SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 23 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if there are CPU writes. With this method, the semaphore ensures that there is clear ownership of the buffer between CPU and SDMA, and the CPU manages cache coherence by using explicit cache writeback operations. /** Pseudo code only **/ /* Example with EDMA as the external master */ EDMA_ISR() { /* EDMA releases ownership of buffer */ SEM_post(SyncSemaphore); return; } main() { while(COND) { /* CPU waits for ownership of buffer */ SEM_pend(SyncSemaphore); /**********************/ /*** CPU Processing ***/ /**********************/ /* Cache writeback for shared block */ /* Buffer must be 64-byte aligned */ BCACHE_wbInv( blockPtr, blockSize, WAIT ); /* Initiate EDMA */ EDMA_Event_Generate(); } } Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or Shared RAM instead of L2 RAM. Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM or Shared RAM instead of L2 RAM. Method 6 Configure the entire L2 RAM as normal SRAM (no cache). Method 7 Configure the entire L1D RAM as normal SRAM (no cache). 24 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.17 SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/Cache/SRAM
ARM9	TI	OMAP-L138	A condition can occur during the device power supply ramp in which the DVDD18 supply, which should be at 1.8V nominal, can be pulled up on-chip by the DVDD3318_A, DVDD3318_B or DVDD3318_C supplies operated at 3.3V. For the sake of this description, DVDD3318_x means any combination of DVDD3318_A, DVDD3318_B or DVDD3318_C. Important Note: The 3.3V DVDD3318_x supplies must not be driven to 0V during zones A – E or high current capable of damaging the device may occur. The 3.3V DVDD3318_x supplies should not be driven during this time. A normal example power-supply ramp is shown below: A B C D E F G 3.3V VT 1.8V 1.2V Figure 5. Normal power-supply ramp • A. All device supplies are undriven • B. The 1.2V supplies are ramped to their nominal levels • C. Potential delay between supply ramps (not required) • D. The 1.8V supplies (specifically DVDD18) are ramped to their nominal levels. During the DVDD18 ramp there will be some minor drift up in the undriven DVDD3318_x supplies. This is normal and is not a problem. • E. Potential delay between supply ramps (not required) • F. DVDD3318_x is ramping but is less than DVDD18 + VT • G. DVDD3318_x is ramping but is greater than DVDD18 + VT When the fault condition occurs, the supplies behave as shown below: A B C D E F G 3.3V ~2.7V VT 1.2V Figure 6. Faulty power-supply ramp The behavior is the same until zone G. When the DVDD3318_x supply exceeds DVDD18 by a transistor V , the DVDD18 supply begins to be pulled up by the T DVDD3318_x supply and follows the DVDD3318_x supply by DVDD3318_x- V . Since T the DVDD18 supply is often connected to other 1.8V supplies in the design, these other supplies can be pulled up also. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 25 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com The condition occurs because the dual-voltage IO buffers have voltage detection circuitry that monitors DVDD3318_x during reset and determines whether the applied supply voltage is 1.8V or 3.3V. This detection circuitry then configures the IOs to operate at the appropriate voltage. As the DVDD3318_x supply ramps, there is a small range near DVDD18 + V where the voltage detection circuit finds the state indeterminate and briefly T turns on circuitry associated with both voltage options creating a current path between them. This current path can cause the DVDD18 supply to be pulled up. The mechanism for this behavior is explained below: DVDD3318_x Dual-Voltage IO Buffer Behavior of the IO buffer during Zone F: As the DVDD3318_x supply ramps, but is not yet one V above the T DVDD18 supply, the comparator enables the 1.8V mode logic 3.3V Mode section and disables the 3.3V mode logic section. No unexpected Enable Logic + current flows between the two sections. DVDD18 - 1.8V Mode Enable Logic Iload External Loads Figure 7. Behavior of the IO buffer during Zone F DVDD3318_x Dual-Voltage IO Buffer Error State of the IO buffer during Zone G: As DVDD3318_x exceeds DVDD18+V , some of the circuitry T across the boundary of the two voltage domains will turn on and 3.3V Mode DVDD18 Enable causes a leakage current (in red) to flow between the two voltage Logic + domains. This current pulls up the DVDD18 supply unless the Ileakage power source providing that supply can oppose it or unless the - load current is strong enough to counteract it. Enable 1.8V Mode Logic If DVDD18 continues to rise as DVDD3318_x ramps, the I comparator never sees enough difference between the two load supplies to switch to 3.3V mode. External Loads Figure 8. Error State of the IO buffer during Zone G DVDD3318_x Dual-Voltage IO Buffer Recovered State of the IO buffer during Zone G: If the load current is high enough or the DVDD18 power supply can oppose the leakage current, then the DVDD18 voltage stays low 3.3V Mode enough for: Enable Logic + DVDD18 • the comparator to recognize 3.3V mode • the 1.8V mode logic is turned off - 1.8V Mode • the leakage stops Enable Logic Iload External Loads Figure 9. Recovered State of the IO buffer during Zone G 26 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications This error condition may occur when either of the following conditions are present: • The regulator used to control the DVDD18 supply can only regulate voltage up and relies on the load to pull the output voltage down • There is low load on the DVDD18 supply during the DVDD3318_x power supply ramp This condition will not occur in designs where: • All DVDD3318_x supplies are operated at 1.8V, or • The regulator used to supply DVDD18 has the capability to actively regulate (drive) its output voltage up or down and doesn’t rely on system load to pull the voltage down, or • The load on the DVDD18 supply during the DVDD3318_x power supply ramp is sufficient to oppose the leakage current.	1. Design simulation has indicated that under the worst-case process/voltage/temperature conditions the maximum leakage current into the DVDD18 supply due to this phenomenon will be 140 mA (the 140 mA is a cumulative current generated by all of the dual-voltage IOs). So this error state can be prevented by ensuring that the load on the DVDD18 supply during the DVDD13318_x supply ramp exceeds 140 mA. This can be achieved by any combination of the following as long as they cumulatively produce >140 mA load on DVDD18 during the DVDD3318_x ramp period: (a) Maintain sufficient bulk capacitance on the DVDD18 supply such that the charging current for these capacitors provides all or part of the required >140 mA. Bulk capacitance in this context means the total capacitance seen by the DVDD18 supply (filter capacitors, bypass capacitors, etc.). Capacitor charging current is defined as I = C*(dV/dt). So the ramp rate of the DVDD3318_x supply and the total bulk capacitance on the DVDD18 supply can be used to calculate the current produced. This solution provides additional power supply filtering and little current leakage after the supplies are ramped (depending on the type of capacitors used). The table below shows some examples of the bulk capacitance that would be required to use this solution alone: Table 12. Bulk Capacitance DVDD3318_x ramp dV/dt (in V per second) Required capacitance to generate 140 mA time for 3.3V 100 µs 33000 4.2 µF 250 µs 13200 10.6 µF 500 µs 6600 21.2 µF 1 ms 3300 42.4 µF 10 ms 330 424.2 µF (b) Use an additional shunt regulator to control the voltage at DVDD18. The shunt regulator is placed between DVDD18 and Vss. As an example, the TLVH431 can provide up to 70 mA of additional load current to help maintain the DVDD18 voltage. When the voltage drops back to the normal 1.8V range, the current flow through the shunt regulator drops into the <100 uA range. This solution requires the shunt regulator and two additional resistors to set the desired regulation voltage. (c) Use a resistor to provide additional load between DVDD18 and Vss. This solution is less desirable since it continues to draw power even after the supply ramp is completed but would likely be the lowest cost. An improvement is to use a FET/switch in series with the resistor between DVDD18 and Vss that can later be turned off (by the RESET signal or a GPIO signal for example). SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 27 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 2. Choose a regulator for the DVDD18 supply (or grouped 1.8V supplies) that is capable of actively regulating voltage up and down. Many high-efficiency switching regulators switch current into the load only when the voltage needs to be raised and rely on the load to pulldown the current. In this error condition, a regulator of this type will not be able to compensate for the leakage current described above. Synchronous buck regulators use external inductance to pulldown the regulated voltage when necessary. 28 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.18 DVDD18 Can Pull Up to 2.7V When Using Dual-Voltage IOs at 3.3V
ARM9	TI	OMAP-L138	The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB- peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported. The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles between host and peripheral, is supported.	None SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 29 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.19 USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported
ARM9	TI	OMAP-L138	: When connecting a SATA GEN3 capable target, for example a Hard Disk Drive (HDD), to a device with a SATA Host Subsystem (after power-up or reset) the speed negotiation fails between the two devices and no link is established. Two different types of failure behaviors with the same results have been observed: Losing Synchronization: The Target (Device) always starts the speed negotiation at the highest speed supported, in this case GEN3, by sending an ALIGNp primitive data pattern to the Host SATA subsystem. The Host SATA subsystem sends a continuous D10.2 Tone at GEN1 speed (1.5 GBits/sec) and should ideally remain at this state until the Host recognizes the Targets' ALIGNp primitive data pattern [at GEN2 or GEN1 but not GEN3 speed]. While the Target (Device) is still at GEN3, due to aliasing, etc., the Host SATA subsystem falsely responds back to the Device with an ALIGNp primitive data pattern at a different speed (GEN2 speed). The Host completes the speed negotiation at GEN2 speed and transitions to a logical IDLE state (Non-ALIGNp primitive SYNCp) before the Target (Device) timeout period expires (54.6 µs). Once the timeout period expires for GEN3 speed, the Target (Device) starts sending an ALIGNp primitive data pattern at GEN2 speed, expecting an ALIGNp primitive data pattern from the Host which never happens because the Host is in a logical IDLE state at GEN2 speed. Another timeout period expires because the target (Device) did not receive the ALIGNp primitive data pattern at GEN2 speed. This forces the Target (Device) to drop its speed from GEN2 to GEN1 and attempt to establish a link at GEN1 speed. The Host still remains in a logical IDLE state at GEN2 speed. After the final timeout period expires, the Target (Device) requests a RESET (by sending COMINIT signal) to restart the link establishment process with the Host. This new link establishment results in the same outcome with the Host and Target always being out of sync. Unknown State/Lock-up: The Target (Device) always starts the speed negotiation at the highest speed supported, in this case GEN3, by sending an ALIGNp primitive data pattern to the Host SATA subsystem. The Host SATA subsystem sends a continuous D10.2 Tone at GEN1 speed (1.5 GBits/sec) and ideally should remains at this state until the Host recognizes the Targets' ALIGNp primitive data pattern [at GEN2 or GEN1 but not GEN3 speed]. While the Target (Device) is still at GEN3, due to aliasing, etc., the Host SATA subsystem falsely responds back to the Target (Device) with an ALIGNp primitive data pattern at a different speed (GEN2 speed) and remains at this state (sending the GEN2 ALIGNp primitive). The Target (Device) times out (54.6 µs) and starts sending an ALIGNp primitive data pattern at GEN2 speed. Target (Device) now recognizes the Host GEN2 ALIGNp primitive data pattern and responds with a logical IDLE state (Non-ALIGNp primitive SYNCp) completing the link establishment from the Target (Device) perspective. However, the Host is stuck in an unknown state sending GEN2 ALIGNp primitive and never completes the link establishment. Both the Host and Target (Device) remain at this state until a higher Host SATA Controller application (User S/W) performs a Reset. Note: This issue does not apply to Target devices with maximum speed capability of GEN2 or GEN1 speed. 30 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	: • Use GEN2 or GEN1 maximum speed drives to avoid the issue or • Use GEN3 drives with jumper restricting capabilities to restrict their speed to GEN2 or • The Host Application S/W can continually perform Port resets to restart the link establishment eventually succeeding in establishing a link. Note: This is not a preferred method because an excessive amount of resets might be required to establishment the link. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 31 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.22 SATA: Link Establishment Fails With SATA GEN3 Capable Targets
ARM9	TI	OMAP-L138	: The PUPD_SEL[29] register does not get initialized when the device is first powered on and in Reset. This register controls the internal pullup and pulldown resistors for the BOOT[7:0] pins. The contents of the PUPD_SEL[29] register at this state are unpredictable and may contain random values. These random values can result in the internal pullups being enabled for some or all of the BOOT[7:0] pins during reset after every power-on, which conflicts with the datasheet claim that the internal pulldowns are enabled during reset. Internal pullups being enabled on the BOOT[7:0] pins may result in boot failures. If weak external pulldown resistors are used on the PCB to select the boot mode, they may not be able to overpower the internal pullups. This can result in the wrong boot mode being latched in the BOOTCFG[7:0] register when coming out of Reset. Once the device is out of Reset, the PUPD_SEL[29] register is initialized, and the internal pulldown resistors for the BOOT[7:0] pins are all enabled. Issuing a second Power-On Reset (POR) results in the intended boot mode being latched, since the pins are internally pulled down as expected. Figure 10 shows the behavior of the PUPD_SEL[29] register before and after reset. Assuming weak or no external pull resistors are on the BOOT[7:0] pins, the BOOTCFG register will latch the unknown values after the device initially comes out of Reset. Note that, TRST must always be low in order to issue a POR and latch the boot pin values -- the boot pins are not latched after a Warm Reset. RESET TRST PUPD_SEL[29] Register 0h BOOTCFG[7:0] Registers Figure 10. Initialization of PUPD_SEL[29] and BOOTCFG[7:0] Registers with Weak or No External Pull Resistors on BOOT[7:0] Pins Other device pins with configurable internal pullup or pulldown resistors are always internally pulled down during reset and are not affected by this advisory.	: One of the following Workarounds must be implemented to ensure that the boot pins are always latched correctly: Method 1 Use strong external pull resistors on BOOT[7:0] pins. Since either the internal pullup or pulldown resistors could be enabled after every power-on, the external resistors must be strong enough to oppose the internal pulls in either case. Section 4, Device Operating Conditions, of the device datasheet shows the electrical characteristics information which can be used to calculate the maximum external pull resistance required. The value is dependent on the DVDD3318_C I/O supply level. For BOOT pins which need to be sampled as logical low, the external pulldown resistance (R ) must be selected by assuming the internal pullup is enabled. The PDmax calculation is shown in Table 13. 32 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 13. Required Pulldown Resistance (R ) for Logical Low BOOT Pins PDmax æ V ö IL ç ÷ DVDD3318_C I V I IL è I R I ø PDmax 3.3 V 310 µA 0.80 V 2.58 kΩ 1.8 V 310 µA 0.80 V 2.03 kΩ For BOOT pins which need to be sampled as logical high, the external pullup resistance (R ) must be selected by assuming the internal pulldown is enabled. The calculation PUmax is shown in Table 2. Table 14. Required Pullup Resistance (R ) for Logical High BOOT Pins PUmax æ DVDD 3318 _ C - V ö IH ç ÷ DVDD3318_C I V I IH I è I ø RPUmax 3.3 V 270 µA 2.00 V 4.81 kΩ 1.8 V 270 µA 1.17 V 2.33 kΩ Method 2 For applications that have already implemented the Secondary Reset Workaround described in	2.3.23 BOOT: Internal Pullup Resistors for BOOT[7:0] Pins Are Sometimes Enabled During Reset, Leading to Boot Failures
ARM9	TI	OMAP-L138	Details	Workaround(s)	2.0.20, no additional modifications are required as a fix for this Advisory. As shown in Figure 10, issuing a second POR will always latch the BOOT pins while the internal pulldown resistors enabled. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 33 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com
ARM9	TI	OMAP-L138	: The ROM bootloader (RBL) reads a NAND page in segments of 512 bytes (user data) over the External Memory Interface A (EMIFA). The EMIF also reads the associated ECC data which is stored in the spare area of the flash (as shown in Figure 11). The ECC Correct function in the RBL can correct up to 4 bit errors in the user data and/or ECC data by using the syndrome generated from the ECC data and the parity of the user data calculated by the EMIFA module. However, over the life span of the NAND flash, ECC data stored in the spare area can develop errors due to bit flips. When the calculated syndrome indicates an error in the ECC data, the ECC Correct and Read functions of the RBL abort the read process even though, it is possible to correct up to 4 bit errors combined in user and ECC data. Consequently the device fails to boot. Explanation of Current ROM Bootloader Behavior: The RBL implements a search mechanism to look for the boot image in NAND flash by using an Open function and a Read function. The Open function includes a bad block check where the RBL skips to the next block (shown as (A) in Figure 11) if the block under consideration is marked as "bad" (in the spare area). On finding a good block, the RBL attempts to read page0 (the first page) in that block. If page0 of the good block has an ECC data error or an uncorrectable error (more than 4 bit errors combined), the RBL skips to the next block (shown as (B) in Figure 11). This bad block check mechanism enables the device to check up to the first 32 blocks in the NAND flash for booting (the boot process will fail if all 32 blocks have uncorrectable or ECC data errors in page0). Note that the RBL does not abort on detecting an error in ECC data on page0. Once the RBL finds a good block with a good page0, it continues to read subsequent pages in that block. If an uncorrectable or ECC error is detected in subsequent pages, the RBL will abort with a boot error (shown as (C) in Figure 11). The workaround, described below, enables the boot process to continue for both types of errors (ECC data and uncorrectable errors). 34 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications (1) All pages marked in green are good and all pages marked in red have "uncorrectable" errors. Figure 11. D800K008 ROM Behavior Before Application of Software Patch(1)	: The workaround ignores errors in ECC data (these errors do not need to be corrected) so that the boot process can continue, correcting errors in the user data (up to 4 bit errors total), as necessary. The workaround also includes a mechanism to restart the NAND read process from the next good block if an uncorrectable error (more than 4 bit errors) is detected on any page of a good block. This workaround is implemented using a software patch that is loaded in device RAM at boot time and is designed to change the default behavior of the ECC Correct and Read functions in the RBL. The patch binary replaces function pointers to the ECC Correct and Read functions in the ROM function table, (defined in device internal memory), during boot. The patch binary will reside in page0 of the NAND block and so will be applied only after the page0 of a good block has been read. Once the patch is read, all subsequent page reads in the block will use the new ECC Correct and Read functions. ECC data errors on any page (other than page0) are ignored, any user data error (up to 4 bit errors total) is corrected and the boot process continues. If an uncorrectable error is detected on any page, the block is skipped and the boot process is restarted on the next good block. The behavior of the device boot from the NAND after application of the patch is shown in Figure 12. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 35 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com (1) All pages marked in green are good and all pages marked in red have "uncorrectable" errors. Figure 12. D800K008 ROM Behavior With Software Patch Applied(1) The software patch is available as a pre-built file with the latest version of the AIS tool that is used to generate the NAND flash boot image. The Using the OMAP-L132/L138 Bootloader Application Report (Literature number: SPRAB41) provides a link to the install package for the AIS tool which includes the following in the install directory: prebuilt patch files, the GUI AIS generation tool (AISGEN.exe, version 1.11 or later), command-line AIS generation tool and an example INI file. Application of the Software Patch to NAND Boot Images: • For the GUI tool, AISGEN.exe version 1.11 or later (found in the install directory), the patch integrates the modified ECC Correct function into the user application file to generate one binary AIS file. • For the Command line AIS tool, HEXAIS_OMAP_L138.exe users (found in the install directory), the patch can be integrated into the user application file to generate one binary AIS file by inserting lines below to the end of the INI configuration file. The patch name is: ARM_nand_ecc_patch_OMAP-L138.out 36 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications [INPUTFILE] ; get the NAND ECC patch file FILENAME=Patch_name.out ; patch the NAND ECC handling routine [AIS_Jump] LOCATION=_NAND_ECC_patchApply • The patch will be burnt on page0, as it is in the head of AIS file. Once page0 has been read successfully, the AIS set command will overwrite the function pointer in the RBL with the modified function pointer and the modified function will be applied to the later pages read. Memory usage of the patch at boot time is as follows: – 500 bytes at location 0xFFFF 0B00 Recommendations to Improve Robustness: • Page0 should be stored on multiple blocks as backup to take advantage of the safety mechanism built into Silicon Revision 2.1 to cycle to the next block when a page0 read fails in a good block. • Maintain backup boot images in multiple blocks. The patch to the Abort function reinitializes the boot process and forces the boot to cycle to the next good block and restart the boot process by reading from it. • Silicon Revision 2.1 supports booting from Block 0 of the flash which many NAND manufacturers guarantee as a “more reliable” block than all other blocks. Hence, setting up boot to start from that Block 0 could help improve the reliability of boot. This is a hardware change, requiring the bootmode pins BOOT[6:5] = 1x. For more details on the bootmode pins, see the Using the OMAP-L132/L138 Bootloader Application Report (Literature number: SPRAB41), NAND-Boot Modes. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 37 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.24 Boot: ECC Data Error in Spare Area Causes NAND Boot Failure
ARM9	TI	OMAP-L138	When CPPI DMA completes a receive data transaction it posts a write to the Rx data buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.	Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred procedure calls (whose schedule can be delayed depending on OS load), the latency sensitive application (like ISO Audio) might be affected by delay in notification to the application. 38 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.25 USB0: CPU gets Stale Receive Data from the Data Buffer located in External Memory
ARM9	TI	OMAP-L138	The erroneous short packet status can be detected on current endpoint and XDMA closes the Rx transfer in current endpoint. When more than one endpoint have been processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints. This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA mode.	The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different. Software must keep tracking every endpoint data transferring size. When DMA completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 39 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.26 USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint is Transferring Data
ARM9	TI	OMAP-L138	Teardown receive DMA is not working perfectly. This happens when a teardown is initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.	Software should make sure that DMA does not get to an unknown state during teardown by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure can be initiated. Software should also add 250 ms delay during teardown. 40 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 3 Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 2.1 and earlier of the device. 3.1 Usage Notes for Silicon Revision 2.1 Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions. Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications. 3.2 Silicon Revision 2.1 Known Design Exceptions to Functional Specifications The advisories are not enumerated in sequential order and hence some numbers may not appear in the document Table 15. Silicon Revision 2.1 Advisory List Title ................................ Page	2.3.27 USB0: DMA Hung up in Frequent Teardowns
ARM9	TI	OMAP-L138	Under conditions in which the device is subjected to large variations in operating temperatures, the USB0 PLL temperature compensation circuitry does not have enough margin to guarantee compensation for PLL drift across all temperature ranges. As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized). Once the onset of PLL drift occurs, the mean frequency will continue to drift outside the expected frequency and will eventually cause the PLL to lose lock resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset. If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation circuitry is expected to provide the proper compensation to prevent the mean PLL frequency from losing lock and beginning to drift. More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature range of 0˚C to 90˚C. TI has identified a point-to-point device temperature range in which there is a very high confidence the compensation circuitry will properly compensate for all temperature variations, provided the USB0 PHY was most recently initialized (calibrated) within this same temperature range. Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always experience a failure in USB transmission. Root Cause The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY was not designed with a large enough range to compensate for all variations in temperature across the specified operating range of the device. How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps: 1. Allowing the unit to soak in an ambient temperature of -35˚C until the device temperature reaches approximately the same temperature. 2. Power up the device and provide the necessarily software programming in order to invoke the USB Signal Quality Test Pattern. 3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C. Record the measured mean frequency by the compliance software. NOTE: The set points can be varied to obtain finer temperature resolution of when the PLL begins to drift a per platform basis. The above temperature profile is provided for reference. 42 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications	When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0 PHY without a re-enumeration. In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to determine when the issue is present. One such approach is to look for an absence of USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application. As an additional safeguard, an application can also intentionally schedule pre- determined USB PHY resets at specific temperature points if operation over a broad range is expected. Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module: #define CFGCHIP2 *((volatile unsigned int *) 0x01C14184) #define USBPHY_PHYPDWN 0x00000200 Void phy_reset(void) { CFGCHIP2 |= USBPHY_PHYPDWN; /* Power down the USB PHY */ mdelay(1); /* Wait 500ms */ CFGCHIP2 &= ~USBPHY_PHYPDWN; /* Power up the USB PHY */ } SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 43 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 4 Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 2.0 of the device. 4.1 Usage Notes for Silicon Revision 2.0 Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions. Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications. 4.2 Silicon Revision 2.0 Known Design Exceptions to Functional Specifications Table 16. Silicon Revision 2.0 Advisory List Title ................................ Page	2.1.21 USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings
ARM9	TI	OMAP-L138	For affected silicon revisions, the DSP initiates the system boot sequence when the device is released from reset. Before the ARM can take control of the user boot mode, the DSP must first initialize the ARM reset vector table so that the ARM will execute from its boot ROM. The ARM reset vector table is located in the ARM’s local RAM, however the ARM local RAM can only be accessed by two bus masters: ARM and PRU0. Therefore, the DSP must program PRU0 to copy the desired reset vector table into the ARM’s local RAM. The PRU instructions are located inside of an instruction RAM (IRAM) which is initialized by the DSP during ROM boot (see Figure 13). After the instructions are stored to IRAM, the PRU is reset and enabled to execute its instructions. In this case, the PRU is instructed to initialize the ARM reset vector table. Read PRU Core PRU IRAM Write Enable Bit Reset Bit External Master (DSP) Figure 13. PRU and DSP Block Diagram When the device is first powered-on, the read bus from the PRU IRAM is not initialized and will contain random values (see Figure 14). Under unpredictable circumstances, the random value on the read bus may resemble a reserved instruction which can be interpreted by the PRU when the core is reset and not enabled. If the PRU core executes this reserved instruction, it will not be able to properly execute the first functional op-code in the PRU IRAM when the core is later enabled. In this fail state, the PRU will never acknowledge to the DSP that the reset vector table was successfully initialized and the DSP will be stuck in a polling loop waiting for the PRU to complete its task. Read Rsvd Inst PRU Core Fail State! PRU IRAM Write Enable Bit Reset Bit External Master (DSP) Figure 14. Boot Failure on Power-On SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 45 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Although the PRU core execution is stuck, the PRU IRAM read bus is now initialized with a non-reserved instruction that was fetched from the IRAM by the PRU core (see Figure 15). If a secondary reset is provided to the device (either POR or WARM), the PRU will be able to execute its functional instructions as expected. Read Good Inst PRU Core Pass State! PRU IRAM Write Enable Bit Reset Bit External Master (DSP) Figure 15. Secondary Reset Note that in order to recover from this fail state with a secondary reset, the DSP must be allowed to execute its boot ROM up to the point where the PRU has fetched a known instruction from the PRU IRAM. The approximate count of 15k cycles into the boot ROM is sufficient. The 15k clock cycle count does not include the 6192 clock cycles required to complete a device POR reset (see Figure 16). With a 24MHz crystal, the first RESET signal must be asserted high for at least 883us (or approximately 1ms). Greater than 15k Cycles RESET RESETOUT 6192 Cycles Figure 16. First POR Reset Timing	Modify the target board so that the affected device is given a secondary reset on power-up as shown in Figure 16. Two example methods are described in the sections that follow. Although secondary resets are compatible with future silicon revisions, they are not required for devices where the root cause has been fixed via an updated DSP boot ROM. In order to reduce BOM costs, board designers may want to route a reset signal bypass path so that the workaround circuit can be depopulated on future PCB builds. ❏Use a reset supervisor device that includes a watchdog timeout function so that the reset supervisor will issue a secondary reset if the device fails to boot. The watchdog should be serviced with a device signal that is controlled by software. Options for servicing the watchdog timeout include GPIO, unused clock sources such as CLKOUT or a periodic output peripheral like TIMER and ePWM. 46 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications Potential reset supervisors are TPS382x for 3.3V IOs (shown in Figure 17) and TPS312x for 1.8V IOs. TPS3820 3.3V OMAP-L138 VDD DVDD3318 GND GND Board Reset MR WDI CLKOUT RESET RESET 0-W Not Populated Figure 17. Reset Supervisor with Watchdog Function The watchdog supervisor workaround is easy to implement, however the watchdog timeout period may exceed application boot-up time requirements. For example, the TPS3820 has a typical watchdog timeout period of 200ms. The second workaround can speed up the reset process. ❏Implement a logic-based secondary reset circuit which is timed using RC components. For the circuit shown in Figure 18, a single board reset control signal can trigger three logic transitions in a dual XOR gate device. Not Populated 0-W 1A R1 1Y 1B Board Reset 1 C1 1A RESET R2 1Y 1B 2 R3 SN74LVC2G86 C2 Dual XOR Gate SN74LVC2G17 Dual Schmitt Buffer Figure 18. RC-Timed Secondary Reset This is possible because each RC load connected to the board reset control signal can output a different rising-edge waveform. With increasing RC load, the resulting control signal will reach the Schmitt buffers’ Vih level at a later point in time. Figure 19 shows the relationship between the board reset signal and the RESET signal produced by the circuit. The blue and green lines represent the voltage as seen by the Schmitt buffers. The output voltage of a charging RC circuit is defined as: Vo = Vi * (1 - e^[-t / RC]) SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 47 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com R1C1 RESET R2C2 Vih Board Reset Figure 19. RESET Signal vs Board Reset Given ideal conditions, a 3.3V board reset signal, and an input buffer Vih of 1.4V, the following set of component values would generate an initial RESET high period (R1C1 region) of approximately 2ms and a RESET low period (R2C2 region) of approximately 0.5ms: • R1 = 36k, C1 = 100nF, • R2 = 45k, C2 = 100nF, • R3 = 450k When implementing this workaround, some important aspects should be kept in mind: (a) The dual Schmitt buffer is included because the dual XOR gate has an input rise-time requirement that is violated by the RC circuits, (b) The Board Reset signal must meet the XOR gate input rise-time requirement and must provide enough output current to charge the RC circuits to the target Vih level, (c) It is critical for the Vih level of the two input buffers to be very close together so only single-device buffers should be considered for this circuit (such as the 2-in-1 dual Schmitt buffer device used in this example), (d) Variations in the electrical characteristics of the circuit components may produce waveforms that deviate from ideal calculations, and (e) The sole purpose of the R3 pulldown resistor is to discharge the RC components before the board reset signal is driven high. Therefore, the value selected for R3 should be sufficiently large enough to not interfere with the RC circuits as they are charging. 48 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications 5 Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 1.1 of the device. 5.1 Usage Notes for Silicon Revision 1.1 Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions. Silicon revision 1.1 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications. 5.1.1 RTC Standby Power Consumption Is Elevated if the Module Is Not Configured Correctly The RTC module is designed with the ability to keep time while the rest of the device is power cycled off and on. This ability is achieved by placing the RTC in its own power domain and isolating it from the device reset signal. When the CVDD supply is powered down, the RTC_CVDD supply will experience elevated standby power consumption because of leakage between the RTC and core power domains. The RTC module includes circuitry that eliminates the leakage paths between the two domains when the SPLITPOWER bit is set to 1 in the control register (CTRL). The SPLITPOWER bit is a write-only bit that will always read back 0. Therefore, typical read-modify-write sequences should not be used when writing to the CTRL register because the SPLITPOWER bit will be cleared back to 0. Also note that the SPLITPOWER bit has a default value of 0 after RTC module reset, and the only reset available to the RTC module is a software reset, therefore RTC is in an indeterminate state when the RTC_CVDD supply is first powered on. The RTC module should be reset, and the SPLITPOWER bit should be set to 1 before placing the device in a CVDD powered down standby state. The SPLITPOWER bit is permanently set to 1 inside the RTC module beginning with Silicon Revision 2.0 of the device. 5.1.2 SYSCFG: Possible Race Condition When Using KICK Registers When two or more threads are simultaneously accessing the SYSCFG registers, there is the potential for one thread to lock the SYSCFG registers while another thread is still accessing them. There is no hardware semaphore to prevent this from occurring. For example, the race condition can occur in the following situation 1. Thread 1 unlocks the SYSCFG register by writing to the KICK registers 2. An interrupt occurs and Thread 2 unlocks the SYSCFG registers as well 3. Thread 2 finishes and locks the SYSCFG registers 4. Thread 1 is locked out of the SYSCFG registers and is unable to complete its task To prevent the SYSCFG lockout race condition, the application should unlock the SYSCFG registers via the KICK registers and leave them permanently unlocked. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 49 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 5.1.3 SATA & USB Digital Supplies Must Be Powered for Proper Device Operation For silicon revisions prior to 2.0, the SATA and USB digital supply pins must be powered up. These supplies provide power to logic that is critical for device initialization during reset. A bad initialization sequence will cause the device boot process to fail. Another symptom of a bad initialization sequence is that the DIEIDRx registers (0x01C14008h – 0x01C14017h) will appear as all zeros. Starting with silicon revision 2.0, the affected logic will be powered by the CVDD core supply instead of the USB and SATA supplies. The following is a list of the supply pins affected: Table 17. Supply Pins Affected Digital Supply Pin SATA_VDD M2 SATA_VDD N4 SATA_VDD P1 SATA_VDD P2 USB_CVDD M12 5.2 Silicon Revision 1.1 Known Design Exceptions to Functional Specifications Silicon revision 1.1 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications The advisories are not enumerated in sequential order and hence some numbers may not appear in the document. Table 18. Silicon Revision 1.1 Advisory List Title ................................ Page	2.0.20 Intermittent Boot Failures
ARM9	TI	OMAP-L138	Note: DMA refers to all non-CPU requests. SDMA refers to external system DMA master requests handled via the Slave Direct Memory Access port. The C674x Megamodule uses a two-way set associative cache for L1D. This means that every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on the L1D cache architecture. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by the application. An L1D cache-line corruption event occurs when all of the following conditions are met: 1. L1D cache evicts a dirty line (Line A) while allocating a new line (Line B) in the same set/way (cache Lines A and B consist of 64-bytes each). In order for this to happen, the following will have taken place: (a) Line A was previously read by CPU because L1D is a read-allocate cache, (b) Line A is dirty because its value was modified by CPU, and (c) Line B is read by CPU 2. Both Line A and Line B are associated with L2 RAM, and 3. While the original L1D victim write-back from condition (1) is in progress, the SDMA performs both: (a) a read or write operation to Line A in L2 RAM and (b) a write operation to Line B in L2 RAM. If all of the above conditions are met, the L2 RAM data associated with the Line A victim writeback will become corrupt. Additionally, the Line B data originating from the SDMA write will also become corrupt in L1D cache. Figure 20 shows an example scenario of L1D cache and L2 RAM corruption. Line A and Line B Map to LINE A same L1D Cache line. INITIAL STEP 1 STEP 2 STEP 3 STATE C674x Megamodule LINE B C674x CPU CPU Request Request L2 C674x CPU EXTERNAL Activity Line B Pending Controller L2 SRAM SDMA SDMA Requests Read/Write to Line A Activity & Write to Line B L1D EMC L1D Cache Dirty Line A Dirty Line A IN-FLUX Corrupt Controller SDMA PORT EDMA SYSTEMMASTERS Line Status in L1D Cache in L1D Cache Line A Old Data Old Data Old Data Corrupt L2 SRAM Line B tries to replace EMAC CACHE LINE Line B Old Data Old Data Old Data NEW DATA Dirty Line A in the L1D L2 SRAM Cache L1D CACHE Corruption happens because of this state TIME LINE SYSTEM VIEW Figure 20. Example of L1D Cache and L2 RAM Corruption	Method 1 In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 51 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com have partial segments which overlap into the same L1D cache line. /** Pseudo code only **/ Uint8 *SDMA_BUFF, *CPU_BUFF; /* 64-byte aligned allocation Option 1 */ SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 ); CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 ); SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 ); CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 ); /* 64-byte aligned allocation Option 2 with BIOS Call */ SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 ); CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 ); Method 2 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations after CPU writes. With this method, the semaphore ensures that there is clear ownership of the buffer between CPU and SDMA, and the CPU manages cache coherence by using explicit cache writeback operations. /** Pseudo code only **/ /* Example with EDMA as the external master */ EDMA_ISR() { /* EDMA releases ownership of buffer */ SEM_post(SyncSemaphore); return; } main() { while(COND) { /* CPU waits for ownership of buffer */ SEM_pend(SyncSemaphore); /**********************/ /*** CPU Processing ***/ /**********************/ /* Cache writeback for shared block */ /* Buffer must be 64-byte aligned */ BCACHE_wbInv( blockPtr, blockSize, WAIT ); /* Initiate EDMA */ EDMA_Event_Generate(); } } Method 3 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM or L3 RAM instead of L2 RAM. Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM or L3 RAM instead of L2 RAM. 52 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications Method 5 Do not configure L1D memory as cache - use the entire address space as RAM. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 53 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	1.1.2 Under Specific Conditions, SDMA Activity Can Corrupt the L1D Cache and L2 RAM
ARM9	TI	OMAP-L138	The low-voltage operating points are not supported on revisions 1.1 and earlier. The support of these operating points is planned for revision 2.0.	None 54 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications	1.1.7 Low Voltage Operating Points (1.1V, 1.0V) Not Supported
ARM9	TI	OMAP-L138	A potential reliability issue has been discovered when hardware resets (RESET pin high-to-low transitions) occur. If any of the dual-voltage LVCMOS IOs on the device are being operated at 3.3V nominal and a hardware reset occurs, some 1.8V transistors in the IOs buffers are briefly exposed to 3.3V. This exposure to high voltage has the potential to degrade the gate oxide integrity of the transistors over repeated resets. This issue does not occur during a power-up condition where the RESET pin is held low. This issue does not occur with software resets or watchdog timer induced resets. This issue does not occur if all dual-voltage LVCMOS IO buffers are being operated at 1.8V nominal. Reliability estimates have been made to determine a budget for the number of resets in a product lifetime to maintain the reliability of the device under 50 FIT. • At a junction temperature of 105°C, the total number of hardware resets in the product lifetime should not exceed 125,000 hardware resets. • At a junction temperature of 90°C, the total number of hardware resets in the product lifetime should not exceed 250,000 hardware resets.	Limit the number of hardware reset to within the limits listed above. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 55 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	1.1.11 Hardware RESET Reliability Lifetime
ARM9	TI	OMAP-L138	Device peripherals often include an emulation suspend function that gracefully halts peripheral activity. This function is activated when the target CPU is halted through emulator debug. While halted, the control and status registers for the module can be viewed and manipulated for debug purposes. In a multicore device, it is desirable to choose a single CPU to master the emulation suspend function. Typically, the CPU that configures a module is chosen to be its suspend source CPU (ARM or DSP). The SUSPSRC register in the SYSCFG module allows the user to choose which CPU controls the emulation suspend function for each peripheral. For the affected silicon revisions, the SUSPSRC fields MCBSP0SRC, MCBSP1SRC, TIMER64P_2SRC, and VPIFSRC are not functional. The ARM will always be the suspend source regardless of the bit settings. If the ARM is connected and halted through emulator debug, the affected peripherals will appear to be halted as observed by the DSP. Similarly, if the ARM is free-running, the affected peripherals will never halt when the DSP is halted. The described condition is only present during emulation debug – the peripherals will function as expected when the device is free-running in an application.	When developing DSP software, the affected peripherals can be removed from halted states by either free-running the ARM CPU or by setting the peripheral-specific emulation mode to FREE. The affected peripherals can be placed into halted states by halting the ARM CPU. Code Composer Studio (CCS) allows the user to set Global Breakpoints such that the DSP and ARM CPUs will both halt at the same time on a given breakpoint. CCS also includes the ability to simultaneously set debug states (such as RUN and HALT) across multiple processors. When the ARM and DSP both run and halt at the same time, the peripherals will appear as if their suspend source is the DSP. 56 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications	1.1.14 SYSCFG SUSPSRC Bits Not Functional for McBSP0, McBSP1, TIMER2, and VPIF
ARM9	TI	OMAP-L138	Note: This advisory is not applicable if DSP L2 memory is configured as 100% cache or L2 RAM is not accessed by IDMA or SDMA during run-time. The C674x Megamodule has a Master Direct Memory Access (MDMA) bus interface and a Slave Direct Memory Access (SDMA) bus interface. The MDMA interface provides DSP access to resources outside the C674x Megamodule. The MDMA interface is typically used for CPU/cache accesses to memory beyond the Level 2 (L2) memory level. These accesses include cache line allocates, write-backs, and non-cacheable loads and stores to/from system memories. The cacheable memories external to the C674x Megamodule are listed in Table 19. Table 19. Cacheable External Memory Resources External Memory Address Range Shared Ram 0x8000 0000 – 0x8001 FFFF EMIFA 0x4000 0000 – 0x67FF FFFF DDR2/mDDR 0xC000 0000 – 0xCFFF FFFF The SDMA interface allows other DMA master peripherals (listed in Table 20 ) to access Level 1 Data (L1D), Level 1 Program (L1P), and L2 RAM DSP memories. Table 20. DMA Master Peripherals Peripheral Group EDMA0 TC0 RD A EDMA0 TC0 WR B EDMA0 TC1 RD C EDMA0 TC1 WR D EDMA1 TC0 RD E EDMA1 TC0 WR F UHPI G USB0 G USB1 G EMAC G PRU H SATA I UPP I VPIF I ARM J The C674x Megamodule has an L1D cache and L2 cache both implementing write-back data caches– it keeps updated values for external memory in cache for as long as possible. It writes these updated values, called "victims", to external memory when it needs to make room for new data or when requested to do so by the application. The L1D sends its victims to L2. The caching architecture has pipelining, meaning multiple requests could be pending between L1, L2, and MDMA. For more details on the C674x Megamodule and its MDMA and SDMA ports, see the TMS320C674x Megamodule Reference Guide (literature number SPRUFK5). SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 57 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Ideally, the MDMA (dashed-dotted line in Figure 21) and SDMA/IDMA paths (dashed lines in Figure 21) operate independently with minimal interference. Normally MDMA accesses may stall for extended periods of time due to expected system level delays (for example, bandwidth limitations). However, when using L2 as RAM, SDMA and IDMA accesses to L2/L1 may experience unexpected stalling in addition to the normal stalls seen by the MDMA interface. For latency-sensitive traffic, the SDMA stall can result in missing real-time deadlines. In a more severe case, the SDMA stall can produce a deadlock condition in the device. An IDMA stall cannot produce a deadlock condition. Note: SDMA/IDMA accesses to L1P/D will not experience an unexpected stall if there are no SDMA/IDMA accesses to L2. Unexpected SDMA/IDMA stalls to L1 happen only when they are pipelined behind L2 accesses. Additionally, the deadlock scenario will be avoided if there are no SDMA accesses to L2. Figure 21 is provided for illustrative purposes and is incomplete because of simplification. The IDMA/SDMA (dashed-lines) path could also go to L1D/L1P memories, and IDMA can go to DSP CFG peripherals. MDMA transactions can originate also from L1P or L1D through the L2 controller or directly from DSP). 32K bytes 256K bytes 1M bytes L1P RAM/ L2 RAM L2 ROM cache 256 256 256 256 Cache control Cache control Memory protect L1P Memory protect L2 Bandwidth Mgmt Bandwidth Mgmt 256 256 256 Instruction fetch 256 Power down C674x Interrupt Fixed/floating point CPU Controller Register Register IDMA file A file B 64 64 256 CFG Bandwidth Mgmt 32 Configuration EMC Memory protect L1D peripherals Cache control bus MDMA SDMA 8x32 64 64 64 64 32K bytes High performance L1D RAM/ switch fabric SDMA/IDMA Paths cache (SCR1) MDMA Path Figure 21. C674x Megamodule The duration of the SDMA/IDMA stalls depend on the quantity/characteristics of the L1/L2 cache and the MDMA traffic in the system. Therefore, it is difficult to predict if stalling will occur and for how long. IDMA/SDMA stalling and any system impact is most likely in systems with excessive context switching, L1/L2 cache miss/victim traffic, and heavy access to external memory. 58 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications Use the following procedure to determine if SDMA/IDMA stalling is the cause of real-time deadline misses for existing applications. Situations where real-time deadlines may be missed include loss of McASP samples and poor peripheral throughput. 1. Determine if the transfer that is missing the real-time deadline is accessing L2 or L1D memory. If not, then SDMA/IDMA stalling is not the source of the real-time deadline miss. 2. Identify all SDMA transfers to/from L2 memory (for example, EDMA transfer to/from L2 from/to a UART, HPI block transfer to/from L2). If there are no SDMA transfers to/from L2, then SDMA/IDMA stalling is not the source of the problem. 3. Redirect all SDMA transfers to L2 memory to other memories using one of the following methods: (a) Temporarily transfer all the L2 SDMA transfers to L1D SRAM. (b) If not all L2 SDMA transfers can be moved to L1D memory, temporarily direct some of the transfers to memory in Table 1 and keep the rest in L1D memory. There should be no L2 SDMA transfers. If real-time deadline misses are solved using any of the options in Step 3, then IDMA/SDMA stalling is likely the source of the problem. A deadlock situation may arise if the following sequence of events occurs: Step 1: A DMA master from any group (listed in Table 2) issues a write command to the DSP’s SDMA, and a DMA master from the same group issues a subsequent write command to cacheable memory outside of the C674x Megamodule (listed in Table 1). All write commands pass through Switched Central Resource 1 (SCR1). For more details on SCRs, see the device System Reference Guide SPRUG84. Step 2: The DSP’s SDMA asserts itself as not ready and is unable to accept the write data from Step 1, and a cache line writeback is initiated from DSP memory to the same cacheable memory from Step 1. The cache line writeback command also passes through SCR1. With the above scenario, it is possible for SCR1 to order the write commands from Step 1 in front of the write commands from Step 2. Due to the MDMA/SDMA blocking behavior, the SDMA commands from Step 2 will be waiting for the MDMA traffic from Step 1 to finish, resulting in a deadlock situation at SCR1. Figure 22 is provided for illustrative purposes and is incomplete because of simplification. DMA Group A C674x SDMA (L2/L1D) DMA Group B SCR1 DMA Group xx Cacheable Memory C674x MDMA Figure 22. SCR1 System Interconnect SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 59 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated Silicon Revision 1.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	Entirely eliminate IDMA/SDMA stalling and potential for a deadlock condition using one of the following two methods: 1. Configure the entire L2 RAM as 100% cache (for example, move all data buffers from L2 to L1D or other memory). Note: Some throughput degradation is expected when the buffers are moved out to external memo 2. Eliminate all IDMA/SDMA access to L2 RAM when IDMA/SDMA stalling would have an impact by performing one of the following: (a) Constrain each DMA master group to perform writes to either DSP memory space or external memory space, but not to both, or (b) Force each DMA master group to complete pending write commands to either DSP memory space or cacheable memory space before initiating writes to a different destination. Pending write commands from DMA masters are forced to complete when the DMA master initiates a read from the same destination memory. Note that in the case of off-chip memory, a read command only forces the completion of write commands within a 2KB-aligned window. 60 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, SPRZ301M – June 2009 – Revised March 2014 1.1 and 1.0 Submit Documentation Feedback Copyright © 2009–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional Specifications 6 Silicon Revision 1.0 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 1.0 of the devices. 6.1 Usage Notes for Silicon Revision 1.0 Silicon revision 1.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications. 6.2 Silicon Revision 1.0 Known Design Exceptions to Functional Specifications Silicon revision 1.0 applicable advisories have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications. SPRZ301M – June 2009 – Revised March 2014 OMAP-L138 C6000 DSP+ARM® Processor Silicon Revisions 2.3, 2.1, 2.0, 61 Submit Documentation Feedback 1.1 and 1.0 Copyright © 2009–2014, Texas Instruments Incorporated	1.1.16 DSP SDMA/IDMA: Unexpected Stalling and Potential Deadlock Condition
ARM9	TI	OMAP-L132	Note: DMA refers to all non-CPU requests. This includes Internal Direct Memory Access (IDMA) requests and all other system DMA master requests via the Slave Direct Memory Access (SDMA) port. The C674x Megamodule uses a bandwidth management (BWM) system to arbitrate between DMA and CPU requests issued to L2 RAM. See TMS320C674x DSP Megamodule Reference Guide, Literature Number - SPRUFK5 for more information on the BWM. BWM arbitration grants L2 bandwidth based on programmable priorities and contention- cycle-counters. The contention-cycle-counters count the number of cycles for which the associated L2 requests are blocked by higher priority requests. When the contention-cycle-counter reaches a programmed threshold (MAXWAIT), the associated L2 request is granted a slice of L2 bandwidth. This prevents indefinite blocking of low priority requests when faced with the continuous presence of higher priority requests. Ideally, the BWM arbitration will grant equal L2 bandwidth between equal priority DMA and CPU requests. Instead, when equal priority DMA and CPU requests arrive at the BWM, bandwidth is always granted in favor of the CPU over DMA. In the case of successive CPU requests, it is possible for the CPU to block all DMA requests until CPU traffic subsides. Additionally, some command logic in the BWM uses priority level 7, which can also result in SDMA stalls when the CPU is also programmed to priority level 7. Figure 3 shows a high level diagram of the arbitration scheme used for L2 RAM requests. C674x Megamodule EDMA SHAREDRESOURCE ExternalSystemMasters Programmable Priority ARBITRA MasterPriority C674x CPU EMAC ARBITRA Programmable Priority IDMA L2 RAM TION Inherit TION Priority SDMA USB Highest Priority Master Granted Access. Contention counters implemented to not starve low priority requestors Figure 3. Priority Arbitration Scheme for L2 RAM	Configure DMA and CPU requests to different priority levels. There is no penalty for setting the IDMA and SDMA priorities equal to each other. CPU request priority is programmed within the CPUARBU register: /** Pseudo code only **/ Uint32 *CPUARBU; CPUARBU = ( Uint32 * ) ( 0x01841000 ); /* Set priority different from IDMA/SDMA */ *CPUARBU = [CPU_PRIORITY]; 8 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications IDMA request priority is programmed within the IDMA1_COUNT register /** Pseudo code only **/ Uint32 *IDMA1_SRC, *IDMA1_DST; Uint32 *IDMA1_CNT; IDMA1_SRC = ( Uint32 * ) ( 0x01820108 ); IDMA1_DST = ( Uint32 * ) ( 0x0182010C ); IDMA1_CNT = ( Uint32 * ) ( 0x01820110 ); *IDMA1_SRC = sourceAddress; *IDMA1_DST = destinationAddress; /* Set IDMA priority different from CPU */ *IDMA_CNT = ( [IDMA_PRI] << [IDMA_PRI_SHIFT] ) | buffSize ; SDMA request priority is inherited from the MSTPRIn registers /** Pseudo code only **/ Uint32 *MSTPRI1, *MSTPRI2; MSTPRI1 = ( Uint32 * ) ( 0x01C14114 ); MSTPRI2 = ( Uint32 * ) ( 0x01C14118 ); /* Set SDMA master priorities different from CPU */ *MSTPRI1 = [MAST_PRI] << [MAST_SHIFT]; *MSTPRI2 = [MAST_PRI] << [MAST_SHIFT]; SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 9 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.1 DMA Access to L2 RAM Can Stall When DMA and C674x CPU Command Priorities Are Equal
ARM9	TI	OMAP-L132	When the USB controller is operating as a device and an attached host resets the device after the completion of the Device Attached state by driving both differential data lines low, the USB controller operating as a device could receive multiple RESET interrupts for the single RESET signaling invoked by the host. The multiple interrupt generation only happens for the duration of the RESET signaling on the bus. RESET Interrupt is not generated before or after the completion of RESET.	Software must service every USB RESET interrupt received. Software should not proceed on performing any other task, like initialization, until RESET duration has come to completion. The POWER[RESET] bit field will be cleared by the USB Controller when RESET signaling on the bus is removed by the Host. The USB Controller clearing the POWER[RESET] bit field should be used by software as an indication for the completion of RESET signaling. 10 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.3 USB0: Extraneous RESET Interrupt
ARM9	TI	OMAP-L132	In Extended Wait mode, during a read access to an asynchronous memory, if the WAIT input does not go inactive within maximum extended wait cycles programmed in the Async Wait Cycle Config register, the EMIF will report a time-out error. The data returned for this access will be all zeros. If this access is followed by a read to the EMIFA’s memory-mapped register (MMR) space, the EMIFA will still report a time-out error but with the correct data for the MMR read. The EMIF will hold the time-out error until another asynchronous access without a time-out error or an SDRAM access is performed. This issue is only applicable if all of the following are true: • The EMIF is used for asynchronous memory accesses in Extended Wait mode. • There is a potential for a time-out error to occur, that is, the asynchronous memory will not de-assert the WAIT input. • If asynchronous memory read with time-out error is followed by an MMR read.	If a time-out occurs, perform any of the following: • A dummy read to another asynchronous memory chip select that is not configured to be in Extended Wait mode. • A dummy read to the same asynchronous memory chip select after disabling the Extended Wait mode on that chip select. • A dummy read to SDRAM SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 11 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.4 EMIFA: Asynchronous Memory Timeout Error Persistence
ARM9	TI	OMAP-L132	The C674x DSP megamodule supports twelve maskable hardware interrupt signals (CPUINT4 through CPUINT15). Single system interrupts may be mapped directly to a CPUINTn hardware interrupt, or multiple system interrupts may be combined by the ECM into a single signal before mapping to a CPUINTn interrupt. See [SPRUFK5; TMS320C674x DSP Megamodule] for more information on how DSP interrupts are handled. The ECM expects all incoming interrupts to be pulse interrupts, however the [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register multiple times in the ECM.	The CPUINTn hardware interrupts can support both pulse and level interrupts so CHIPINTn interrupts should be mapped directly to CPUINTn hardware interrupts. Furthermore, if the ECM is used for other system interrupts, the CHIPINTn interrupts should be masked out in the EVTMASKn registers. 12 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.5 A Single CHIPINTn Interrupt Event Will Register Multiple Times in the DSP Event Combiner Module (ECM)
ARM9	TI	OMAP-L132	When a soft reset is invoked by setting the RESET bit of the USB CTRLR register ( CTRLR[RESET] = 1 ), the internal reset timing requirements may be violated. Although this timing violation has not been observed in practice, the potential for a timing violation exists. USB resets initiated by system-reset and power-on-reset are immune from the timing violation. There is no plan to fix this issue in future silicon revisions because: 1. No functional problems have been observed to date 2. A software workaround has been developed to avoid the problem	The reset timing violation can be avoided by providing the modified soft reset activation sequence outlined below: 1. Enable the USB controller module clock through the Power and Sleep Controller (PSC) 2. Perform a soft USB reset 3. Wait for the USB soft reset bit to clear 4. Disable the USB controller module clock through the PSC 5. Configure the USB PHY parameters 6. Enable the PHY 7. Enable the USB controller module clock through the PSC SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 13 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.6 Potential USB2.0 Soft Reset Timing Violation
ARM9	TI	OMAP-L132	The input buffers on the device have shown timing sensitivity to the logic-low input voltage that can cause changes to the AC input timings. Due to this issue, input voltages must be driven to 0.5V or below on all dual-voltage LVCMOS input signals (signals associated with supplies DVDD1833_A, DVDD1833_B or DVDD1833_C). Vil driven at or below 0.4V will cause no timing degradation. Vil driven up to 0.5V will cause up to 750 ps degradation in input timings. The following datasheet parameters will be affected by Vil driven up to 0.5V. Their values adjusted for 0.75 ns degradation are shown. Table 3. Timing Requirements for the EMIFA SDRAM Interface 1.2V NO. PARAMETER UNIT MIN MAX Input Setup time, read data valid on 19 t 2.75 ns su(EMA_DV-EM_CLKH) EMA_D[31:0] Table 4. Timing Requirements for the EMIFA Asynchronous Memory Interface 1.2V NO. PARAMETER UNIT MIN MAX Setup time, EMA_D[31:0] valid before EMA_OE 12 t 3.75 ns su(EMDV-EMOEH) high Table 5. Timing Requirements for McASP0 1.2V NO. PARAMETER UNIT MIN MAX AHCLKR/X ext input 1.15 Hold time, AFSR/X input after ACLKR/X 6 th(ACLKRX-AFSRX) (1) AHCLKR/X ext output 1.15 ns AHCLKR/X ext input 1.15 Hold time, AXR0[n] input after 8 th(ACLKRX-AXR) ACLKR/X (1) (2) AHCLKR/X ext output 1.15 (1) McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0 (2) McASP0 ACLKXCTL.ASYNC=0: Receiver is clocked by transmitter's ACLKX0 Table 6. Switching Characteristics for McASP0 1.2V NO. PARAMETER UNIT MIN MAX ACLKR/X ext input 3.5 Delay time, ACLKR/X transmit edge to 13 td(ACLKRX-AFSRX) AFSX/R output valid (1) ACLKR/X ext output 3.5 ACLKR/X ext input 3.5 Delay time, ACLKX transmit edge to 14 td(ACLKX-AXRV) ns AXR output valid (1) ACLKR/X ext output 3.5 Disable time, ACLKR/X transmit edge 15 t to AXR high impedance following last ACLKR/X ext 3.5 dis(ACLKX-AXRHZ) data bit (1) McASP0 ACLKXCTL.ASYNC=1: Receiver is clocked by its own ACLKR0 14 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 7. Timing Requirements for McBSP0 1.2V NO. PARAMETER UNIT MIN MAX Setup time, external FSR high before 5 t CLKR ext 5.5 su(FRH-CKRL) CLKR low 7 t Setup time, DR valid before CLKR low CLKR ext 5.5 ns su(DRV-CKRL) Setup time, external FSX high before 10 t CLKR ext 5.5 su(FXH-CKXL) CLKX low Table 8. Switching Characteristics for McBSP0 1.2V NO. PARAMETER UNIT MIN MAX Delay time, CLKR high to internal FSR 4 t CLKR ext 2.75 d(CKRH-FRV) valid Delay time, CLKX high to internal FSX 9 t CLKR ext 2.75 ns d(CKXH-FXV) valid 2.75 + D1 13 t Delay time, CLKX high to DX valid CLKR ext d(CKXH-DXV) (1) (1) Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR. If DXENA = 0, then D1 = D2 = 0 If DXENA = 1, then D1 = 6P, D2 = 12P Table 9. Switching Characteristics for McBSP1 1.2V NO. PARAMETER UNIT MIN MAX Delay time, CLKR high to internal FSR 4 t CLKR ext 3.25 d(CKRH-FRV) valid Delay time, CLKX high to internal FSX 9 t CLKR ext 3.25 ns d(CKXH-FXV) valid 3.25 + D1 13 t Delay time, CLKX high to DX valid CLKR ext d(CKXH-DXV) (1) (1) Extra delay from CLKX high to DX valid applies only to the first data bit of a device, if and only if DXENA = 1 in SPCR. If DXENA = 0, then D1 = D2 = 0 If DXENA = 1, then D1 = 6P, D2 = 12P	Although there is no specific workaround, the following recommendations can be used to help prevent this issue: • Minimize loads as much as possible, especially DC loads that could cause the Vil to rise. Point-to-point (single-load) connections are unlikely to be affected. • Falling edges should transition as rapidly as possible (so the signal passes through the 0.2V point as early as possible). Heavily loaded nodes resulting in degraded fall times may require drivers to provide rapid input edges. SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 15 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.9 Vil on Dual-Voltage LVCMOS Input Buffers Operated at 3.3V
ARM9	TI	OMAP-L132	The VSR register in the ARM Interrupt Controller (AINTC) is not correctly initialized after reset. If this register is not explicitly configured, the AINTC will only allocate 1 byte per interrupt (instead of 4).	The desired value (even if it is the default value) should be written to the VSR prior to using the interrupt controller. 16 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.10 ARM Interrupt Controller Vector Size Register (VSR) Initialization
ARM9	TI	OMAP-L132	Interrupts destined for the ARM CPU are managed by the ARM Interrupt Controller (AINTC). The AINTC detects, combines, and routes system interrupts to the two native ARM interrupt signals FIQ and IRQ. See the device System Reference Guide for additional information about the AINTC. The AINTC module expects all incoming interrupts to be pulse interrupts, however the [SYSCFG_CHIPSIG_]CHIPINTn interrupts are level interrupts. This mismatch in interrupt types will cause a single CHIPINTn interrupt event to register as multiple interrupt pulses in the AINTC. However, the AINTC does not have the capacity to count the number of interrupt pulses received per system interrupt – it only maintains interrupt flags. A system interrupt is flagged as active until its status is cleared by the user through the AINTC, regardless of the number of interrupts detected. If the status flag for AINTC CHIPINTn is cleared while the CHIPINTn interrupt is still active, the AINTC will continue to detect CHIPINTn interrupts and its status flag will be set again. This additional setting of the AINTC CHIPINTn status flag is false.	Method 1 Do not execute the intended interrupt service routine code if the associated CHIPSIGn status flag is not set in the SYSCFG_CHIPSIG register. A cleared CHIPSIGn status flag indicates that the device is responding to a false interrupt. This method is easy to implement, but does not eliminate false interrupts. /** Pseudo code only **/ void CHIPINT0_ISR(void) { /* Exit immediately if CHIPSIG0 is not set */ if( (SYSCFG->CHIPSIG & 0x1) == 0 ) { return; } /* Intended service routine code */ SYSCFG->CHIPSIG_CLR = 0x1; printf("Hello World!\n"); } SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 17 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Method 2 Do not clear the AINTC CHIPINTn status flag until the CHIPSIGn status has been cleared. This method will eliminate false interrupts, but requires changes to the AINTC interrupt dispatch code. Changing the dispatch code may introduce undesired behavior in the application. /** Pseudo code only **/ /* Sequence that is susceptible to false CHIPINTn interrupts */ void AINTC_ISR_DISPATCH_1(void) { Get_Interrupt_Information(); /* CHIPINTn interrupts continue to be generated after */ /* AINTC CHIPINTn flag is cleared. */ Clear_AINTC_Interrupt_Flag(); /* CHIPINTn interrupts are only stopped after ISR clears */ /* the status flag. */ Branch_To_ISR(); } /* Sequence that is not susceptible to false CHIPINTn interrupts */ void AINTC_ISR_DISPATCH_2(void) { Get_Interrupt_Information(); /* ISR will clear CHIPSIGn flag and discontinue CHIPINTn */ /* interrupts to AINTC. */ Branch_To_ISR(); /* Ok to clear AINTC CHIPINTn flag now. */ Clear_AINTC_Interrupt_Flag(); } 18 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.12 A Single CHIPINTn Interrupt Event Can Register Multiple Times in the AINTC
ARM9	TI	OMAP-L132	The C674x CPU supports a Saturation feature for key arithmetic operations. If an operation results in saturation, the SAT (saturation) bit in the control status register (CSR) is set. In normal operation, one or more functional units can simultaneously perform arithmetic operations that can result in saturation. In the case of simultaneous arithmetic operations, the SAT bit is set if at least one functional unit’s operation results in saturation. The saturation status register (SSR) provides saturation flags for each functional unit, making it possible for the program to distinguish between saturations caused by different instructions in the same execute packet. Also, there is no direct connection to the SAT bit in the control status register (CSR); writes to the SAT bit have no effect on SSR and writes to SSR have no effect on the SAT bit. In the case where a 2 cycle .M unit instruction is in the delay slot of a 4 cycle instruction of the same .M unit, and if both instructions are expected to generate results in the same cycle, the CSR:SAT bit will be incorrectly masked. Ideally, the CSR:SAT bit should be set if any one of the two .M unit instruction causes a saturation. Instead, the arithmetic saturation result of the 2 cycle .M unit instruction will overwrite the CSR:SAT bit. All of the following must take place in order for an application to be affected by this advisory: 1. A 2 cycle .M unit instruction and a 4 cycle .M unit instruction are issued simultaneously 2. Both instructions are processed on the same side 3. The 2 cycle instruction is in the delay slot of the 4 cycle instruction so that the results of both instructions are generated in the same cycle 4. The saturation result of the 4 cycle .M unit instruction is different from the saturation result of the 2 cycle .M unit instruction 5. The application checks for the saturation flag and uses the saturation result of the 4 cycle instruction	Perform one of the following: • For the location of code where saturation results are monitored, do not mix datatypes so that 2 cycle and 4 cycle .M unit instructions are not issued together. • Do not mix floating point .M unit instruction with fixed point 2 cycle .M unit instructions. SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 19 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.13 Incorrect Masking of the C674x CSR:SAT Bit
ARM9	TI	OMAP-L132	Note: SDMA refers to all non-CPU requests to the EMC SDMA (Slave Direct Memory Access) port (see Figure 4). SDMA requests are defined as external system bus master requests handled via this port. The C674x Megamodule uses a two-way set associative cache for L1D. This means that every physical memory location in the system has two possible set/way locations in the cache where it can reside. See TMS320C674x DSP Megamodule Reference Guide (Literature Number SPRUFK5) for more information on the L1D cache architecture and related terminology. Updated (dirty) values in L1D cache are not written back to external memory until cache activity evicts a cache-line (victim write-back) or a write-back is requested by software. An L1D cache-line corruption event occurs when all of the conditions in the following steps are met (see Figure 4): 1. L1D cache Lines 1, 2, and 3 have the following characteristics: • Line 1 is associated with L2 SRAM (Line A in Figure 4), was previously read by CPU, and is clean. (CPU has not updated the data.) • Line 2 is associated with L2 SRAM (Line B in Figure 4), was previously read by CPU, and is clean. (CPU has not updated the data.) • Line 3 was previously read by the CPU and may be either clean or dirty. 2. SDMA receives updated data for L2 SRAM Lines A and B, which correspond to L1D cache Lines 1 and 2. 3. A snoop write operation is initiated by the L2 to overwrite the L1D cache Lines 1 and 2 with updated L2 SRAM Lines A and B. Before the snoop write operation finishes, the CPU performs two reads within the same clock cycle: • Line E in L2 cache is read as a cache hit. Line E is destined to replace Line 2 in L1D Cache, which also has a snoop write pending for the updated Line B content. • Line D in L2 SRAM is read. Line D will replace Line 3 in L1D cache. 4. When the snoop write operation completes, Line 2 in L1D cache now contains the updated L2 SRAM Line B data instead of the L2 cache Line E data. The correct behavior would have been to kill the pending snoop write initiated to update L1D cache Line 2 with the updated L2 SRAM Line B data in Step 3. The L1D cache should have evicted Line B and replaced it with Line E data. Instead, the snoop write operation continues and does not complete until after the L1D cache Line 2 has already been replaced with L2 cache Line E data. The snoop write instruction overwrites the L1D cache Line 2 (containing L2 cache Line E data) with the updated L2 SRAM Line B data. 20 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Time Line System View Line A Line E and Line B Map to STEP 1 STEP 2 STEP 3 STEP 4 same L1D Cache line. Line A Line B C674x subsystem Line A Line C C6xCPU Read Line D L2 Line A Line D Activity Read Line E C6X CPU Controller L2 SRAM SDMA Write Line A Snoop Write Line A Line E Activity Write Line B Initiated L1D EMC L2 CACHE L1D Cache Clean Line A Clean Line A IN FLUX Clean Line A Controller SDMA PORT Line 1 (New Data) L1D Cache Clean Line B Clean Line B IN FLUX CORRUPT EMAC Line 2 Line E replaces Line B due Line A Line 1 [A] PRU L1D Cache Clean/Dirty Clean/Dirty IN FLUX Clean Line D to CPU read. Line 3 Line C Line C SYSTEM MASTERS Line A Line 2 [B/E] Delayed snoop wrtie to Line EDMA Line A Line 3 [C/D] B corrupts Line E in L1D$ L1D Corruption happens CACHE EXTERNAL because of this state Figure 4. Example of L1D Cache Corruption	Method 1: Do not perform two CPU read operations in the same clock cycle. For C code, use compiler flag (--c64p_dma_l1d_workaround) available in the C6000 Compiler (CodeGen) Tools version 7.0.2 and later. For assembly code, the -- c64p_dma_l1d_workaround flag will only issue a warning. Method 2: In cases where buffer access will not be shared between CPU and SDMA, unintended CPU/SDMA cache-line sharing can be avoided by aligning CPU and SDMA buffers to 64-byte boundaries. Aligning buffers to 64-byte boundaries will result in wasted space, however it ensures that the CPU and SDMA buffers will not have partial segments which overlap into the same L1D cache line. /** Pseudo code only **/ Uint8 *SDMA_BUFF, *CPU_BUFF; /* 64-byte aligned allocation Option 1 */ SDMA_BUFF = malloc( (Int32) (( SDMA_BUFF_SIZE + 63)/64) * 64 ); CPU_BUFF = malloc( (Int32) ((CPU_BUFF_SIZE + 63)/64) * 64 ); SDMA_BUFF = (Uint8 *) ( (Int32) SDMA_BUFF & ~63 ); CPU_BUFF = (Uint8 *) ( (Int32) CPU_BUFF & ~63 ); /* 64-byte aligned allocation Option 2 with BIOS Call */ SDMA_BUFF = MEM_alloc( IRAM, SDMA_BUFF_SIZE, 64 ); CPU_BUFF = MEM_alloc( IRAM, CPU_BUFF_SIZE, 64 ); SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 21 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Method 3 Manage access to a 64-byte boundary aligned buffer that is shared between CPU and SDMA by implementing a semaphore and forcing cache writeback operations if there are CPU writes. With this method, the semaphore ensures that there is clear ownership of the buffer between CPU and SDMA, and the CPU manages cache coherence by using explicit cache writeback operations. /** Pseudo code only **/ /* Example with EDMA as the external master */ EDMA_ISR() { /* EDMA releases ownership of buffer */ SEM_post(SyncSemaphore); return; } main() { while(COND) { /* CPU waits for ownership of buffer */ SEM_pend(SyncSemaphore); /**********************/ /*** CPU Processing ***/ /**********************/ /* Cache writeback for shared block */ /* Buffer must be 64-byte aligned */ BCACHE_wbInv( blockPtr, blockSize, WAIT ); /* Initiate EDMA */ EDMA_Event_Generate(); } } Method 4 Do not allow SDMA to access L2 RAM. SDMA can use buffers in L1D RAM instead of L2 RAM. Method 5 Configure the entire L2 RAM as cache. Critical peripheral data can be accessed in L1D RAM instead of L2 RAM. Method 6 Configure the entire L2 RAM as normal SRAM (no cache). Method 7 Configure the entire L1D RAM as normal SRAM (no cache). 22 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.17 SDMA Activity Can Corrupt L1D When L2 Is Configured as Mixed/Cache/SRAM
ARM9	TI	OMAP-L132	A condition can occur during the device power supply ramp in which the DVDD18 supply, which should be at 1.8V nominal, can be pulled up on-chip by the DVDD3318_A, DVDD3318_B or DVDD3318_C supplies operated at 3.3V. For the sake of this description, DVDD3318_x means any combination of DVDD3318_A, DVDD3318_B or DVDD3318_C. Important Note: The 3.3V DVDD3318_x supplies must not be driven to 0V during zones A – E or high current capable of damaging the device may occur. The 3.3V DVDD3318_x supplies should not be driven during this time. A normal example power-supply ramp is shown below: A B C D E F G 3.3V VT 1.8V 1.2V Figure 5. Normal power-supply ramp • A. All device supplies are undriven • B. The 1.2V supplies are ramped to their nominal levels • C. Potential delay between supply ramps (not required) • D. The 1.8V supplies (specifically DVDD18) are ramped to their nominal levels. During the DVDD18 ramp there will be some minor drift up in the undriven DVDD3318_x supplies. This is normal and is not a problem. • E. Potential delay between supply ramps (not required) • F. DVDD3318_x is ramping but is less than DVDD18 + VT • G. DVDD3318_x is ramping but is greater than DVDD18 + VT When the fault condition occurs, the supplies behave as shown below: A B C D E F G 3.3V ~2.7V VT 1.2V Figure 6. Faulty power-supply ramp The behavior is the same until zone G. When the DVDD3318_x supply exceeds DVDD18 by a transistor V , the DVDD18 supply begins to be pulled up by the T DVDD3318_x supply and follows the DVDD3318_x supply by DVDD3318_x- V . Since T the DVDD18 supply is often connected to other 1.8V supplies in the design, these other supplies can be pulled up also. SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 23 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com The condition occurs because the dual-voltage IO buffers have voltage detection circuitry that monitors DVDD3318_x during reset and determines whether the applied supply voltage is 1.8V or 3.3V. This detection circuitry then configures the IOs to operate at the appropriate voltage. As the DVDD3318_x supply ramps, there is a small range near DVDD18 + V where the voltage detection circuit finds the state indeterminate and briefly T turns on circuitry associated with both voltage options creating a current path between them. This current path can cause the DVDD18 supply to be pulled up. The mechanism for this behavior is explained below: DVDD3318_x Dual-Voltage IO Buffer Behavior of the IO buffer during Zone F: As the DVDD3318_x supply ramps, but is not yet one V above the T DVDD18 supply, the comparator enables the 1.8V mode logic 3.3V Mode section and disables the 3.3V mode logic section. No unexpected Enable Logic + current flows between the two sections. DVDD18 - 1.8V Mode Enable Logic Iload External Loads Figure 7. Behavior of the IO buffer during Zone F DVDD3318_x Dual-Voltage IO Buffer Error State of the IO buffer during Zone G: As DVDD3318_x exceeds DVDD18+V , some of the circuitry T across the boundary of the two voltage domains will turn on and 3.3V Mode DVDD18 Enable causes a leakage current (in red) to flow between the two voltage Logic + domains. This current pulls up the DVDD18 supply unless the Ileakage power source providing that supply can oppose it or unless the - load current is strong enough to counteract it. Enable 1.8V Mode Logic If DVDD18 continues to rise as DVDD3318_x ramps, the I comparator never sees enough difference between the two load supplies to switch to 3.3V mode. External Loads Figure 8. Error State of the IO buffer during Zone G DVDD3318_x Dual-Voltage IO Buffer Recovered State of the IO buffer during Zone G: If the load current is high enough or the DVDD18 power supply can oppose the leakage current, then the DVDD18 voltage stays low 3.3V Mode enough for: Enable Logic + DVDD18 • the comparator to recognize 3.3V mode • the 1.8V mode logic is turned off - 1.8V Mode • the leakage stops Enable Logic Iload External Loads Figure 9. Recovered State of the IO buffer during Zone G 24 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications This error condition may occur when either of the following conditions are present: • The regulator used to control the DVDD18 supply can only regulate voltage up and relies on the load to pull the output voltage down • There is low load on the DVDD18 supply during the DVDD3318_x power supply ramp This condition will not occur in designs where: • All DVDD3318_x supplies are operated at 1.8V, or • The regulator used to supply DVDD18 has the capability to actively regulate (drive) its output voltage up or down and doesn’t rely on system load to pull the voltage down, or • The load on the DVDD18 supply during the DVDD3318_x power supply ramp is sufficient to oppose the leakage current.	1. Design simulation has indicated that under the worst-case process/voltage/temperature conditions the maximum leakage current into the DVDD18 supply due to this phenomenon will be 140 mA (the 140 mA is a cumulative current generated by all of the dual-voltage IOs). So this error state can be prevented by ensuring that the load on the DVDD18 supply during the DVDD13318_x supply ramp exceeds 140 mA. This can be achieved by any combination of the following as long as they cumulatively produce >140 mA load on DVDD18 during the DVDD3318_x ramp period: (a) Maintain sufficient bulk capacitance on the DVDD18 supply such that the charging current for these capacitors provides all or part of the required >140 mA. Bulk capacitance in this context means the total capacitance seen by the DVDD18 supply (filter capacitors, bypass capacitors, etc.). Capacitor charging current is defined as I = C*(dV/dt). So the ramp rate of the DVDD3318_x supply and the total bulk capacitance on the DVDD18 supply can be used to calculate the current produced. This solution provides additional power supply filtering and little current leakage after the supplies are ramped (depending on the type of capacitors used). The table below shows some examples of the bulk capacitance that would be required to use this solution alone: Table 10. Bulk Capacitance DVDD3318_x ramp dV/dt (in V per second) Required capacitance to generate 140 mA time for 3.3V 100 µs 33000 4.2 µF 250 µs 13200 10.6 µF 500 µs 6600 21.2 µF 1 ms 3300 42.4 µF 10 ms 330 424.2 µF (b) Use an additional shunt regulator to control the voltage at DVDD18. The shunt regulator is placed between DVDD18 and Vss. As an example, the TLVH431 can provide up to 70 mA of additional load current to help maintain the DVDD18 voltage. When the voltage drops back to the normal 1.8V range, the current flow through the shunt regulator drops into the <100 uA range. This solution requires the shunt regulator and two additional resistors to set the desired regulation voltage. (c) Use a resistor to provide additional load between DVDD18 and Vss. This solution is less desirable since it continues to draw power even after the supply ramp is completed but would likely be the lowest cost. An improvement is to use a FET/switch in series with the resistor between DVDD18 and Vss that can later be turned off (by the RESET signal or a GPIO signal for example). SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 25 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 2. Choose a regulator for the DVDD18 supply (or grouped 1.8V supplies) that is capable of actively regulating voltage up and down. Many high-efficiency switching regulators switch current into the load only when the voltage needs to be raised and rely on the load to pulldown the current. In this error condition, a regulator of this type will not be able to compensate for the leakage current described above. Synchronous buck regulators use external inductance to pulldown the regulated voltage when necessary. 26 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.18 DVDD18 Can Pull Up to 2.7V When Using Dual-Voltage IOs at 3.3V
ARM9	TI	OMAP-L132	The USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) allows a USB- peripheral to request the USB-host to enable Vbus and start a session. On this device, the SRP protocol is not supported. The OTG Host Negotiation Protocol (HNP), which allows USB-devices to swap roles between host and peripheral, is supported.	None SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 27 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.19 USB 2.0 On-The-Go (OTG) Session Request Protocol (SRP) Is Not Supported
ARM9	TI	OMAP-L132	: The PUPD_SEL[29] register does not get initialized when the device is first powered on and in Reset. This register controls the internal pullup and pulldown resistors for the BOOT[7:0] pins. The contents of the PUPD_SEL[29] register at this state are unpredictable and may contain random values. These random values can result in the internal pullups being enabled for some or all of the BOOT[7:0] pins during reset after every power-on, which conflicts with the datasheet claim that the internal pulldowns are enabled during reset. Internal pullups being enabled on the BOOT[7:0] pins may result in boot failures. If weak external pulldown resistors are used on the PCB to select the boot mode, they may not be able to overpower the internal pullups. This can result in the wrong boot mode being latched in the BOOTCFG[7:0] register when coming out of Reset. Once the device is out of Reset, the PUPD_SEL[29] register is initialized, and the internal pulldown resistors for the BOOT[7:0] pins are all enabled. Issuing a second Power-On Reset (POR) results in the intended boot mode being latched, since the pins are internally pulled down as expected. Figure 10 shows the behavior of the PUPD_SEL[29] register before and after reset. Assuming weak or no external pull resistors are on the BOOT[7:0] pins, the BOOTCFG register will latch the unknown values after the device initially comes out of Reset. Note that, TRST must always be low in order to issue a POR and latch the boot pin values -- the boot pins are not latched after a Warm Reset. RESET TRST PUPD_SEL[29] Register 0h BOOTCFG[7:0] Registers Figure 10. Initialization of PUPD_SEL[29] and BOOTCFG[7:0] Registers with Weak or No External Pull Resistors on BOOT[7:0] Pins Other device pins with configurable internal pullup or pulldown resistors are always internally pulled down during reset and are not affected by this advisory.	: The following Workaround must be implemented to ensure that the boot pins are always latched correctly: Use strong external pull resistors on BOOT[7:0] pins. Since either the internal pullup or pulldown resistors could be enabled after every power-on, the external resistors must be strong enough to oppose the internal pulls in either case. Section 4, Device Operating Conditions, of the device datasheet shows the electrical characteristics information which can be used to calculate the maximum external pull resistance required. The value is dependent on the DVDD3318_C I/O supply level. For BOOT pins which need to be sampled as logical low, the external pulldown resistance (R ) must be selected by assuming the internal pullup is enabled. The PDmax calculation is shown in Table 11. 28 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications Table 11. Required Pulldown Resistance (R ) for Logical Low BOOT Pins PDmax æ V ö IL ç ÷ DVDD3318_C I V I IL è I R I ø PDmax 3.3 V 310 µA 0.80 V 2.58 kΩ 1.8 V 310 µA 0.80 V 2.03 kΩ For BOOT pins which need to be sampled as logical high, the external pullup resistance (R ) must be selected by assuming the internal pulldown is enabled. The calculation PUmax is shown in Table 2. Table 12. Required Pullup Resistance (R ) for Logical High BOOT Pins PUmax æ DVDD 3318 _ C - V ö IH ç ÷ DVDD3318_C I V I IH I è I ø RPUmax 3.3 V 270 µA 2.00 V 4.81 kΩ 1.8 V 270 µA 1.17 V 2.33 kΩ SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 29 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.23 BOOT: Internal Pullup Resistors for BOOT[7:0] Pins Are Sometimes Enabled During Reset, Leading to Boot Failures
ARM9	TI	OMAP-L132	: The ROM bootloader (RBL) reads a NAND page in segments of 512 bytes (user data) over the External Memory Interface A (EMIFA). The EMIF also reads the associated ECC data which is stored in the spare area of the flash (as shown in Figure 11). The ECC Correct function in the RBL can correct up to 4 bit errors in the user data and/or ECC data by using the syndrome generated from the ECC data and the parity of the user data calculated by the EMIFA module. However, over the life span of the NAND flash, ECC data stored in the spare area can develop errors due to bit flips. When the calculated syndrome indicates an error in the ECC data, the ECC Correct and Read functions of the RBL abort the read process even though, it is possible to correct up to 4 bit errors combined in user and ECC data. Consequently the device fails to boot. Explanation of Current ROM Bootloader Behavior: The RBL implements a search mechanism to look for the boot image in NAND flash by using an Open function and a Read function. The Open function includes a bad block check where the RBL skips to the next block (shown as (A) in Figure 11) if the block under consideration is marked as "bad" (in the spare area). On finding a good block, the RBL attempts to read page0 (the first page) in that block. If page0 of the good block has an ECC data error or an uncorrectable error (more than 4 bit errors combined), the RBL skips to the next block (shown as (B) in Figure 11). This bad block check mechanism enables the device to check up to the first 32 blocks in the NAND flash for booting (the boot process will fail if all 32 blocks have uncorrectable or ECC data errors in page0). Note that the RBL does not abort on detecting an error in ECC data on page0. Once the RBL finds a good block with a good page0, it continues to read subsequent pages in that block. If an uncorrectable or ECC error is detected in subsequent pages, the RBL will abort with a boot error (shown as (C) in Figure 11). The workaround, described below, enables the boot process to continue for both types of errors (ECC data and uncorrectable errors). 30 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications (1) All pages marked in green are good and all pages marked in red have "uncorrectable" errors. Figure 11. D800K008 ROM Behavior Before Application of Software Patch(1)	: The workaround ignores errors in ECC data (these errors do not need to be corrected) so that the boot process can continue, correcting errors in the user data (up to 4 bit errors total), as necessary. The workaround also includes a mechanism to restart the NAND read process from the next good block if an uncorrectable error (more than 4 bit errors) is detected on any page of a good block. This workaround is implemented using a software patch that is loaded in device RAM at boot time and is designed to change the default behavior of the ECC Correct and Read functions in the RBL. The patch binary replaces function pointers to the ECC Correct and Read functions in the ROM function table, (defined in device internal memory), during boot. The patch binary will reside in page0 of the NAND block and so will be applied only after the page0 of a good block has been read. Once the patch is read, all subsequent page reads in the block will use the new ECC Correct and Read functions. ECC data errors on any page (other than page0) are ignored, any user data error (up to 4 bit errors total) is corrected and the boot process continues. If an uncorrectable error is detected on any page, the block is skipped and the boot process is restarted on the next good block. The behavior of the device boot from the NAND after application of the patch is shown in Figure 12. SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 31 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com (1) All pages marked in green are good and all pages marked in red have "uncorrectable" errors. Figure 12. D800K008 ROM Behavior With Software Patch Applied(1) The software patch is available as a pre-built file with the latest version of the AIS tool that is used to generate the NAND flash boot image. The Using the OMAP-L132/L138 Bootloader Application Report (Literature number: SPRAB41) provides a link to the install package for the AIS tool which includes the following in the install directory: prebuilt patch files, the GUI AIS generation tool (AISGEN.exe, version 1.11 or later), command-line AIS generation tool and an example INI file. Application of the Software Patch to NAND Boot Images: • For the GUI tool, AISGEN.exe version 1.11 or later (found in the install directory), the patch integrates the modified ECC Correct function into the user application file to generate one binary AIS file. • For the Command line AIS tool, HEXAIS_OMAP_L138.exe users (found in the install directory), the patch can be integrated into the user application file to generate one binary AIS file by inserting lines below to the end of the INI configuration file. The patch name is: ARM_nand_ecc_patch_OMAP-L138.out 32 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications [INPUTFILE] ; get the NAND ECC patch file FILENAME=Patch_name.out ; patch the NAND ECC handling routine [AIS_Jump] LOCATION=_NAND_ECC_patchApply • The patch will be burnt on page0, as it is in the head of AIS file. Once page0 has been read successfully, the AIS set command will overwrite the function pointer in the RBL with the modified function pointer and the modified function will be applied to the later pages read. Memory usage of the patch at boot time is as follows: – 500 bytes at location 0xFFFF 0B00 Recommendations to Improve Robustness: • Page0 should be stored on multiple blocks as backup to take advantage of the safety mechanism built into Silicon Revision 2.1 to cycle to the next block when a page0 read fails in a good block. • Maintain backup boot images in multiple blocks. The patch to the Abort function reinitializes the boot process and forces the boot to cycle to the next good block and restart the boot process by reading from it. • Silicon Revision 2.1 supports booting from Block 0 of the flash which many NAND manufacturers guarantee as a “more reliable” block than all other blocks. Hence, setting up boot to start from that Block 0 could help improve the reliability of boot. This is a hardware change, requiring the bootmode pins BOOT[6:5] = 1x. For more details on the bootmode pins, see the Using the OMAP-L132/L138 Bootloader Application Report (Literature number: SPRAB41), NAND-Boot Modes. SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 33 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.24 Boot: ECC Data Error in Spare Area Causes NAND Boot Failure
ARM9	TI	OMAP-L132	When CPPI DMA completes a receive data transaction it posts a write to the Rx data buffer located in external memory, posts a write to update the descriptor located in external memory, and raises an interrupt to CPU. When the system load is high, the posted writes to DDR may not be complete before the CPU receives the interrupt. In this case, the CPU would fetch stale receive data from the Rx data buffer located in external memory.	Initialize the datalength descriptor field to zero. CPPI DMA updates this field after the completion of an RX DMA operation with the actual number of bytes received. In the ISR (actually in a deferred call context), poll this field until it becomes a non-zero value to ensure data buffer has been updated with actual data. The descriptor buffer write is posted after the data buffer write, so waiting for the descriptor field to be updated ensures the data buffer has been updated. Since this workaround involves deferred procedure calls (whose schedule can be delayed depending on OS load), the latency sensitive application (like ISO Audio) might be affected by delay in notification to the application. 34 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications	2.3.25 USB0: CPU gets Stale Receive Data from the Data Buffer located in External Memory
ARM9	TI	OMAP-L132	The erroneous short packet status can be detected on current endpoint and XDMA closes the Rx transfer in current endpoint. When more than one endpoint have been processed, if one of the endpoints has a short packet, then the short packet status is broadcasting to all endpoints. This results in premature completion of a Rx descriptor in generic RNDIS CPPI DMA mode.	The workaround involves monitoring transfer data size before and after transferring and reconfiguring data transfer size by software if the before and after size is different. Software must keep tracking every endpoint data transferring size. When DMA completion interrupt is received, software checks size difference. If the size is not equal, software requests the remaining data. SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 35 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated Silicon Revision 2.3 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com	2.3.26 USB0: Early DMA Completion in DMA Receive Mode and More Than One Endpoint is Transferring Data
ARM9	TI	OMAP-L132	Teardown receive DMA is not working perfectly. This happens when a teardown is initiated by software during the endpoint is still active. Frequent teardown results in XDMA hung up situation.	Software should make sure that DMA does not get to an unknown state during teardown by disabling the DMAEN bit in the RXCSR register. After this the teardown procedure can be initiated. Software should also add 250 ms delay during teardown. 36 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 3 Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 2.1 and earlier of the device. 3.1 Usage Notes for Silicon Revision 2.1 Usage notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These usage notes will be incorporated into future documentation updates for the device (such as the device-specific data sheet), and the behaviors they describe will not be altered in future silicon revisions. Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.2, Silicon Revision 2.3 Known Design Exceptions to Functional Specifications. 3.2 Silicon Revision 2.1 Known Design Exceptions to Functional Specifications The advisories are not enumerated in sequential order and hence some numbers may not appear in the document Table 13. Silicon Revision 2.1 Advisory List Title ................................ Page	2.3.27 USB0: DMA Hung up in Frequent Teardowns
ARM9	TI	OMAP-L132	Under conditions in which the device is subjected to large variations in operating temperatures, the USB0 PLL temperature compensation circuitry does not have enough margin to guarantee compensation for PLL drift across all temperature ranges. As a result, the mean frequency generated by the USB0 (USB 2.0 OTG) PHY PLL will begin to drift (relative to the expected 480 Mbps) when the temperature of the device is subjected to large swing from the original temperature in which the USB0 PHY was most recently calibrated (initialized). Once the onset of PLL drift occurs, the mean frequency will continue to drift outside the expected frequency and will eventually cause the PLL to lose lock resulting in failure of USB packet reception and/or transmission. This break in transmission will continue until the USB0 PHY is recalibrated during a USB0 PHY Reset. If the device is not exposed to large variations in temperature relative to the temperature at which the USB0 PHY was most recently initialized, the temperature compensation circuitry is expected to provide the proper compensation to prevent the mean PLL frequency from losing lock and beginning to drift. More specifically, this advisory is most applicable in applications where the device is expected to operate outside the commercial temperature range of 0˚C to 90˚C. TI has identified a point-to-point device temperature range in which there is a very high confidence the compensation circuitry will properly compensate for all temperature variations, provided the USB0 PHY was most recently initialized (calibrated) within this same temperature range. Operating outside the 0˚C-65˚C temperature range increases the susceptibility of the device to experience PLL drift, but does not mean that the application will always experience a failure in USB transmission. Root Cause The Voltage Controlled Oscillator (VCO) Compensation circuitry local to the USB0 PHY was not designed with a large enough range to compensate for all variations in temperature across the specified operating range of the device. How to Most Easily Reproduce the Issue: Reproduction of this issue can most easily be accomplished by the following steps: 1. Allowing the unit to soak in an ambient temperature of -35˚C until the device temperature reaches approximately the same temperature. 2. Power up the device and provide the necessarily software programming in order to invoke the USB Signal Quality Test Pattern. 3. Using a USB 2.0 Certified Test Platform, execute the USB signal quality test procedure across the following temperature set points. -35˚C, 0˚C, +35˚C, +70˚C. Record the measured mean frequency by the compliance software. NOTE: The set points can be varied to obtain finer temperature resolution of when the PLL begins to drift a per platform basis. The above temperature profile is provided for reference. 38 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 SPRZ317G – August 2011 – Revised March 2014 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated www.ti.com Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications	When a break in transmission is detected, USB0 traffic can be recovered by a software reset of the USB0 PHY. A PHY reset implies recalibration of the PHY PLL at the reset temperature. The system has not been observed to reliably recover on its own. A PHY reset also implies re-enumeration of all devices. There is no way to recalibrate the USB0 PHY without a re-enumeration. In order to invoke the recovery mechanism (that is a USB0 PHY reset) one needs to determine when the issue is present. One such approach is to look for an absence of USB0 Core interrupts over a specified time window. This window should be optimized for the expected USB traffic based upon the application. As an additional safeguard, an application can also intentionally schedule pre-determined USB PHY resets at specific temperature points if operation over a broad range is expected. Here is an example of one way to power cycle the USB0 PHY via the Chip Configuration 2 Register in the System Configuration (SYSCFG) Module: #define CFGCHIP2 *((volatile unsigned int *) 0x01C14184) #define USBPHY_PHYPDWN 0x00000200 Void phy_reset(void) { CFGCHIP2 |= USBPHY_PHYPDWN; /* Power down the USB PHY */ mdelay(1); /* Wait 500ms */ CFGCHIP2 &= ~USBPHY_PHYPDWN; /* Power up the USB PHY */ } SPRZ317G – August 2011 – Revised March 2014 OMAP-L132 C6000™ DSP+ARM® Processor Silicon Revisions 2.3, 2.1 39 Submit Documentation Feedback Copyright © 2011–2014, Texas Instruments Incorporated	2.1.21 USB0 PLL Mean Frequency Can Drift Across Large Temperature Swings
Cortex-A8	NXP		: Unaligned access to AIPS can be driven high by SAHARA, DAP, and FEC. If they access the AIPS internal registers during an unaligned access, an ABORT occurs. Projected ImpactJEEHEHRECONSTRUCT: Unaligned accesses to the AIPS internal registers fail.	: Make only aligned accesses to the AIPS internal registers.	11136 AIPS: Unaligned access causes abort on writes to the internal registers
Cortex-A8	NXP		: If a sequence of load and store operations are performed to different address locations in a memory region that is marked as shared device, then a load can incorrectly bypass a store. The issue is reported by ARM, erratum ID 709718, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If the load address and store address are mapped to access the memory region of the same device, and the device relies on memory operations to occur in program order, then this device may not operate as intended.	: The erratum occurs only for the shared device memory regions and not for the non-shared device memory regions. Therefore, this problem can be worked around by using the remap registers to remap all the shared device transactions to the non-shared device. The only difference between the shared device and the non-shared device is the attributes produced for the transaction on the AXI interface. Therefore, the user does not experience any impact in terms of performance from this workaround. Another possible use of the TEX remap is to map the shared device regions to the strongly ordered transactions. This second remapping option is less desirable as it affects the performance, as strongly ordered transactions are not buffered. The following code sequence is required to setup and enable the TEX remap. This should be done before enabling the MMU. ; Setup PRRR so device is always mapped to non-shared MRC p15, 0, r0, c10, c2, 0; Read Primary Region Remap Register BIC r0,#3<<16 MCR p15, 0, r0, c10, c2, 0; Write Primary Region Remap Register ; Enable TEX remap MRC p15, 0, r0, c1, c0, 0; Read Control Register ORR r0,r0,#1<<28 MCR p15, 0, r0, c1, c0, 0; Write Control Register Another valid workaround is to place a data memory barrier (DMB) between all the memory accesses to the device regions, where ordering is required between a store and a subsequent load to a different physical address.	09831 ARM: Load and Store operations on the shared device memory regions may not complete in program order
Cortex-A8	NXP		: Under certain conditions, a sequence of instructions where an MCR instruction that writes a CP15 register is closely followed by an MRC that reads the same register, are executed such that the RAW hazard is not detected and the MRC reads the old value of the register. This scenario can only occur for accesses to one of the following four CP15 registers: â¢ CacheSizeSelection Register â¢ Thread and ProcessID user read/write â¢ Thread and ProcessID user read only â¢ Thread and ProcessID privilege only These registers are both readable and writable and have been optimized to execute in a single cycle. Furthermore, this scenario occurs only when a specific sequence of instructions is executed between the MCR and the MRC. The sequence must meet two criteria: â¢ It must take less than three cycles to execute â¢ It must have one of the instructions in the following list: â ARM PLD with [Rn, -Rm, <shift>] addressing mode â ARM or Thumb PLD with [Rn, Rm,<shift>] addressing mode (unless it is LSL #0 or LSL #2) â Thumb or ThumbEE load/store instruction with [Rn, Rm,<shift>] addressing mode (unless it is LSL #0 or LSL #2) â Thumb TBB instruction The issue is reported by ARM, erratum ID 588115, Category 31. Projected ImpactJEEHEHRECONSTRUCT: If this erratum is encountered, the old stale value of the register is read rather than the newly written value, in which case the system software may appear to behave incorrectly. However, the usage model for such a software sequence is unclear, and hence the likelihood of encountering it in practice is very low, especially considering the requirement of the second unrelated instruction that must also fall between the MCR and the MRC.	: If a workaround for this erratum is desired, there are two options. The first simple option is to add a NOP immediately following the MCR register write in any case where encountering this erratum may be a concern. By adding a single NOP, the minimum required cycle window is guaranteed and the erratum does not occur. The second option is to set bit 16 in the CP15 Auxiliary Control Register. This causes a pipeline flush on every write to the CP15 register and ensures that the RAW hazard condition does not 1. Category 3 defined as: Behavior that is not the originally intended behavior but should not cause any problems in applications. Chip Errata for the i.MX53, Rev. 6 Freescale Semiconductor 11	11132 ARM: A RAW hazard on certain CP15 registers can result in a stale register read
Cortex-A8	NXP		: All memory transactions performed as part of a tablewalk should be considered Privileged, even in the User mode. However, Cortex-A8 incorrectly marks memory transactions generated from tablewalks performed in User mode as the user transactions on the AXI bus. This indication is given by the ARPROT[0] signal, which is set to zero during the transaction. The conditions are as follows: â¢ Cortex-A8 must be in user mode â¢ A memory transaction (instruction or data) misses in the TLB and causes a tablewalk â¢ The address for the page table entry is not found in the L2 cache, resulting in an external memory request â¢ This erratum occurs when APROT[0] incorrectly indicates a user transaction for this memory request on the AXI bus. The issue is reported by ARM, erratum ID 488063. Projected ImpactJEEHEHRECONSTRUCT: As the values broadcast on ARPROT[0] are completely transparent to the software, the implications for this erratum are only on a specific subset of the processor systems, specifically for a system that includes some form of system level memory protection unit, that uses the ARPROT bits to determine if a memory request can be allowed. For any system that does include such a unit, that unit may report false errors on page table accesses due to this erratum.	: As the processor directly does not make use of ARPROT[0], any workaround would be specific to the device that makes use of the values broadcast on ARPROT[0]. The most likely usage would be some form of system memory protection unit. If such protection unit exists, it may need to filter out any access to the page tables from the address space that is protected to operate properly. This implies that the external protection unit cannot provide additional protection for the page tables. For example, the page table cannot be inserted in a Secure RAM which cannot be accessed in User mode, as in this case, an additional protection is added beside the MMU. Alternatively, the CSU can be configured to transform User access to Privileged on addresses used by PAGE TABLE.	11141 ARM: ARPROT[0] is incorrectly set to indicate a USER transaction for memory accesses generated from user12SPACEJEEHEHtablewalks
Cortex-A8	NXP		: ARMv7 architecture specifies that the CSSELR should be banked between Secure and Non-secure states. Cortex-A8 does not currently bank this register. The conditions are as follows: â¢ The system should have an active process in secure state and an active process in non-secure state at the same time. â¢ The system should perform cache maintenance operations in both secure and non-secure processes. The issue is reported by ARM, erratum ID 485963, Category 21. Projected ImpactJEEHEHRECONSTRUCT: A cache cleaning sequence that reads the CSSELR may not work as expected. The published sequence for cleaning the entire cache (see ARM Architecture Reference Manual) includes setting the CSSELR followed by a read from the selected Cache Size ID register (CCSIDR). If the non-secure side executes this sequence, and is encountered by a secure interrupt between the setting of the CSSELR and the reading of the selected CCSIDR, then there is a possibility that the secure side may also use the CSSELR. On returning to the non-secure side, the CSSELR value may have changed, which makes the cache cleaning sequence to malfunction. Similarly, a non-secure interrupt can cause a secure cache cleaning sequence to malfunction.	: When transitioning security state, the secure monitor software should save the current CSSELR value (corresponding to the security state the processor is transitioning out of) and restore the previously saved CSSELR value (corresponding to the security state the processor is transitioning into).	11135 ARM: C15 Cache Selection Register (CSSELR) is not banked
Cortex-A8	NXP		: When a Clean to Point of Coherency (PoC) by MVA operation is performed, or the Preload Engine is programmed to clean a region of memory from the L2 cache, a cache line from that region can be corrupted with a stale copy of memory, and a memory store operation is lost. The conditions are as follows: â¢ A Cache Clean by MVA to the PoC instruction is executed to clean cache line A, or the preload engine is configured to clean a memory region which includes cache line A. Either of the operations result in the placement of cache line A into a victim buffer for writeback to external memory. It also keeps the line still valid in the L2 cache. â¢ A memory store operation is performed to the same cache line A that is evicted by the cache clean operation. This operation results in a modification of cache line A in the L2 cache (but not to the copy of the line that may still remain in the victim buffer if memory response is slow). â¢ A cache eviction is done of cache line A due to an unrelated memory request to load cache line B. The modified copy of cache line A is placed in a victim buffer. At this point, the two victim buffers may contain two different versions of cache line A. As each victim buffer uses a different AXI ID and arbitrates independently for the AXI bus, there is no guarantee for the order in which the memory updates occur, and the store operation may be overwritten by the cache clean operation, leaving the external memory with stale contents. The issue is reported by ARM, erratum ID 586323, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If the operation sequence occurs as described above, one or more store operations are lost, resulting in incorrect program behavior. This can occur for any application which either uses the preload engine to clean a memory region, or uses Clean by MVA to PoC maintenance operations to clean a region of memory.	: There are two feasible workarounds that can be used for this erratum. The first workaround is to place a DMB or DSB barrier at the end of each cache clean routine or preload engine memory clean sequence. This barrier operation ensures that the cleaned line goes out and is seen by main memory before the store is executed and therefore guarantees that the clean is done correctly and memory contains the correct final value. This workaround is consistent with the ARM recommended practice for ending the maintenance routine. The above workaround is convenient to implement and should work for all expected usage models. However, there is still the possibility that an interrupt can be taken during the clean routine, and the interrupt handler can perform a store operation to the line just cleaned, allowing for the scenario which can lead to the erratum. 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX53, Rev. 6 16 Freescale Semiconductor11143 Another workaround that avoids even the case mentioned above, is to convert all Clean by MVA to PoC operations to Clean and Invalidate by MVA to PoC as described in the code sequence as follows: â¢ Replace all uses of: MCR p15, 0, <Rn>, c7, c10, 1; â¢ Clean Data cache line by MVA to PoC with this instruction: MCR p15, 0, <Rn>, c7, c14, 1; â¢ Clean and Invalidate cache line by MVA to PoC. There is no Preload Engine equivalent for the second workaround option as it is not possible to configure the preload engine to perform a clean and invalidate operation. Therefore, if there are concerns that the DSB based workaround is insufficient, then it is advisable to not use the Preload Engine for cleaning memory regions. The preload engine can be configured such that it is not accessible at user/privilege and nonsecure/secure level of granularity. For more information on Preload Engine configurability, see Cortex-A8 Technical Reference Manual.	11143 ARM: Cache clean memory ops generated by the Preload Engine or Clean by MVA to PoC instructions may corrupt the memory
Cortex-A8	NXP		: If a non-cacheable memory request is subsequently followed by any cache maintenance operation done by MVA, then the memory can be corrupted. The conditions are as follows: â¢ The L1 data cache must be of size 32 Kbyte â¢ The L1 data cache hardware alias checks are enabled (the L1ALIAS bit in the Auxiliary Control Register is set to 0) â¢ The virtual memory management used by the operating system does not follow the page coloring guidelines and allows virtual to physical address alias cases to exist on bit 12 of the address â¢ A non-cacheable memory request to normal, device, or strongly ordered memory is subsequently followed by a cache maintenance operation done by MVA without any cacheable memory operations executed in between. The non-cacheable memory request can be fully executed, or can be a speculative instruction in the branch shadow that subsequently is flushed. When the above conditions are met and the cache maintenance operation is performed to generate a hash alias scenario on its cache lookup, memory corruption or a false parity error can occur. The issue is reported by ARM, erratum ID 586324, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If the operation sequence occurs as described above, then memory can be corrupted or a false parity error can be generated. In addition, even if the workaround as described below is implemented, it is possible that a nonsecure maintenance operation could result in the invalidation of a secure memory location. Therefore, this could possibly be viewed as an avenue for a security attack. However, the contents of secure memory cannot be viewed as a direct result of this erratum and the lack of consistent repeatability makes it very difficult for the user to make use of this erratum as a security attack.	: If full PIPT caching support is not required by the operating system, or the processor includes a 16 Kbyte L1 data cache, then no workaround is required. If alias conditions can occur, then the workaround is to guarantee that a cache maintenance operation is not immediately preceded by a non-cacheable memory request. This is guaranteed by initiating every cache maintenance by MVA routine with a cacheable load or store request immediately preceding the main loop and ending with a DSB barrier operation at the end of the loop. The load or store that precedes the loop can be done to any cacheable memory location. In addition, both interrupts and aborts should be masked during the cache maintenance routine. Interrupt masking is required to prevent a non-cacheable memory request, either fully executed or in a branch shadow, from initiating the sequence that can 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX53, Rev. 6 18 Freescale Semiconductor11145 result in this erratum. If there are concerns about the interrupt latency, the maintenance loop can be amended to enable and disable the interrupts directly around the maintenance operation. This impacts the time taken to complete the maintenance loop. To workaround any concerns of a potential security attack due to this erratum, all secure memory should be marked as inner write through. This can be done either by using the caching attributes in the page tables for all secure page tables or by making use of the secure banked version of the remap registers. Apart from making all secure memory write through, a routine should be run out of reset to completely fill the cache with dummy data, to prevent invalid, uninitialized data in the cache from being written out to memory and potentially corrupting secure memory. Making all secure memory inner write through guarantees that even if the invalidation of a secure line in the L1 cache occurs due to this erratum, the correct data is not lost.	11145 ARM: Under a specific set of conditions, a cache maintenance operation performed by MVA can result in memory corruption
Cortex-A8	NXP		: When a Clean to Point of Coherency or Clean and Invalidate to Point of Coherency by MVA operation is performed, it is possible that the line remains present in the L2 cache and any dirty data is not pushed out on to the AXI bus to main memory. This can occur whenever the requested address is present in the L1 cache but not the L2 cache. The conditions are as follows: â¢ The memory region being cleaned is configured in write allocate mode â¢ The cache line being cleaned is initially present in the L1 cache and not in the L2 cache The issue is reported by ARM, erratum ID 586320, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If a Clean or Clean and Invalidate operation does not operate as intended, and leaves the data present in the L2 cache, the memory coherency in the system can no longer be guaranteed. Therefore, this erratum impacts any code sequence used to maintain the system coherence.	: The software workaround for this erratum is to disable the write allocate in the L2 cache, as shown in the following instruction sequence: MRC p15, 1, <Rd>, c9, c0, 2; read L2 cache Aux Ctrl Reg ORR <Rd>, <Rd>, #(1 << 22); set the Write Allocate disable bit MCR p15, 1, <Rd>, c9, c0, 2; write the L2 cache Aux Ctrl Reg Disabling the write allocate in the L2 cache can impact the performance of some applications. If this performance impact is deemed to be very high, there are two other software workarounds that can be used. The first is to disable write allocate around each sequence of clean by MVA to PoC or clean/invalidate by MVA to PoC instructions, as shown in the following instruction sequence: MRC p15, 1, <Rd>, c9, c0, 2; read L2 cache Aux Ctrl Reg ORR <Rd>, <Rd>, #(1 << 22); set the Write Allocate disable bit MCR p15, 1, <Rd>, c9, c0, 2; write the L2 cache Aux Ctrl Reg <perform sequence of MVA operations here> MRC p15, 1, <Rd>, c9, c0, 2; read L2 cache Aux Ctrl Reg BIC <Rd>, <Rd>, #(1 << 22); clear the Write Allocate disable bit MCR p15, 1, <Rd>, c9, c0, 2; write the L2 cache Aux Ctrl Reg The final workaround that can be implemented is to perform each maintenance operation twice with interrupts disabled. By performing the operation twice in back-to-back successions with no other memory operations executed in between, it can be assured that the line is evicted from both L1 and L2 cache and written out to main memory. 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX53, Rev. 6 20 Freescale Semiconductor11142 Perform the following steps: 1. Disable the interrupts and the imprecise aborts 2. Execute the maintenance operation first pass 3. Execute the same maintenance operation, second pass 4. Enable the interrupts and the imprecise aborts Repeat the above sequence for each cache maintenance operation. Interrupts can remain disabled for a longer sequence of maintenance operations, but this has a negative effect on interrupt latency. This workaround has a performance impact on the execution time of cache maintenance operations.	11142 ARM: Clean and Clean/Invalidate maintenance ops by MVA to PoC may not push data to external memory
Cortex-A8	NXP		: Under specific set of conditions, the stale data saved in the L2 cache can be erroneously returned to the processor on a subsequent load instruction. The conditions are as follows: â¢ The L2 cache must be configured as an inner cache rather than as an outer cache â¢ The L2 cache must be configured to use write allocate memory type The issue is reported by ARM, erratum ID 468413, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If this erratum occurs, stale data can be read by a subsequent load instruction, resulting in an incorrect program behavior.	: There are two viable workarounds for this erratum. One workaround is, not to configure the L2 cache as an inner cache, but maintain the default setting as an outer cache. The second workaround is to use the remap registers to remap the inner cache attributes from write allocate to write back instead.	11146 ARM: Incorrect L2 cache eviction can occur when L2 is12SPACEJEEHEHconfigured as an inner cache
Cortex-A8	NXP		: Three memory requests in the L2 cache can interact and result in a deadlock condition. The exact scenario involves a dependency chain of three requests, an instruction fetch request, a memory preload instruction (PLD) and a swap instruction (SWP). In this dependency loop, no request can progress as each one of them is dependent on the next request. That is, the PLD request cannot complete as the IF request is pending to use the BIU. The IF request cannot complete because of the pending SWP request, and the SWP request is not allowed to complete as it is waiting on the PLD to complete before obtaining the lock on the bus. The conditions are as follows: â¢ PLD instructions must be used by the processor â¢ SWP instructions must be used by the processor The issue is reported by ARM, erratum ID 468415, Category 31. Projected ImpactJEEHEHRECONSTRUCT: This erratum only impacts the users of swap instructions. Swap instructions have been deprecated from the ARMv7 version of the ARM Architecture as its functional use in terms of setting up semaphores is now replaced from the ARMv6 architecture forwards by the LDREX and STREX instructions. If this erratum is encountered and the processor deadlock occurs, it can only be interrupted by resetting the processor.	: One software workaround for this erratum is, not to use the swap instructions. If swap instructions are to be used in the code base, the other software workaround is to disable the PLD instructions and make them a NOP. The code required to implement this workaround is as follows: MRC p15, 0, r0, c1, c0, 1; read register ORR r0, r0, #(1<<9); PLDNOP - force PLD to be NOP MCR p15, 0, r0, c1, c0, 1; write register This workaround has some performance impact on the peak memory copy bandwidth.	11144 ARM: Swap instruction, preload instruction, and instruction fetch request can interact and cause deadlock
Cortex-A8	NXP		: Under very specific set of conditions, data from a Neon load request can be incorrectly forwarded to a subsequent, unrelated memory request. The conditions are as follows: â¢ Neon loads and stores must be in use â¢ Neon L1 caching must be disabled â¢ Trustzone must be configured and in use â¢ The secure memory address space and the non-secure memory address space both use the same physical addresses, either as an alias or the same memory location or for separate memory locations The issue is reported by ARM, erratum ID 468414, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If this erratum is encountered, it is possible for a load request to receive the wrong data value which can likely result in incorrect operation of the program.	: There are many software solutions for this erratum and only one has to be applied. The recommended solution, if possible, is to map cacheable areas of memory so that both secure and non-secure do not share the same physical address space. Another possible solution is to force NEON to cache in the L1 data cache. This can be programmed using the Auxiliary Control Register bit [5], L1NEON, as follows: MRC p15, 0, r0, c1, c0, 1; read register ORR r0, r0, #(1<<5) ; L1NEON caching enable MCR p15, 0, r0, c1, c0, 1 ; write register. Another possible solution is to disable L2 data forwarding from the victim buffers. This can be programmed using the L2 Auxiliary Control Register bit[27], Load data forwarding disable as follows: MRC p15, 1, r0, c9, c0, 2 ; read register ORR r0, r0, #(1<<27) ; L2 load data forwarding disable MCR p15, 1, r0, c9, c0, 2 ; write register Both workarounds can be implemented with little or no perceived performance impact in the majority of applications.	11133 ARM: NEON load data can be incorrectly forwarded to a12SPACEJEEHEHsubsequent request
Cortex-A8	NXP		: If a load request is processed which misses the L2 cache, but cannot be immediately forwarded to the BIU, it encounters a special hazard which prevents the request from being required to access the L2 cache RAM again to save power. There can be multiple requestors with unique addresses, (that is, one address per cache line) with this special hazard. All write-allocate requests that access the L2 cache RAM, on port1, do not have address comparators to check for this special hazard condition. So, if a subsequent write-allocate request is issued to the L2 cache RAM on port1 and allocates a victim buffer, then all requests pending with this special hazard must be forced to perform a L2 cache RAM lookup again to maintain memory coherency. There is a 1-cycle window in which the write-allocate request must allocate to a victim buffer and a pending request to the BIU is not prohibited from going to the BIU, such that a deadlock can occur. The conditions are as follows: â¢ The processor must have L2 cache present and enabled. â¢ The L2 cache must be configured to support the write allocate memory type. The issue is reported by ARM, erratum ID 468416, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If this erratum is encountered and processor deadlock occurs, it can only be interrupted by asserting RESET on the processor.	: The workaround for this erratum is to disable write-allocate by programming the L2 Auxiliary Control Register bit[22], Write allocate disable: MRC p15, 1, r0, c9, c0, 2; read register ORR r0, r0, #(1&lt;&lt;22); Write allocate disable MCR p15, 1, r0, c9, c0, 2; write register Disabling write allocate in the L2 cache could have a performance impact for some applications.	11134 ARM: Under a specific set of conditions, processor deadlock can occur when L2 cache is servicing write allocate memory
Cortex-A8	NXP		: In the register AMC of the Tiger/ARM Platform (0xBASE_0018) the bit ALPEN must be set to 1 and ALP[2:0] must be set to â000â. Other combinations are reserved and must be avoided. Projected ImpactJEEHEHRECONSTRUCT: Memory retention issues unless the guideline is followed.	: None	11212 ARM: Clarification regarding the ALP bits in AMC register
Cortex-A8	NXP		: If the PMU is in use and an overflow event occurs simultaneously with a write to one of the subsets of CP15 and CP14 registers, the overflow event can be lost. The conditions are as follows: 1. The performance counters must be in use 2. The performance counter must have an overflow (counter value goes beyond 0xFFFF_FFFF) 3. Simultaneous with the counter overflow, a MCR instruction must be executed that writes to one of the following CP14/CP15 registers: â Any PMU register other than PMU counter registers â ThumbEE Configuration Register â ThumbEE Handler Base Register â System Control Register â Auxiliary Control Register â Secure Configuration Register â Secure Debug Enable Register â Nonsecure Access Control Register â Context ID and Thread ID Registers â Coprocessor Access Register â Cache Size Select Register The issue is reported by ARM, erratum ID 628216, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If the erratum occurs, the overflow status flag is not set for that counter in the Overflow Flag Status Register, and an interrupt request is not generated, even when the Interrupt Enable Set Register is configured to generate an interrupt on counter overflow.	: The main workaround is to poll the performance counter. The maximum increment in a single cycle for a given event is 2. Therefore, polling can be infrequent as no counter can increment by more than 232 in fewer than 2 billion cycles. If the main usage model for performance counters is collecting values over a long period, then polling can be used to collect values (and reset the counter) rather than waiting for an overflow to occur. Polling can be done infrequently and overflow can be avoided. If the main usage model for performance counters relies on presetting the counter to some value and waits for an overflow to occur, then polling can be used to detect when an overflow event is 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX53, Rev. 6 30 Freescale Semiconductor10696 missed. An overflow can be determined to have been missed if the unsigned value in the counter is less than the value preset into the counter. Polling can be done infrequently because of the number of cycles it requires for this check to fail. If the erratum is triggered and an overflow event is missed, the counter sample can be thrown away or the true value can be reconstructed.	10696 ARM: If a Perf Counter OVFL occurs simultaneously with an update to a CP14 or CP15 register, the OVFL status can be lost
Cortex-A8	NXP		: If a Neon store is done to Device type memory and is followed in instruction sequence by a load instruction to Device type memory, it is possible that an unrelated store instruction that is done to cacheable memory and hit the L1 cache has its data dropped and therefore not update memory. There are three different memory types defined in the ARM architecture namely, Strongly Ordered, Device, or Normal. Device type memory is one of the three different memory types. This region is specified by the page table entries used by the MMU. The conditions for this erratum are that relatively close in the instruction stream, the following must occur: â¢ A Neon store is done to Device type memory. â¢ A load is executed to Device type memory (any load to Device type memory region, not just from Neon), consecutive to the Neon store. â¢ Several stores hit the L1 cache. (Any store that hit the L1 cache - Neon or integer core. The address does not matter.) The issue is reported by ARM, erratum ID 507113, Category 31. Projected ImpactJEEHEHRECONSTRUCT: If the erratum occurs, one or more cacheable stores that hit the L1 cache do not update the cache, leaving stale contents in memory. This is likely to cause observable, incorrect behavior in the application. The Neon access to memory region marked as Device is not a practical case in general.	: The only workaround for this erratum is to avoid accessing the Device type memory with Neon store instructions. (There should be no practical case for this, anyway). However, if needed, define the region as Strongly Ordered memory, instead.	10729 ARM: A Neon store to device memory can result in dropping a previous store
Cortex-A8	NXP		: All BTB invalidate operations, including BTB Invalidate by MVA operations, by default are implemented as a NOP in the Cortex-A8 processor. These operations can be executed as NOPs as flushing BTB entries are not required by the Cortex-A8 processor for correct functionality, and there is no additional performance penalty for an incorrect branch prediction versus a non-prediction. However, it is possible for BTB operations to be enabled by setting the IBE bit in the CP15 Auxiliary Control Register. When enabled in this fashion, BTB invalidate by MVA operations may not work as intended. Instead of writing zeros to the valid bit of the BTB entry matching the MVA provided, the CP15 âInvalidate Branch Predictor by MVAâ operation writes the value currently in the âInstruction L1 System Array Debug Register 0.â This register is not initialized at the reset time and can only be written in secure, privileged modes when CP15SDISABLE is not set. The conditions are as follows: 1. The branch predictor is enabled (SCTLR.Z = 1) 2. The Auxiliary Control Register IBE bit is set to 1 3. An invalidate Branch predictor by MVA operation is executed 4. The Instruction L1 System Array Debug Register 0 contains a non-zero value which sets the valid bit and clears the page cross bit. The issue is reported by ARM, erratum ID 687067, Category 31. Projected ImpactJEEHEHRECONSTRUCT: If the non-zero value contained in L1 System Array Debug Register 0 sets the valid bit of the BTB entry, then the entry is not invalidated as intended.	: A workaround for this erratum is, not to enable the IBE bit. ARM recommends that the IBE bit should not be enabled unless it is required for an erratum workaround. If the IBE is to be enabled, then the L1 System Array Debug Register 0 should be initialized to a zero value. This register is for RAM array debug purposes and is not used as a part of normal functionality. It is only accessible in a privileged secure mode. Therefore, it can be statically initialized as a part of the boot code sequence. If the register is used for debug purposes, the value should be reset to zero when the debug sequence completes. The code to initialize the L1 System Array Debug Register 0 is as follows: MOV r1, #0 MCR p15, 0, r1, c15, c1, 0 ; write instruction data 0 register MRC p15, 0, R1, c1, c0, 1 ; read Aux Ctl Register ORR R1, R1 #(1 << 6) ; set IBE to 1 MCR p15, 0, R1, c1, c0, 1 ; write Aux Ctl Register 1. Category 3 defined as: Behavior that is not the originally intended behavior but should not cause any problems in applications. Chip Errata for the i.MX53, Rev. 6 34 Freescale Semiconductor10707	10707 ARM: BTB invalidate by MVA operations do not work as intended when the IBE bit is enabled
Cortex-A8	NXP		: If a debug watchpoint and a precise data abort are both triggered from the same data access, the ARM Architecture specifies that the data abort should be prioritized. However, this does not occur on the Cortex-A8 and the watchpoint is taken instead. The conditions for the erratum are as follows: 1. At least one debug watchpoint is programmed 2. A precise data abort occurs on the same address as the watchpoint The issue is reported by ARM, erratum ID 693270, Category 31. Projected ImpactJEEHEHRECONSTRUCT: The implications of this erratum only affects the debug software. The data abort should take precedence over the watchpoint so that the OS has a chance to fix up paged-out memory before re-executing the instruction and presenting the debugger with the watchpointed address. Due to this erratum, this fix up does not occur and the debugger should be capable of handling a faulting address.	: The workaround for this erratum is to ensure that the debugger software handles the faulting address. When the debugger is signalled a watchpoint, and identifies that the page being accessed is subjected to an MMU fault, which it would like the OS to patch up before dealing with itself, it can perform the following actions: â¢ Disable the watchpoint â¢ Set vector catch on the local Data Abort exception (secure or non-secure, as appropriate) â¢ Set the PC at the watchpointed instruction and restart execution The processor restarts, re-executes the instruction and generate the MMU fault. It then fetches the instruction from the Data Abort handler and re-enter Debug state because of the Vector Catch event. The debugger can then perform the following actions: â¢ Re-enable the watchpoint â¢ Disable the vector catch â¢ Set the PC at the Data Abort vector and restart execution The processor restarts and re-executes the Data Abort vector instruction. The OS then patches up the MMU fault and attempts to re-execute the original instruction. Re-executing the instruction regenerates the Watchpoint debug event, but now the page is properly patched up.	10730 ARM: Taking a watchpoint is incorrectly prioritized over a precise data abort if both occur simultaneously on the same address
Cortex-A8	NXP		: If the integer to floating point conversion operation, VCVT.f32.u32, is executed with the FPSCR register configured for Default NaN and Flush-to-zero enabled, and the rounding mode used is RP (Round-to-Positive infinity), it returns the incorrect result for the source operation 0xFFFF_FF01. Specifically, it returns the result 0x0000_0000 instead of the correct result 0x4F80_0000. The erratum can occur only for this specific input value and this specific configuration of the FPSCR register. The conditions are as follows: 1. Default NaN is enabled (FPSCR[25] = 1âb1) 2. Flush-to-zero is enabled (FPSR[24] = 1âb1) 3. RP rounding mode is enabled (FPSR[23:22] = 2âb01) 4. A VCVT.f32.u32 instruction is executed with the source operand 0xFFFF_FF01 5. The result of the instruction is incorrect 0x0000_0000 rather than 0x4F80_0000 The issue is reported by ARM, erratum ID 715847, Category 31. Projected ImpactJEEHEHRECONSTRUCT: The incorrect result from the conversion operation can result in further incorrect results calculated and unexpected program behavior.	: The erratum only occurs if the floating point unit is configured in run fast mode with RP rounding. The easiest workaround is to avoid using this particular mode combination. Round-to-Nearest (RN) is a common rounding mode used, but if RP functionality is desired, it should be done without using Default NaN and/or without Flush-to-zero enabled. Default NaN signalling, Flush-to-zero, and rounding mode are all configured using bits [25:22] of the FPSCR register. This register is typically configured by the system software and should not change within an application.	10731 ARM: VCVT.f32.u32 can return wrong result for the input 0xFFFF_FF01 in one specific configuration of the floating point unit
Cortex-A8	NXP		: If a Clean by MVA, Invalidate by MVA, or Clean and Invalidate by MVA cache maintenance operation is performed in a memory region that is marked non-cacheable, device, or strongly ordered, it is possible for the processor to deadlock or have stale data left in the processor. This erratum occurs when the address hits the cache in a way that is not predicted by the Hash Virtual Address Buffer (HVAB), which is a cache way predictor inside the processor. This erratum can occur only for the cache maintenance operations that are performed by MVA. It does not occur for the set/way based cache maintenance operations. The conditions are as follows: 1. A memory region is marked cacheable in a page table entry, and a cache line from that region is placed in the data cache 2. A second page table entry marks the same memory region as non-cacheable, device, or strongly ordered. This can occur by changing the memory attributes in the existing page table entry, or through an alternative page table entry that maps the same virtual to physical address but with non-cacheable, device, or strongly ordered attributes rather than cacheable 3. A Clean by MVA, Invalidate by MVA, or Clean and Invalidate by MVA cache maintenance operation is done to this address 4. The maintenance operation receives a false hit indication from the HVAB array 5. The maintenance operation receives a true hit indication from the Tag lookup, which implies that the data is present in the array, but located in a different way that is not predicted by the HVAB 6. An eviction of the dirty line has started but not finished, and the processor leaves stale data in the cache and can potentially enter a deadlock state The issue is reported by ARM, erratum ID 728018, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If stale data is left in the cache, the processor does not work as intended. If deadlock state occurs, it can only be exited by asserting the RESET pin on the processor.	: There are two possible workarounds for this erratum. The first workaround is to avoid performing the cache maintenance operations to non-cacheable addresses previously marked cacheable and therefore may be resident in the cache. If the address is present in the cache, it implies that the memory region is marked cacheable at some earlier point of time and explicitly changed to non-cacheable before the maintenance operation is performed. If the region type is not changed to non-cacheable before executing the maintenance operation, this erratum can be avoided. The value of changing a memory region from cacheable to non-cacheable 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX53, Rev. 6 40 Freescale Semiconductor11206 before performing the maintenance operations is that this is the only way that the ARM v7 Architecture guarantees the line is not immediately placed back into the cache due to the possibility of data speculation. However, in Cortex-A8, this degree of data speculation is never done. Therefore, changing the memory type to non-cacheable before executing the cache maintenance operation is not required to assure that the line is not immediately placed back into the cache. However, if there is a code compatibility with other v7 implementations (that may exhibit this level of data speculation) is a concern, then this first workaround is insufficient, and the second workaround should be used. The second workaround is to execute the loop of cache maintenance operations twice. Execute the loop once with the memory region still marked cacheable. Then change the page table entry to make the memory region non-cacheable and execute the loop for a second time. The first loop cleans the data from the cache in the Cortex-A8. On the Cortex-A8, the second loop is redundant as it misses on all lines in the cache, but resolves the data speculation issue that can occur on a different v7 architecture implementation. The existing cache maintenance code in a dynamically paged environment can be dependent on the maintenance operation triggering a page fault to set the correct page table entry. The workaround code must independently ensure that the correct page table entry is present.	11206 ARM: Cache maintenance operations by MVA for a non-cacheable memory region can result in processor deadlock
Cortex-A8	NXP		: When Neon performs a single byte load from Strongly Ordered or Device type memory with an access size of more than 8 bytes, the system AXI bus issues a burst access which is longer than 8 beats of a single byte. However, the M4IF is capable of supporting only access with a burst length of less than or equal to 8, as indicated in the i.MX53 Applications Processor Reference Manual (MCIMX53RM). When an access with burst length greater than 8 beat is detected by the M4IF, it is not forwarded to the memory controllers. Instead, a DECERR AXI bus error is indicated and data abort exception is sent back to the master. Conditions for this issue: 1. A single byte Neon load is issued with more than 8 bytes access, for example: Vld1.8 {d0,d1,d2,d3}, [Rs]! 2. The source address is Strongly Ordered or Device memory type Projected ImpactJEEHEHRECONSTRUCT: The Neon access to memory region marked as Strongly Ordered or Device are not usually a practical case in general. Note that there are also other reported limitations for Neon access to Device type memory such as ENGcm10729.	: Several software solutions can be proposed for this issue: â¢ Use 8-bit Neon load with access size of less or equal to 8 bytes. For example: Vld1.8 {d0-d1}, [Rs]! This solution results in some performance degradation. â¢ Use 16 or 32-bit Neon load instructions instead. For example: Vst1.32 {d0 â d3}, [Rs]! The limitation of this proposal is that the source data address must be 16 or 32-bit aligned. â¢ Define the memory region as Normal Non-Cacheable type instead of Strongly Ordered or Device memory type. In this case, need to avoid potential memory consistence issues and perform Data Synchronization Barrier (DSB) before other DMA engine access the region for read, as the Write Buffer is enabled.	11413 ARM: A Neon load from device memory type can result in data abort
Cortex-A8	NXP		: There are two muxes which select a clock source for pll1_sw_clk (which is also the source for ARM clock). One of them is a regular mux (step select mux), and the other is a synchronous mux. The clock sources are selected by a single register (CCSR). If the pll1_sw_clk_sel bit is cleared (CCSR[2]) and the selection of the regular mux (CCSR[8:7]) is changed at the same time, then the regular mux is likely to switch first and can cause a glitch on pll1_sw_clk and hence on ARM clock and possibly other clocks as well. Due to above, the CCSR[8:7] bits may only be modified when step_clk is no longer selected. Therefore, CCSR[2] must be cleared in separate register access prior to changing CCSR[8:7]. Projected ImpactJEEHEHRECONSTRUCT: None, if the proposed workaround is implemented.	: The CCSR[8:7] bits can be modified only when step_clk is no longer selected. The ARM clock source selection should be done in two accesses. The CCSR[2] must be cleared in separate register access prior to changing CCSR[8:7].	11209 CCM: ARM clock source switch limitation
Cortex-A8	NXP		: When the emi_int1 clock in the CCM_CCGR5 register is disabled, the transaction to the CCM passes through the INT1 channel of the EMI. However, the BRESP cannot be received by the ARM because the clocks are already turned off. This causes the system to hang. Projected ImpactJEEHEHRECONSTRUCT: None. User should refrain from disabling the EMI int1 clock.	: None	11479 CCM: System hangs when EMI int1 clock is disabled
Cortex-A8	NXP		: The CSPI automatically clears the overrun error status bit when the RxFIFO is read. This bit should not be cleared. This bit is designed for the interrupt access mode, and not for the DMA access mode. The conditions are as follows: â¢ When the RO bit is cleared by an RxFIFO read, it does not cause a problem if no DMA accesses to the CSPI occur â¢ When DMA is utilized, the interrupt status of RO can be lost because of uncontrolled RxFIFO access by DMA Projected ImpactJEEHEHRECONSTRUCT: If the RxFIFO is read before reading the Overrun error status bit, it is possible to miss the Overrun and thus miss the data.	: When DMA is used for data transfers, the software can program the CSPI to only allow the interrupt generation during the overrun condition and not enable any other interrupt sources. In this way, whenever an interrupt comes from CSPI, the software can assume that it is the result of an Overrun condition.	11154 CSPI: Incorrectly clears the overrun status bit
Cortex-A8	NXP		: Under certain conditions, the DPLL IP TOG_SEL bit is not cleared after the TOG_DIS bit is set. This issue is random in nature. Projected ImpactJEEHEHRECONSTRUCT: The proposed workaround resolves the issue.	: A software delay for a fixed amount of time based on TOG_COUNT after the TOG_DIS bit is set.	11152 DPLL: TOG_SEL bit not cleared after the TOG_DIS bit is set
Cortex-A8	NXP		: According to the eCSPI specifications, when eCSPI is set to operate in the Slave mode (CHANNEL_MODE[x] = 0), the SSB_CTRL[x] bit controls the behavior of burst completion. In the Slave mode, the SSB_CTRL bit controls the behavior of SPI burst completion as follows: â¢ 0âSPI burst completed when (BURST_LENGTH + 1) bits are received â¢ 1âSPI burst completed when SSB input negated Also, in BURST_LENGTH definition, it is stated âIn the Slave mode, this field takes effect in SPI transfer only when SSCTL is cleared.â However, the mode SSB_CTRL[x] = 1 is not functional in Slave mode. Currently, BURST_LENGTH always defines the burst length. According to the SPI protocol, negation of SSB always causes completion of the burst. However, due to the above issue, the data is not sampled correctly in RxFIFO when {BURST_LENGTH+1}mod32 is not equal to {actual burst length}mod32. Therefore, setting the BURST_LENGTH parameter to a value greater than the actual burst does not resolve the issue. Projected ImpactJEEHEHRECONSTRUCT: Slave mode with unspecified burst length cannot be supported due to this issue. The burst length should always be specified with the BURST_LENGTH parameter and the SSB_CTRL[x] should be set to zero.	: There is no workaround except for not using the SSB_CTRL[x] = 1 option in the Slave mode. The accurate burst length should always be specified using the BURST_LENGTH parameter.	10189 eCSPI Burst completion by SSB signal in Slave mode is not functional
Cortex-A8	NXP		: Due to non proper clock synchronization implementation, the WMIS0 and the WMIS1 watermark status registers can return wrong value. The probability is low. Projected ImpactJEEHEHRECONSTRUCT: The watermark status and the interrupt indications can be read wrongly. The status bits can be read as zero instead of one (Reading one as zero does not likely to occur).	: In the real applications, the Read command is to be issued after a watermark interrupt is issued to the Cortex. After the watermark interrupt is generated, the appropriate status register indicators should read as one to indicate the violated watermark region. A workaround to the issue is to check the data that is read, and repeat the read command in case all the register bits values are read as zero.	11038 EMI2.5: Read from M4IF Watermark status registers may have wrong result
Cortex-A8	NXP		: 8-bit memory devices are supported by the WEIM interface, which is connected only to the EIM_D[31:24] pads. Connection to the EIM_D[23:16] pads is not supported. This erratum clarifies the statement in the i.MX53 Applications Processor Reference Manual (MCIMX53RM) , that only 16-bit and 32-bit memory devices are supported by the WEIM interface. Projected ImpactJEEHEHRECONSTRUCT: WEIM 8-bit memory devices are supported according to above description.	: None	11245 EMI: WEIM 8-bit memory devices support clarification
Cortex-A8	NXP		: EIM has a debug mode that enables BCLK to be a free running clock. This mode is selected by writing 1 to the BCM bit of the EIMâs WCR register. â¢ When BCM is 1, this clock can be divided by configuring the GBCD field. â¢ When BCM is 0, this clock can be divided by configuring the BCD field. Due to this error, when BCM is set, GBCD is not 0 and BCD = 0, the result will be a non-active clock. Projected ImpactJEEHEHRECONSTRUCT: Due to this erratum, the software specific combination of BCM,GBCD, & BCD is not working.	: This can be bypassed by configuring the BCD of all the active chip selects (CS) to be equal to GBCD.	11786 EMI: EIM BCLK in DEBUG mode is not functional when GBCD is zero and BCD is not zero
Cortex-A8	NXP		: There is a possibility of an extra pulse on SCLK in the EPIT, when switching between the clock sources. Projected ImpactJEEHEHRECONSTRUCT: It can result in an incorrect counter increment in the EPIT.	: Clock source should be changed only when the EPIT is disabled. A way to accomplish the same is as follows: 1. Disable EPITâEPITCR[0] = 0 (EN = 0), that is, disable EPIT 2. Disable EPIT outputâEPITCR[23:22] = 00 (OM = 00) 3. Disable EPIT capture interruptâEPITCR[2] = 0 (OCIEN = 0) 4. Change clock sourceâEPITCR[25:24] (CLKSRC), determines which clock source is selected for running the counter 5. Clear status registerâEPITSR[0] (OCIF), this is a write one to clear register 6. Configure EPIT to start count once enabled from load valueâEPITCR[1] = 1 (ENMOD = 1) 7. Re-enable EPIT EPITCR[0] = 1 (EN = 1), that is, enable EPIT 8. Reconfigure output and interrupt	11028 EPIT: Possibility of additional pulse on src_clk when switching between clock sources
Cortex-A8	NXP		: Two issues are observed with respect to the automatic power down in eSDCTL: 1. PWDT cycle amount in the specification should be divided by 2. 2. The PWDT should be individually enabled for each chip select, to gain maximum power saving. However a bug is observed, which resulted in read operation from one chip select, preventing the other chip select from entering the power down mode. Only if both chip selects are idle, the power down mode is observed. Projected ImpactJEEHEHRECONSTRUCT: The issue impacts the power saving optimization.	: None	11052 eSDCTL: Auto power down issues
Cortex-A8	NXP		: A glitch may occur on the SDHC card clock when the software sets the RSTA bit (software reset) in the system control register. It can also be generated by setting the clock divider value. The glitch produced can cause the external card to switch to an unknown state. The occurrence is not deterministic. Projected ImpactJEEHEHRECONSTRUCT: Potential disruption of SD card operation.	: A simple workaround is to disable the SD card clock before the software reset, and enable it when the module resumes the normal operation. The Host and the SD card are in a master-slave relationship. The Host provides clock and control transfer across the interface. Therefore, any existing operation is discarded when the Host controller is reset. The recommended flow is as follows: 1. Software disable bit[3] of the System Control register 2. Trigger software reset and/or set clock divider 3. Check bit[3] of the Present State Register for stable clock 4. Enable bit[3] of the System Control register. Using the above method, the eSDHC cannot send command or transfer data when there is a glitch in the clock line, and the glitch does not cause any issue.	11213 eSDHC: Glitch is generated on card clock with software reset or clock divider change
Cortex-A8	NXP		: Issue in eSDHC ADMA mode operation. The eSDHC read transfer is not completed when block size is not a multiple of 4 in transfer mode ADMA1 or ADMA2. The eSDHC DMA controller is stuck waiting for the TC bit in the interrupt status register. The following examples trigger this issue: 1. Working with an SD card while setting ADMA1 mode in the eSDHC 2. Performing partial block read 3. Writing one block of length 0x200 4. Reading two blocks of length 0x22 each. Reading from the address where the write operation is performed. Start address is 0x512 aligned. Watermark is set as one word during read. This read is performed using only one ADMA1 descriptor in which the total size of the transfer is programmed as 0x44 (2 blocks of 0x22). Projected ImpactJEEHEHRECONSTRUCT: The issue exists only when the block size is not a multiple of 4 in transfer mode ADMA1 or ADMA2.	: When the ADMA1 or ADMA2 mode is used and the block size is not a multiple of 4, the software should set the block size to: 4 block size â ------------ 4 In other words, the block size should be rounded to the next multiple of 4 bytes. In case of write, the software should add the corresponding number of bytes at each block end, before the write is initialized. In case of read, the software should remove the dummy bytes after the read is completed. For example, if the original block length is 22 bytes, and there are several blocks to transfer, the software should set the block size to 24. The following data is written/stored in the external memory: 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 2 Bytes valid data + 2 Byte dummy data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 2 Bytes valid data + 2 Byte dummy data Chip Errata for the i.MX53, Rev. 6 54 Freescale Semiconductor11116 In this example, 48 (24 x 2) bytes are transferred instead of 44 bytes. The software should remove the dummy data. Alternatively, the PIO mode can be used if the block size is non-4 byte aligned.	11116 eSDHCv2/eSDHCv3: ADMA transfer error when the block size is not a multiple of four
Cortex-A8	NXP		: ADMA2 mode in the eSDHC is used for transfers to/from the SD card. There are three types of ADMA2 descriptors: TRANS, LINK or NOP. The eSDHC has a problem when the last descriptor (which has the End bit '1') is a LINK descriptor or a NOP descriptor. In this case, the eSDHC completes the transfers associated with this descriptor set, whereas it does not even start the transfers associated with the new data command. For example, if a WRITE transfer operation is performed on the card using ADMA2, and the last descriptor of the WRITE descriptor set is a LINK descriptor, then the WRITE is successfully finished. Now, if a READ transfer is programmed from the SD card using ADMA2, then this transfer does not go through. Projected ImpactJEEHEHRECONSTRUCT: Limitation for configuring the last descriptor as LINK or NOP.	: Software workaround is to always program TRANS descriptor as the last descriptor.	11115 eSDHCv2/eSDHCv3: Problem when ADMA2 last descriptor is12SPACEJEEHEHLINK or NOP
Cortex-A8	NXP		: An issue is identified when interfacing the SDIO card. There is a case where an SDIO interrupt from the card is not recognized by the hardware, resulting in a hang. If the SDIO card lowers the DAT1 line (which indicates an interrupt) when the SDIO interrupt is disabled in the eSDHC registers (that is, CINTEN bits in IRQSTATEN and IRQSIGEN are set to zero), then, after the SDIO interrupt is enabled (by setting the CINTEN bits in IRQSTATEN and IRQSIGEN registers), the eSDHC does not sense that the DAT1 line is low. Therefore, it fails to set the CINT interrupt in IRQSTAT even if DAT1 is low. Generally, CINTEN bit is disabled in interrupt service. The SDIO interrupt service steps are as follows: 1. Clear CINTEN bit in IRQSTATEN and IRQSIGEN. 2. Reset the interrupt factors in the SDIO card and write 1 to clear the CINT interrupt in IRQSTAT. 3. Re-enable CINTEN bit in IRQSTATEN and IRQSIGEN. If a new SDIO interrupt from the card occurs between step 2 and step 3, the eSDHC skips it. Projected ImpactJEEHEHRECONSTRUCT: The issue is relevant only for the SDIO card interrupt usage.	: The workaround interrupt service steps are as follows: 1. Clear CINTEN bit in IRQSTATEN and IRQSIGEN. 2. Reset the interrupt factors in the SDIO card and write 1 to clear CINT interrupt in IRQSTAT. 3. Clear and then set D3CD bit in the PROCTL register. Clearing D3CD bit sets the reverse signal of DAT1 to low, even if DAT1 is low. After D3CD bit is re-enabled, the eSDHC can catch the posedge of the reversed DAT1 signal, if the DAT1 line is still low. 4. Re-enable CINTEN bit in IRQSTATEN and IRQSIGEN.	11186 eSDHCv2/eSDHCv3: eSDHC misses SDIO interrupt when CINT is disabled
Cortex-A8	NXP		: DLL_STS_REF_LOCK bit in DLL Status Register (DLLSTS) does not indicate the reference DLL lock status properly. The DLL_STS_REF_LOCK bit function indicates that the DLL has detected and locked to a half-phase ref_clock shift, allowing the slave delay-line to perform programmed clock delays. Because the timing delay of one tap cell in DLL is too short, a two cell delay period is not wide enough to allow phase_n and phase_p of the reference clock to straddle the high-pulse at the same time. As a result, the DLL_STS_REF_LOCK status bit cannot indicate the actual status. Projected ImpactJEEHEHRECONSTRUCT: The DLL functionality itself is not impacted, only the DLL_STS_REF_LOC indicator is not working properly.	: Do not use the DLL_STS_REF_LOC as indicator. The DLL_STS_SLV_LOCK status bit is sufficient indicator for the software. The DLL_STS_SLV_LOCK represents slave delay-line lock status. It indicates that a valid calibration has been set to the slave-delay line and that the slave-delay line is implementing the programmed delay value.	11406 eSDHCv3: DLL_STS_REF_LOCK status bit does not indicate12SPACEJEEHEHwhen DLL is locked
Cortex-A8	NXP		: The FEC only creates wrap burst accesses upon data access (non-buffer descriptor). The NFC under EMIv2 cannot handle such accesses from the MAX (M2) input port. DescriptionJEEHEHRECONSTRUCT: The Tx Warning Interrupt and the Rx Warning Interrupt signals from the FLEXCAN module are not connected internally to the CPU. Therefore, if these interrupts are enabled, they will not work as documented in the i.MX53 reference manual. Projected ImpactJEEHEHRECONSTRUCT: The FEC cannot use the NFC to access memory. Projected ImpactJEEHEHRECONSTRUCT: The Tx Warning Interrupt and the Rx Warning Interrupt are not available for use in any application where the FLEXCAN module of the i.MX53 is used.	: The FEC should use the DDR for its buffer. WorkaroundsJEEHEHRECONSTRUCT: None.	11214 FEC: Fast Ethernet Controller (FEC) accesses to NAND Flash Controller (NFC) does not work
Cortex-A8	NXP		: There is a possibility of an extra pulse on SCLK in the GPT when switching between the clock sources. DescriptionJEEHEHRECONSTRUCT: In certain applications, the on-chip LDOs may not power up correctly. When the issue occurs, both internal LDO regulators do not drive the VDD_ANA_PLL and VDD_DIG_PLL supply outputs. The potential for this outcome is aggravated at high temperatures (>50-60Â°C) and slower VCC supply ramp times. Impacted units do not function properly due to incorrect operation of the TEST_MODE input. The deviceâs offset latch circuit is designed to output a logic level zero, on application of VCC (logic power) and in the absence of NVCC_RESET (I/O power). The TEST_MODE circuit outputs an erroneous logic level one on application of VCC in the impacted units. This has the unintended effect of putting the device into test mode state which powers off the LDO regulators. On impacted units, if the applied NVCC_RESET is not sourced from the internal LDO regulator then the output of the LDO is delayed till NVCC_RESET is applied. This LDO delay corresponds to the time it takes to bring up NVCC_RESET after VDD_REG. Projected ImpactJEEHEHRECONSTRUCT: The bug can produce an incorrect counter increment in the GPT when switching between the clock sources. Projected ImpactJEEHEHRECONSTRUCT: The impact depends on the systemâs power sequencing and supply connections as follows: â¢ If the on-chip LDO regulator powers NVCC_RESET, it prevents the correct TEST_MODE input value from reaching the LDO enable logic, thereby creating a deadlock situation in the impacted units. Both LDO regulators do not enable and drive the VDD_ANA_PLL and VDD_DIG_PLL supplies. â¢ If an external regulator powers NVCC_RESET, and the power-up sequence complies with the data sheet then the issue does not occur. Externally supplying and correctly sequencing the NVCC_RESET supply allows the TEST_MODE logic to achieve the correct state. Thus, the LDOs are enabled. â¢ If an external regulator powers NVCC_RESET, and comes up after VDD_REG , then a delayed LDO output enable is observed. Once NVCC_RESET comes up, it correctly resolves the state of the TEST_MODE input, thus enabling the internal LDO regulators. This delay is not a system issue since LDOâs are fully functional and POR_B remains low while other supplies are sequenced. Workaround: Users must ensure that the NVCC_RESET supply is powered externally (not from the i.MX53 LDO VDD_ANA_PLL supply output) after VCC is stable and before other I/O supplies (NVCC_xxx) are powered up. Silicon Fix: Fixed in silicon revision 3N78C Chip Errata for the i.MX53, Rev. 6 62 Freescale Semiconductor11127 .	: Changing the clock source should only be done when the GPT is disabled. A way to accomplished this is as follows: 1. Disable GPTâWrite 1'b0 to EN bit of GPTCR 2. Disable interruptsâWrite 6'b000000 in Bits [5:0] of GPTIR 3. Configure Output Mode to unconnected/ disconnectedâWrite zeros in OM3, OM2, OM1 in GPTCR 4. Disable Input Capture ModesâWrite zeros in IM1,IM2 in GPTCR 5. Change clock source CLKSRC in GPTCR 6. Clear Status registerâWrite 003F in GPTSR 7. Set ENMOD in GPTCR 8. ENABLE GPTâWrite 1'b1 to EN bit of GPTCR. The GPTSR should not be read immediately after changing the clock source (a wait of at least one SCLK is required).	11029 GPT: Possibility of additional pulse on src_clk when switching between clock sources
Cortex-A8	NXP		: If the step-by-step mechanism is enabled while the M4IF is operational (there are transactions in the internal buffers), there can be a situation where one or more of the arbitrations' AXI protocol is violated in the âwrite address channelâ or âread address channel.â Projected ImpactJEEHEHRECONSTRUCT: The M4IF violates the AXI protocol and crashes if step-by-step is set ON or OFF during the run-time.	: Before entering the step-by-step mode, configure the EMI to the software LPMD and then read the LPACK register. The LPACK register indicates that the M4IF is idle and the step-by-step can be enabled. The difference between the regular procedure of LPMD and this procedure is that the EMI clocks remain ON.	11127 M4IF: Step-by-step mechanism violates AXI protocol
Cortex-A8	NXP		: Enabling the power-saving mode in M4IF before configuring the DDR module causes deadlock during DDR configuration. Projected ImpactJEEHEHRECONSTRUCT: None	: Initialization must be performed first, followed by enabling the M4IF power saving.	10682 M4IF power-saving mode should not be enabled before DDR is ENGcm1094012SPACEJEEHEHconfigured
Cortex-A8	NXP		: Reading the M4IF status registers of an inactive AXI master or slave ports stalls the entire IC system. This occurs when a specific master or slave clock is not provided to the M4IF, but the ARM/JTAG tries to read that masterâs status bits. When the master or slave clock is not active, the read request fails to propagate the status bits that go through synchronization (IPG_CLK to *_clk), acknowledge never comes back, and the entire chipâs IP bus is stuck. Some M4IF status registers bundle the status of several masters or slaves. If one of the masters or slaves is inactive, accessing such a register stalls the entire system, even if the user is interested only in the status of other active ports. Table 4 lists the impacted registers and the clock signals that should be active for read access to succeed. Table 4. List of Impacted Registers12SPACEJEEHEHRegisters Required Master/Slave to be Active for Read Action to Succeed MDCR fast, slow, int1, int2 WMIS0 fast WMIS1 fast MLEN m0, m1, m2, m3, m4, m5, m6, m7, fast, slow, int1, int2 FDPS fast SSRL0 fast SSRL1 fast SSRH0 fast SSRH1 fast MDSR0 The arbitration domain selected by MDCR/RARB MDSR1 The arbitration domain selected by MDCR/RARB MDSR2 The arbitration domain selected by MDCR/RARB MDSR3 The arbitration domain selected by MDCR/RARB MDSR4 The arbitration domain selected by MDCR/RARB MDSR5 The arbitration domain selected by MDCR/RARB MDSR6 The arbitration domain selected by MDCR/RARB MDSR7 The arbitration domain selected by MDCR/RARB MDSR8 The arbitration domain selected by MDCR/RARB SBS0 The arbitration domain selected by MDCR/RARB SBS1 The arbitration domain selected by MDCR/RARB Chip Errata for the i.MX53, Rev. 6 Freescale Semiconductor 65		11203 M4IF: Reading M4IF status registers of an inactive AXI master or slave stalls entire system
Cortex-A8	NXP		: No impact on regular functionality. The status registers are usually accessed for debugging purposes.	: Enable the relevant M4IF masters or slaves clocks for the status read.	11203 Table 4. List of Impacted Registers (continued)12SPACEJEEHEHRegisters Required Master/Slave to be Active for Read Action to Succeed PSM0 m0,m1 PSM1 m2,m3 PSM2 m4,m5 PSM3 m6,m7 MDCR fast, slow, int1, int2 MCR0 fast, slow, int1, int2
Cortex-A8	NXP		: When ECC_MODE = 1 the 8-sym error detection and correction does not work with 512 byte main area Ã16 NAND Flash. Projected ImpactJEEHEHRECONSTRUCT: The 8-sym ECC mode does not work with Ã16 bus width NAND. This mode works with Ã8 bus width NAND. This restricts 8-sym ECC operation to 8-bit NAND devices.	: None	11215 NFC: 8-Sym ECC mode does not work with 512 byte page x1612SPACEJEEHEHbus NAND Flash
Cortex-A8	NXP		: The copy back feature of the NFC module does not work as expected. When trying to copy a page from source address to destination address, the destination address is always the successive page of the source address. Projected ImpactJEEHEHRECONSTRUCT: The copy back cannot be done to an address that is not successive to the source address.	: There are two options: â¢ Perform the copy back through Atomic operations â¢ Instead of copy back, perform a read operation followed by a write operation Both options affect the overall performance.	10288 NFC: Copy back function destination address restriction
Cortex-A8	NXP		: NFC offers a block-write-protect feature in which only a range of pre-defined blocks can be modified. This range of blocks can be set to UNLOCK (blocks that can be modified), LOCK (blocks that cannot be modified) or LOCK_TIGHT (blocks that cannot be modified and the range cannot be changed). Though switching to LOCK_TIGHT mode, the range of blocks can still be modified. Projected ImpactJEEHEHRECONSTRUCT: Lock cannot be trusted to prevent data from being overwritten. As the software does not use this feature (both WinCE and LINUX), there is no impact.	: As there is no difference between LOCK and LOCK_TIGHT modes, the software should not use LOCK_TIGHT mode.	11124 NFC: Block write-protect does not support lock-tight
Cortex-A8	NXP		: NFC offers a block-write-protect mechanism. Only a configurable range of NAND blocks can be modified. Any erase/program operations on the blocks outside this range should be blocked by NFC. This mechanism does not work in automatic program and in automatic erase. Projected ImpactJEEHEHRECONSTRUCT: As there is no workaround for this bug, the write protect mechanism cannot be used.	: It should be handled in the software, as it is done now for the Windows and Linux drivers.	11217 NFC: Block write-protect does not work in automatic operations
Cortex-A8	NXP		: When working with addr_op = 01, and trying to perform a copy-back operation, the NFC ignores the destination address configured, and copies the page to âsource addressâ +1. Additionally, the following automatic operation is carried out from address_register1 instead of address_register0. Projected ImpactJEEHEHRECONSTRUCT: Automatic operation is carried out from address_register1 instead of address_register0. Workaround: If the system requires to work in addr_op = 01, switch to addr_op = 11, before the copy-back operation, and switch back after the copy-back operation is complete.		11182 NFC: Copy-back does not work properly when addr_op = 01
Cortex-A8	NXP		: The software reset (setting the NFC_RST bit in NFC and then sending reset command 0xFF to NAND Flash) does not work correctly under the following conditions: â¢ Reset between the read operations â¢ With atomic program operation, the RESET command is not being issued â¢ Auto program operationâIf reset occurs after writing data to the NFC and before the write confirm command, the CACK bit is not set after setting CREQ Projected ImpactJEEHEHRECONSTRUCT: The software reset does not work consistently, but the failure conditions are not common in real world applications.	: Do not to apply software reset for the above conditions.	11126 NFC: Software reset does not work properly under certain conditions
Cortex-A8	NXP		: After automatic Program operation the NFC is expected to perform a status read and store the status in STATUS_SUM register. With RBB_MODE = 1 (that is, NFC waiting using BSY_B signal), the status read does not occur at the end of the Program/CopyBack0 and CopyBack1 operations. Projected ImpactJEEHEHRECONSTRUCT: The status is not correct.	: Workaround for this erratum: â¢ In the Automatic mode, use RBB_MODE = 0 â¢ If RBB_MODE = 1 is to be used, then after the Automatic program, Automatic CopyBack0 and Automatic CopyBack1 operations, Status read should be done explicitly.	11218 NFC: Status read does not occur at the end of the program, with RBB_MODE = 1
Cortex-A8	NXP		: When working in symmetric mode with a clock ratio 1:2, and using a 16-bit Flash bus width, the NFC reads data and organizes it using a shift in the internal RAM in such a way that the last 16 bits of the data block being transferred are not written to the memory. Projected ImpactJEEHEHRECONSTRUCT: Wrong data may be read.	: Avoid combining the following parameters/conditions: â¢ 16-bit flash bus width â¢ Symmetric mode â¢ 1:2 clock-ratio	11219 NFC: Misses read data when working in Symmetric mode with clock ratio 1:2, and using a 16-bit Flash bus width
Cortex-A8	NXP		: When the NFC is configured to addr_op = 1 or 3 â¢ If num_of_devices = 0â1, then the LSB of the page/blocks address section of the addr_group bits is not used for address generation. â¢ If num_of_devices = 2â3, then the 2 LSB's of the page/blocks address section of the addr_group bits is not used for address generation. â¢ If num_of_devices = 4â7, then the 3 LSB's of the page/blocks address section of the addr_group bits is not used for address generation. Projected ImpactJEEHEHRECONSTRUCT: Working in these addr_op modes has some limitations on the size of the devices (depending on the number of devices). Such large devices do not exist at this time. This can be an issue when using larger devices that may become available in future.12SPACEJEEHEHNOTE addr_op = 0 works as designed with any combination.	: Do not use the combination of parameters/modes described above.	11220 NFC: Cannot reach entire address space when addr_op = 1 or 3
Cortex-A8	NXP		: The NFC error correction mechanism is based on BCH error correction codes. The BCH error correction code allows correction up to a particular number of errors (T = 4 or 8 depending on the configuration), and detection in case of higher number of error bits. In a situation where the number of errors (NOBER) is larger than the number of errors the NFC can correct (T), the NFC should report on uncorrectable error. Due to a theoretical limitation, the BCH code can fail in detecting the error when the number of actual error bits is much larger than the number of correctable bits. The failure depends on the location of the errors (related to Hamming distance), and its probability is very small. The detection failure probability can be calculated using the formula as follows: P 1 e = -------- T! 2T â where T is number of correctable errors. â¢ For 4-bit ECC, the calculated probability for a decoder error is 1 : 384 â¢ For 8-bit ECC, the calculated probability for a decoder error is 1 : 10,321,920 In case of failure, the NFC reports only on T or less errors (NOBER=T) and tries to correct them. As a result the data is damaged and the NFC does not report on it. Projected ImpactJEEHEHRECONSTRUCT: There is a small probability for failure in detection of the errors by the ECC mechanism due to theoretical limitation of the ECC code.	: To reduce the failure significantly, treat the case where NFC reports NOBER = T as uncorrectable error. This implies that if the number of errors is equal to T, the software must invalidate the block. It is a common practice for the software to mark the block as bad in advance when the number of reported errors approaches T.	11221 NFC: ECC mechanism may fail to report uncorrectable error situation
Cortex-A8	NXP		: The NFC may not properly sample the ready/busy (R/B) signal under the following conditions: 1. RBB_MODE = 1 (Ready-Busy mode 1 - NFC monitors ready-busy status by checking NANDF_RBx (R/B) signals) 2. ADD_OP = 01 (Addressing Option 01 - NFC uses only address_group0 with single NAND device 3. enfc_clk period is less than twb/3 (twb is the period from WE write enable signal HIGH to R/B ready/busy signal assertion) If RBB_MODE = 1 and ADD_OP = 01, the NFC may miss the sampling of the ready/busy signal (R/B) if the enfc_clk is too fast. According to the NAND flash protocol, the NAND device should enter the busy mode and assert the R/B signal (driving R/B signal to zero) after the maximum time period of twb after the deassertion of the WE signal (driving write enable to one). The NFC samples the R/B signal after a fixed time of 3 enfc_clk cycles after the deassertion of WE. Typically, the twb period is 100 ns. When the enfc_clk is set to less than 33 ns period, the NFC may miss sampling the R/B. DescriptionJEEHEHRECONSTRUCTs table in the i.MX53 Applications Processor Reference Manual (MCIMX53RM) for detailed modes description. If the above two options are not feasible, the enfc_clk frequency can be reduced such that clock period is larger than twb/3. This results in small performance degradation as the supported ONFI1.0 NAND can run at up to 40 MHz. Projected ImpactJEEHEHRECONSTRUCT: Violation of NAND interface protocol can result in data corruption. The implementation of the proposed workaround may have insignificant performance impact.	: The recommended workaround is to set RBB_MODE = 0. This also frees up the NANDF_RBx pads for other usages. The NFC monitors the ready-busy status by performing a status-read command. Another option is to work with ADD_OP other than 01, allowing to work automatically with a single device other than device0. See, NAND_FLASH_CONFIG Register Field	11002 NFC can miss the sampling of the ready/busy signal (R/B) when RBB_MODE = 1
Cortex-A8	NXP		: Data corruption or EMI hanging can occur on SDMA Multi-Page read from the NFC in case of simultaneous read access by other master from WEIM. Use of SDMA is relevant for a case of multiple pages read from the NFC (that is, setting NUM_OF_ITERATION to a value greater than zero and setting NO_SDMA to zero in NFC for automatic interleave mode). Projected ImpactJEEHEHRECONSTRUCT: SDMA read access from NFC may be corrupted in case other masters perform read from WEIM at same time. There are no issues in following cases: â ARM accesses the NFC when WEIM is accessed by any other master in the system â SDMA accesses the NFC when the WEIM is idle â NFC is idle and WEIM is accessed by any master in the system	: Avoid the above described situation. Note that, in current WinCE and Linux BSP releases from Freescale, the SDMA Multi-Page mode read from NFC is not activated.	11053 SDMA multi-page read from the NFC, when the WEIM is operating, can result in data corruption or EMI hanging
Cortex-A8	NXP		: If the power supply of an unused UHVIO pad power group is pulled down, it can cause malfunction in the other functional UHVIO IO cells. The UHVIO IO cells (that support signal levels above 3 V) are used in interfaces such as SD card, NAND Flash. For example, grounding SD2 power supply rail through a small resistor (say 470 Î©) causes boot issues from the SD1 interface. This is caused due to a particular HVIO IO cell design limitation. Projected ImpactJEEHEHRECONSTRUCT: Pay attention to this limitation during board design. An unintentional grounding can occur because of nonfunctional or disabled voltage supply device connected to the UHVIO based interface VCC line.	: Take measures to avoid such cases. Leaving the unused interface supply open, does not cause any issue. The issue occurs only when a supply is grounded through a small resistor. The best design practice is to apply power to all the supply rails.	11180 Grounding nonfunctional UHVIO IO pads power rails can cause malfunction in other UHVIO IO cells
Cortex-A8	NXP		: UHVIO pads have an automatic power supply voltage level detector mechanism that should detect if the interface voltage is high (3.0 V â 3.6 V) or low (1.65 V â 3.1 V), and configure the pad accordingly. This detector may not work correctly for voltage levels between 1.95 V and 3.1 V. It detects this range as high voltage when it should be low. This impacts the pad timing performance, adding a propagation delay of up to 2.5 ns. Projected ImpactJEEHEHRECONSTRUCT: UHVIO pads are used by several interfaces such as NAND Flash, SDHC, EIM, FEC, Keypad, PATA, CSI, and some GPIOs. For general functionality the impact is not significant because the pads can be configured appropriately by setting the IOMUX pad control register bit VDOEN1 to manual voltage selection and the HVEOVERWRITE bit to 1. However, during the boot, the pads are configured by default to enable the automatic supply voltage detection. As a result, UHVIO pad base interfaces cannot use the fast boot mode if they are in the 1.95 V â 3.1 V voltage range. This limitation applies particularly to NANDF and SDHC interfaces.	: In case the UHVIO based interface operates at voltage level in the 1.95 V to 3.1 V range, configure the pads for manual voltage level selection by setting the IOMUX pad control register bit VDOEN1 for manual voltage selection and the HVEOVERWRITE bit to 1. To guarantee no timing issues occur during boot on an external interface operating at a voltage level in the 1.95 V to 3.1 V range, disable the fast boot mode by burning the corresponding e-fuse. E-fuses exist in both NAND Flash and SDHC boot modes, and select either a fast or slow boot option.	11642 UHVIO pads automatic supply voltage level detect function may not work for voltage between 1.95 V to 3.1 V
Cortex-A8	NXP		: SATA can work in two clock modes: internal and external. Due to an error in the ROM code, boot from SATA when using the internal clock mode is not working. SATA can be used in internal clock mode if boot is done from another source. Projected ImpactJEEHEHRECONSTRUCT: Boot from SATA when working in internal clock mode is not working.	: 1. Boot from SATA when working in external clock mode can be used. 2. Use Low Power Boot Mode (LPB) and force low power condition using pull-ups or pull-downs. LPB is used in the following way: â Blow BT_LPB fuse. â Do one of the following options: â Pull-up PATA_DIOW pad to imitate low power condition and blow BT_LPB_POLARITY fuse â Pull-down PATA_DIOW pad to imitate low power condition and avoid blowing BT_LPB_POLARITY	11851 ROM (Boot): Boot from SATA fails when internal clock mode is used
Cortex-A8	NXP		: The RTICv3 feature that allows the TrustZone software to disable the run-time check of the selected memory regions (region unlock), can cause the RTICv3 to hang and stop the run time integrity check of other regions. Projected ImpactJEEHEHRECONSTRUCT: The RTICv3 feature that allows the TrustZone software to disable run-time check of the selected memory regions cannot be utilized.	: None. Avoid using the memory region unlock feature in the TrustZone code.	10971 f ENGcm10971 RTICv3 memory region unlock feature can cause the RTICv3 to hang
Cortex-A8	NXP		: SAHARA does not work properly if AHB:IP buses clock ratio is 1:1. It works fine with AHB:IP buses clock ratio 2:1. Projected ImpactJEEHEHRECONSTRUCT: Adds limitation on system configuration for the clock ratio of 1:1 between AHB and IP buses.	: Avoid using a ratio of 1:1 between AHB and IP buses clock frequencies. Other software workarounds are considered, but not yet confirmed.	10363 SAHARA/CCM: Frequency ratio restriction for AHB and IP buses in SAHARA
Cortex-A8	NXP		: The AHCI specification states that the IS.INFS bit should be set when ERR_C is set, which does not occur. ERR_C is set when a Phy_not_ready condition is detected during non-data FIS reception or transmission. Projected ImpactJEEHEHRECONSTRUCT: None. In addition to ERR_C, a Phy_not_ready condition also causes the IS.PRCS bit to be set. IS.PRCS = 0 and SSTS.DET = 0 (indicates device disconnect) supersede other errors and should be handled by the software. Setting IFS/INFS is redundant and does not give any more useful information to the software. The severity is low. Medium probability.	: None	10417 SATA: IS.INFS bit is not set when ERR_C is set
Cortex-A8	NXP		: When an unknown FIS (UFIS) is received and the PMP field is incorrect (does not correspond to the command header CH.PMP field), both PDMA and TSM state machines lock-up, and IS.IPMS interrupt is generated. Projected ImpactJEEHEHRECONSTRUCT: A UFIS is received in the RxFIFO and the IS.IPMS bit is set, generating IPMS intrq. Therefore, PDMA and TSM state machines lock-up. The severity is medium. The probability of occurrence is low. Receiving an unknown FIS is an error scenario. This should not happen in the normal operation.	: Host software issues port reset (COMRESET) or global reset, if IS.IPMS interrupt is received.	10975 SATA: Unknown FIS with incorrect PMP field received
Cortex-A8	NXP		: Under a certain condition (small data transfer of 20 bytes with two Data FISes (12 bytes + 8 bytes + âend-statusâ is delayed a little) and four PRDs (4 + 4 + 4 + 8 bytes)), it is possible that a read overflow condition can be detected erroneously when such a condition is not present. As a result the P#IS.OFS is set. Projected ImpactJEEHEHRECONSTRUCT: A P#IS.OFS interrupt is generated erroneously. The Host controller is not affected otherwise. So the normal operation can continue. The severity is low. The probability is low.	: Software can either retry the command or generate COMRESET.	10983 SATA: Erroneous detection of Read Overflow condition
Cortex-A8	NXP		: The SRST FIS is not read from the system memory, when the ST bit clears during an on-going transfer and the core locks up. This happens only during certain conditions (for example, when a DMA read transfer takes a long time due to a large burst being converted into multiple single transfers). There are two parts to this problem: 1. TSM locks up in HT_PIOOTRANS2 (PIO) or in HT_DMAOTRANS2 (DMA) when software wants to send a SRST and clears the CMD.ST bit 2. PDMA unsuccessfully requests an SRST command header when the current read transfer is not finished and p_dma_req = 1 Projected ImpactJEEHEHRECONSTRUCT: The PDMA/TSM module lockup. The severity is medium. The probability is low.	: The software should use Port Reset (COMRESET) instead.	10982 SATA: Soft Reset not sent when issued by the software during on-going transfer
Cortex-A8	NXP		: Under certain conditions (combination of core clock values and software delays), the core can generate a phy_reset indefinitely. It occurs during one of the following cases: 1. If Global reset causes CMD.SUD = 0, then the software writes CMD.SUD = 1 to spin-up to the device 2. Under normal operation, when CMD.SUD = 1 and when the software issues a port reset by toggling SCTL.DET = 0 â 1 â 0 DescriptionJEEHEHRECONSTRUCT: The SATA AHCI specification states that the software should issue a soft reset with 0xF in the PMP field, to check if a port multiplier is connected to the Host controller. If a device is connected directly to the Host controller, without a port multiplier, the returned FIS has a value of 0x0 in the PMP field. As the values of the PMP field in the Soft Reset FIS and the returned Signature FIS from the device are different, the Host controller reports an error and sets the IS.IPMS bit. The PDMA module is supposed to check the PMP field of the incoming FIS only when CMD.PMA = 1. As CMD.PMA is set to zero initially, the controller should accept the signature FIS from the device even with PMP = 0xF. Currently, PMA is not used/ignored. Projected ImpactJEEHEHRECONSTRUCT: The top-level port phy_reset is asserted indefinitely. This is a synchronous reset, typically used only when the PHY handles TX OOB. The severity is low. The probability is low. Projected ImpactJEEHEHRECONSTRUCT: If a port multiplier is connected, problem does not arise. When the software attempts to enumerate the port multiplier, the port multiplier returns a FIS with 0xF in the PMP field, which is expected by the controller. If a device is connected directly to the Host without a port multiplier, the PMP field in the returned FIS contains 0x0, as opposed to 0xF in the soft reset FIS issued by the software. This causes the IS.IPMS bit to be set, and the TFD.STS.BSY bit is never cleared. The severity is medium. The probability is low.	: Port reset/COMRESET after time-out. WorkaroundsJEEHEHRECONSTRUCT: When IS.IPMS is set and TFD.STS.BSY is not cleared, no further transfers can be made until a COMRESET is issued. Determine the presence/absence of the Port Multiplier using IPMS intrq. If it is set, the PM is not attached and SRST with PMP = 0h must be issued.	11018 SATA: Problems with phy_reset when Staggered Spin-Up12SPACEJEEHEHsupported
Cortex-A8	NXP		: If CMD.ST = 0 and the PDMA of eofdata_q register is set due to a Data FIS received, it can cause data corruption on the AHB bus during the next initiated transfer (the current transfer is aborted, as expected). It happens if the software clears the CMD.ST bit to send a soft reset while there is still an outstanding data command. DescriptionJEEHEHRECONSTRUCT: The VS.MNR field (Minor Version Number) reset value is 0x0100. The correct value should be 0x0300 indicating support for AHCI 1.3. Projected ImpactJEEHEHRECONSTRUCT: Data corruption on the AHB bus (same data is written twice on consecutive addresses). The severity is low. The probability is low. Projected ImpactJEEHEHRECONSTRUCT: None. The severity is low.	: Ensure that there are no outstanding data commands, before clearing the CMD.ST bit. WorkaroundsJEEHEHRECONSTRUCT: None	11084-2 ENGcm11084-2 SATA: Data FIS received when CMD.ST = 0
Cortex-A8	NXP		: When DMASTP FIS with inactive slot (TAG with corresponding P#SACT bit is zero) is received, it is currently posted to the memory and the data transfer phase is initiated from the wrong slot location. The correct behavior should generate IFS intrq and transition to Fatal state. DescriptionJEEHEHRECONSTRUCT: When the Device and the Host send PMREQ at the exact same time, but the Device is disconnected before the Host actually detects a PMACK or PMNAK in the deframer, the Host core remains in the power state (L_TPMPartial or L_TPMSLumber) until a COMINIT is received. Also, in this case, the Host core does not flag this as a 'phy not ready' error condition to the Host firmware and the SERR.ERR_C register does not get updated to indicate loss of communication. Projected ImpactJEEHEHRECONSTRUCT: IFS is not asserted when DMASTP with inactive slot is received, 'bad' DMASTP FIS is posted to the memory, and data transfer operation is initiated resulting in wrong data transfer and likely bus error or other errors (such as incorrect PRD and so forth). The severity is low. The probability is low. Projected ImpactJEEHEHRECONSTRUCT: The Host remains in the L_TPMPartial/L_TPMSlumber state, indefinitely transmitting PMREQ, though there is no Device connected to it, until COMINIT is received from the Device. In addition, the SERR.ERR_C register does not get updated to indicate loss of communication. The severity is low. The probability is low.	: None WorkaroundsJEEHEHRECONSTRUCT: None	11084-4 ENGcm11084-4 SATA: DMA Setup FIS with inactive slot reception
Cortex-A8	NXP		: A problem is identified with the BCM 30 Datastream FIFO, where it has approximately a 1/8 or a 1/16 chance of losing the first data, causing a lock up after a low power mode, due to a problem with the reset logic. When the problem occurs, the FIFO loses the first data that contains alignment information. This results in the core locking on the first non-ALIGN Primitives and the core being locked. The only recovery at this point is a software time-out and the Host issued COMRESET. DescriptionJEEHEHRECONSTRUCT: As per the SATA specification, in the far-end Tx-only responder mode, the BIST Activate FIS A-bit means ALIGN Bypass (do not transmit ALIGN primitives) when A = 1. The AHCI controller only accepts A = 0 and does not send ALIGNs. A = 1 causes the controller to R_ERR the BIST Activate FIS. This behavior is opposite to what the specification requires. The correct behavior should be: â A = 0 - R_ERR â A = 1 - R_OK (no ALIGNs sent) Projected ImpactJEEHEHRECONSTRUCT: The Device locks-up after it switches from the low power mode.The severity is high. Projected ImpactJEEHEHRECONSTRUCT: None	: None WorkaroundsJEEHEHRECONSTRUCT: None	11084-6 ENGcm11084-6 SATA: Possible core lockup after switching from the low power mode
Cortex-A8	NXP		: The DWC SATA AHCI core removes and replaces all ALIGNs in the far-end re-timed BIST responder loopback mode. This can cause overflow in the BIST FIFO, if the Tx frequency of the device is faster than the Host Tx frequency (clk_asic). According to the SATA specification, the link can consume up to two ALIGNs and prevent the overflow. DescriptionJEEHEHRECONSTRUCT: Under certain conditions, the Host controller fails to wake up from the low power mode. The problem arises when the Host issues a COMRESET (software requested reset of system) at the exact time when the Device is disconnected and then reconnected, and when both the Host and the Device were previously in the power down mode. The series of events to cause this error are described as follows: 1. The Host sends a partial power mode request. 2. The Device issues a partial power mode request (collision). 3. The Host backs off and accepts the device power mode request. 4. Both the Host and the Device go into slumber power mode (phy_slumber asserted). 5. The Device is disconnected and reconnected, after which it sends COMINIT. 6. The Host does not respond to COMINIT as it issued a COMRESET from the application software at the exact time COMINIT is detected. 7. The Host does not detect COMINIT, but phy_slumber is de-asserted and asserted again and remains asserted. 8. The Host hangs in the power down mode. This problem is caused by signals from the clk_asic clock domain remaining asserted after clk_asic is restored, and the signals cause another power mode to be asserted. Projected ImpactJEEHEHRECONSTRUCT: The loopback data is corrupted when the BIST FIFO overflows. The severity is high. The probability is medium. Projected ImpactJEEHEHRECONSTRUCT: The Host may not wake up from the low power mode. The severity is medium. The probability is low.	: Disable the spread spectrum clocking (SSC) on the Host side. WorkaroundsJEEHEHRECONSTRUCT: The core can come out of this hang condition if software issues another COMRESET. Additionally, if the Device supports Asynchronous Signal Recovery, after 10ms, the Device reissues COMINIT and OOB completes successfully at that point.	11084-8 ENGcm11084-8 SATA: BIST responder re-timed loopback mode may drop data due to FIFO overflow
Cortex-A8	NXP		: A CRC error is incorrectly asserted for a subsequent FIS after a SYNC primitive is injected inside the incoming FIS. As per the SATA specification, if a SYNCp is received, the other side should not finish the FIS (SATA specification violation). This error condition represents an extremely rare case of data or non SYNCp Primitive being corrupted to be SYNCp, and then the FIS is completed. DescriptionJEEHEHRECONSTRUCT: If a SYNC is inserted immediately after the first Rx Data FIS DWord (46h header), the PDMA locks up, as it expects the next DWord to be data. Projected ImpactJEEHEHRECONSTRUCT: The Host responds to the subsequent FIS with R_ERR. This error is handled by the system in the usual fashion. For a non-data FIS, the FIS is tried again. For data FIS, the command fails and the error should be handled by the software. The severity is low. The probability is low. Projected ImpactJEEHEHRECONSTRUCT: The PDMA locks in DR_Receive_prerd state. SERR.DIAG_S bit is set, but interrupt is not generated. The severity is low. The probability is low.	: None WorkaroundsJEEHEHRECONSTRUCT: COMRESET after time-out.	11084-10 ENGcm11084-10 SATA: Injected primitive error inside FIS causes CRC error
Cortex-A8	NXP		: If the P#CMD.ST bit is cleared immediately after the core enters the low power mode using aggressive power management (after the last outstanding command is finished as reported by the CI bits for non-NCQ commands or the SACT bits for NCQ commands), issuing a new command by setting P#CMD.ST and P#CI bits can cause the core to get stuck trying to wake up. Projected ImpactJEEHEHRECONSTRUCT: The PDMA state machine (portsm_cs) remains in PM_WakeLink state as the three pulses (two acks and one wake) generated are close to each other on the pulse synchronizer (pm_host_ack/wake) causing the synchronizer to miss the last wake pulse. The core does not process any new commands issued. Under the normal operation, the P#CMD.ST bit is not cleared. The severity is low. The probability is low.	: Do not clear the P#CMD.ST bit when new commands are issued and the aggressive PM is enabled. Alternatively, issue COMRESET when the command times out when this condition is detected.	11084-12 ENGcm11084-12 SATA: Synchronizer misses last wake pulse when CMD.ST bit is cleared in aggressive power mode
Cortex-A8	NXP		: In rare cases the Secured Real Time Counter (SRTC) module can incorrectly invalidate its counters. During a power up or down sequence, the SRTC module supply source is shifted between a coin cell (NVCC_SRTC_POW) and VDDA. The signal that initiates the supply switch from NVCC_SRTC_POW to VDDA is generated based on the output of the LDO regulator which powers up when VDD_REG is applied. If VDDA is not present before VDD_REG, the logic switches to the power supply thatâs not available yet. When this occurs, the SRTC module may incorrectly report a security violation causing the data (counter and register values) to be lost. Devices may not function properly due to incorrect toggling of the TEST_MODE input (refer to erratum ENGcm12374). For security reasons, toggling of the TEST_MODE signal causes the register contents of the SRTC to be cleared. Projected ImpactJEEHEHRECONSTRUCT: â¢ The SRTC module may experience an inadvertent register reset during power up or power down events of the IC. A clock tampering security violation is incorrectly recorded in the SRTC status register. â¢ The loss of register contents during a power cycle prevents the module from maintaining the time of day functionality. â¢ Both the secure and non-secure operation of the SRTC module are impacted. â¢ The SRTC module can still be used for applications that do not require the registers to be preserved over a power cycle. Workaround: There is no guaranteed workaround that prevents the SRTC counter reset issue from occurring. Hence it is recommended to use an external RTC solution (PMIC or standalone RTC) to completely avoid the issue. To reduce the likelihood of the SRTC data loss issue, a modified power up/down sequence can be used: â The NVCC_RESET supply must ramp up along with the VCC supply. â The power up sequence must bring up the supplies in the following order: VCC => VDDA => VDD_REG The ramping supply must be fully powered up and stable per the datasheet before ramping up the next supply in the above sequence. The power down sequence must shut down the supplies in the following order: VCC => VDD_REG => VDDA or VCC => VDDA => VDD_REG12SPACEJEEHEHNOTE The above power sequences reduce the likelihood of the SRTC data loss issue, however does not guarantee that the issue can be completely avoided. Chip Errata for the i.MX53, Rev. 6 Freescale Semiconductor 101		12374 SRTC loses data while powering up/down
Cortex-A8	NXP		: In AC97, 16-bit mode, the Rx data is received in bits [19:4] of RxFIFO, instead of [15:0] bits. Projected ImpactJEEHEHRECONSTRUCT: The SDMA script should be updated accordingly to perform the shift to the right location on the fly during data transfer. If the data register is accessed directly by software, it should account for the shifted data and perform shifting to the right location.	: The data should be shifted to the right location by the SDMA script or by the software in case of direct access to the register.	11129 SSI: In AC97, 16-bit mode, received data is shifted by four bit locations
Cortex-A8	NXP		: The USBOH core uses the erroneous hrdata (when hresp is high) and results in the false USB transfer at the external Interface. Projected ImpactJEEHEHRECONSTRUCT: False transfer of USB.	: This should not happen in real system because when configured correctly, the USB should not get an error response. If it happens, then Garbage In Garbage Out.	11151 USB: Erroneous descriptor handling by USBOH module
Cortex-A8	NXP		: HS-TLL and FS-TLL are not supported. These features will be removed from the specification. DescriptionJEEHEHRECONSTRUCT: The USB host controller can lock up when a FIFO underrun occurs on a non-32-bit aligned data buffer. This applies to both the Host controller and the OTG controller in Host mode. Projected ImpactJEEHEHRECONSTRUCT: Removed support for the option of on board USB connection without transceiver. Projected ImpactJEEHEHRECONSTRUCT: Ethernet over USB is sensitive to trigger this issue since the data buffers in this case are usually not 32-bit aligned (in Linux).	: None. Need to add transceiver for on board connection. WorkaroundsJEEHEHRECONSTRUCT: 1. Set Stream Disable bit (SDIS) in the USBMODE register. This forces the controller to load an entire packet in the FIFO before starting to transmit on the USB bus. Hence, the FIFO never underruns. This somewhat reduces the max bandwidth of the USB since there is idle time as the controller waits for the entire packet to be loaded. 2. Instead of setting SDIS, the FIFO threshold can be increased so that more data is in the FIFO before a packet transmit is started. This increases the tolerance to bus latency and avoids FIFO underrun. The threshold can be increased by using higher values for the TXTHRESHOLD filed in the TXFILLTUNING register. The default value is 2 bursts (64 bytes if burst size=8).	11331 USB: High Speed Transceiverless Logic interface (HS-TLL) and Full Speed Transceiverless Logic interface (FS-TLL) USB12SPACEJEEHEHinterfaces are not supported
Cortex-A8	NXP		: There is a limitation when selecting different Huffman tables for AC/DC coefficients for the two chrominance components, Cb and Cr. The JPEG decoder design cannot handle two different Huffman tables for Cb and Cr. Cb and Cr are assumed to use the same Huffman table, which is true in most cases. Projected ImpactJEEHEHRECONSTRUCT: The bug occurs when the two chroma components, Cb and Cr, use different Huffman tables for AC/DC coefficients. Therefore, if Cb and Cr use the same Huffman table, this problem does not occur. Normally, JPEG streams use the same Huffman tables for Cb and Cr. It should be rare for JPEG streams to use different Huffman tables for the two chroma components. There is a large visual quality degradation. However, in reality, the probability of using two different Huffman tables for Cb and Cr is low. As a result, the overall impact for JPEG decoding should not be significant.	: None. There is no firmware workaround fix for this erratum.	10380 VPU: JPEG decoder does not support different AC/DC Huffman tables for Cb and Cr
Cortex-A8	NXP		: If the CMEOR bit in CCM is not overridden, the VPU clock can be gated off automatically by the vpu_idle signals, while the VPU enters idle state. The VPU may miss generating the decoding/encoding done interrupt when the clock is automatically gated off by the vpu_idle signal. Projected ImpactJEEHEHRECONSTRUCT: The automatic clock gating can be disabled and replaced by software controlled clock gating with minor impact to power saving.	: Do not activate the automatic clock gating and use the software implementation for VPU clock gating, instead. The VPU clock is gated on before sending a command and gated off after receiving interrupt of the command.	11195 VPU may miss generating encoding/decoding interrupt when automatic clock gating is activated
Cortex-A8	NXP		: Due to a memory timing problem on memories used in the i.MX53 IPU and VPU, these blocks may miscalculate incoming data for decoding. The problem occurs when the IPU and VPU are running at max frequency of 200MHz. Projected ImpactJEEHEHRECONSTRUCT: Some artifacts may be seen on the decoded image.	: None	11856 IPU and VPU may present some artifacts when running at12SPACEJEEHEH200MHz
Cortex-A8	NXP		: When eSDHC3 port is used in single data rate (SDR) SD mode, it cannot meet the required setup time to operate at a maximum frequency of 50MHz. In this mode it can support up to 45MHz for SD clock frequency. In EMMC4.4 mode, the required setup time is smaller, thus there is no issue and up to 52MHz is supported. Projected ImpactJEEHEHRECONSTRUCT: For SD cards, which can support 50MHz clock, this frequency may not be achieved on the eSDHC3 port in SDR mode thus affecting bandwidth. Nevertheless, no issue has been reported so far using 50MHz. There is no impact on other SD ports. Software Workaround: Use a SD clock frequency up to 45MHz for this port when SD card is used. Silicon Fix: No plan to fix.		12290 eSDHCv3 on eSDHC3 port has setup timing issue in SD SDR12SPACEJEEHEHmode
Cortex-A8	NXP		: Occurs when a pending command which issues busy is completed. For a command with R1b response, the proper software sequence is to poll the DLA for R1b commands to determine busy state completion. The DLA polling is not working properly for the ESDHC module. This is relevant for all eSDHC ports (eSDHC1-4 ports). Projected ImpactJEEHEHRECONSTRUCT: DLA bit in PRSSTAT register cannot be polled to wait for busy state completion. Software Workaround: Updated block guide to reflect that DLA is not applicable to detect busy state, instead, should poll bit 24 in PRSSTAT register (DLSL[0] bit) to check that wait busy state is over. Silicon Fix: No plan to fix.		12360 eSDHC AutoCMD12 and R1b polling problem
Cortex-A8	NXP		: The 256-bit SCC fuse (SCC_KEY[255:0]) has been programmed with the same value across i.MX53 devices. The SCC key should be unique per device, to ensure that data encrypted with one i.MX53 cannot be decrypted by another i.MX53. Projected ImpactJEEHEHRECONSTRUCT: A non-unique SCC_KEY means that the binding of the encrypted data to the IC is no longer unique to that IC. This affects the secure off-chip key storage functionality. Secure off-chip key storage may be used to protect data that is persistent in nature. Secure off-chip key storage is only enabled when the IC has been booted using the secure functionality. If the IC is not securely booted then secure off-chip key storage is not an available feature and thus the IC is not affected by this erratum. Software Workaround: None. Silicon Fix: No silicon fix required. The unique SCC_Key has been implemented. Contact factory for additional information. Chip Errata for the i.MX53, Rev. 6 112 Freescale Semiconductor12363		12354 SCC key fusing with a non-unique value
Cortex-A8	NXP		: In the event that an uncorrectable ECC error occurs while reading Main/Main+Spare from the NAND device, then all spare read operations would fail until the next successful Main/Main+Spare read operation. Projected ImpactJEEHEHRECONSTRUCT: The NFC wrongly indicates ECC error. Software Workaround: Read main or main+spare after first uncorrectable error. Silicon Fix: No hardware fix scheduled. This issue will be addressed in the next BSP release.		12363 NFC wrong indication of ECC uncorrectable error occurrence after reading the spare area
Cortex-A8	NXP		: The DDR2 JEDEC standard requires the DDR clock (SDCLK) to start toggling at least 200 Î¼S before the clock enable (SDCKE) signal rise. For DDR3, the minimum time is 500 Î¼S. In the ESDCTLv2 IP implementation, the actual number that is counted is actually a half CKIL cycle less than described in the eSDCTL chapter in i.MX53 RM. Thus, when programming the recommended value in SDE_to_RST field, the result is a half CKIL cycle less than expected, thus violating the above JEDEC requirement. Note that CKIL is a 32 KHz clock. Impact: So far, no issue has been seen. Software Workaround: For DDR2, in the RST_to_CKE field (ESDCTL_ESDOR[5:0]), program a value of 10 h, to toggle SDCLK at least 7 CKIL cycles before SDCKE assertion. For DDR3, program a value of 23 h to toggle SDCLK at least 33 CKIL cycles before SDCKE assertion. Silicon Fix: No hardware fix is required. The i.MX53 RM and the BSP will be updated accordingly. Chip Errata for the i.MX53, Rev. 6 114 Freescale Semiconductor12379		12377 ESDCTLv2 might fail to wait the minimal time between DDR clk & clk enable
Cortex-A8	NXP		: When the AUS bit is set, the address lines of the EIM are un-shifted. By default, AUS bit is cleared and address lines are shifted according to port size (8, 16 or 32 bits). Due to an error the address bits 27:24 are shifted when AUS=1. For example, CPU address: 0xBD00_0000 ([A27:20]=1101 0000 becomes: 0xB600_0000 ([A27:20]=0110 0000) on the EIM bus. Since A[27:25] is shifted to [A26:24] and A[23:0] is not shifted. As a result A[24] is missed. Impact: If the memory used does not exceed 32 MB, there is no impact. This mode is related to a unique memory configuration that is not often used. Most systems can work in the default mode (AUS=0). Board designers should connect the EIM address bus without a shift (for example, A0âA0 and A1âA1), while working in AUS=0 mode. Software Workaround: â¢ Use the AUS = 0 mode (default) while connecting the address signals without a shift (for example, A0âA0 and A1âA1). â¢ For AUS=1, for devices larger than 32 MB, need to build a memory map that takes this shifting into consideration and does not include A[24] line. Silicon Fix: No hardware fix is scheduled.		12379 EIM: AUS mode is non functional for devices larger than 32MB
Cortex-A8	NXP		: When the TIEN bit is set to low, the ESAI transmitter may misalign the data with the desired channels, regardless of the number of pre-loaded data written to ETDR register. As a result, the audio may be transmitted to the wrong channel, causing a channel mismatch. In case of two channels, the channels could be swapped. If TIEN bit is set to high, and the number of pre-loaded data is equal to the number of channels, the data will be sent to the correct channel. Projected ImpactJEEHEHRECONSTRUCT: The audio may be transmitted to the wrong channel when TIEN=0. Workaround: Set TIEN bit, and write the proper initial words to ETDR register.12SPACEJEEHEH		12385 ESAI: Channel misalignment may happen in ESAI transmitter data stream when TIEN bit is zero
Cortex-A8	NXP		: The operation of the Embedded Trace Buffer (ETB) is not guaranteed at 1.2 GHz. This issue does not occur on most i.MX53 parts. Projected ImpactJEEHEHRECONSTRUCT: In some cases, the ETB cannot be used at above 1 GHz, by using the default ARM voltage settings. Workaround: â¢ Increase the ARM voltage during debug at 1.2 GHz, maintaining the voltage limits specified in the datasheet. â¢ Perform the debug at 1 GHz instead of at 1.2 GHz. Silicon Fix: No fix scheduled. Chip Errata for the i.MX53, Rev. 6 Freescale Semiconductor 117		12386 ETB may not function properly at 1.2GHz
Cortex-A8	NXP		: Unaligned access to AIPS can be driven high by SAHARA, DAP, and FEC. If they access the AIPS internal registers during an unaligned access, an ABORT occurs. Projected ImpactJEEHEHRECONSTRUCT: Unaligned accesses to the AIPS internal registers fail.	: Make only aligned accesses to the AIPS internal registers.	07298 ENGcm07298 AIPS: Unaligned access causes abort on writes to the internal registers
Cortex-A8	NXP		: If a sequence of load and store operations are performed to different address locations in a memory region that is marked as shared device, then a load can incorrectly bypass a store. The issue is reported by ARM, erratum ID 709718, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If the load address and store address are mapped to access the memory region of the same device, and the device relies on memory operations to occur in program order, then this device may not operate as intended.	: The erratum occurs only for the shared device memory regions and not for the non-shared device memory regions. Therefore, this problem can be worked around by using the remap registers to remap all the shared device transactions to the non-shared device. The only difference between the shared device and the non-shared device is the attributes produced for the transaction on the AXI interface. Therefore, the user does not experience any impact in terms of performance from this workaround. Another possible use of the TEX remap is to map the shared device regions to the strongly ordered transactions. This second remapping option is less desirable as it affects the performance, as strongly ordered transactions are not buffered. The following code sequence is required to setup and enable the TEX remap. This should be done before enabling the MMU. ; Setup PRRR so device is always mapped to non-shared MRC p15, 0, r0, c10, c2, 0; Read Primary Region Remap Register BIC r0,#3<<16 MCR p15, 0, r0, c10, c2, 0; Write Primary Region Remap Register ; Enable TEX remap MRC p15, 0, r0, c1, c0, 0; Read Control Register ORR r0,r0,#1<<28 MCR p15, 0, r0, c1, c0, 0; Write Control Register Another valid workaround is to place a data memory barrier (DMB) between all the memory accesses to the device regions, where ordering is required between a store and a subsequent load to a different physical address.	09830 ENGcm09830 ARM: Load and Store operations on the shared device memory regions may not complete in program order
Cortex-A8	NXP		: Under certain conditions, a sequence of instructions where an MCR instruction that writes a CP15 register is closely followed by an MRC that reads the same register, are executed such that the RAW hazard is not detected and the MRC reads the old value of the register. This scenario can only occur for accesses to one of the following four CP15 registers: â¢ CacheSizeSelection Register â¢ Thread and ProcessID user read/write â¢ Thread and ProcessID user read only â¢ Thread and ProcessID privilege only These registers are both readable and writable and have been optimized to execute in a single cycle. Furthermore, this scenario occurs only when a specific sequence of instructions is executed between the MCR and the MRC. The sequence must meet two criteria: â¢ It must take less than three cycles to execute â¢ It must have one of the instructions in the following list: â ARM PLD with [Rn, -Rm, <shift>] addressing mode â ARM or Thumb PLD with [Rn, Rm,<shift>] addressing mode (unless it is LSL #0 or LSL #2) â Thumb or ThumbEE load/store instruction with [Rn, Rm,<shift>] addressing mode (unless it is LSL #0 or LSL #2) â Thumb TBB instruction The issue is reported by ARM, erratum ID 588115, Category 31. Projected ImpactJEEHEHRECONSTRUCT: If this erratum is encountered, the old stale value of the register is read rather than the newly written value, in which case the system software may appear to behave incorrectly. However, the usage model for such a software sequence is unclear, and hence the likelihood of encountering it in practice is very low, especially considering the requirement of the second unrelated instruction that must also fall between the MCR and the MRC.	: If a workaround for this erratum is desired, there are two options. The first simple option is to add a NOP immediately following the MCR register write in any case where encountering this erratum may be a concern. By adding a single NOP, the minimum required cycle window is guaranteed and the erratum does not occur. The second option is to set bit 16 in the CP15 Auxiliary Control Register. This causes a pipeline flush on every write to the CP15 register and ensures that the RAW hazard condition does not occur. 1. Category 3 defined as: Behavior that is not the originally intended behavior but should not cause any problems in applications. Chip Errata for the i.MX51, Rev. 5 14 Freescale Semiconductor07788 The second workaround has the advantage of requiring just one change to the CPU configuration that can be done statically. The disadvantage is that it has some impact on the performance of write updates to CP15 registers that would not otherwise require a pipeline flush. This second workaround can be implemented using the following code sequence to be executed in the Secure state: MRC p15, 0, R1, c1, c0, 1 ; read Aux Ctl Register ORR R1, R1 #(1 << 16) ; set bit 16 to 1 MCR p15, 0, R1, c1, c0, 1 ; write Aux Ctl Register	07788 ENGcm07788 ARM: A RAW hazard on certain CP15 registers can result in a stale register read
Cortex-A8	NXP		: All memory transactions performed as part of a tablewalk should be considered Privileged, even in the User mode. However, Cortex-A8 incorrectly marks memory transactions generated from tablewalks performed in User mode as the user transactions on the AXI bus. This indication is given by the ARPROT[0] signal, which is set to zero during the transaction. The conditions are as follows: â¢ Cortex-A8 must be in user mode â¢ A memory transaction (instruction or data) misses in the TLB and causes a tablewalk â¢ The address for the page table entry is not found in the L2 cache, resulting in an external memory request â¢ This erratum occurs when APROT[0] incorrectly indicates a user transaction for this memory request on the AXI bus. The issue is reported by ARM, erratum ID 488063. Projected ImpactJEEHEHRECONSTRUCT: As the values broadcast on ARPROT[0] are completely transparent to the software, the implications for this erratum are only on a specific subset of the processor systems, specifically for a system that includes some form of system level memory protection unit, that uses the ARPROT bits to determine if a memory request can be allowed. For any system that does include such a unit, that unit may report false errors on page table accesses due to this erratum.	: As the processor directly does not make use of ARPROT[0], any workaround would be specific to the device that makes use of the values broadcast on ARPROT[0]. The most likely usage would be some form of system memory protection unit. If such protection unit exists, it may need to filter out any access to the page tables from the address space that is protected to operate properly. This implies that the external protection unit cannot provide additional protection for the page tables. For example, the page table cannot be inserted in a Secure RAM which cannot be accessed in User mode, as in this case, an additional protection is added beside the MMU. Alternatively, the CSU can be configured to transform User access to Privileged on addresses used by PAGE TABLE.	04786 ENGcm04786 ARM: ARPROT[0] is incorrectly set to indicate a USER transaction for memory accesses generated from user tablewalks
Cortex-A8	NXP		: ARMv7 architecture specifies that the CSSELR should be banked between Secure and Non-secure states. Cortex-A8 does not currently bank this register. The conditions are as follows: â¢ The system should have an active process in secure state and an active process in non-secure state at the same time. â¢ The system should perform cache maintenance operations in both secure and non-secure processes. The issue is reported by ARM, erratum ID 485963, Category 21. DescriptionJEEHEHRECONSTRUCT: When a Clean to Point of Coherency (PoC) by MVA operation is performed, or the Preload Engine is programmed to clean a region of memory from the L2 cache, a cache line from that region can be corrupted with a stale copy of memory, and a memory store operation is lost. The conditions are as follows: â¢ A Cache Clean by MVA to the PoC instruction is executed to clean cache line A, or the preload engine is configured to clean a memory region which includes cache line A. Either of the operations result in the placement of cache line A into a victim buffer for writeback to external memory. It also keeps the line still valid in the L2 cache. â¢ A memory store operation is performed to the same cache line A that is evicted by the cache clean operation. This operation results in a modification of cache line A in the L2 cache (but not to the copy of the line that may still remain in the victim buffer if memory response is slow). â¢ A cache eviction is done of cache line A due to an unrelated memory request to load cache line B. The modified copy of cache line A is placed in a victim buffer. At this point, the two victim buffers may contain two different versions of cache line A. As each victim buffer uses a different AXI ID and arbitrates independently for the AXI bus, there is no guarantee for the order in which the memory updates occur, and the store operation may be overwritten by the cache clean operation, leaving the external memory with stale contents. The issue is reported by ARM, erratum ID 586323, Category 21. Projected ImpactJEEHEHRECONSTRUCT: A cache cleaning sequence that reads the CSSELR may not work as expected. The published sequence for cleaning the entire cache (see ARM Architecture Reference Manual) includes setting the CSSELR followed by a read from the selected Cache Size ID register (CCSIDR). If the non-secure side executes this sequence, and is encountered by a secure interrupt between the setting of the CSSELR and the reading of the selected CCSIDR, then there is a possibility that the secure side may also use the CSSELR. On returning to the non-secure side, the CSSELR value may have changed, which makes the cache cleaning sequence to malfunction. Similarly, a non-secure interrupt can cause a secure cache cleaning sequence to malfunction. Projected ImpactJEEHEHRECONSTRUCT: If the operation sequence occurs as described above, one or more store operations are lost, resulting in incorrect program behavior. This can occur for any application which either uses the preload engine to clean a memory region, or uses Clean by MVA to PoC maintenance operations to clean a region of memory.	: When transitioning security state, the secure monitor software should save the current CSSELR value (corresponding to the security state the processor is transitioning out of) and restore the previously saved CSSELR value (corresponding to the security state the processor is transitioning into). WorkaroundsJEEHEHRECONSTRUCT: There are two feasible workarounds that can be used for this erratum. The first workaround is to place a DMB or DSB barrier at the end of each cache clean routine or preload engine memory clean sequence. This barrier operation ensures that the cleaned line goes out and is seen by main memory before the store is executed and therefore guarantees that the clean is done correctly and memory contains the correct final value. This workaround is consistent with the ARM recommended practice for ending the maintenance routine. The above workaround is convenient to implement and should work for all expected usage models. However, there is still the possibility that an interrupt can be taken during the clean routine, and the interrupt handler can perform a store operation to the line just cleaned, allowing for the scenario which can lead to the erratum. 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 19	04785 ENGcm04785 ARM: C15 Cache Selection Register (CSSELR) is not banked
Cortex-A8	NXP		: If a non-cacheable memory request is subsequently followed by any cache maintenance operation done by MVA, then the memory can be corrupted. The conditions are as follows: â¢ The L1 data cache must be of size 32 Kbyte â¢ The L1 data cache hardware alias checks are enabled (the L1ALIAS bit in the Auxiliary Control Register is set to 0) â¢ The virtual memory management used by the operating system does not follow the page coloring guidelines and allows virtual to physical address alias cases to exist on bit 12 of the address â¢ A non-cacheable memory request to normal, device, or strongly ordered memory is subsequently followed by a cache maintenance operation done by MVA without any cacheable memory operations executed in between. The non-cacheable memory request can be fully executed, or can be a speculative instruction in the branch shadow that subsequently is flushed. When the above conditions are met and the cache maintenance operation is performed to generate a hash alias scenario on its cache lookup, memory corruption or a false parity error can occur. The issue is reported by ARM, erratum ID 586324, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If the operation sequence occurs as described above, then memory can be corrupted or a false parity error can be generated. In addition, even if the workaround as described below is implemented, it is possible that a nonsecure maintenance operation could result in the invalidation of a secure memory location. Therefore, this could possibly be viewed as an avenue for a security attack. However, the contents of secure memory cannot be viewed as a direct result of this erratum and the lack of consistent repeatability makes it very difficult for the user to make use of this erratum as a security attack.	: If full PIPT caching support is not required by the operating system, or the processor includes a 16 Kbyte L1 data cache, then no workaround is required. If alias conditions can occur, then the workaround is to guarantee that a cache maintenance operation is not immediately preceded by a non-cacheable memory request. This is guaranteed by initiating every cache maintenance by MVA routine with a cacheable load or store request immediately preceding the main loop and ending with a DSB barrier operation at the end of the loop. The load or store that precedes the loop can be done to any cacheable memory location. In addition, both interrupts and aborts should be masked during the cache maintenance routine. Interrupt masking is required to prevent a non-cacheable memory request, either fully executed or in a branch shadow, from initiating the sequence that can 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 21	07784 Another workaround that avoids even the case mentioned above, is to convert all Clean by MVA to PoC operations to Clean and Invalidate by MVA to PoC as described in the code sequence as follows: â¢ Replace all uses of: MCR p15, 0, <Rn>, c7, c10, 1; â¢ Clean Data cache line by MVA to PoC with this instruction: MCR p15, 0, <Rn>, c7, c14, 1; â¢ Clean and Invalidate cache line by MVA to PoC. There is no Preload Engine equivalent for the second workaround option as it is not possible to configure the preload engine to perform a clean and invalidate operation. Therefore, if there are concerns that the DSB based workaround is insufficient, then it is advisable to not use the Preload Engine for cleaning memory regions. The preload engine can be configured such that it is not accessible at user/privilege and nonsecure/secure level of granularity. For more information on Preload Engine configurability, see Cortex-A8 Technical Reference Manual.
Cortex-A8	NXP		: When a Clean to Point of Coherency or Clean and Invalidate to Point of Coherency by MVA operation is performed, it is possible that the line remains present in the L2 cache and any dirty data is not pushed out on to the AXI bus to main memory. This can occur whenever the requested address is present in the L1 cache but not the L2 cache. The conditions are as follows: â¢ The memory region being cleaned is configured in write allocate mode â¢ The cache line being cleaned is initially present in the L1 cache and not in the L2 cache The issue is reported by ARM, erratum ID 586320, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If a Clean or Clean and Invalidate operation does not operate as intended, and leaves the data present in the L2 cache, the memory coherency in the system can no longer be guaranteed. Therefore, this erratum impacts any code sequence used to maintain the system coherence.	: The software workaround for this erratum is to disable the write allocate in the L2 cache, as shown in the following instruction sequence: MRC p15, 1, <Rd>, c9, c0, 2; read L2 cache Aux Ctrl Reg ORR <Rd>, <Rd>, #(1 << 22); set the Write Allocate disable bit MCR p15, 1, <Rd>, c9, c0, 2; write the L2 cache Aux Ctrl Reg Disabling the write allocate in the L2 cache can impact the performance of some applications. If this performance impact is deemed to be very high, there are two other software workarounds that can be used. The first is to disable write allocate around each sequence of clean by MVA to PoC or clean/invalidate by MVA to PoC instructions, as shown in the following instruction sequence: MRC p15, 1, <Rd>, c9, c0, 2; read L2 cache Aux Ctrl Reg ORR <Rd>, <Rd>, #(1 << 22); set the Write Allocate disable bit MCR p15, 1, <Rd>, c9, c0, 2; write the L2 cache Aux Ctrl Reg <perform sequence of MVA operations here> MRC p15, 1, <Rd>, c9, c0, 2; read L2 cache Aux Ctrl Reg BIC <Rd>, <Rd>, #(1 << 22); clear the Write Allocate disable bit MCR p15, 1, <Rd>, c9, c0, 2; write the L2 cache Aux Ctrl Reg The final workaround that can be implemented is to perform each maintenance operation twice with interrupts disabled. By performing the operation twice in back-to-back successions with no other memory operations executed in between, it can be assured that the line is evicted from both L1 and L2 cache and written out to main memory. 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 23	07786 result in this erratum. If there are concerns about the interrupt latency, the maintenance loop can be amended to enable and disable the interrupts directly around the maintenance operation. This impacts the time taken to complete the maintenance loop. To workaround any concerns of a potential security attack due to this erratum, all secure memory should be marked as inner write through. This can be done either by using the caching attributes in the page tables for all secure page tables or by making use of the secure banked version of the remap registers. Apart from making all secure memory write through, a routine should be run out of reset to completely fill the cache with dummy data, to prevent invalid, uninitialized data in the cache from being written out to memory and potentially corrupting secure memory. Making all secure memory inner write through guarantees that even if the invalidation of a secure line in the L1 cache occurs due to this erratum, the correct data is not lost.
Cortex-A8	NXP		: Under specific set of conditions, the stale data saved in the L2 cache can be erroneously returned to the processor on a subsequent load instruction. The conditions are as follows: â¢ The L2 cache must be configured as an inner cache rather than as an outer cache â¢ The L2 cache must be configured to use write allocate memory type The issue is reported by ARM, erratum ID 468413, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If this erratum occurs, stale data can be read by a subsequent load instruction, resulting in an incorrect program behavior.	: There are two viable workarounds for this erratum. One workaround is, not to configure the L2 cache as an inner cache, but maintain the default setting as an outer cache. The second workaround is to use the remap registers to remap the inner cache attributes from write allocate to write back instead.	07782 Perform the following steps: 1. Disable the interrupts and the imprecise aborts 2. Execute the maintenance operation first pass 3. Execute the same maintenance operation, second pass12SPACEJEEHEH4. Enable the interrupts and the imprecise aborts Repeat the above sequence for each cache maintenance operation. Interrupts can remain disabled for a longer sequence of maintenance operations, but this has a negative effect on interrupt latency. This workaround has a performance impact on the execution time of cache maintenance operations.
Cortex-A8	NXP		: Three memory requests in the L2 cache can interact and result in a deadlock condition. The exact scenario involves a dependency chain of three requests, an instruction fetch request, a memory preload instruction (PLD) and a swap instruction (SWP). In this dependency loop, no request can progress as each one of them is dependent on the next request. That is, the PLD request cannot complete as the IF request is pending to use the BIU. The IF request cannot complete because of the pending SWP request, and the SWP request is not allowed to complete as it is waiting on the PLD to complete before obtaining the lock on the bus. The conditions are as follows: â¢ PLD instructions must be used by the processor â¢ SWP instructions must be used by the processor The issue is reported by ARM, erratum ID 468415, Category 31. Projected ImpactJEEHEHRECONSTRUCT: This erratum only impacts the users of swap instructions. Swap instructions have been deprecated from the ARMv7 version of the ARM Architecture as its functional use in terms of setting up semaphores is now replaced from the ARMv6 architecture forwards by the LDREX and STREX instructions. If this erratum is encountered and the processor deadlock occurs, it can only be interrupted by resetting the processor.	: One software workaround for this erratum is, not to use the swap instructions. If swap instructions are to be used in the code base, the other software workaround is to disable the PLD instructions and make them a NOP. The code required to implement this workaround is as follows: MRC p15, 0, r0, c1, c0, 1; read register ORR r0, r0, #(1<<9); PLDNOP - force PLD to be NOP MCR p15, 0, r0, c1, c0, 1; write register This workaround has some performance impact on the peak memory copy bandwidth.	04761 ENGcm04761 ARM: Swap instruction, preload instruction, and instruction fetch request can interact and cause deadlock
Cortex-A8	NXP		: Under very specific set of conditions, data from a Neon load request can be incorrectly forwarded to a subsequent, unrelated memory request. The conditions are as follows: â¢ Neon loads and stores must be in use â¢ Neon L1 caching must be disabled â¢ Trustzone must be configured and in use â¢ The secure memory address space and the non-secure memory address space both use the same physical addresses, either as an alias or the same memory location or for separate memory locations The issue is reported by ARM, erratum ID 468414, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If this erratum is encountered, it is possible for a load request to receive the wrong data value which can likely result in incorrect operation of the program.	: There are many software solutions for this erratum and only one has to be applied. The recommended solution, if possible, is to map cacheable areas of memory so that both secure and non-secure do not share the same physical address space. Another possible solution is to force NEON to cache in the L1 data cache. This can be programmed using the Auxiliary Control Register bit [5], L1NEON, as follows: MRC p15, 0, r0, c1, c0, 1; read register ORR r0, r0, #(1<<5) ; L1NEON caching enable MCR p15, 0, r0, c1, c0, 1 ; write register. Another possible solution is to disable L2 data forwarding from the victim buffers. This can be programmed using the L2 Auxiliary Control Register bit[27], Load data forwarding disable as follows: MRC p15, 1, r0, c9, c0, 2 ; read register ORR r0, r0, #(1<<27) ; L2 load data forwarding disable MCR p15, 1, r0, c9, c0, 2 ; write register Both workarounds can be implemented with little or no perceived performance impact in the majority of applications.	04759 ENGcm04759 ARM: NEON load data can be incorrectly forwarded to a subsequent request
Cortex-A8	NXP		: If a load request is processed which misses the L2 cache, but cannot be immediately forwarded to the BIU, it encounters a special hazard which prevents the request from being required to access the L2 cache RAM again to save power. There can be multiple requestors with unique addresses, (that is, one address per cache line) with this special hazard. All write-allocate requests that access the L2 cache RAM, on port1, do not have address comparators to check for this special hazard condition. So, if a subsequent write-allocate request is issued to the L2 cache RAM on port1 and allocates a victim buffer, then all requests pending with this special hazard must be forced to perform a L2 cache RAM lookup again to maintain memory coherency. There is a 1-cycle window in which the write-allocate request must allocate to a victim buffer and a pending request to the BIU is not prohibited from going to the BIU, such that a deadlock can occur. The conditions are as follows: â¢ The processor must have L2 cache present and enabled. â¢ The L2 cache must be configured to support the write allocate memory type. The issue is reported by ARM, erratum ID 468416, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If this erratum is encountered and processor deadlock occurs, it can only be interrupted by asserting RESET on the processor.	: The workaround for this erratum is to disable write-allocate by programming the L2 Auxiliary Control Register bit[22], Write allocate disable: MRC p15, 1, r0, c9, c0, 2; read register ORR r0, r0, #(1&lt;&lt;22); Write allocate disable MCR p15, 1, r0, c9, c0, 2; write register Disabling write allocate in the L2 cache could have a performance impact for some applications.	04760 ENGcm04760 ARM: Under a specific set of conditions, processor deadlock can occur when L2 cache is servicing write allocate memory
Cortex-A8	NXP		: In the register AMC of the Tiger/ARM Platform (0xBASE_0018) the bit ALPEN must be set to 1 and ALP[2:0] must be set to â000â. Other combinations are reserved and must be avoided. DescriptionJEEHEHRECONSTRUCT: If the PMU is in use and an overflow event occurs simultaneously with a write to one of the subsets of CP15 and CP14 registers, the overflow event can be lost. The conditions are as follows:12SPACEJEEHEH1. The performance counters must be in use 2. The performance counter must have an overflow (counter value goes beyond 0xFFFF_FFFF) 3. Simultaneous with the counter overflow, a MCR instruction must be executed that writes to one of the following CP14/CP15 registers: â Any PMU register other than PMU counter registers â ThumbEE Configuration Register â ThumbEE Handler Base Register â System Control Register â Auxiliary Control Register â Secure Configuration Register â Secure Debug Enable Register â Nonsecure Access Control Register â Context ID and Thread ID Registers â Coprocessor Access Register â Cache Size Select Register The issue is reported by ARM, erratum ID 628216, Category 21. Projected ImpactJEEHEHRECONSTRUCT: Memory retention issues unless the guideline is followed. Projected ImpactJEEHEHRECONSTRUCT: If the erratum occurs, the overflow status flag is not set for that counter in the Overflow Flag Status Register, and an interrupt request is not generated, even when the Interrupt Enable Set Register is configured to generate an interrupt on counter overflow.	: None WorkaroundsJEEHEHRECONSTRUCT: The main workaround is to poll the performance counter. The maximum increment in a single cycle for a given event is 2. Therefore, polling can be infrequent as no counter can increment by more than 232 in fewer than 2 billion cycles. If the main usage model for performance counters is collecting values over a long period, then polling can be used to collect values (and reset the counter) rather than waiting for an overflow to occur. Polling can be done infrequently and overflow can be avoided. If the main usage model for performance counters relies on presetting the counter to some value and waits for an overflow to occur, then polling can be used to detect when an overflow event is 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 33	10230 ENGcm10230 ARM: Clarification regarding the ALP bits in AMC register
Cortex-A8	NXP		: If a Neon store is done to Device type memory and is followed in instruction sequence by a load instruction to Device type memory, it is possible that an unrelated store instruction that is done to cacheable memory and hit the L1 cache has its data dropped and therefore not update memory. There are three different memory types defined in the ARM architecture namely, Strongly Ordered, Device, or Normal. Device type memory is one of the three different memory types. This region is specified by the page table entries used by the MMU. The conditions for this erratum are that relatively close in the instruction stream, the following must occur: â¢ A Neon store is done to Device type memory. â¢ A load is executed to Device type memory (any load to Device type memory region, not just from Neon), consecutive to the Neon store. â¢ Several stores hit the L1 cache. (Any store that hit the L1 cache - Neon or integer core. The address does not matter.) The issue is reported by ARM, erratum ID 507113, Category 31. Projected ImpactJEEHEHRECONSTRUCT: If the erratum occurs, one or more cacheable stores that hit the L1 cache do not update the cache, leaving stale contents in memory. This is likely to cause observable, incorrect behavior in the application. The Neon access to memory region marked as Device is not a practical case in general.	: The only workaround for this erratum is to avoid accessing the Device type memory with Neon store instructions. (There should be no practical case for this, anyway). However, if needed, define the region as Strongly Ordered memory, instead.	10700 missed. An overflow can be determined to have been missed if the unsigned value in the counter is less than the value preset into the counter. Polling can be done infrequently because of the number of cycles it requires for this check to fail. If the erratum is triggered and an overflow event is missed, the counter sample can be thrown away or the true value can be reconstructed.
Cortex-A8	NXP		: All BTB invalidate operations, including BTB Invalidate by MVA operations, by default are implemented as a NOP in the Cortex-A8 processor. These operations can be executed as NOPs as flushing BTB entries are not required by the Cortex-A8 processor for correct functionality, and there is no additional performance penalty for an incorrect branch prediction versus a non-prediction. However, it is possible for BTB operations to be enabled by setting the IBE bit in the CP15 Auxiliary Control Register. When enabled in this fashion, BTB invalidate by MVA operations may not work as intended. Instead of writing zeros to the valid bit of the BTB entry matching the MVA provided, the CP15 âInvalidate Branch Predictor by MVAâ operation writes the value currently in the âInstruction L1 System Array Debug Register 0.â This register is not initialized at the reset time and can only be written in secure, privileged modes when CP15SDISABLE is not set. The conditions are as follows: 1. The branch predictor is enabled (SCTLR.Z = 1) 2. The Auxiliary Control Register IBE bit is set to 1 3. An invalidate Branch predictor by MVA operation is executed 4. The Instruction L1 System Array Debug Register 0 contains a non-zero value which sets the valid bit and clears the page cross bit. The issue is reported by ARM, erratum ID 687067, Category 31. Projected ImpactJEEHEHRECONSTRUCT: If the non-zero value contained in L1 System Array Debug Register 0 sets the valid bit of the BTB entry, then the entry is not invalidated as intended.	: A workaround for this erratum is, not to enable the IBE bit. ARM recommends that the IBE bit should not be enabled unless it is required for an erratum workaround. If the IBE is to be enabled, then the L1 System Array Debug Register 0 should be initialized to a zero value. This register is for RAM array debug purposes and is not used as a part of normal functionality. It is only accessible in a privileged secure mode. Therefore, it can be statically initialized as a part of the boot code sequence. If the register is used for debug purposes, the value should be reset to zero when the debug sequence completes. The code to initialize the L1 System Array Debug Register 0 is as follows: MOV r1, #0 MCR p15, 0, r1, c15, c1, 0 ; write instruction data 0 register MRC p15, 0, R1, c1, c0, 1 ; read Aux Ctl Register ORR R1, R1 #(1 << 6) ; set IBE to 1 MCR p15, 0, R1, c1, c0, 1 ; write Aux Ctl Register 1. Category 3 defined as: Behavior that is not the originally intended behavior but should not cause any problems in applications. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 37	10716 The memory which is Device Shared should be mapped as Normal Outer/Inner Non-Cacheable. This is the preferred memory type for RAM memory mapped as NCB. Customer software must avoid Device memory types. Chip Errata for the i.MX51, Rev. 5 36 Freescale Semiconductor10701 ENGcm10701 ARM: BTB invalidate by MVA operations do not work as intended when the IBE bit is enabled
Cortex-A8	NXP		: If a debug watchpoint and a precise data abort are both triggered from the same data access, the ARM Architecture specifies that the data abort should be prioritized. However, this does not occur on the Cortex-A8 and the watchpoint is taken instead. The conditions for the erratum are as follows:12SPACEJEEHEH1. At least one debug watchpoint is programmed 2. A precise data abort occurs on the same address as the watchpoint The issue is reported by ARM, erratum ID 693270, Category 31. Projected ImpactJEEHEHRECONSTRUCT: The implications of this erratum only affects the debug software. The data abort should take precedence over the watchpoint so that the OS has a chance to fix up paged-out memory before re-executing the instruction and presenting the debugger with the watchpointed address. Due to this erratum, this fix up does not occur and the debugger should be capable of handling a faulting address.	: The workaround for this erratum is to ensure that the debugger software handles the faulting address. When the debugger is signalled a watchpoint, and identifies that the page being accessed is subjected to an MMU fault, which it would like the OS to patch up before dealing with itself, it can perform the following actions: â¢ Disable the watchpoint â¢ Set vector catch on the local Data Abort exception (secure or non-secure, as appropriate) â¢ Set the PC at the watchpointed instruction and restart execution The processor restarts, re-executes the instruction and generate the MMU fault. It then fetches the instruction from the Data Abort handler and re-enter Debug state because of the Vector Catch event. The debugger can then perform the following actions: â¢ Re-enable the watchpoint â¢ Disable the vector catch â¢ Set the PC at the Data Abort vector and restart execution The processor restarts and re-executes the Data Abort vector instruction. The OS then patches up the MMU fault and attempts to re-execute the original instruction. Re-executing the instruction regenerates the Watchpoint debug event, but now the page is properly patched up.	10701
Cortex-A8	NXP		: If the integer to floating point conversion operation, VCVT.f32.u32, is executed with the FPSCR register configured for Default NaN and Flush-to-zero enabled, and the rounding mode used is RP (Round-to-Positive infinity), it returns the incorrect result for the source operation 0xFFFF_FF01. Specifically, it returns the result 0x0000_0000 instead of the correct result 0x4F80_0000. The erratum can occur only for this specific input value and this specific configuration of the FPSCR register. The conditions are as follows: 1. Default NaN is enabled (FPSCR[25] = 1âb1) 2. Flush-to-zero is enabled (FPSR[24] = 1âb1) 3. RP rounding mode is enabled (FPSR[23:22] = 2âb01) 4. A VCVT.f32.u32 instruction is executed with the source operand 0xFFFF_FF01 5. The result of the instruction is incorrect 0x0000_0000 rather than 0x4F80_0000 The issue is reported by ARM, erratum ID 715847, Category 31. Projected ImpactJEEHEHRECONSTRUCT: The incorrect result from the conversion operation can result in further incorrect results calculated and unexpected program behavior.	: The erratum only occurs if the floating point unit is configured in run fast mode with RP rounding. The easiest workaround is to avoid using this particular mode combination. Round-to-Nearest (RN) is a common rounding mode used, but if RP functionality is desired, it should be done without using Default NaN and/or without Flush-to-zero enabled. Default NaN signalling, Flush-to-zero, and rounding mode are all configured using bits [25:22] of the FPSCR register. This register is typically configured by the system software and should not change within an application.	10703
Cortex-A8	NXP		: If a Clean by MVA, Invalidate by MVA, or Clean and Invalidate by MVA cache maintenance operation is performed in a memory region that is marked non-cacheable, device, or strongly ordered, it is possible for the processor to deadlock or have stale data left in the processor. This erratum occurs when the address hits the cache in a way that is not predicted by the Hash Virtual Address Buffer (HVAB), which is a cache way predictor inside the processor. This erratum can occur only for the cache maintenance operations that are performed by MVA. It does not occur for the set/way based cache maintenance operations. The conditions are as follows: 1. A memory region is marked cacheable in a page table entry, and a cache line from that region is placed in the data cache 2. A second page table entry marks the same memory region as non-cacheable, device, or strongly ordered. This can occur by changing the memory attributes in the existing page table entry, or through an alternative page table entry that maps the same virtual to physical address but with non-cacheable, device, or strongly ordered attributes rather than cacheable 3. A Clean by MVA, Invalidate by MVA, or Clean and Invalidate by MVA cache maintenance operation is done to this address 4. The maintenance operation receives a false hit indication from the HVAB array 5. The maintenance operation receives a true hit indication from the Tag lookup, which implies that the data is present in the array, but located in a different way that is not predicted by the HVAB 6. An eviction of the dirty line has started but not finished, and the processor leaves stale data in the cache and can potentially enter a deadlock state The issue is reported by ARM, erratum ID 728018, Category 21. Projected ImpactJEEHEHRECONSTRUCT: If stale data is left in the cache, the processor does not work as intended. If deadlock state occurs, it can only be exited by asserting the RESET pin on the processor.	: There are two possible workarounds for this erratum. The first workaround is to avoid performing the cache maintenance operations to non-cacheable addresses previously marked cacheable and therefore may be resident in the cache. If the address is present in the cache, it implies that the memory region is marked cacheable at some earlier point of time and explicitly changed to non-cacheable before the maintenance operation is performed. If the region type is not changed to non-cacheable before executing the maintenance operation, this erratum can be avoided. The value of changing a memory region from cacheable to non-cacheable 1. Category 2 defined as: Behavior that contravenes the specified behavior and that can limit or severely impair the intended use of specified features, but does not render the product unusable in all or the majority of applications. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 43	10724 mode which is another condition for this erratum. Our FP support comes from a DLL provided by ARM. The ARM DLL should avoid the specific rounding mode associated with the erratum. Need to ensure RP rounding mode is not enabled. Chip Errata for the i.MX51, Rev. 5 42 Freescale Semiconductor11205 ENGcm11205 ARM: Cache maintenance operations by MVA for a non-cacheable memory region can result in processor deadlock
Cortex-A8	NXP		: When Neon performs a single byte load from Strongly Ordered or Device type memory with an access size of more than 8 bytes, the system AXI bus issues a burst access which is longer than 8 beats of a single byte. However, the M4IF is capable of supporting only access with a burst length of less than or equal to 8, as indicated in the i.MX51 Multimedia Applications Processor Reference Manual ( MCIMX51). The AXI bus access with burst length larger than 8 beat cannot complete. The results can be unpredictable and may lead to system hang. The MLEN bit indicates on an error, but it may not be possible to read it if the system hangs. Conditions for this issue: 1. A single byte Neon load is issued with more than 8 bytes access, for example: Vld1.8 {d0,d1,d2,d3}, [Rs]! 2. The source address is Strongly Ordered or Device memory type Projected ImpactJEEHEHRECONSTRUCT: The Neon access to memory region marked as Strongly Ordered or Device are not usually a practical case in general. Note that there are also other reported limitations for Neon access to Device type memory such as ENGcm10716.	: Several software solutions can be proposed for this issue: â¢ Use 8-bit Neon load with access size of less or equal to 8 bytes. For example: Vld1.8 {d0-d1}, [Rs]! This solution results in some performance degradation. â¢ Use 16 or 32-bit Neon load instructions instead. For example: Vst1.32 {d0 â d3}, [Rs]! The limitation of this proposal is that the source data address must be 16 or 32-bit aligned. â¢ Define the memory region as Normal Non-Cacheable type instead of Strongly Ordered or Device memory type. In this case, need to avoid potential memory consistence issues and perform Data Synchronization Barrier (DSB) before other DMA engine access the region for read, as the Write Buffer is enabled.	11205 before performing the maintenance operations is that this is the only way that the ARM v7 Architecture guarantees the line is not immediately placed back into the cache due to the possibility of data speculation. However, in Cortex-A8, this degree of data speculation is never done. Therefore, changing the memory type to non-cacheable before executing the cache maintenance operation is not required to assure that the line is not immediately placed back into the cache. However, if there is a code compatibility with other v7 implementations (that may exhibit this level of data speculation) is a concern, then this first workaround is insufficient, and the second workaround should be used. The second workaround is to execute the loop of cache maintenance operations twice. Execute the loop once with the memory region still marked cacheable. Then change the page table entry to make the memory region non-cacheable and execute the loop for a second time. The first loop cleans the data from the cache in the Cortex-A8. On the Cortex-A8, the second loop is redundant as it misses on all lines in the cache, but resolves the data speculation issue that can occur on a different v7 architecture implementation. The existing cache maintenance code in a dynamically paged environment can be dependent on the maintenance operation triggering a page fault to set the correct page table entry. The workaround code must independently ensure that the correct page table entry is present.
Cortex-A8	NXP		: There are two muxes which select a clock source for pll1_sw_clk (which is also the source for ARM clock). One of them is a regular mux (step select mux), and the other is a synchronous mux. The clock sources are selected by a single register (CCSR). If the pll1_sw_clk_sel bit is cleared (CCSR[2]) and the selection of the regular mux (CCSR[8:7]) is changed at the same time, then the regular mux is likely to switch first and can cause a glitch on pll1_sw_clk and hence on ARM clock and possibly other clocks as well. Due to above, the CCSR[8:7] bits may only be modified when step_clk is no longer selected. Therefore, CCSR[2] must be cleared in separate register access prior to changing CCSR[8:7]. DescriptionJEEHEHRECONSTRUCT: When the emi_int1 clock in the CCM_CCGR5 register is disabled, the transaction to the CCM passes through the INT1 channel of the EMI. However, the BRESP cannot be received by the ARM because the clocks are already turned off. This causes the system to hang. Projected ImpactJEEHEHRECONSTRUCT: None, if the proposed workaround is implemented. Projected ImpactJEEHEHRECONSTRUCT: None. User should refrain from disabling the EMI int1 clock.	: The CCSR[8:7] bits can be modified only when step_clk is no longer selected. The ARM clock source selection should be done in two accesses. The CCSR[2] must be cleared in separate register access prior to changing CCSR[8:7]. WorkaroundsJEEHEHRECONSTRUCT: None	11208 ENGcm11208 CCM: ARM clock source switch limitation
Cortex-A8	NXP		: The CSPI automatically clears the overrun error status bit when the RxFIFO is read. This bit should not be cleared. This bit is designed for the interrupt access mode, and not for the DMA access mode. The conditions are as follows: â¢ When the RO bit is cleared by an RxFIFO read, it does not cause a problem if no DMA accesses to the CSPI occur â¢ When DMA is utilized, the interrupt status of RO can be lost because of uncontrolled RxFIFO access by DMA DescriptionJEEHEHRECONSTRUCT: There is a synchronization mechanism at the DAP AHB access port (AHB-AP) between the clock domains connected at the SoC level (PCLKDBG and HCLK for dap_sys).The problem occurs in DAPAHBAp DapSync module when synchronizing AhbStateDbg HCLK to AhbStateSyncPCLK. This is a 3-bit bus and each bit is being sampled twice. This method does not ensure valid data on output bus. Projected ImpactJEEHEHRECONSTRUCT: If the RxFIFO is read before reading the Overrun error status bit, it is possible to miss the Overrun and thus miss the data. Projected ImpactJEEHEHRECONSTRUCT: Invalid data may appear on the output bus. The DapStateSync bus is also implemented in the same way and suffers from the same issue ZEffectZ: preventing reliable access of the IPs by DAP without CPU intervention.	: When DMA is used for data transfers, the software can program the CSPI to only allow the interrupt generation during the overrun condition and not enable any other interrupt sources. In this way, whenever an interrupt comes from CSPI, the software can assume that it is the result of an Overrun condition. WorkaroundsJEEHEHRECONSTRUCT: Ensure the core is in the active mode and the debug IPs are accessed through the core.	08209 ENGcm08209 CSPI: Incorrectly clears the overrun status bit
Cortex-A8	NXP		: Debug ROM address is defined wrong in DAP design (0x8000_0000 instead of 0x6000_0000). DescriptionJEEHEHRECONSTRUCT: Under certain conditions, the DPLL IP TOG_SEL bit is not cleared after the TOG_DIS bit is set. This issue is random in nature. Projected ImpactJEEHEHRECONSTRUCT: When RVI (the debugger) connects to the i.MX51 (the target), the scan chain can not automatically be built. Projected ImpactJEEHEHRECONSTRUCT: The proposed workaround resolves the issue.	: The scan chain must either be manually built or an external RVI script must be used. WorkaroundsJEEHEHRECONSTRUCT: A software delay for a fixed amount of time based on TOG_COUNT after the TOG_DIS bit is set.	09395 ENGcm09395 DAP: Debug ROM address in DAP design is incorrect
Cortex-A8	NXP		: When the SSB_POL is set to â1â the associated slave select does not automatically return to an inactive state after the data transaction is complete. NOTE This bug only applies to eCSPI modules and is not present in CSPI modules. The BGA signals CSPI1_MOSI, CSPI1_MISO, CSPI1_SSO, CSPI1_SS1, and CSPI1_RDY are not labeled correctly. The actual source for these signals is one of the on-chip eCSPI modules. DescriptionJEEHEHRECONSTRUCT: According to the eCSPI specifications, when eCSPI is set to operate in the Slave mode (CHANNEL_MODE[x] = 0), the SSB_CTRL[x] bit controls the behavior of burst completion. In the Slave mode, the SSB_CTRL bit controls the behavior of SPI burst completion as follows: â¢ 0âSPI burst completed when (BURST_LENGTH + 1) bits are received â¢ 1âSPI burst completed when SSB input negated Also, in BURST_LENGTH definition, it is stated âIn the Slave mode, this field takes effect in SPI transfer only when SSCTL is cleared.â However, the mode SSB_CTRL[x] = 1 is not functional in Slave mode. Currently, BURST_LENGTH always defines the burst length. According to the SPI protocol, negation of SSB always causes completion of the burst. However, due to the above issue, the data is not sampled correctly in RxFIFO when {BURST_LENGTH+1}mod32 is not equal to {actual burst length}mod32. Therefore, setting the BURST_LENGTH parameter to a value greater than the actual burst does not resolve the issue. Projected ImpactJEEHEHRECONSTRUCT: This issue produces an undesired behavior in the channels configured to SSB_POL = 1. The ports operate properly when SSB_POL = 0. Projected ImpactJEEHEHRECONSTRUCT: Slave mode with unspecified burst length cannot be supported due to this issue. The burst length should always be specified with the BURST_LENGTH parameter and the SSB_CTRL[x] should be set to zero.	: There are two workarounds, as follows: â¢ The software solution applies to channels configured as SSB_POL = 1. After the data transaction is complete, the SS signal must be reconfigured as a GPIO. The GPIO must be programmed to a low level. â¢ A hardware solution is to place an inverter on the SS signal and program SSB_POL = 0. WorkaroundsJEEHEHRECONSTRUCT: There is no workaround except for not using the SSB_CTRL[x] = 1 option in the Slave mode. The accurate burst length should always be specified using the BURST_LENGTH parameter.	09397 ENGcm09397 eCSPI: Slave select remains asserted after transfer is complete when the SSB POL = 1
Cortex-A8	NXP		: There is a problem in WARM_RESET during sleep mode. The WARM_RESET flow is as follows: 1. SRC recognize WARM_RESET case (for example, RESET_IN_B) 2. SRC issues dvfs_req to EMI12SPACEJEEHEH3. SRC wait to dvfs_ack 4. If after some time the acknowledge does not arrive a counter in SRC recognizes it and SRC issues a cold RESET. When in Sleep Mode, EMI does not get clocks and therefore results in the issue. DescriptionJEEHEHRECONSTRUCT: The exclusive accesses are used as a semaphore mechanism in the AXI protocol. The basic process of an exclusive access is as follows: 1. A master performs an exclusive read from an address location. 2. At some later time a master tries to complete the exclusive operation by performing an exclusive write to the same address location. 3. The exclusive write of a master is signaled as: â Successful, if no other master has written to that location between the read and write accesses. â Failed, if another master has written to that location between the read and write accesses. In this case the address location is not update. On some occasions the EMI fails to detect a write access to the location tagged by the exclusive read and does not report on failure at exclusive write. This is happens when the tagged location is accessed indirectly in the middle of a burst. For example, assume the following sequence: â¢ Master A tags address nn by performing exclusive read access â¢ Master B writes to address mm â¢ Master A tags performs exclusive write to address nn If address nn = mm, the exclusive tag is cleared (exclusive write is not successful) - as expected. If master B performs a burst with the first address of the burst is equal nn, the exclusive tag is also cleared as expected. However, if master B performs a burst where the first address of the burst is not nn, but during the burst it does cross address nn, the exclusive tag is not cleared (exclusive write succeeds) - not as expected. Projected ImpactJEEHEHRECONSTRUCT: Any reset arriving in sleep mode even if it is supposed to be a warm reset is treated as cold reset, for example resetting all EMI registers. DDR content is preserved even though a cold reset is issued because in Sleep mode the memory is already in self refresh. Projected ImpactJEEHEHRECONSTRUCT: In i.MX51 based systems, only the Cortex-A8 is capable generating exclusive access. The exclusive access of the core to non-shared memory locations are all handled internally within the Cortex-A8 (CA8) monitor and do not propagate to the EMI. The exclusive access based semaphore mechanism between the core and other masters in the system is not utilized in practice. In case this mechanism is still required, it can be successfully operated with non-burst access.	: None. WorkaroundsJEEHEHRECONSTRUCT: Exclusive access to EMI works only if the tagged address is accessed directly. The access detection mechanism fails if the tagged location is written by consecutive burst access. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 55	09421 ENGcm09421 EMI/SRC: Warm reset can not be issued in sleep mode
Cortex-A8	NXP		: 8-bit memory devices are supported by WEIM interface connecting only to one of the following three locations: â¢ EIM_DA[7:0] pads â¢ EIM_DA[15:8] pads â¢ EIM_D[31:24] pads Connection to the EIM_D[23:16] pads is not supported. This erratum clarifies the statement in the MCIMX51 Multimedia Applications Processor Reference Manual (MCIMX51RM) that only 16-bit and 32-bit memory devices are supported by the WEIM interface. Projected ImpactJEEHEHRECONSTRUCT: WEIM 8-bit memory devices are supported according to above description.	: None	09424 The issue can be avoided if the software constrains the regular write to the tagged location to use non-burst access or use and addresses corresponding to the first word in the burst.
Cortex-A8	NXP		: There is a possibility of an extra pulse on SCLK in the EPIT, when switching between the clock sources. DescriptionJEEHEHRECONSTRUCT: After application of write commands, tWR clocks are required between the last written data until the precharge command to same bank. In cases where there is also an access to bank x followed by a back-to-back write access to bank y, bank x does not accept a precharge command until the data write of the second access (to bank y) is completed. According to the JEDEC standard, the precharge command to bank x should only be held until it has finished its own data and tWR. Projected ImpactJEEHEHRECONSTRUCT: It can result in an incorrect counter increment in the EPIT. Projected ImpactJEEHEHRECONSTRUCT: Due to the bug, writes to a bank are influenced by data writes to other banks. This results in minor performance degradation. In a situation where two masters are accessing two different DDR banks and one of the masters performs a new access to a different row, a precharge sent to the first row must be performed before the master can access the new row. In that case the second master must finish its access before the precharge can be issued. This situation also can occur in the case of one master making multiple accesses one after another to two different rows. This produces a minor performance decrease, because the new access is waiting for a precharge command to be issued. Some precharge commands are delayed a few extra clocks. In cases where missed access to any of the banks occurred between the time of the last access and the access to the original bank there is no impact and this limitation does not occur.	: Clock source should be changed only when the EPIT is disabled. A way to accomplish the same is as follows: 1. Disable EPITâEPITCR[0] = 0 (EN = 0), that is, disable EPIT 2. Disable EPIT outputâEPITCR[23:22] = 00 (OM = 00) 3. Disable EPIT capture interruptâEPITCR[2] = 0 (OCIEN = 0) 4. Change clock sourceâEPITCR[25:24] (CLKSRC), determines which clock source is selected for running the counter 5. Clear status registerâEPITSR[0] (OCIF), this is a write one to clear register 6. Configure EPIT to start count once enabled from load valueâEPITCR[1] = 1 (ENMOD = 1) 7. Re-enable EPIT EPITCR[0] = 1 (EN = 1), that is, enable EPIT12SPACEJEEHEH8. Reconfigure output and interrupt WorkaroundsJEEHEHRECONSTRUCT: None required, as the performace degradation is approximately 0.1%.	04773 ENGcm04773 EPIT: Possibility of additional pulse on src_clk when switching between clock sources
Cortex-A8	NXP		: The Enhanced SDRAM General Purpose Register (ESDGPR register at address 0xBASE+0x1034) bits 19 through 31 do not return correct value on read. The write operation works according to the specification. DescriptionJEEHEHRECONSTRUCT: For slow CPU read polling with WML (Water Mark Level) as 1, excessive data can be read from the card due to the presence of a flop between the buffer and the system bus. This causes the read buffer to overrun and by this halting the data transfer at both the sides and hanging the operation. Projected ImpactJEEHEHRECONSTRUCT: No functional impact. Projected ImpactJEEHEHRECONSTRUCT: CPU polling reads when WML is set to 1 can not be supported.	: None. WorkaroundsJEEHEHRECONSTRUCT: Do not set WML to 1. The eSDHC does not allow WML as 1 for CPU polling reads. This scenario is unusual even for single access. A read when WML is set to 2 can still be split into two successive reads.	08971 ENGcm08971 eSDCTL: ESDGPR register bits 19 to 31 are not readable
Cortex-A8	NXP		: After stopping at a block gap during a write operation, when the transfer is resumed, the data transfer can not complete and the transfer complete status bit is not set. DescriptionJEEHEHRECONSTRUCT: When eSDHC attempts to stop the transmission by sending CMD12, the clock does not always stop even though the data transfer is aborted. Projected ImpactJEEHEHRECONSTRUCT: The eSDHC can not finish write operations after encountering a block gap stop. Projected ImpactJEEHEHRECONSTRUCT: The result is communication with the SD/MMC card is lost	: Do not use stop-at-block-gap during write operations. WorkaroundsJEEHEHRECONSTRUCT: After sending CMD12 to abort the data transfer, poll the card clock status to see if it is stopped. If it is stopped, write to the XFER_TYPE register to issue the CMD12 as normal, and make several accesses (write or read, depending on the current transfer direction) to the buffer until the clock is restored.	09111 ENGcm09111 eSDHC: Cannot finish a write operation after a block gap stop
Cortex-A8	NXP		: The eSDHC does not support infinite data transfers, if the Block Count register is set to one, even when block count enable is not set. DescriptionJEEHEHRECONSTRUCT: When HS-I2C is used with SDMA (for example with a camera sensor) along with a read/write to/from an SD card, the eSDHC does not appear to forward the interrupt event to the TZIC (Cortexâs interrupt controller). Projected ImpactJEEHEHRECONSTRUCT: The eSDHC does not support infinite Block Transfer Mode. There is no limitation for single block transfers (with Multi/Single Block Select set to zero, Block Count Enable set to zero, and Block Count set to one). Projected ImpactJEEHEHRECONSTRUCT: The software ISR is never signaled, and as a result the read/write to the SD card causes it to hang. NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules.	: The following software workaround can be used instead of the infinite block mode: 1. Set BCEN bit to one and enable block count 2. Set the BLKCNT to the maximum value in Block Attributes Register (BLKATTR) (0xFFFF for 65535 blocks) WorkaroundsJEEHEHRECONSTRUCT: Do not use SDMA with the HS-I2C.	09107 ENGcm09107 eSDHC: Does not support Infinite Block Transfer Mode
Cortex-A8	NXP		: After DMA read operation, if hclk is automatically gated off, the DINT status can not be cleared by software. DescriptionJEEHEHRECONSTRUCT: Corrupted data is read if the buffer RAM is read until it is empty and the buffer register only contains one word. At this time, the buffer ready is still active when the Watermark level is 1 (RD_WML register bits is 1 or [{(BLK_SIZE + 3) Ã· 4}% RD_WML = 1). Projected ImpactJEEHEHRECONSTRUCT: Can not clear bit Projected ImpactJEEHEHRECONSTRUCT: Corrupted data is read from a buffer when the buffer RAM is read.	: Set HCKEN bit before starting DMA read operation, to disable hclk auto-gating feature; after the DINT and TC bit received when read operation is done, clear HCKEN bit to re-enable the hclk auto-gating feature. WorkaroundsJEEHEHRECONSTRUCT: Do not use RD_WML and [{(BLK_SIZE + 3) Ã· 4}% RD_WML = 1) configuration for read operations.	09403 ENGcm09403 eSDHC: Software can not clear DMA interrupt status bit after read operation
Cortex-A8	NXP		: A glitch may occur on the SDHC card clock when the software sets the RSTA bit (software reset) in the system control register. It can also be generated by setting the clock divider value. The glitch produced can cause the external card to switch to an unknown state. The occurrence is not deterministic. DescriptionJEEHEHRECONSTRUCT: A possible data corruption or incorrect bus transactions on the internal AHB bus, causing possible system corruption or a stall, can occur under the combination of the following conditions: 1. ADMA2 or ADMA1 type descriptor12SPACEJEEHEH2. TRANS descriptor with END flag 3. Data length is less than or equal to 4 bytes (the length field of the corresponding descriptor is set to 1, 2, 3, or 4) and the ADMA transfers one 32-bit word on the bus 4. Block Count Enable mode Projected ImpactJEEHEHRECONSTRUCT: Potential disruption of SD card operation. Projected ImpactJEEHEHRECONSTRUCT: Data corruption or incorrect bus transactions on the internal AHB bus, causing possible system corruption or a stall.	: A simple workaround is to disable the SD card clock before the software reset, and enable it when the module resumes the normal operation. The Host and the SD card are in a master-slave relationship. The Host provides clock and control transfer across the interface. Therefore, any existing operation is discarded when the Host controller is reset. The recommended flow is as follows: 1. Software disable bit[3] of the System Control register 2. Trigger software reset and/or set clock divider 3. Check bit[3] of the Present State Register for stable clock 4. Enable bit[3] of the System Control register. Using the above method, the eSDHC cannot send command or transfer data when there is a glitch in the clock line, and the glitch does not cause any issue. WorkaroundsJEEHEHRECONSTRUCT: The software should avoid setting ADMA type last descriptor (TRANS descriptor with END flag) to data length less than or equal to 4 bytes. In ADMA1 mode, if needed, a last NOP descriptor can be appended to the descriptors list. In ADMA2 mode this workaround is not feasible due to ENGcm11161.	10407 ENGcm10407 eSDHC: Glitch is generated on card clock with software reset or clock divider change
Cortex-A8	NXP		: Issue in eSDHC ADMA mode operation. The eSDHC read transfer is not completed when block size is not a multiple of 4 in transfer mode ADMA1 or ADMA2. The eSDHC DMA controller is stuck waiting for the TC bit in the interrupt status register. The following examples trigger this issue: 1. Working with an SD card while setting ADMA1 mode in the eSDHC 2. Performing partial block read12SPACEJEEHEH3. Writing one block of length 0x200 4. Reading two blocks of length 0x22 each. Reading from the address where the write operation is performed. Start address is 0x512 aligned. Watermark is set as one word during read. This read is performed using only one ADMA1 descriptor in which the total size of the transfer is programmed as 0x44 (2 blocks of 0x22). Projected ImpactJEEHEHRECONSTRUCT: The issue exists only when the block size is not a multiple of 4 in transfer mode ADMA1 or ADMA2.	: When the ADMA1 or ADMA2 mode is used and the block size is not a multiple of 4, the software should set the block size to: 4 block size â ------------ 4 In other words, the block size should be rounded to the next multiple of 4 bytes. In case of write, the software should add the corresponding number of bytes at each block end, before the write is initialized. In case of read, the software should remove the dummy bytes after the read is completed. For example, if the original block length is 22 bytes, and there are several blocks to transfer, the software should set the block size to 24. The following data is written/stored in the external memory: 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 2 Bytes valid data + 2 Byte dummy data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 4 Bytes valid data 2 Bytes valid data + 2 Byte dummy data Chip Errata for the i.MX51, Rev. 5 70 Freescale Semiconductor11104 In this example, 48 (24 x 2) bytes are transferred instead of 44 bytes. The software should remove the dummy data. Alternatively, the PIO mode can be used if the block size is non-4 byte aligned.	11104 ENGcm11104 eSDHCv2: ADMA transfer error when the block size is not a multiple of four
Cortex-A8	NXP		: ADMA2 mode in the eSDHC is used for transfers to/from the SD card. There are three types of ADMA2 descriptors: TRANS, LINK or NOP. The eSDHC has a problem when the last descriptor (which has the End bit '1') is a LINK descriptor or a NOP descriptor. In this case, the eSDHC completes the transfers associated with this descriptor set, whereas it does not even start the transfers associated with the new data command. For example, if a WRITE transfer operation is performed on the card using ADMA2, and the last descriptor of the WRITE descriptor set is a LINK descriptor, then the WRITE is successfully finished. Now, if a READ transfer is programmed from the SD card using ADMA2, then this transfer does not go through. DescriptionJEEHEHRECONSTRUCT: An issue is identified when interfacing the SDIO card. There is a case where an SDIO interrupt from the card is not recognized by the hardware, resulting in a hang. If the SDIO card lowers the DAT1 line (which indicates an interrupt) when the SDIO interrupt is disabled in the eSDHC registers (that is, CINTEN bits in IRQSTATEN and IRQSIGEN are set to zero), then, after the SDIO interrupt is enabled (by setting the CINTEN bits in IRQSTATEN and IRQSIGEN registers), the eSDHC does not sense that the DAT1 line is low. Therefore, it fails to set the CINT interrupt in IRQSTAT even if DAT1 is low. Generally, CINTEN bit is disabled in interrupt service. The SDIO interrupt service steps are as follows: 1. Clear CINTEN bit in IRQSTATEN and IRQSIGEN. 2. Reset the interrupt factors in the SDIO card and write 1 to clear the CINT interrupt in IRQSTAT. 3. Re-enable CINTEN bit in IRQSTATEN and IRQSIGEN. If a new SDIO interrupt from the card occurs between step 2 and step 3, the eSDHC skips it. Projected ImpactJEEHEHRECONSTRUCT: Limitation for configuring the last descriptor as LINK or NOP. Projected ImpactJEEHEHRECONSTRUCT: The issue is relevant only for the SDIO card interrupt usage.	: Software workaround is to always program TRANS descriptor as the last descriptor. WorkaroundsJEEHEHRECONSTRUCT: The workaround interrupt service steps are as follows: 1. Clear CINTEN bit in IRQSTATEN and IRQSIGEN. 2. Reset the interrupt factors in the SDIO card and write 1 to clear CINT interrupt in IRQSTAT. 3. Clear and then set D3CD bit in the PROCTL register. Clearing D3CD bit sets the reverse signal of DAT1 to low, even if DAT1 is low. After D3CD bit is re-enabled, the eSDHC can catch the posedge of the reversed DAT1 signal, if the DAT1 line is still low. 4. Re-enable CINTEN bit in IRQSTATEN and IRQSIGEN.	11161 ENGcm11161 eSDHCv2: Problem when ADMA2 last descriptor is LINK or NOP
Cortex-A8	NXP		: ENGcm11403 eSDHCv2: Erroneous CMD CRC error and CMD Index error may occur on sending new CMD during data transfer When sending new, non data CMD during data transfer between the eSDHC and EMMC card, the module may return an erroneous CMD CRC error and CMD Index error. This occurs when the CMD response has arrived at the moment the FIFO clock is stopped. The following bits after the start bit of the response are wrongly interpreted as index, generating the CRC and Index errors. The data transfer itself is not impacted. The rate of occurrence of the issue is very small, as there is a need for the following combination of conditions to occur at the same cycle: â¢ The FIFO clock is stopped due to FIFO full or FIFO empty â¢ The CMD response start bit is received DescriptionJEEHEHRECONSTRUCT: The FEC only creates wrap burst accesses upon data access (non-buffer descriptor). The NFC under EMIv2 cannot handle such accesses from the MAX (M2) input port. Projected ImpactJEEHEHRECONSTRUCT: Sending new, non data CMD during data transfer between eSDHC and EMMC card may not succeed with indication on CRC and Index errors. Projected ImpactJEEHEHRECONSTRUCT: The FEC cannot use the NFC to access memory.	: The recommendation is to not set FIFO watermark level to a too small value in order to reduce frequency of clock pauses. The problem is identified by receiving the CMD CRC error and CMD Index error. Once this issue occurs, one can send the same CMD again until operation is successful. WorkaroundsJEEHEHRECONSTRUCT: The FEC should use the DDR for its buffer.	11403
Cortex-A8	NXP		: There is a possibility of an extra pulse on SCLK in the GPT when switching between the clock sources. DescriptionJEEHEHRECONSTRUCT: Due to an issue with ALU precision, several features of the GPU2D hardware incur accumulation of errors, which can result in visual artifacts. This can affect gradient rendering for certain step values and image transformation for larger render target sizes. Projected ImpactJEEHEHRECONSTRUCT: The bug can produce an incorrect counter increment in the GPT when switching between the clock sources. Projected ImpactJEEHEHRECONSTRUCT: The issue can cause artifacts in gradient rendering for certain step values and image transformation for larger render target sizes.	: Changing the clock source should only be done when the GPT is disabled. A way to accomplished this is as follows: 1. Disable GPTâWrite 1'b0 to EN bit of GPTCR 2. Disable interruptsâWrite 6'b000000 in Bits [5:0] of GPTIR 3. Configure Output Mode to unconnected/ disconnectedâWrite zeros in OM3, OM2, OM1 in GPTCR 4. Disable Input Capture ModesâWrite zeros in IM1,IM2 in GPTCR12SPACEJEEHEH5. Change clock source CLKSRC in GPTCR 6. Clear Status registerâWrite 003F in GPTSR12SPACEJEEHEH7. Set ENMOD in GPTCR 8. ENABLE GPTâWrite 1'b1 to EN bit of GPTCR. The GPTSR should not be read immediately after changing the clock source (a wait of at least one SCLK is required). WorkaroundsJEEHEHRECONSTRUCT: This issue will be fixed in the software driver libraries resolving the visual artifacts. There is no customer-side workaround for earlier driver versions.	07200 ENGcm07200 GPT: Possibility of additional pulse on src_clk when switching between clock sources
Cortex-A8	NXP		: When HS-I2C is configured for 7-bit address master mode operation, and the slave does not acknowledge the address, the HS-I2C starts generating high frequency clocks on the SCL line. This bug is only applicable to certain addresses, as follows: 00_00001âThis combination is reserved for CBUS operation. 01_00001âIssue address 10_00001âIssue address 11_00001â Issue address There is no issue with other addresses. DescriptionJEEHEHRECONSTRUCT: When writing the WA(0x15) in the FIFO (HITDR), the bit TDE remains asserted, the write in the FIFO is not detected. Projected ImpactJEEHEHRECONSTRUCT: The impact of this bug is minor (loss of 3 addresses out of 127) and it is unlikely that amount of devices that are attached to the HS-I2C bus in an actual application reaches that number. NOTE This erratum only applies to the HS-I2C module and not to the two standard 2 I C modules. Projected ImpactJEEHEHRECONSTRUCT: During data transfers the device address is sent twice (instead of the address + WA). but, if the FIFO is written a second time just after the first FIFO write, the TDE is cleared and the read works as expected. NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules.	: The workaround is to ensure that the above addresses are not used while configuring the hardware on the board. WorkaroundsJEEHEHRECONSTRUCT: There are two software workarounds, as follows: â¢ Replace the simple write in FIFO register with the following code: while(MEM_GET_BITS16(HSI2C_HISR, BIT1)!=0) {MEM_WRITE16(HSI2C_HITDR, *data) â¢ Generate the start signal only after filling both HIMADR and HITDR with data. This workaround is under review.	09194 ENGcm09194 HS-I2C: Address Issue
Cortex-A8	NXP		: In HS-I2C, the purpose of the HICR[AUTO_RSTA] bit is to generate a repeat start when NOACK is received in Master mode Tx operation with FIFO enabled or FIFO and DMA enabled mode. When the HICR[AUTO_RSTA] (AUTO repeat start generation) bit is set and NOACK is received in address phase. The HS-I2C is not generating the repeat start. DescriptionJEEHEHRECONSTRUCT: If the slave device uses clock stretching to delay the HS-I2C controller after every byte is sent, the i.MX51 waits for the clock to go high between bytes but does not wait between the final byte and the STOP signal. Because of this, no valid STOP signal is seen on the bus. In other words, the use of HIRDCR automatically generates a stop condition on the data bus (HIRDCR[RDC_RSTA] = 0) after the final byte of data is received regardless of whether the slave is in a condition to accept it. If the slave device holds the clock low (clock stretch) after the final byte of data is transferred, the slave never receives the immediate STOP condition from the i.MX51. Projected ImpactJEEHEHRECONSTRUCT: The auto-restart feature does not work. NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules. Projected ImpactJEEHEHRECONSTRUCT: TBD NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules.	: Use the HICR[RSTA] bit for repeat start. There is a NOACK status (HISR[RXAK]) bit. The corresponding interrupt should always be enabled and AUTO_RSTA should be disabled. WorkaroundsJEEHEHRECONSTRUCT: The workaround is to use the GPIO alternate input to the I2C1_CLK pad to detect when the external device has released the clock and only after sending the STOP signal.	07892 ENGcm07892 HS-I2C: Auto Restart not working
Cortex-A8	NXP		: The HICR[HIIEN] bit that should operate as a interrupt enable bit, does not mask the interrupts. DescriptionJEEHEHRECONSTRUCT: Read after write from an external device fails randomly Projected ImpactJEEHEHRECONSTRUCT: The HICR[HIIEN] bit does not work. Projected ImpactJEEHEHRECONSTRUCT: The first data is not written before START condition therefore the Read after write from an external device fails randomly NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules.	: Use the individual interrupt mask bits of the status register in the Interrupt Mask Register (HIIMR) or disable them in TZIC. NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules. WorkaroundsJEEHEHRECONSTRUCT: See â7-Bit/10-Bit Address Master Transmitâ section of the âHigh Speed Inter IC (HS_I2C)â chapter in the i.MX51 Applications Processor Reference Manual (MCIMX51RM). Item 6 in the section reads: âWrite one Byte of DATA to be transmitted to the Tx Data Register (HITDR).â Before the Start condition, data must be written to HITDR and the second data has to be written to HITDR after the ADDRESS phase of Byte Transfer Done (BTD). Going forward, Data must be written to the HITDR in advance before the BTD of previous data has been issued.	07894 ENGcm07894 HS-I2C: HICR[HIIEN] bit does not mask the interrupts
Cortex-A8	NXP		: In the HS-I2C module the HISR[RDC_ZERO] status bit is not cleared when HIRDCR[RDC_RSTA] is not set. DescriptionJEEHEHRECONSTRUCT: When 9 is written to the HIFSFDR, the ipg_hsi2c_clk should be divided by 72, but the output is incorrect. Projected ImpactJEEHEHRECONSTRUCT: The HS-I2C Interrupt may occur unexpectedly. NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules. Projected ImpactJEEHEHRECONSTRUCT: Specifically when the ipg_hsi2c_clk = 26/3 MHz the expected output is 120 kHz (approximately) where as the actual output is approximately 103.3 kHz. NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules.	: There are two software workarounds, as follows: 1. Use the mask bit to clear the HS-I2C interrupt and enable it again after generating the start (MSTA bit setting) condition when required. 2. Avoid this issue by eliminating the use of the RDC and TDC counters. WorkaroundsJEEHEHRECONSTRUCT: The I2C protocol works with range of frequencies and an accurate frequency is not a requirement. In I2C protocol FS mode, bit by bit clock stretching by slave device is possible. If a very accurate frequency is required, software may need to execute the following steps: 1. Configure HIFSFDR according to the SCL clock frequency required. 2. Check if it works. 3. If it does not work, configure for a lower division frequency until it works.	07886 ENGcm07886 HS-I2C: TDC_ZERO and RDC_ZERO status bits are not cleared
Cortex-A8	NXP		: The HS-I2C module does not operate in high speed mode. DescriptionJEEHEHRECONSTRUCT: If the alpha value is set to 0xFF for IC (Image Converter) combining, combining result is incorrect. This is relevant to the IC module only. Projected ImpactJEEHEHRECONSTRUCT: The high speed mode of the HS-I2C module can not be used. Projected ImpactJEEHEHRECONSTRUCT: Very minor difference in result because we do not use full masking visible only in very special case.	: None. NOTE This erratum only applies to the HS-I2C module and not to the two standard I2C modules. WorkaroundsJEEHEHRECONSTRUCT: The workaround is to use any value between 0x0 to 0xFE and to avoid the usage of 0xFF.	09113 ENGcm09113 HS-I2C: High Speed mode of HS-I2C does not work
Cortex-A8	NXP		: When the IPU frequency change is configured to End-of-Line or End-of-Frame operation, the frequency change ready ack is stuck due to and early EMI ACK to the DVFS frequency change request (EMI stops transfers until the frequency changes). When the IPU frequency change is configured to âpixel clockâ, the ACK from the IPU to the CCM is granted rapidly (before the EMI can stop the transfer) and system functions correctly at the new DVFS frequency. In order to support End-of-Line or End-of-Frame configuration, the CCM must send the DVFS frequency change request to the EMI after all the ACKs are received from other masters (IPU, HSC). DescriptionJEEHEHRECONSTRUCT: This issue applies to the Image Processing Unit's Pre-processing and Post-processing. When the flow of CSC1 + Combining + CSC2 is activated in the Image Convertor and the input to CSC1 is in YUV (4:2:0 or 4:2:2) format, then every second pixel in the output is black resulting in 50% black columns on the screen. The issue is observed for CSC1 outputs of YUV or RGB. The issue disappears if CSC2 is off. In addition, the issue disappears if the input to CSC1 is RGB (8:8:8 or 5:6:5). The combined picture is not impacted by black pixels Projected ImpactJEEHEHRECONSTRUCT: There is no support for End-of-Line and End-of-Frame IPU frequency changes when using DVFS. Projected ImpactJEEHEHRECONSTRUCT: Two CSC (color space conversions) can not be performed in the IC (Image Converter) if the input to the first CSC is in YUV format.	: Configure IPU for DVFS changes only on pixel boundary. WorkaroundsJEEHEHRECONSTRUCT: The CSC function in the IC requires 3 cycles per pixels. The CSC function in the DP (Display Processor) requires one cycle per pixel. Due to the very high load on the IC module when CSC2 is used, it was never planned to use CSC2. If a second CSC is required, the DP should be used instead. In a use case where CSC has to be done twice, the user should perform the first CSC in the IC and the second one in the DP.	09131 ENGcm09131 IPU/CCM: Configuration for DVFS_PER operation (pixel/EOL/EOF)
Cortex-A8	NXP		: The problem can happen under the following conditions: 1. Two simultaneous tasks are running in the IC. 2. Both tasks perform combining. 3. Local alpha is used. The IC reads a set of 4 pixels and 4 alpha values. The IC has a 2 bit pointer that points to the current alpha value to be used (out of 4). Due to an error during task switching thereâs a situation where the alpha pointer is not updated correctly. As a result the pointer of task1 is used for task2. Hence, a wrong alpha value is used. The IPU overcomes the problem on the following task switching. DescriptionJEEHEHRECONSTRUCT: The registers setup described in Table 4 is required for proper display and sensor interfaces operation. This configuration bypasses the unsupported HSC module (removed from specification) and configures the system for legacy mode operation. Table 4 shows bypass mode registers setup. Table 4. Bypass Mode Registers Setup Required Register Address Access Reset Value Bypass Value MCG Control Designation Register (MCD) 0x83FD_C000 R/W 0x0000_0000 0x0000_0F00 MCG CCM Control Register (MCCMC) 0x83FD_C0D8 R/W 0x0000_0000 0x0000_000C MXT Configuration Register (MXT_CONF) 0x83FD_C800 R/W 0x0000_0000 0xF003_008B Projected ImpactJEEHEHRECONSTRUCT: The actual visual impact is very small as the problem may happen sporadically and the IPU overcomes it on the next task switching. The problem affects the correctness of the data only so wrong data can be displayed for a short period of time. Projected ImpactJEEHEHRECONSTRUCT: None.	: 1. Use global alpha for combining. 2. Perform one of the combining tasks in the DP. 3. Run the flows through the IC in consecutive order. WorkaroundsJEEHEHRECONSTRUCT: Setup the registers accordingly.	10295 ENGcm10295 IPU: Error while combining in IC when two simultaneous tasks are involved
Cortex-A8	NXP		: If the step-by-step mechanism is enabled while the M4IF is operational (there are transactions in the internal buffers), there can be a situation where one or more of the arbitrations' AXI protocol is violated in the âwrite address channelâ or âread address channel.â DescriptionJEEHEHRECONSTRUCT: Enabling the power-saving mode in M4IF before configuring the DDR module causes deadlock during DDR configuration. Projected ImpactJEEHEHRECONSTRUCT: The M4IF violates the AXI protocol and crashes if step-by-step is set ON or OFF during the run-time. Projected ImpactJEEHEHRECONSTRUCT: None	: Before entering the step-by-step mode, configure the EMI to the software LPMD and then read the LPACK register. The LPACK register indicates that the M4IF is idle and the step-by-step can be enabled. The difference between the regular procedure of LPMD and this procedure is that the EMI clocks remain ON. WorkaroundsJEEHEHRECONSTRUCT: Initialization must be performed first, followed by enabling the M4IF power saving.	07168 ENGcm07168 M4IF: Step-by-step mechanism violates AXI protocol
Cortex-A8	NXP		: The FPST (Fast arbitration Power Saving Timer) control bit field in the M4IF MCR1 register defines the timer value of the power saving mode of the fast arbitration. The value in this field represents clock cycles of the fast memory arbitration clock multiplied by 8. The minimum value for FPST in MCR1 reg is defined as follows: The minimum time interval between LPMD/DVFS requests requires that two refreshes be sent to memory during that interval. So the minimum time is tXSR + tRFC, which is the time from exit self-refresh to first refresh command and the time from first refresh to second refresh. DescriptionJEEHEHRECONSTRUCT: Reading the M4IF status registers of an inactive AXI master or slave ports stalls the entire IC system. This occurs when a specific master or slave clock is not provided to the M4IF, but the ARM/JTAG tries to read that masterâs status bits. When the master or slave clock is not active, the read request fails to propagate the status bits that go through synchronization (IPG_CLK to *_clk), acknowledge never comes back, and the entire chipâs IP bus is stuck. Some M4IF status registers bundle the status of several masters or slaves. If one of the masters or slaves is inactive, accessing such a register stalls the entire system, even if the user is interested only in the status of other active ports. Table 5 lists the impacted registers and the clock signals that should be active for read access to succeed. Table 5. List of Impacted Registers Registers Required Master/Slave to be Active for Read Action to Succeed MDCR fast, slow, int1, int2 WMIS0 fast WMIS1 fast MLEN m0, m1, m2, m3, m4, m5, m6, m7, fast, slow, int1, int2 FDPS fast SSRL0 fast SSRL1 fast SSRH0 fast SSRH1 fast MDSR0 The arbitration domain selected by MDCR/RARB MDSR1 The arbitration domain selected by MDCR/RARB MDSR2 The arbitration domain selected by MDCR/RARB MDSR3 The arbitration domain selected by MDCR/RARB MDSR4 The arbitration domain selected by MDCR/RARB MDSR5 The arbitration domain selected by MDCR/RARB MDSR6 The arbitration domain selected by MDCR/RARB MDSR7 The arbitration domain selected by MDCR/RARB MDSR8 The arbitration domain selected by MDCR/RARB SBS0 The arbitration domain selected by MDCR/RARB SBS1 The arbitration domain selected by MDCR/RARB Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 95 Projected ImpactJEEHEHRECONSTRUCT: None.	: M4IF and DDR control programing must meet this restriction: tXSR (DDR parameter) + tRFC (DDR parameter) < 8 Ã FPST (M4IF parameter)	10709 ENGcm10709 M4IF: Power-saving restriction on FPST due to DDR
Cortex-A8	NXP		: When performing auto_erase/auto_program/copy_back operation, NFC is supposed to detect the deassertion of RB_B signal, and then send a status-read command in order to capture the status of the last operation, and thus reducing software overhead. In ~50% of the cases, the NFC does not send this status-read command. Projected ImpactJEEHEHRECONSTRUCT: No impact on regular functionality. The status registers are usually accessed for debugging purposes. Projected ImpactJEEHEHRECONSTRUCT: Status is not correct.	: Enable the relevant M4IF masters or slaves clocks for the status read. WorkaroundsJEEHEHRECONSTRUCT: The software must launch a status-read command at the end of auto_erase, auto_prog or copy_back operations.	11226 Table 5. List of Impacted Registers (continued) Registers Required Master/Slave to be Active for Read Action to Succeed PSM0 m0,m1 PSM1 m2,m3 PSM2 m4,m5 PSM3 m6,m7 MDCR fast, slow, int1, int2 MCR0 fast, slow, int1, int2
Cortex-A8	NXP		: When ECC_MODE = 1 the 8-sym error detection and correction does not work with 512 byte main area Ã16 NAND Flash. DescriptionJEEHEHRECONSTRUCT: The copy back feature of the NFC module does not work as expected. When trying to copy a page from source address to destination address, the destination address is always the successive page of the source address. Projected ImpactJEEHEHRECONSTRUCT: The 8-sym ECC mode does not work with Ã16 bus width NAND. This mode works with Ã8 bus width NAND. This restricts 8-sym ECC operation to 8-bit NAND devices. Projected ImpactJEEHEHRECONSTRUCT: The copy back cannot be done to an address that is not successive to the source address.	: None WorkaroundsJEEHEHRECONSTRUCT: There are two options: â¢ Perform the copy back through Atomic operations â¢ Instead of copy back, perform a read operation followed by a write operation Both options affect the overall performance.	09619 ENGcm09619 NFC: 8-Sym ECC mode does not work with 512 byte page x16 bus NAND Flash
Cortex-A8	NXP		: NFC offers a block-write-protect feature in which only a range of pre-defined blocks can be modified. This range of blocks can be set to UNLOCK (blocks that can be modified), LOCK (blocks that cannot be modified) or LOCK_TIGHT (blocks that cannot be modified and the range cannot be changed). Though switching to LOCK_TIGHT mode, the range of blocks can still be modified. DescriptionJEEHEHRECONSTRUCT: NFC offers a block-write-protect mechanism. Only a configurable range of NAND blocks can be modified. Any erase/program operations on the blocks outside this range should be blocked by NFC. This mechanism does not work in automatic program and in automatic erase. Projected ImpactJEEHEHRECONSTRUCT: Lock cannot be trusted to prevent data from being overwritten. As the software does not use this feature (both WinCE and LINUX), there is no impact. Projected ImpactJEEHEHRECONSTRUCT: As there is no workaround for this bug, the write protect mechanism cannot be used.	: As there is no difference between LOCK and LOCK_TIGHT modes, the software should not use LOCK_TIGHT mode. WorkaroundsJEEHEHRECONSTRUCT: It should be handled in the software, as it is done now for the Windows and Linux drivers.	09135 ENGcm09135 NFC: Block write-protect does not support lock-tight
Cortex-A8	NXP		: When working with addr_op = 01, and trying to perform a copy-back operation, the NFC ignores the destination address configured, and copies the page to âsource addressâ +1. Additionally, the following automatic operation is carried out from address_register1 instead of address_register0. DescriptionJEEHEHRECONSTRUCT: The software reset (setting the NFC_RST bit in NFC and then sending reset command 0xFF to NAND Flash) does not work correctly under the following conditions: â¢ Reset between the read operations â¢ With atomic program operation, the RESET command is not being issued â¢ Auto program operationâIf reset occurs after writing data to the NFC and before the write confirm command, the CACK bit is not set after setting CREQ Projected ImpactJEEHEHRECONSTRUCT: Automatic operation is carried out from address_register1 instead of address_register0. Workaround: If the system requires to work in addr_op = 01, switch to addr_op = 11, before the copy-back operation, and switch back after the copy-back operation is complete. Projected ImpactJEEHEHRECONSTRUCT: The software reset does not work consistently, but the failure conditions are not common in real world applications.	: Do not to apply software reset for the above conditions.	09400 ENGcm09400 NFC: Copy-back does not work properly when addr_op = 01
Cortex-A8	NXP		: After automatic Program operation the NFC is expected to perform a status read and store the status in STATUS_SUM register. With RBB_MODE = 1 (that is, NFC waiting using BSY_B signal), the status read does not occur at the end of the Program/CopyBack0 and CopyBack1 operations. DescriptionJEEHEHRECONSTRUCT: When a warm reset is issued, all the NFC registers should not be reset. This is done to enable a quick return to operation after the warm reset occurs. But when a warm reset is asserted to the NFC, the unlock registers are also reset. Therefore, the commands are not executed after warm reset. Projected ImpactJEEHEHRECONSTRUCT: The status is not correct. Projected ImpactJEEHEHRECONSTRUCT: Commands are not executed after warm reset. Workaround has minor performance impact.	: Workaround for this erratum: â¢ In the Automatic mode, use RBB_MODE = 0 â¢ If RBB_MODE = 1 is to be used, then after the Automatic program, Automatic CopyBack0 and Automatic CopyBack1 operations, Status read should be done explicitly. WorkaroundsJEEHEHRECONSTRUCT: After a warm reset, the user should unlock the unlock registers of the NFC. This allows the NFC to start working as expected. Unlocking the registers cause a minor delay until the NFC is ready to work.	08208 ENGcm08208 NFC: Status read does not occur at the end of the program, with RBB_MODE = 1
Cortex-A8	NXP		: The NFC should issue a read status command and move to the next operation only when the status is ready (status = 0xE0) but the NFC uses the ready/busy signal instead. For example, in automatic program operation, the NFC should perform a read status loop until the status is ready and only then assert the interrupt. But the NFC asserts the interrupt when the ready/busy signal returns to 1 (ready) while the read status is still busy. DescriptionJEEHEHRECONSTRUCT: When working in symmetric mode with a clock ratio 1:2, and using a 16-bit Flash bus width, the NFC reads data and organizes it using a shift in the internal RAM in such a way that the last 16 bits of the data block being transferred are not written to the memory. Projected ImpactJEEHEHRECONSTRUCT: When RBB_MODE = 0, the user can not tell if the device is busy or not. Automatic operations fail. Also, the system can hang. Projected ImpactJEEHEHRECONSTRUCT: Wrong data may be read.	: Connect the ready/busy signal from the Flash to the i.MX51 and program RBB_MODE = 1. However, using this workaround restricts the number of CS supported to 4 instead of 8. WorkaroundsJEEHEHRECONSTRUCT: Avoid combining the following parameters/conditions: â¢ 16-bit flash bus width â¢ Symmetric mode â¢ 1:2 clock-ratio	09970 ENGcm09970 NFC: NFC does not work properly when RBB_MODE = 0 (read status)
Cortex-A8	NXP		: The NFC does not issue DMA read request (dma_rd_req) when the page size is 1/2 Kbyte (PS = 00) and in SDMA mode (NO_SDMA = 0). It works normally when using other page sizes. DescriptionJEEHEHRECONSTRUCT: When the NFC is configured to addr_op = 1 or 3 â¢ If num_of_devices = 0â1, then the LSB of the page/blocks address section of the addr_group bits is not used for address generation. â¢ If num_of_devices = 2â3, then the 2 LSB's of the page/blocks address section of the addr_group bits is not used for address generation. â¢ If num_of_devices = 4â7, then the 3 LSB's of the page/blocks address section of the addr_group bits is not used for address generation. Projected ImpactJEEHEHRECONSTRUCT: Data can not be read by the SDMA Projected ImpactJEEHEHRECONSTRUCT: Working in these addr_op modes has some limitations on the size of the devices (depending on the number of devices). Such large devices do not exist at this time. This can be an issue when using larger devices that may become available in future. NOTE addr_op = 0 works as designed with any combination.	: Do not use the combination of parameters/conditions described above. WorkaroundsJEEHEHRECONSTRUCT: Do not use the combination of parameters/modes described above.	10033 ENGcm10033 NFC: Does not Issue DMA read request using 1/2 Kbyte Page in SDMA mode
Cortex-A8	NXP		: When the NFC_CONFIGURATION1[NFC_RST] bit is asserted, the state machines of the NFC is supposed to be initialized, but the state machines of the ECC encoder/decoder do not return to IDLE mode. Therefore the operation that is executed right after NFC_RST operation incorrectly indicates an uncorrectable ECC error. DescriptionJEEHEHRECONSTRUCT: When working in asymmetric mode, using a clock ratio of (flash_clock:axi_clock) 1:2 and a Flash bus width of 16-bits, the NFC reads data from the NAND Flash it sometimes repeats the same address of the internal RAM and therefore writes to the same addresses, overwriting data instead of incrementing the write pointer. Projected ImpactJEEHEHRECONSTRUCT: The program/read operations execute correctly, but the NFC indicates uncorrectable ECC errors in the ECC_STATUS_RESULT register. Projected ImpactJEEHEHRECONSTRUCT: Corrupted/invalid read data when operating with the combination of conditions described above.	: Avoid using the NFC_RST bit of the NFC_CONFIGURATION1 register. WorkaroundsJEEHEHRECONSTRUCT: Avoid operating in this combination of conditions	10135 ENGcm10135 NFC: Incorrect ECC Error Detection when NFC_RST bit is set
Cortex-A8	NXP		: The bug occurs when the NFC is configured as follows: Interleaved mode Addr_op = 2 More than one device Number of iterations > 1 During automatic read operations the NFC only reads the data from the last device and not from all the devices. The reason for that is that in addr_op = 2 the NFC issues the address phase to each of the devices separately because the address is taken from different register. DescriptionJEEHEHRECONSTRUCT: When the number of iterations are greater than the number of devices then the NFC is supposed to issue accesses to each device in a loop until the proper number of iterations is reached. The problem is that when the NFC completes the first loop it does not check whether the device is busy and issues accesses to the devices when they are in busy state. Projected ImpactJEEHEHRECONSTRUCT: Incorrect read operations when using the combination of conditions described above. Projected ImpactJEEHEHRECONSTRUCT: Incorrect read operations under the combination of conditions mentioned.	: Avoid using this combination of conditions. WorkaroundsJEEHEHRECONSTRUCT: Configure the number of iterations to less than or equal to the number of devices used in interleaved mode, so that the NFC can issue one page per connected device.	10158 ENGcm10158 NFC: Reads only from the last device using addr_op = 2 without read confirmation
Cortex-A8	NXP		: The NFC-ECC engine does not protect the last 10 spare bytes of the last section in page size of 4 Kbytes + 218 bytes. In the case where the page size is 4 Kbytes + 218 bytes, the first 7 sections are of 512 bytes and have spare of 26 bytes, and the last section has spare of 36 bytes. In the case where 4/8 bits ECC protection, the arrangement of the last section of the memory is as following: 18 bytes/12 bytes then 8 bytes/14 bytes of ECC and 10 bytes of user-specific. Those 10 bytes of the last section are not ECC protected. DescriptionJEEHEHRECONSTRUCT: If RBB_MODE = 1 and atomic operation, the NFC monitors only the rb_b signal of device0 (rb_b0) instead of the rb_b# signal that corresponds to the selected device. Thus, when the NFC executes atomic operation with a device other than device0, it monitors the incorrect ready/busy signal. Projected ImpactJEEHEHRECONSTRUCT: The last 10 spare bytes of the last section in 4 Kbytes + 218 bytes are not ECC protected. Projected ImpactJEEHEHRECONSTRUCT: Can not work in atomic operation with a device other than device0.	: Do not use these bytes. The Freescale WinCE and Linux BSPs (board support packages) do not use these bytes. WorkaroundsJEEHEHRECONSTRUCT: Connect on board to rb_b0 port a wired-OR of all the ready/busy signals of all the devices.	10205 ENGcm10205 NFC Doesn't Protect the Last 10 Spare Bytes of the Last Section in 4KB+218
Cortex-A8	NXP		: The NFC error correction mechanism is based on BCH error correction codes. The BCH error correction code allows correction up to a particular number of errors (T = 4 or 8 depending on the configuration), and detection in case of higher number of error bits. In a situation where the number of errors (NOBER) is larger than the number of errors the NFC can correct (T), the NFC should report on uncorrectable error. Due to a theoretical limitation, the BCH code can fail in detecting the error when the number of actual error bits is much larger than the number of correctable bits. The failure depends on the location of the errors (related to Hamming distance), and its probability is very small. The detection failure probability can be calculated using the formula as follows: 1 P = -------- e T T! â 2 where T is number of correctable errors. â¢ For 4-bit ECC, the calculated probability for a decoder error is 1 : 384 â¢ For 8-bit ECC, the calculated probability for a decoder error is 1 : 10,321,920 In case of failure, the NFC reports only on T or less errors (NOBER=T) and tries to correct them. As a result the data is damaged and the NFC does not report on it. DescriptionJEEHEHRECONSTRUCT: When the host issues a read burst access to the NFC and during the data phase the host deasserts the rready signal (indication from the host that he is ready to accept the read data), then the NFC fails to drive the next datums after the deassertion and also the assertion of the rlast (indication from the slave for end of read data transfer) does not occur on time. Thus, the current read access is incorrect and causes a severe AXI protocol violation. Projected ImpactJEEHEHRECONSTRUCT: There is a small probability for failure in detection of the errors by the ECC mechanism due to theoretical limitation of the ECC code. Projected ImpactJEEHEHRECONSTRUCT: The NFC is not able to handle more than 4 data word read transactions at a given time. A restriction is imposed on read access to NAND Flash that require special attention in software and may cause some performance degradation for NAND Flash usage.	: To reduce the failure significantly, treat the case where NFC reports NOBER = T as uncorrectable error. This implies that if the number of errors is equal to T, the software must invalidate the block. It is a common practice for the software to mark the block as bad in advance when the number of reported errors approaches T. WorkaroundsJEEHEHRECONSTRUCT: Due to this coherency issue, the system should prevent the NFC buffers from being cached. This can be prevented by limiting the outstanding read accesses to the NFC buffers to four data words for all combined accesses at any time. In case of access from single AHB bus masters, which can only submit one outstanding access at a time (such as the SDMA), the burst size must not exceed 4. In case of AXI bus masters, such as the ARM core, the software must control the data read accesses to be less then 4 data words at a time. Note that there is also a need to make sure that both Neon and the Core do not read together more then 4 data words at a time from the NFC buffers. In case of multiple masters accessing the NFC, the limitation remains the same. For example, if both ARM and SDMA need to access the NFC buffers, the SDMA could limit its burst reads to 2 and ARM must not request more the 2 data words at a time.	10356 ENGcm10356 NFC: ECC mechanism may fail to report uncorrectable error situation
Cortex-A8	NXP		: This issue is related to SDMA access to NFC in automatic interleave mode. The faulty NFC operation occurs in the following conditions: â When NUM_OF_ITERATION is greater than zero, and NO_SDMA = 0 for automatic interleave mode access from SDMA. â FMP (Fifo Mode Protect) is set to a value smaller than the Page Size (PS). The FMP determines the interval between the write and read pointers to memory buffer. â FMP threshold is reached before the host drives more data to the RAM In this case, the NFC fetches data from the RAM and drives it to the flash line. This causes the difference between the write and read pointers to violate the FMP threshold and as a result, the NFC stops driving data to the flash line. In such a situation, the last data that is driven to the flash line does not pass through the ECC (Error Correction) encoding engine. As a result, the ECC engine fails to encode the whole 0.5 Kbyte data and reports wrongly on uncorrectable errors. Projected ImpactJEEHEHRECONSTRUCT: The above described case with the FMP (FIFO Mode Protection) feature activated and with NUM_OF_ITERATIONS greater than zero (that is, for SDMA) can result in wrong function of NFC. The issue impacts only SDMA access to NFC in interleave mode with page size equal to 4 Kbyte. In this case, the automatic interleave mode can not be supported and has to be managed manually. Other cases can be resolved using the settings described in the workaround section. The implication of proposed setting is some additional latency in write operation only. The latency is derived from the time it takes to fill the internal RAM with the page data.	: The 0.5 Kbyte and 2 Kbyte use cases can be supported under the specified restrictions: â¢ In case of the write operation with page size of 0.5 Kbyte (PS = 00), it is allowed to configure the NFC to automatic interleaved mode (that is, with NO_SDMA=0 and setting NUM_OF_ITERATIONS to greater than zero). In this case, the FMP field (that defines a safety buffer inside the NFC internal RAM between the AXI host address and the NAND address) must be set to 0.5 Kbyte (set FMP = 4). In read operation, the FMP can be set to any value that is less than or equal to 0.5 Kbyte, (that is, setting FMP to either 0, 1, 2, 3 or 4). Chip Errata for the i.MX51, Rev. 5 118 Freescale Semiconductor10676 â¢ In case of write operation with page size of 2 Kbyte (PS = 01), it is allowed to configure the NFC to automatic interleaved mode (that is, with NO_SDMA=0 and setting NUM_OF_ITERATIONS to greater than zero). Here, the FMP field must be set to 2 Kbyte (that is, setting FMP = 6). In the read operation, any value of FMP which is less than or equal to 2KB can be configured (that is, setting FMP to either 0, 1, 2, 3, 4, 5, or 6). In case the page size is 4 Kbyte (PS = 10), it is forbidden to configure the NFC to automatic interleaved mode for both write and read operations. NO_SDMA should be set to 1 and the field NUM_OF_ITERATIONS should be set to 0. Instead, the interleave operation should be implemented manually as also proposed in erratum ENGcm10967. â¢ Set the number of pages to read/write to 1 (set NUM_OF_ITERATIONS = 0). â¢ Set the number of devices connected (that is, setting the field NUM_OF_DEVICES). â¢ Use addressing option 1 (set ADR_OP = 1, part of the address is used for chip select) and configure the target address and the target chip select at address group0 (that is, setting the fields NAND_ADD0 and NAND_ADD8). â¢ An interrupt is issued after each single page read/write transfer. Upon receiving the interrupt, reconfigure RBA (Ram Buffer Address) and the corresponding bits of ADDR_ADD0 to repeat the operation for the next device.	10676 ENGcm10676 NFC fails to perform ECC encoding in interleave mode if FMP is larger than PS
Cortex-A8	NXP		: This issue is related to SDMA access to NFC in automatic interleave mode (NO_SDMA = 0). NFC buffer mechanism does not operate properly under the following set of conditions, potentially feeding wrong data from the internal NFC RAM to FLASH data line. The fault occurs under the following set of conditions: â¢ NFC is set to operate in interleave mode (NO_SDMA = 0) and NUM_OF_ITERATION > 0 for SDMA access. â¢ Page Size is set to 4 Kbyte (PS = 10) â¢ FIFO Mode Protect is set to 4 Kbyte (FMP = 7) DescriptionJEEHEHRECONSTRUCT: NFC issues premature DMA read request for each page in case of the TOO configuration in interleaved mode. The TOO (Two On One) configuration is a case where two 8-bit NAND devices are connected to the same CS line to form a 16-bit data width (one device on the lower byte of data bus and second device on the upper byte). An interleaved mode is configured by setting the number of devices and NUM_OF_ITERATION to a value greater than zero, and NO_SDMA = 0 for SDMA access. When the NFC is configured for the above two modes, in addition to the DMA request at the end of the buffer, it wrongly issues additional DMA read request for each page in the middle of the buffer. Due to this, the SDMA starts fetching data from the RAM buffer before the complete data is available. Projected ImpactJEEHEHRECONSTRUCT: The above described case can result in wrong functioning of NFC and should be avoided. The issue is relevant only for SDMA access to NFC in interleave mode with page size equal to 4 Kbyte. Projected ImpactJEEHEHRECONSTRUCT: Erroneous behavior under the above mentioned conditions.	: For Page Size equal to 4 Kbyte (PS = 10) the NUM_OF_ITERATION must be set to 0 and NO_SDMA must be set to 1, disabling the interleave mode. An interleave mode can be implemented manually by configuring the appropriate NUM_OF_DEVICES while setting ADD_OP = 1 (Addressing Option 1, part of the address is used for chip select). In this case, an interrupt is issued after each single page read/write transfer. Upon receiving the interrupt, reconfigure RBA (Ram Buffer Address) and the corresponding bits of ADDR_ADD0 to repeat the operation for the next device. WorkaroundsJEEHEHRECONSTRUCT: Avoid using interleaved mode in TOO configuration.	10967 ENGcm10967 NFC does not function properly for 4 Kbyte Page Size in interleave mode
Cortex-A8	NXP		: When the NFC is configured to perform an automatic status read operation (that is, setting AUTO_STAT), it should execute that operation on the device ID that is configured in the ACTIVE_CS. Due to the reported issue the NFC executes the operation on another device rather than the one specified in ACTIVE_CS. DescriptionJEEHEHRECONSTRUCT: The NFC may not properly sample the ready/busy (R/B) signal under the following conditions: 1. RBB_MODE = 1 (Ready-Busy mode 1 - NFC monitors ready-busy status by checking NANDF_RBx (R/B) signals) 2. ADD_OP = 01 (Addressing Option 01 - NFC uses only address_group0 with single NAND device 3. enfc_clk period is less than twb/3 (twb is the period from WE write enable signal HIGH to R/B ready/busy signal assertion) If RBB_MODE = 1 and ADD_OP = 01, the NFC may miss the sampling of the ready/busy signal (R/B) if the enfc_clk is too fast. According to the NAND flash protocol, the NAND device should enter the busy mode and assert the R/B signal (driving R/B signal to zero) after the maximum time period of twb after the deassertion of the WE signal (driving write enable to one). The NFC samples the R/B signal after a fixed time of 3 enfc_clk cycles after the deassertion of WE. Typically, the twb period is 100 ns. When the enfc_clk is set to less than 33 ns period, the NFC may miss sampling the R/B. DescriptionJEEHEHRECONSTRUCTs table in the i.MX51 Multimedia Applications Processor Reference Manual ( MCIMX51) for detailed modes description. If the above two options are not feasible, the enfc_clk frequency can be reduced such that clock period is larger than twb/3. This results in small performance degradation as the supported ONFI1.0 NAND can run at up to 40 MHz. Projected ImpactJEEHEHRECONSTRUCT: Incorrect status return for automatic status read operation. Projected ImpactJEEHEHRECONSTRUCT: Violation of NAND interface protocol can result in data corruption. The implementation of the proposed workaround may have insignificant performance impact.	: Perform atomic status read operation (that is, send command 70 followed by single toggle of RE). WorkaroundsJEEHEHRECONSTRUCT: The recommended workaround is to set RBB_MODE = 0. This also frees up the NANDF_RBx pads for other usages. The NFC monitors the ready-busy status by performing a status-read command. Another option is to work with ADD_OP other than 01, allowing to work automatically with a single device other than device0. See, NAND_FLASH_CONFIG Register Field	11060 ENGcm11060 NFC does not perform automatic status read operation (AUTO_STAT) according to ACTIVE_CS
Cortex-A8	NXP		: Data corruption or EMI hanging can occur on SDMA Multi-Page read from the NFC in case of simultaneous read access by other master from WEIM. Use of SDMA is relevant for a case of multiple pages read from the NFC (that is, setting NUM_OF_ITERATION to a value greater than zero and setting NO_SDMA to zero in NFC for automatic interleave mode). DescriptionJEEHEHRECONSTRUCT: If the power supply of an unused UHVIO pad power group is pulled down, it can cause malfunction in the other functional UHVIO IO cells. The UHVIO IO cells (that support signal levels above 3 V) are used in interfaces such as SD card, NAND Flash. For example, grounding SD2 power supply rail through a small resistor (say 470 Î©) causes boot issues from the SD1 interface. This is caused due to a particular HVIO IO cell design limitation. Projected ImpactJEEHEHRECONSTRUCT: SDMA read access from NFC may be corrupted in case other masters perform read from WEIM at same time. There are no issues in following cases: â ARM accesses the NFC when WEIM is accessed by any other master in the system â SDMA accesses the NFC when the WEIM is idle â NFC is idle and WEIM is accessed by any master in the system Projected ImpactJEEHEHRECONSTRUCT: Pay attention to this limitation during board design. An unintentional grounding can occur because of nonfunctional or disabled voltage supply device connected to the UHVIO based interface VCC line.	: Avoid the above described situation. Note that, in current WinCE and Linux BSP releases from Freescale, the SDMA Multi-Page mode read from NFC is not activated. WorkaroundsJEEHEHRECONSTRUCT: Take measures to avoid such cases. Leaving the unused interface supply open, does not cause any issue. The issue occurs only when a supply is grounded through a small resistor. The best design practice is to apply power to all the supply rails.	11036 ENGcm11036 SDMA multi-page read from the NFC, when the WEIM is operating, can result in data corruption or EMI hanging
Cortex-A8	NXP		: Pulling down the power supply of any of NVCC_HSx supplies (from the group of NVCC_HS6, NVCC_HS10, NVCC_HS4_1, NVCC_HS4_2 supplies) or VREG supply results in high leakage current from VCC through the supply that is pulled down. Leakage of order of a few hundreds of mA is observed in case NVCC_HSx or VREG supplies are shortened to ground. If the supplies in NVCC_HSx supplies and VREG are left unconnected or in high impedance state, the leakage would not be observed. This is caused due to a particular MIPI shielding IO cell design limitation. The leakage current in this case is caused by the ESD protection diode inside the MIPI interface shielding pads. DescriptionJEEHEHRECONSTRUCT: If the HAB_TYPE e-fuse is blown as Production, then accesses to peripherals from DCD and SDP commands is disabled and DDR controller cannot be configured, so DDR cannot be used. The ROM does not check if the address is valid if HAB_TYPE is not Production for write header and write file SDP commands. So there is no issue in this case. However, if HAB_TYPE is Production, the ROM allows SDP commands only if the target address lies within the DDR, IRAM, GMEM, NAND flash buffer or WEIM memory regions. SDP Write commands to peripherals such as the memory and clock controllers are denied. Projected ImpactJEEHEHRECONSTRUCT: Need to consider this limitation during the board design. This is mostly relevant to suspend mode, in which the supply regulator of those pins may be turned off to save power. Typically, when a regulator is off, there would be high impedance on the associated supply pin(s), and leakage depends on the resistive path to ground that exists on the board. If there is a high resistive path, almost no leakage would be observed. This is also relevant to power-up sequence, because these supplies would be powered-up after VCC supply and depends on the resistive path, there could be some leakage till these supplies are stable. Projected ImpactJEEHEHRECONSTRUCT: Can not execute serial boot if HAB_TYPE is set to Production.	: Take measures to avoid such cases. Note that leaving the unused interface supply open, does not cause any issue. Having this situation for short periods (such as during power up sequence) should not cause any damage. Alternatively, if high impedance with a low resistive path to ground is projected on the supply, then leakage is negligible. WorkaroundsJEEHEHRECONSTRUCT: Use internal RAM boot image. In this case DDR configuration is not required.	11041 ENGcm11041 Dependency between VCC, VREG and NVCC_HSx supplies
Cortex-A8	NXP		: The Boot procedure fails when the boot code tries to initialize and access the NAND Flash, in case one of the unused R/Bx signals is grounded. In a system with a single NANDF Flash device, NANDF_RB1, NANDF_RB2, NANDF_RB3 are not in use, as the Boot code uses only CS0. These signals can be alternatively used for other functions (such as GPIO input). Due to reported limitation, the boot in NAND Flash mode fails, if one of the unused NANDF_RBx signals is held at zero during the boot. DescriptionJEEHEHRECONSTRUCT: OneNAND boot driver calculates page and sector numbers incorrectly for 4 Kbyte devices. Projected ImpactJEEHEHRECONSTRUCT: This limitation impacts the possible usage of NANDF_RB1, NANDF_RB2 and NANDF_RB3 in other alternate IOMUX modes as input, with zero level at boot. Projected ImpactJEEHEHRECONSTRUCT: 4 Kbyte OneNAND devices boot does not work for image sizes above 1 Kbyte. 2 Kbyte OneNAND devices boot works properly.	: The only workaround is to avoid setting the unused R/Bx signals to zero during boot, in case of NAND Flash boot mode. WorkaroundsJEEHEHRECONSTRUCT: For 4 Kbyte devices, it is possible to use only the top half of pages. In this case, ROM reads the boot image properly, but the bottom half of pages are wasted.	11189 ENGcm11189 ROM (Boot)/NFC: NAND Flash Boot fails when one of the unused NANDF_RBx signals are held at low
Cortex-A8	NXP		: The sw_reset bit in the RTIC spec says that it should not be modified in run-time check mode. A software reset was done during one time hash mode and immediately after that RTIC was enabled. The RTIC state machine is corrupted in such a scenario. The assertion of software reset when hash_once_command is set in rtic_control, leads to the assertion of hash_once and hence of zero_byte_length in rtic_dma_request. This in turn sets the mem_part_1_done bit and even when RTIC is enabled this remains set, leading to corruption of the state machine. DescriptionJEEHEHRECONSTRUCT: The RTICv3 feature that allows the TrustZone software to disable the run-time check of the selected memory regions (region unlock), can cause the RTICv3 to hang and stop the run time integrity check of other regions. Projected ImpactJEEHEHRECONSTRUCT: RTIC hangs. Projected ImpactJEEHEHRECONSTRUCT: The RTICv3 feature that allows the TrustZone software to disable run-time check of the selected memory regions cannot be utilized.	: Be aware of limitation. Do not reset RTIC during one time hash mode. WorkaroundsJEEHEHRECONSTRUCT: None. Avoid using the memory region unlock feature in the TrustZone code.	05863 f ENGcm05863 RTIC: Software reset during one time hash mode corrupts RTIC state machine
Cortex-A8	NXP		: SAHARA does not work properly if AHB:IP buses clock ratio is 1:1. It works fine with AHB:IP buses clock ratio 2:1. DescriptionJEEHEHRECONSTRUCT: There is the possibility of a loss of SRTC failure status upon peripheral supply voltage (the HP section) power up. The SRTC incorporates a System State Retention Register (SSRR) that stores system parameters during system shutdown modes. This register and all SRTC counters are powered by dedicated supply rail NVCC_SRTC_POW that remains active, allowing all other supply rails to shut down. The SSRR also stores the system security state. If a security violation occurs, the SSRR marks the event as a security violation indication. The SRTC is split to two supplies: LP and HP. The LP section is powered by NVCC_SRTC_POW and always remains active, whereas the HP section is powered by VCC rail and can be shut down. As long as the SRTC LP section remains active with its separate power supply and clock inputs, it continues to detect and record security violations when the HP section and the rest of the chip are powered down. When power is restored to the HP section, any security violation detected during power down becomes visible to the rest of the system through a security monitor alarm and the SRTC register interface. In particular, software can examine the LP status register to observe the LP Failure state and status bits indicating which security violation occurred. In rare cases, an erroneous reset of the LP section has been observed during HP power-up when a security violation was recorded during HP section power down. This causes the LP to move to Initialize state rather than Failure state, and erases all record of the security violation. Please note that this scenario can occur only if SRTC LP has gone into failure state when the peripheral supply power (HP) is off. The unintended SRTC reset does not occur while the SRTC LP remains in the Valid state. Projected ImpactJEEHEHRECONSTRUCT: Adds limitation on system configuration for the clock ratio of 1:1 between AHB and IP buses. Projected ImpactJEEHEHRECONSTRUCT: This issue is relevant for systems supporting DRM (digital rights management) and other applications requiring a secure clock or monotonic counter. If the SRTC failure status is lost as above, then a system which has been tampered while the main power was off may appear indistinguishable from a system which has a SRTC that is not violated. If software is then permitted to provision the LP time and monotonic counters insecurely, this could mislead the application relying on the SRTC. Note that this issue does not permit the SRTC LP clock and monotonic counters to be modified directly without leaving the Valid state. In order to complete the attack, there is a need to execute malicious or insecure software that tries to reconfigure the SRTC after it is reset. The system can be protected against such software by code signing and authentication methods.	: Avoid using a ratio of 1:1 between AHB and IP buses clock frequencies. Other software workarounds are considered, but not yet confirmed. WorkaroundsJEEHEHRECONSTRUCT: None. However, this issue can be mitigated by ensuring that the LP time and monotonic counters are securely reprovisioned. One approach is to authenticate all provisioning software using HAB (high assurance boot) and to lock the LP time and monotonic counters against further changes before allowing unauthenticated software to execute. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 133	10334 ENGcm10334 SAHARA/CCM: Frequency ratio restriction for AHB and IP buses in SAHARA
Cortex-A8	NXP		: In Network and Synchronous mode of operation, if Rx is enabled and after one or more frames passes Tx is enabled, the first data is transmitted from FIFO1 instead of FIFO0. Projected ImpactJEEHEHRECONSTRUCT: Wrong data is transmitted.	: Enable Tx and Rx in same frame when in Network and Synchronous mode of operation	10272
Cortex-A8	NXP		: If Tx is enabled or disabled within a 5 clock cycle window before Frame Sync. Data transmission may not be proper in the following conditions: â¢ Normal Synchronous mode: With Rx disabled if Tx is enabled 3 clock cycle before non-early FS, glitch of 0.5 clock cycles can be seen on the STXD line. â¢ Normal Synchronous mode: If Tx is enabled 4 clock cycle before external early word length frame sync with fifo0 disabled two channel disabled, ddr_stxd is high for 1.5 clock cycles. â¢ Normal Synchronous mode: If Tx is reenabled 2 clock cycles before early FS, ddr_stxd line goes high for 0.5 clk cycles. â¢ I2s_slave: Tx is disabled in the first time slot and is again reenabled in the 2nd time slot of a different frame wrong data getting transmitted in the next frame. The tx state machine is not running for the frame in which wrong data is transmitted. â¢ I2s_master: Tx is disabled 2 clk cycle before FS data is repeated in second time slot 6.Network Synchronous mode: Reenabling Tx, 1 clock cycles before External FS, and frame count as 2, results in data in first time slot getting missed. â¢ Network Synchronous mode: External Early word length FS. If Tx is reenabled 2 clk cycles before FS signal then in the next frame data is transmitted for 0.5 clk cycles. DescriptionJEEHEHRECONSTRUCT: In Normal Asynchronous mode: If Tx is disabled 2 clk cycle before non early bit length external FS, ddr_stxd signal is indefinitely set high even when no data is transmitted. Projected ImpactJEEHEHRECONSTRUCT: Data transmitted may be lost. Projected ImpactJEEHEHRECONSTRUCT: Wrong data transmission may be recognized.	: The following workaround can be implemented to avoid these issues. Enable/disable Tx after occurrence of RFS interrupt: 1. Enable RE(SCR[2]) 2. Enable RIE and RFS_EN in SIER12SPACEJEEHEH3. Wait for occurrence of RFS 4. Enable/disable TE(SCR[1]) WorkaroundsJEEHEHRECONSTRUCT: Disable Tx after occurrence of TFS interrupt, using the following steps to disable TX_EN bit is: 1. Enable TIE and TFS_EN in SIER. 2. Wait for occurrence of TFS. 3. Disable TE(SCR[1]).	09220 ENGcm09220 SSI: If TX_EN bit toggled 5 clk cycles before FS, the data transmission not correct
Cortex-A8	NXP		: When SSI is in normal synchronous mode and frame sync is configured as bit length early frame sync, data is not transmitted. DescriptionJEEHEHRECONSTRUCT: I2S_master mode: If Rx is disabled and again enabled with Tx disabled along with TFR_CLK DIS set, the first data after reenabling is received in the second time slot and hence channel swapping takes place. Network Synchronous mode: If Rx is disabled and again enabled with Tx disabled when TFR_CLK_DIS is set. Data is not accepted into the fifo according to the masking bits. Projected ImpactJEEHEHRECONSTRUCT: There is no toggling on the TXD data line. Projected ImpactJEEHEHRECONSTRUCT: Channel swapping or data lost (according to mode).	: 1. Enable SSI_EN and Tx_EN in the same frame. 2. Do not use early FS in Internal FS mode. WorkaroundsJEEHEHRECONSTRUCT: Two different workarounds can be used for this issue: â¢ Reset SSI every time Rx is enabled. â¢ Do not use TFR_CLK_DIS feature.	06569 ENGcm06569 SSI: Transmission does not take place in case of bit length early frame sync mode
Cortex-A8	NXP		: The receive overrun error is generated when the received FIFO index is 1 more than the watermark level, but the data is received properly in the FIFO. There is no loss of data, the only problem is that the receive overrun interrupt is generated at the wrong time. DescriptionJEEHEHRECONSTRUCT: In AC97, 16-bit mode, the Rx data is received in bits [19:4] of RxFIFO, instead of [15:0] bits. Projected ImpactJEEHEHRECONSTRUCT: The receive overrun error is not valid when the watermark mechanism is used. Projected ImpactJEEHEHRECONSTRUCT: The SDMA script should be updated accordingly to perform the shift to the right location on the fly during data transfer. If the data register is accessed directly by software, it should account for the shifted data and perform shifting to the right location.	: If no overruns can be guaranteed on a system level (based on the serial data rate and latency of servicing the SSI), two options are suggested: a) Give up on the overflow indication. Set the watermark at a sufficiently low level such that the probability for true overflow condition is very low. This option allows smoother performance but lacks any indication that a true overflow has occurred. b) Set the watermark level to the FIFO size so that the overflow interrupt corresponds with the actual overflow condition. This option provides overflow indication, however there is larger probability for overflow to occur because the watermark indicator is the FIFO size. Option (a) can be utilized in cases where the application actually has no means to recover from overflow condition in any case (for example in case of audio playback). This option gives smoother performance. Option (b) can be utilized in cases where there are good means to recover from an overflow state (for example in case the SSI channel is used for control or status indication and there is an option for data retransmit). In this case, the probability of actual overflow is higher, but there is a reliable indication that the overflow has actually occurred. WorkaroundsJEEHEHRECONSTRUCT: The data should be shifted to the right location by the SDMA script or by the software in case of direct access to the register.	09668 ENGcm09668 SSI: Receive Overrun Error Generated at Wrong Time for Watermark Level
Cortex-A8	NXP		: When receiving this sequence OUT - DATA0 - OUT - DATA1, if the inter-packet delay between DATA0 and the 2nd OUT is under 200ns, the device sees the DATA1 packet as a short-packet, even if it is correctly formed. This terminates the transfer from the device point of view, generating an IOC interrupt. DATA0 is correctly received, though. DescriptionJEEHEHRECONSTRUCT: The occurrence of an error in device mode sends ISO data in the next Î¼Frame that should have been discarded. Projected ImpactJEEHEHRECONSTRUCT: It should only be applicable to ISO OUT as a Device. Projected ImpactJEEHEHRECONSTRUCT: Critical for timing-dependent device ISO IN Mult = 3.	: When MX51's USB is operating in device mode, the host should not send two ISO_OUT sequences within less that 200 ns, otherwise i.MX51's USB does not operate correctly. WorkaroundsJEEHEHRECONSTRUCT: The SW has to set the MULT < 3 to avoid this bug.	09134 ENGcm09134 USB: Core device fails to receive two sequential OUT transactions in short time
Cortex-A8	NXP		: The USBOH core uses the erroneous hrdata (when hresp is high) and results in the false USB transfer at the external Interface. DescriptionJEEHEHRECONSTRUCT: The following software flow produces this issue. 1. Configure PTS of Host (or OTG) controller to select ULPI (or UTMI) mode (default is serial mode) and turn USB_CLK_ROOT (comes from on-chip PLL) off. 2. Set PORTSC.PHCD bit to put USB controller & PHY into suspend mode -> ULPI (or UTMI) PHY clock stops correctly. 3. Turn USB_CLK_ROOT on and wait a short time. 4. Turn USB_CLK_ROOT off. 5. Clear PHCD bit â PHY clock starts running correctly 6. Delay to allow PHY clock to become active 7. Set PHCD bit again â Controller suspends the PHY and immediately wakes it up, which is incorrect behavior. This happens because after Step 4, the serial USB engine stays in suspend mode even after the PHCD bit is cleared. This is because the USB_CLK_ROOT is not valid any more. The root cause is that USB_CLK_ROOT is used for the USB controller's serial engine. For one USB controller, the USB_CLK_ROOT for serial engine can be always turned off in ULPI or UTMI mode. The case mentioned above (turn on, turn off this clock while PHCD is high) is not a real use case. However on MX51, there are several USB controllers which share the same USB_CLK_ROOT clock. In this case, if one USB works in ULPI or UTMI mode while PHCD is set, another USB may work in serial mode which may turn on, turn off the USB_CLK_ROOT. This is the flow which has issue mentioned above. Projected ImpactJEEHEHRECONSTRUCT: False transfer of USB. Projected ImpactJEEHEHRECONSTRUCT: Improper USB interface operation as described above.	: This should not happen in real system because when configured correctly, the USB should not get an error response. If it happens, then Garbage In Garbage Out. WorkaroundsJEEHEHRECONSTRUCT: The situation can be avoided if the USB_CLK_ROOT clock is turned on briefly when any port wakes up from low power suspend. This ensures that the âsuspendedâ state is cleared in the serial PHY interface. One can optionally check, during wake-up processing, if the USB clock did run during low-power suspend and only turn on USB_CLK_ROOT when needed.	07300 ENGcm07300 USB: Erroneous descriptor handling by USBOH module
Cortex-A8	NXP		: The USB-OTG port ULPI mode is provided for debugging purposes and is not supported for regular operation. There is no commitment for proper timing functionality on this interface. This erratum is related to USB OTG port only, for which internal USB-PHY is provided. Projected ImpactJEEHEHRECONSTRUCT: The USB-OTG port does not support ULPI interface. The erratum does not relate to the functionality of ULPI mode on other USB-Host ports or to the USB-OTG internal PHY interface.	: Utilize the USB-OTG PHY interface instead or use other USB-Host ports for ULPI interface.	10636
Cortex-A8	NXP		: HS-TLL and FS-TLL are not supported. These features will be removed from the specification. DescriptionJEEHEHRECONSTRUCT: The VC-1 intensity bug occurred during motion compensation interpolation process. This bug is that the intensity register is set for wrong intensity scale/shift values in special cases.This bug induces the image distortion because VPU has one intensity information about motion vector in the intensity process. In VC-1 standard, this codec should have all intensity information by line. This bug affects the VC-1 stream which have both field interlace mode and frame mode. There is no impact on the normal decoding stream of VPU except the VC-1 Intensity field mode stream. The VC-1 AP bug includes three sub bugs: â¢ Field picture boundary distortion: â Appear condition: Current picture is a field, reference picture is a frame, reference vector is set for the outer of P/B Frame, intensity is enabled, and scale/shift intensity value for top and bottom are different to each other. â DescriptionJEEHEHRECONSTRUCT: If the reference vector is set for the outer of reference picture, the intensity scale/shift value should be changed in VC-1 Standard. VPU has the intensity information which is the âintensity bottomâ without change. But, In VC-1 standard, the intensity information changed from â-1:intensity bottomâ to â0:intensity Topâ. â¢ Field picture reference to the same frame field picture: â Appear condition: Current picture is a field, reference picture is in the same frame, scale/shift intensity value for top and bottom are different to each other. â DescriptionJEEHEHRECONSTRUCT: When current field picture is referencing a field picture in same frame, current version of MC is always referencing parameters for forward intensity compensation which cause distortion on the any field position. â¢ Frame picture reference to previous field picture: â Appear condition: Current picture is a frame, reference picture is a field, intensity is enabled, and scale/shift intensity value for top and bottom are different to each other. â DescriptionJEEHEHRECONSTRUCT: In VC-1 standard, the intensity value must be changed by y-position on the two field reference picture. But VPU VC-1 intensity value always indicate the âtop Field Intensity valueâ which cause distortion on the line of the picture. Projected ImpactJEEHEHRECONSTRUCT: Removed support for the option of on board USB connection without transceiver. Projected ImpactJEEHEHRECONSTRUCT: There are three different cases for the projected impact: â¢ Case 1 This bug only affects VC-1 stream which have both field interlace mode and frame mode. That kind of bitstream rarely appears in real application case. â¢ Case 2 There is no impact on the normal decoding stream of VPU except the VC-1 Intensity field mode stream. â¢ Case 3 Visual quality impact. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 149	: None. Need to add transceiver for on board connection.	11408 ENGcm11408 USB: High Speed Transceiverless Logic interface (HS-TLL) and Full Speed Transceiverless Logic interface (FS-TLL) USB interfaces are not supported
Cortex-A8	NXP		: This logic bug is in the DC prediction for H.263-P3 Advanced Intra Coding (Annex I) decoding. A clip function logic design was mistakenly implemented thus causes a wrong clipping result when H.263 Annex I is enabled and the DC prediction value falls in the range of [0, -2048]. This condition most likely happens in a picture having very black and white neighborhood 8x8 blocks. Projected ImpactJEEHEHRECONSTRUCT: This bug can cause a very noticeable visual impact. However, because H.263-P3 content is not common, so the general impact is small. There is no impact on the encoder, the effect is on H.263-P3 decoder only. Annex I is not implemented/supported by the H.263-P3 encoder.	: Workaround for case 1: This case needs RTL fix, no firmware workaround. And it has minor visual impact along the boundary of the picture. Workaround for case 2: This case can be fixed by firmware. Firmware sets the parameters for forward intensity compensation with values for forward and current intensity compensation. Workaround for case 3: Can not be fixed by firmware, but visual quality can be improved by firmware. RTL update can fully fix the problem. WorkaroundsJEEHEHRECONSTRUCT: None. No firmware workaround fix feasible.	9125
Cortex-A8	NXP		: This logic bug is for the VLC implementation for DivX Version 3.11. Almost escape and run tables had wrong values, and escape run manipulation had been implemented incorrectly. Regarding to the level tables, there's no problem in normal stream except the table intra_mb_last_10. Some parts of syntax could be regarded as an error with the table intra_mb_last_10, in a normal, error free, stream. Regarding to the run tables, some run values are coded wrong. So, the counts of run length is different as maximum one in these cases. The wrong run-escape manipulation can make difference either as minus one to the counts of run length against luminance values. In general, there are two kinds of bug. One is wrong error detection due to one omitted column of a table array. The other is difference of run length due to wrong run-escape manipulation and wrong table values. The differences of the counts could be maximum one. DescriptionJEEHEHRECONSTRUCT: Some MPEG1 bit streams are decoded unsuccessfully. This hardware bug occurs in the process of updating the integer motion vector when the motion vector is negative. The VPU always assumes â0â in MSB even for a negative motion vector, thus mistakenly producing a positive motion vector. Projected ImpactJEEHEHRECONSTRUCT: This bug should cause a noticeable visual quality degradation (theoretically) for some of the video sequences. But visual quality impact is not significant, and the clip we used to find this bug does not have any visual quality degradation. This bug occurs only in DivX V3.11, and DivX V4, V5, V6 do not have this bug. Since DivX V5 and V6 content is more popular than that of V3.11, so the overall impact should not be significant. Projected ImpactJEEHEHRECONSTRUCT: Some MPEG1 bit streams can be decoded unsuccessfully. A wrong motion vector is produced for a negative integer motion vector. Because negative integer motion vectors in MPEG1 are very common, visual quality degradation is significant due to the wrong motion vectors for motion compensation. The usage of MPEG1 is rare in new products, so the overall impact is small.	: None. There is no way for firmware workaround fix because the tables and escape run manipulation are done in hardware logic. WorkaroundsJEEHEHRECONSTRUCT: There is a firmware workaround.	10260 ENGcm10260 VPU DivX V3.11 Variable-length-decoding (VLC) bug
Cortex-A8	NXP		: There is a limitation when selecting different Huffman tables for AC/DC coefficients for the two chrominance components, Cb and Cr. The JPEG decoder design cannot handle two different Huffman tables for Cb and Cr. Cb and Cr are assumed to use the same Huffman table, which is true in most cases. DescriptionJEEHEHRECONSTRUCT: The PLL loses frequency lock, drifting either higher or lower than the locked frequency, for a period of ~2 Î¼s, before re-locking itself with no user intervention. The root cause is a meta stable analog signal, which may cause the VCO to adjust the frequency of the output clock significantly out of range. The meta stable signal returns to normal operation after one VCO/4 clock cycle, and the PLL then acts as designed to return the PLL output to the programmed frequency (within ~2 Î¼s). This erratum applies to i.MX512D, i.MX513D and i.MX515D devices. Projected ImpactJEEHEHRECONSTRUCT: The bug occurs when the two chroma components, Cb and Cr, use different Huffman tables for AC/DC coefficients. Therefore, if Cb and Cr use the same Huffman table, this problem does not occur. Normally, JPEG streams use the same Huffman tables for Cb and Cr. It should be rare for JPEG streams to use different Huffman tables for the two chroma components. There is a large visual quality degradation. However, in reality, the probability of using two different Huffman tables for Cb and Cr is low. As a result, the overall impact for JPEG decoding should not be significant. Projected ImpactJEEHEHRECONSTRUCT: Drifting faster than the lock frequency can result in DDR and internal logic failures. Drifting slower than the lock frequency can result in DDR failures. Depending on system activity and magnitude of frequency drift, corrupt memory transactions may occur, possibly causing system failure. Work Arounds: The issue can be mitigated by using a Multiplication Factor Numerator (MFN) software work around which puts the PLL into an operating mode to avoid unintended VCO adjustments in response to any potential meta stable event. The PLL should also be configured into Phase Lock Mode (PLM = 1). The MFN implementation is accomplished by locking the PLL at a higher than targeted frequency (864 MHz), and then changing the MFN to reach the target frequency (800 MHz). This is a specified dither mode PLL function. By running the PLL slower than the locked frequency, even if a meta stable event occurs, erroneous deviations to the VCO are avoided. The workaround applies to devices with a target CPU frequency of 800 MHz operation. There are two parts to the work around, and they need to be applied whenever the PLL is shutdown and re-started. The implementation below assumes PLL1 is being used as the source for the CPU and DDR clock. â¢ Part 1: Work around applied during system initialization (boot code) â Disable auto-restart of PLL1 by clearing AREN bit in DP_CONFIG â Configure PLL1 multiplication factors for 864 MHz using the following factors: MFI = 8; MFN = 180; MFD = 179; PDF = 0 â Change DDR clock to be sourced from PLL2 â Change ARM clock to be sourced from PLL2 â Manually restart PLL1 (RST = 1) with phase and frequency lock (PLM = 1) using DP_CTL â Wait for PLL1 to lock by polling lock ready flag (LRF) in DP_CTL â PLL1 will now be locked at 864 MHz Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 155	: None. There is no firmware workaround fix for this erratum.	10390 ENGcm10390 VPU: JPEG decoder does not support different AC/DC Huffman tables for Cb and Cr
Cortex-A8	NXP		: Occurs when a pending command which issues busy is completed. For a command with R1b response, the proper software sequence is to poll the DLA for R1b commands to determine busy state completion. The DLA polling is not working properly for the ESDHC module. This is relevant for all eSDHC ports (eSDHC1-4 ports). Projected ImpactJEEHEHRECONSTRUCT: DLA bit in PRSSTAT register cannot be polled to wait for busy state completion. Software Work Around: Updated block guide to reflect that DLA is not applicable to detect busy state, instead, should poll bit 24 in PRSSTAT register (DLSL[0] bit) to check that wait busy state is over. Silicon Fix: No plan to fix. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 157		12051 â Update MFN to transition to 800 MHz by applying the following factor: MFN = 60 â Request PLL to load new MFN using DP_CONFIG (LDREQ bit) â Wait for acknowledge of new MFN factor from PLL by polling DP_CONFIG (LDREQ bit) â PLL1 will now be locked at 800 MHz â Delay 4 Î¼s to avoid PLL instability window â Move ARM clock to be sourced from PLL1 â Move DDR clock to be sourced from PLL1 â¢ Part 2: Work around applied to suspend/resume code (kernel) â Change DDR clock to be sourced from PLL2 â Change ARM clock to be sourced from PLL2 â Update MFN to transition to PLL1 to 864 MHz by applying the following factor: MFN = 180 â Request PLL to load new MFN using DP_CONFIG (LDREQ bit) â No need to wait for new PLL rate. PLL will be disabled during suspend â Enter suspend â Interrupt wakes system â System will resume with PLL1 locked at 864 MHz. DDR and ARM are sourced from PLL2 â Update MFN to transition to 800 MHz by applying the following factor: MFN = 60 â Request PLL to load new MFN using DP_CONFIG (LDREQ bit) â Wait for the acknowledgement of new MFN factor from PLL by polling DP_CONFIG (LDREQ bit) â PLL1 will now be locked at 800 MHz â Delay 4 Î¼s to avoid PLL instability window â Move ARM clock to be sourced from PLL1 â Move DDR clock to be sourced from PLL1 â Continue resuming system
Cortex-A8	NXP		: In the event that an uncorrectable ECC error occurs while reading Main/Main+Spare from the Nand device, then all spare read operations would fail until the next successful Main/Main+Spare read operation. DescriptionJEEHEHRECONSTRUCT: The DDR2 JEDEC standard requires the DDR clock (SDCLK) to start toggling at least 200 Î¼S before clock enable (SDCKE) signal rise. In the ESDCTLv2 implementation, it was planned to count 7 CKIL clock periods, calculating to 30.05 Î¼S*7 or 210.35 Î¼S, which is greater than 200 Î¼S and within the JEDEC requirement. However, in practice, SDCKE wait period can be as short as 6 CKIL periods, thus violating the above JEDEC requirement. Impact: So far, no issue has been seen. Software Workaround: No software workaround. Silicon Fix: No hardware fix is scheduled. This is a silicon design deviation from the JEDEC standard. Chip Errata for the i.MX51, Rev. 5 Freescale Semiconductor 159 Projected ImpactJEEHEHRECONSTRUCT: The NFC wrongly indicates ECC error. Software Work Around: Read main or main+spare after first uncorrectable error. Silicon Fix: No hardware fix scheduled. This issue will be addressed in the software drivers in the next driver release. Chip Errata for the i.MX51, Rev. 5 158 Freescale Semiconductor12376 ENGcm12376 eSDCTL: ESDCTLv2 fails to wait the minimal 200uS between DDR clk & clk enable		12362 ENGcm12362 NFC wrong indication of ECC uncorrectable error occurrence after reading the spare area
Cortex-A8	NXP		: When the AUS bit is set, the address lines of the EIM are un-shifted. By default, AUS bit is cleared and address lines are shifted according to port size (8, 16 or 32 bits). Due to an error, the address bits 27:24 are shifted when AUS=1. For example, CPU address: 0xBD00_0000 ([A27:20]=1101 0000 becomes: 0xB600_0000 ([A27:20]=0110 0000) on the EIM bus. Since A[27:25] is shifted to [A26:24] and A[23:0] is not shifted. As a result A[24] is missed. Impact: If the memory used does not exceed 32 MB, there is no impact. This mode is related to a unique memory configuration that is not often used. Most systems can work in the default mode (AUS=0). Board designers should connect the EIM address bus without a shift (for example, A0âA0, and A1âA1), while working in AUS=0 mode. Software Workaround: â¢ Use the AUS = 0 mode (default) while connecting the address signals without a shift (for example, A0âA0 and A1âA1). â¢ For AUS=1, for devices larger than 32 MB, need to build a memory map that takes this shifting into consideration and does not include A[24] line. Silicon Fix: No hardware fix is scheduled.		12378 ENGcm12378 EIM: AUS mode is non functional for devices larger than 32MB
Cortex-A8	TI	OMAP-3530	When configured as the master, the I2C module does not allow 0-byte data transfers. Note: Programming I2Ci.I2C_CNT[15:0]: DCOUNT = 0 will cause undefined behavior.	No workaround. Do not use 0-byte data requests. 18 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.2 I2C Module Does Not Allow 0-Byte Data Requests
Cortex-A8	TI	OMAP-3530	If a General Purpose Timer (GPTimer) is in posted mode (TSIRC.POSTED = 1), due to internal resynchronizations, any values read in TCRR, TCAR1, and TCAR2 registers immediately after the timer interface clock (L4) goes from a stopped state to an active state may not return the expected values. This situation is most likely when the OMAP35x Applications Processor wakes up from an idle state. Notes: â¢ GPTimer non-posted synchronization mode is not impacted by this advisory. â¢ This advisory also impacts reads from Watchdog timers WCRR registers. â¢ All of the watchdog timers support only posted internal synchronization mode. There is no capability to change the internal synchronization scheme to non-posted mode via software. â¢ The 32K sync timer CR and 32SYNCNT_REV registers are also impacted by this advisory, since the 32K sync timer is always in posted synchronization mode.	The software must wait at least 2 timer interface clock cycles + 1 timer functional clock cycle after L4 clock-wakeup before reading TCRR, TCAR1, or TCAR2 registers for GP Timers in posted internal synchronization mode, and before reading the WCRR register of the Watchdog timers. The same workaround must be applied before reading CR and 32KSYNCNT_REV registers of the synctimer module. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 19 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.4 Delay Required to Read Some GP, WD, and Sync Timer Registers After Wake-Up
Cortex-A8	TI	OMAP-3530	Under certain conditions, parallel loads with predication to the same cache line may cause victims to be dropped and/or DMA to hang. All of the following conditions must be true in order for this problem to occur: 1. Two LD instructions in parallel. 2. Both are LDs to the same cache line (upper 26 address bits are the same). 3. The LD using T1 is predicated and the predicate is false. 4. The LD using T2 is either not predicated, or is predicated and the predicate is true. 5. The cache line is absent from the cache. 6. The two other lines in the same L1D set are valid. 7. The LRU cache line in the set is dirty. Results: â¢ L1D informs L2 to expect a victim for the affected set. â¢ L2 stalls DMAs with addresses that correspond to that set (DMA includes accesses from IDMA and EDMA). Note: DMA includes accesses from IDMA, EDMA, and any external masters, such as PCI or other CPUs. â¢ L1D processes the true-predicated request correctly. â¢ L1D does not send the indicated victim. Impact: â¢ If the load instruction reads a cacheable location: â The updated data in the LRU line gets dropped. â DMA accesses whose addresses match the affected set hang. â¢ If the load instruction reads a non-cacheable location: â L1D retains the updated data from the LRU line. â DMA reads may see stale data if the LRU line's address is in L2 memory.	Use Code Gen patch 6.0.3 (available on update advisor) to recompile your source code and avoid this issue. Libraries supplied by TI will be re-released using the 6.0.3 compiler patch. Customer-generated libraries from TI's third-party supplier may also need to be recompiled. For existing object code and libraries, an available Perl script can determine locations of parallel predicated loads that may fail. The script is available at the same update advisor location as the Code Gen patch. 20 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.9 L1D Cache : C64x+ L1D Cache May Lose Data or Hang DMA Operations Under Certain Conditions (OMAP3530/25 only)
Cortex-A8	TI	OMAP-3530	If the I2C module is configured as a slave, in autoidle mode (I2C_SYSC.AUTOIDLE = 1) and the ARDY (I2C.12C_STAT[2]) condition and the START condition are detected in the module at the same time, internal clock gating will be incorrectly applied. This will cause the I2C to NACK (I2C.12C_STAT[1]) the transfer for which the START (I2C.I2C_STA[6]) condition was received. Subsequent transfers will be ACKed as expected.	Workaround 1: Software must set SYSC_AUTOIDLE to 0. In this case, the failure condition never occurs. Workaround 2: Ensure that the external I2C master always resends a NACKed transfer via software. If a transfer was NACKed because of this race condition, the next transfer will always be ACKed. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 21 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.11 Race Condition May Cause I2C Slave to NACK a Transfer
Cortex-A8	TI	OMAP-3530	Because of a glitchy structure inside the UART module, accessing the MDR1 register may create a dummy underrun condition and freeze the UART IrDa transmission. Only IrDa modes Slow Infrared (SIR), Medium Infrared (MIR), and Fast Infrared (FIR) are impacted. Even if the bug condition occurs in UART mode or IrDa CIR mode, it will have no effect. Therefore, UART1 and UART2 are immune to this problem, and only UART3 may exhibit this issue when used in one of the IrDa modesâ SIR, MIR, or FIR.	To ensure this problem does not occur, the following software initialization sequence must be used each time MDR1 must be changed to one of the three failing IrDa modes: 1. If needed, setup the UART by writing the required registers, except MDR1. 2. Set appropriately the MDR1.MODE_SELECT bit field. 3. Wait for 5 L4 clock cycles + 5 UART functional clock cycles. 4. Clear TX and RX FIFO in FCR register to reset its counter logic. 5. Read RESUME register to resume the halted operation. 22 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.12 MDR1 Access Can Freeze UART Module When in IrDa Mode
Cortex-A8	TI	OMAP-3530	When performing any block cache operation, such as "Writeback", "Writeback with Invalidate", or "Invalidate", for any memory controller or memory range (e.g., L1P, L2, L1D) the word count programmed must be less than or equal to 0xFF80. If a value greater than 0xFF80 is desired, then this must be broken into multiple operations. The following registers are affected: L2WWC, L2WIWC, L2IWC, L1PIWC, L1DWIWC, L1DWWC, and L1DIWC.	No workaround. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 23 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.13 IVA2: Block Cache Operations Word Count (*WC) Must Be Less Than or Equal to 0xFF80 (OMAP3530/25 only)
Cortex-A8	TI	OMAP-3530	Under certain rare conditions, the I2C_STAT[13].RDR bit may be set as well as the corresponding interrupt fire, even when there is no data in the receive FIFO, or the I2C data transfer is still ongoing. These spurious RDR events must be ignored by the software.	Software must filter out unexpected RDR pulses, using the flowchart illustrated in Figure 3 when receiving an I2C RDR interrupt. 24 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.15 I2C: RDR Flag May Be Incorrectly Set
Cortex-A8	TI	OMAP-3530	The EDMA channel controller (TPCC) has 2 event queues: Q0 and Q1. Each queue can be mapped to one of the two Transfer Controllers (TPTC): TPTC0 or TPTC1. As explained in the OMAP35x Technical Reference Manual (literature number SPRUF98 ), the events in each event queue will be extracted as soon as the corresponding TPTC is available for a new Transfer Request (TR) to be programmed into the TPTC. However, due to an issue in the IVA2.2 subsystem, the requests queued in Q1 cannot be submitted to their TPTC as long as Q0 is not empty. Specified behavior is that TR When TPTC can accept a shall be submitted from each new TR, TPTC activates queue as soon as the empty signal corresponding TC becomes available empty0 Q0 C B A TPTC0 TPTC Q1 F E D TPTC1 empty1 Owing to the bug, Q1 remains blocked as long TPCC as Q0 is not empty Figure 4. TR Submission Scheme	Infrequent short transfers (e.g., latency critical synchronized transfers to/from peripheral) must be placed in Q0, and longer transfers (e.g., block copy) in Q1. For example, when a latency critical transfer is placed in EDMA and a longer transfer in QDMA, the following programming model will minimize the impact of this limitation: â¢ EDMA Event is queued to Q0 (using IVA_TPCC.DMAQNUMn register, n from 0 to 7) â¢ QDMA Event is queued to Q1 (using IVA_TPCC.QDMAQNUM register) â¢ Queue to TC Mapping is Q0:TPTC1 Q1:TPTC0 (using IVA_TPCC.QUETCMAP register) â¢ Queue Priority is Q0 = 0x0, Q1 = 0x7 (using IVA_TPCC.QUEPRI register) 26 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.16 IVA2: EDMA Channel Priority Is Not Correctly Enforced (OMAP3530/25 only)
Cortex-A8	TI	OMAP-3530	If a power domain meets the conditions to go to an INACTIVE state (i.e., POWERSTATE is programmed to 0x3 (ON) and clock can be shut off), then the domain will transition to INACTIVE state. However, the domain cannot go to RET or OFF state automatically from INACTIVE state, even if software updates the POWERSTATE bit to 0x1 (RET) or 0x0 (OFF). The domain must be transitioned to the ON state before it can transition to the RET or OFF states.	The following two conditions must be met: 1. Do not use autostate with PM_PWSTCTRL_XXX.POWERSTATE=0x3 (ON) to put power state in INACTIVE. Using autostate from ON to RET (or OFF) transition is not impacted. 2. Perform wake-up event (software must force wakeup) to transition to an active state before transitioning to the RET or OFF states. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 27 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.29 Inactive State Management: Impossible to Transition to OFF or RETENTION States
Cortex-A8	TI	OMAP-3530	The Voltage Controller generates an I2C access error when an I2C command is sent to PowerIC during a voltage domain sleep transition. When the access error is generated, an interrupt is generated for software error handling. PRCM generates a warm_reset when an access error is generated by the Voltage Controller during voltage domain wake-up transition. This is to recover the full system (OMAP35x Applications Processor + OMAP Peripherals + Power IC) and avoid a deadlock (OMAP35x Applications Processor wakeup transition stalling due to I2C access error and VDD1/ VDD2 not supplied). Since both VDD1 and VDD2 Voltage Controllers share the same interrupt line, an access error for VDD2 Voltage controller is also propagated to VDD1 Voltage controller. This bug occurs only with the I2C module used by the Smart Reflex module. Other instances of the I2C module are not impacted by this issue. In the following scenario, 1. VDD1 is performing a wake-up transition while VDD2 is performing a sleep transition. 2. An I2C access error is generated on VDD2 sleep request and VDD1 and VDD2 share the same error line, so this access error on VDD2 is broadcasted to both VDD1 and VDD2. The condition for a warm_reset generation is met on VDD1, and Warm_reset is asserted inappropriately. This issue was detected in simulation, but it is a corner case that is not expected to occur in production, since the I2C access error should never occur if the PCB is safe. This bug is reported in the silicon errata to help developpers in case this kind of behavior is detected, but so far it has not been seen in real silicon.	By construction, the issue cannot happen if no I2C command is sent during a VDD2 sleep transition (use SYS_OFF_MODE and Smart Reflex disabled). It will never happen if an I2C access error does not occur (this is the expected behavior). 28 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.36 Inappropriate Warm Reset Generation on Smart Reflex I2C Error
Cortex-A8	TI	OMAP-3530	An issue can occur during C64x+ execution when: 1. The DSP code contains 2 contiguous SPLOOP/D/W 2. DSP is interrupted when executing the first SPLOOP/D/W 3. There are less than 2 execute packets between the SPKERNEL of the first SPLOOP/D/W and the SPLOOP/D/W instruction of the second When this issue occurs, the first SPLOOP/D/W terminates abruptly (i.e. without completing the loop), even though the termination condition is false. The failure mechanism can be seen as a hang or by the first SPLOOP/D/W draining for the interrupt and starting the second SPLOOP/D/W without taking the interrupt or returning to complete the first SPLOOP/D/W.	Ensure there are at least two execute packets between the SPKERNEL of the first SPLOOP/D/W and the SPLOOP/D/W instruction of the second. A fix is implemented in the compiler included in version CGT6.0.6 of the Code Generation Tool (CGT). From this revision of CGT, the compiler now ensures there are two cycles between SPKERNEL and SPLOOP/D/W instructions by adding the appropriate number of NOP instructions following the SPKERNEL instruction. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 29 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.41 CPU: Back-to-Back SPLOOPS With Interrupts Can Cause Incorrect Operation on C64x+ CPU (OMAP3530/25 only)
Cortex-A8	TI	OMAP-3530	A false internal exception can be generated by C64x+ if an interrupt happens during DSP code flow and the instructions that will be annulled during pipeline flush are dependant. This issue occurs in the exception detection logic. It examines the DSP instructions during the pipeline flush, even though they have been annulled. The hardware does not detect this and incorrectly assumes that multiple write instructions to the same register with 2 different conditional registers will be executed. The DSP generates an incorrect internal exception in the following scenario: the CPU is draining the pipeline as part of an interrupt context switch. During this time, it annuls instructions in the pipeline. The first annulled execute packet changes the value of one or more predicate registers. The second annulled execute packet has two or more predicated instructions that use the predicates written in the previous cycle. The values held in the predicate registers appear to cause the instructions in the second annulled execute packet to write to the same register. The conflicting writes would not happen if the first execute packet was not annulled. Example: ZERO A0 ZERO A1 ------------> (interrupt occurs here) MVK 1, A0; (annulled) [!A0] MVK 2, A1; (annulled) || [!B0] MVK 3, A1; (annulled) Invalid exception triggers as it appears that the last two MVK will both write A1. Even if this issue appears in a DSP code, it does not affect the code flow and does not produce an unexpected exit routine value.	The CPU only recognizes the incorrect exception while it drains the pipeline for an interrupt. As a result, the CPU begins exception processing upon reaching the interrupt handler. The NRP (NMI Return Pointer Register) and NTSR (NMI Task State Register) will reflect the state of the machine upon arriving at the interrupt handler. Therefore, to identify the incorrect resource conflict exception in software, verify the following conditions at the beginning of the exception handler prior to normal exception processing: 1. Exception occurred during an interrupt context switch. â¢ In NTSR, verify that INT=1, SPLX=0, IB=0, CXM=00. â¢ Verify that NRP points to an interrupt service fetch packet. That is, (NRP & 0xFFFFFE1F) == (ISTP & 0xFFFFFE1F). 2. The exception is a resource conflict exception. In IERR, verify that RCX == 1 and all other IERR bits == 0. 3. The exception is an internal exception. In EFR, verify that IXF == 1 and all other EFR bits == 0. Upon matching the above conditions, suppress the exception as follows: â¢ Clear EFR.IXF by writing 2 to ECR. â¢ Resume the interrupt handler by branching to NRP. The above workaround identifies and suppresses all cases of the incorrect resource conflict exception. It resumes normal program execution when the incorrect exception occurs, and has minimal impact on the execution time of program code. The interrupted code sequence runs as expected when the interrupt handler returns. The workaround also suppresses a particular valid exception case that is 30 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.42 IVA2: DSP Generates False Internal Exception for Multiple Writes (OMAP3530/25 only)
Cortex-A8	TI	OMAP-3530	The GPMC may stall if the following conditions are met: 1. GPMC_CONFIG[0].NANDFORCEPOSTEDWRITE=1. 2. Software performs more than 256 continuous write accesses in NAND_COMMAND_x, NAND_ADDRESS_x or NAND_DATA_x registers. 3. GPMC_STATUS[0].EMPTYWRITEBUFFERSTATUS is always 0 (buffer not empty) during write accesses. This means the software has to write fast enough in GPMC registers in order to never have the write buffer empty. This mechanism is CS independent. If the software performs 128 write accesses in NAND_DATA_0 followed by 128 write accesses in NAND_DATA_1 then the bug will occur.	Accesses performed through the "prefetch and write posting engine" of the GPMC are not impacted by this limitation, and software should use this mechanism for the best performance. If the prefetch and write posting engine is not used, when GPMC_CONFIG[0].NANDFORCEPOSTEDWRITE=1 and after 255 write accesses in NAND_COMMAND_x, NAND_DATA_x or NAND_ADDRESS_x registers, the software has to wait until GPMC_STATUS[0].EMPTYWRITEBUFFERSTATUS=1 before sending the next 255 write accesses. 32 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.53 GPMC May Stall After 256 Write Accesses in NAND_DATA, NAND_COMMAND, or NAND_ADDRESS Registers
Cortex-A8	TI	OMAP-3530	A dummy DMA RX request is generated as soon as the SPI is configured in slave mode and a SPI clock edge is detected. The dummy DMA RX request is generated during module configuration, when the module is not performing an SPI transfer. The dummy DMA RX request occurs as soon as the SPI interface signal sensitivity is changed compared to the default value. The dummy DMA RX request is generated because the mechanism to avoid dummy data capture on a CS glitch is done regardless of channel activation. SPI RX DMA Request 2âSPI Slave Configuration SPI CS SPI CLK 4âEnable Slave, then Master. Dummy DMA Request is Generated Because of Previous CLK Falling 3âSPI Master Configuration (CLK Driven Low) 1âSPI Pin Muxing Configuration (CLK Pulled Up, CS Pulled Down) Figure 5. SPI Dummy DMA RX Generation	Avoid conditions where the SPI is in slave mode and the SPI clock toggles (see examples below). SPI RX DMA Request 2âSPI Slave Configuration SPI CS SPI CLK 4âEnable Slave, then Master. No Dummy DMA Request Generated (No Previous CLK Falling Edge) 3âSPI Master Configuration (CLK Driven Low) 1âSPI Pin Muxing Configuration (CLK Pulled Down, CS Pulled Down) Figure 6. Dummy DMA RX Generation (No Clock Edge) SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 33 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.57 SPI Dummy DMA RX Request Generation
Cortex-A8	TI	OMAP-3530	The DMA optimization functionality has been implemented in the display controller to reduce bandwidth. The access to the memory in 90- and 270- degree-rotation can be programmed to fetch two pixels per access. When this feature is used, the re-sampling (even if the ratio is 1) must be enabled to store the pixel in the lines buffer. This feature can be used with RGB16 and YUV422 pixels formats. Due to the address generation and the horizontal scaling issue, the DMA optimization does not work properly with RGB16 and YUV422 format for 90-degree and 270-degree rotations. The image is not correctly displayed on the panel.	No workaround. The bit VIDDMAOPTIMIZATION (bit 20 of DISPC_VID1_ATTRIBUTES or DISPC_VID2_ATTRIBUTES register) must be left to its default value: 0x0. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 35 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.62 90 and 270-Degree Rotation DMA Optimization Does Not Function Properly
Cortex-A8	TI	OMAP-3530	The DMA4_IRQSTATUS_Lx and DMA4_IRQENABLE_Lx registers, where x is 0, 1, 2 or 3 are not protected in secure and supervisor modes. Therefore, the channel interrupt line of a secure / supervisor channel can be asserted. However, it is not possible to set or reset an interrupt event.	No workaround. 36 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.66 SDMA: DMA4_IRQSTATUS_Lx and DMA4_IRQENABLE_Lx Registers Are Not Secure
Cortex-A8	TI	OMAP-3530	The PRM_VOLTCTRL and PRM_CLKSRC_CTRL registers are reset on a Warm Reset; however, they should be reset on Cold Reset only. These parameters depend on the device environment only, but the registers must be re-programmed.	No consequence. If default values are used, the registers must be re-programmed at Warm Reset release. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 37 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.74 PRM_VOLTCTRL and PRM_CLKSRC_CTRL Registers Reset on Warm Reset
Cortex-A8	TI	OMAP-3530	Scenario: â¢ IVA2 is idled. â¢ Interrupt is propagated to the IVA2. â¢ IVA2 INTC (WUGEN) generates a Wake-Up event to the PRCM for IVA2 Wake-Up. â¢ A Wake-Up dependency is defined between IVA and CAM, or IVA and SGX. â¢ PRCM wakes-up IVA2, which initiates wake-up for CAM/SGX. â¢ Interrupt is propagated to IVA2 Core. â¢ At this point IVA2 Core could initiate a transfer to CAM/SGX even though the CAM/SGX module may not have finished its wake-up sequence, thus resulting in OCP transfer fail.	The IVA2 software should look at the CAM/SGX clock activity status bit to verify that the CAM/SGX domain is ON before performing any accesses. Next, 10 NOPs should be inserted for additional margin. 38 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.75 IVA2: CAM/SGX Dependencies (OMAP3530/25 only)
Cortex-A8	TI	OMAP-3530	An OCP bus error (SRESP) occurs when an access to the module is performed while the module is coming out of Soft Reset.	Insert 2 NOPs after Soft Reset assertion. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 39 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.76 Erroneous SResp Generation Issued to AES Immediately After Soft Reset
Cortex-A8	TI	OMAP-3530	The MPU L2 Cache Size Status register value is inverted compared to the value given in the spec. The MPU L2 cache size status (CONTROL_FEATURE_OMAP_STATUS[11:10].MPU_L2_CACHESIZE) is inverted: Expected: â¢ 00 = 0KB â¢ 01 = 64KB â¢ 10 = 128KB â¢ 11 = 256KB Current implementation: â¢ 00 = 256KB â¢ 01 = 128KB â¢ 10 = 64KB â¢ 11 = 0KB	The software should appropriately handle the inversion. 40 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.77 MPU L2 Cache Size Status Register Value Inverted
Cortex-A8	TI	OMAP-3530	This defect will only occur for the following conditions: â¢ The USBMOTGHS is acting as a host â¢ BULK IN Split transactions in which the RX polling interval (RXINTERVAL) is large and the peripheral is not responding This may cause tokens and packets to be transmitted near the SOF causing inter-packet gap violations and data corruption of the packet. When the USBOTGHS is acting as a host and a Bulk Split IN transaction is in progress, the USBOTGHS transmits an in token and the device responds by sending data. If data is received, the USBOTGHS requests another packet at its scheduled time (send an IN token). However, if the device responds with a NAK by default, then the USBOTGHS will continue to request a packet until stopped by software. However the RXINTERVAL (0x1D) register can be used to limit the number of NAKs received. By default, the USBOTGHS will not limit the number of requests. The error identified by this defect occurs if the USBOTGHS has been transmitting IN tokens for the entire micro frame In this case, the MUSBMHDRC can transmit an IN token that is so close to the SOF that if the device responds by sending a packet, the packet would be corrupted by the transmission of the SOF. The result would be a corrupted packet (which can be identified by the CRC). For all other transactions, this corruption is avoided by use of the HS_EOF1 (0x1C), FS_EOF1 (0x1D) or LS_EOF1 (0x1E) registers. These registers define a blackout that prevents transmission of IN tokens too close to the SOF.	Limit the number of times the USBOTGHS will transmit an IN token if no packet is available. Limiting the number of attempts to 2 or 3 attempts will ensure that this corruption will never occur. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 41 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.80 Acting as a Host; For Bulk Split IN Transactions, the MUSBMHDRC Can Transmit Tokens too Close to the SOF Packet, Causing an IPG Error
Cortex-A8	TI	OMAP-3530	The OCP master interface of the sub-chip has a design limitation. This interface connects to an OCP slave on one side and to the AHB master interface of Mentor GraphicsÂ® USB On-The-Go (OTG) controller, MUSBMHDRC on the other side. It's a wrapper that converts AHB master read/write requests to equivalent OCP read/write requests and the OCP response/data from OCP slave is expected to be converted to equivalent AHB response/data. In the design, the AHB hresp is always set to OKAY. As a result, an OCP response is never translated to an equivalent AHB response. If an OCP error response is received on the master interface, it will be sent as an AHB OKAY response and not as an AHB Error response. The DMA controller will continue with the DMA read/write transfer since it is unaware of the OCP error response that occurred for the given read/write transfer. The bus error bit in DMA_CNTL register will never be set.	In an OCP error scenario, halt the DMA and terminate the DMA transfer. 42 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.81 OCP Error Does Not Get Communicated to USBOTG
Cortex-A8	TI	OMAP-3530	The SDRAM output clock is gated when an incorrect L3 CLK_SEL ratio is set. This operation is generally transparent and handled at boot time by the ROM code. The workaround should be implemented for the following scenarios: â¢ GP device External Fast boot is used. â¢ EMU device External boot is used.	For External Boot or External Fast Boot which are both impacted by the issue, CLKSEL_L3 (bit 1:0) = 10b must be set before performing SDRC configuration. In all other cases, this programing is handled by the ROM code and no workaround is necessary. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 43 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.83 L3 Interconnect Clock Divisor Default Value Must Be Modified Before Configuration of SDRAM Controller
Cortex-A8	TI	OMAP-3530	The Drain_IE bit in the DMA4_CICRi[12] register is not initialized after POR, and its default value can be either '0' or '1' while the documentation specifies '0'.	Prior to the DMA setup, the software must write 0x0 to this bit to disable the Drain_IE interrupt in the CICR register. 44 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.114 DMA: Drain_IE Reset Value
Cortex-A8	TI	OMAP-3530	During a destination synchronized transfer on the write port (or source sync with SDMA.DMA4_CCRi[25] BUFFERING_DISABLE = 1), if a transaction error is reported at the last element of the transaction, the channel is not automatically disabled by DMA.	Whenever a transaction error is detected on the write side of the channel, the software must disable the channel by writing a '0' to DMA4_CCRi[7]: ENABLE bit. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 45 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.115 sDMA: Channel Is Not Disabled After a Transaction Error
Cortex-A8	TI	OMAP-3530	When the OMAP35x device is programmed to go to OFF/RET mode, the power, reset, and clock management module (PRCM) powers down the High-speed USB Host Subsystem. In response, the High-speed USB Host Controller suspends the bus and the USBTLL issues a suspend interrupt. Before USB Host Controller is switched OFF its register contents are automatically saved to voltage domain retention memory. Also, before the CORE voltage domain is switched to OFF/RET, the USBTLL contents are saved. Once these registers are saved, the OMAP35x device transitions to the OFF/RET state. When an external device initiates a remote wakeup, the PRCM wakes the OMAP35x device. The CORE domain reset is released and the USBTLL registers are restored. Upon the completion of the USBTLL register restore an ALT interrupt is erroneously generated by the USBTLL to the external device. This breaks the USB remote wakeup protocol and as a result the external device aborts the remote wakeup sequence.	To workaround this issue the IdGnd fall interrupts should be disabled by the external device at boot-up. This interrupt can be disabled by clearing the IDGND_FALL bit of the ULPI_USB_INT_EN_FALL_i registers. 46 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.121 USB DEVICE Aborts Remote Wake-Up Sequence When OMAP35x Device Wakes From OFF/RET to ON in USB TLL Mode
Cortex-A8	TI	OMAP-3530	The registers CONTROL_SWRV_i and CONTROL_MSV are expected to be readable regardless of the device type, i.e. general purpose (GP) device or high security (HS) device. The expected behavior is implemented on GP devices. However, on HS devices there is a difference between read accesses performed in secure and non-secure modes: â¢ Read access to CONTROL_SWRV_i or CONTROL_MSV in non-secure privilege mode always returns 0s. â¢ Read access to CONTROL_SWRV_i or CONTROL_MSV in secure privilege mode returns the accurate register value.	No workaround. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 47 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.127 CONTROL_SWRV_i and CONTROL_MSV Registers Accessible Only in Secure Mode on HS Devices
Cortex-A8	TI	OMAP-3530	All the interrupt events either masked or un-masked should be cleared before transitioning the IVA2 domain to standby. This condition is mandatory to allow the idle transition, otherwise the IVA2 is kept active. This issue may occur if the video sequencer is not used (i.e., kept under reset or already idled) while the IVA2 idle sequence is performed. In this case, if an interrupt is propagated to the video sequencer, it will not be handled by the interrupt handler which is inactive but would avoid the IVA2 standby transition. The interrupt is not processed because the video sequencer is inactive, thus avoiding the standby transition of the whole IVA2 domain. The following is an example of this issue: When performing an MP3 low-power use case, the video sequencer is not used, kept under reset, and only the DSP domain of the IVA2 sub-system is used. Any interrupt (even masked) to the video sequencer avoids standby transition for the entire IVA2 domain.	Any write/read to the video sequencer IRQ Register (SEQ_IRQCLR/SEQ_IRQSTATE, etc.) from the DSP or L3 interconnect resolves this issue and allows the standby transition. See below sample code example which can be inserted in C source code: // Definition of Constant Values asm("IVA2_SEQ_BASE_ADDRESS .set 0x00090000"); asm("SEQ_IRQSTATE_OFFSET .set 0x0000004C"); asm("EFI_READ32_REQ_CMD .set 0x02"); //;; Required Code Fragment for Dummy read register in Sequencer // push registers to be used asm(" STW A3, *SP--"); asm(" STW A4, *SP--"); asm(" STW B4, *SP--"); asm(" SUB SP, 4, SP"); // secure 1 word for local frame generation //;; Sequencer ReadRegister() sequence asm(" ZERO B4"); asm(" MVKH IVA2_SEQ_BASE_ADDRESS, B4"); asm(" DINT"); OMAP3530 silicon errata Revision 5.0 150 asm(" ADDK SEQ_IRQSTATE_OFFSET, B4"); asm(" NOP"); asm(" EFSW.L1X B4, EFI_READ32_REQ_CMD"); asm(" NOP 9"); asm(" NOP 8"); asm(" EFRW.S1 A3"); asm(" STW A3, *B15[1]"); // if required to save the read data asm(" NOP 2"); asm(" RINT"); // pop registers asm(" ADD SP, 4, SP"); asm(" LDW *++SP, B4"); asm(" LDW *++SP, A4"); asm(" LDW *++SP, A3"); 48 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.128 Pending Interrupt to Video Sequencer Prevent IVA2 from Going Into Idle Mode
Cortex-A8	TI	OMAP-3530	In the case where: â¢ A McSPI module is configured as master and is connected to another McSPI module configured as a slave (on the same chip, or on a different chip) â¢ The CS polarity is changed from the reset state (i.e., changed from CS inactive low to CS inactive high) on the master and slave sides â¢ The slave is enabled and then the master is enabled according to the programming guide then the slave McSPI will generate a false underflow as soon as the first channel is enabled on the master McSPI side. This is because the master McSPI sets the right clock and chip select polarities only when the first channel is enabled. As the CS polarity is changed on the master side, this will generate a low-to-high transition on the CS signal. The slave McSPI will detect this transition and will try to load its shift register, which will result in an underflow interrupt being generated because there is no data to load. If the slave is an external SPI device, then there is no issue. Only slave McSPI modules will be impacted. If the CS polarity is not changed from its reset state, then there is no issue. This issue will only occur when performing loopback tests on the same chip between two McSPI modules or when communicating through SPI between two McSPI modules on 2 different chips.	The following initialization sequence will solve this issue: 1. On the master side: Set MCSPI_MODULCTRL:SINGLE. Perform the following 3 steps by doing 3 different OCP accesses: â¢ Configure channel I in MCSPI_CH(I)_CONF â¢ Set MCSPI_CH(I)_CONF:FORCE â¢ Reset MCSPI_CH(I)_CONF:FORCE â¢ Reset MCSPI_MODULCTRL:SINGLE bit. The SPI bus polarity is now updated. 2. On the slave side : Configure channel 0 : write MCSPI_CH0_CONF Enable channel 0 : set MCSPI_CH0_CTRL:EN 3. On the master side : Enable channel i : set MCSPI_CH(i)_CTRL:EN SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 49 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.129 McSPI Can Generate a Wrong Underflow Interrupt
Cortex-A8	TI	OMAP-3530	The TV detect in AC coupling mode is not implemented accurately and is not functional; therefore, TV detection in AC mode is impossible.	Use DC coupling mode only. 50 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.131 TV Detect AC Coupling Mode Not Supported
Cortex-A8	TI	OMAP-3530	USB DMA can be used only with one channel (Rx or Tx) active at a time. When more than one channel is active, then DMA transfers cannot be guaranteed.	Workaround A: Use the interrupt mode. Workaround B: Use Tx DMA mode1 for highest throughput requirement endpoint. Use interrupt mode for others. Workaround C: Use Rx DMA mode0 for highest throughput requirement endpoint and interrupt mode for others. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 51 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.132 USB DMA Cannot Handle Concurrent Channels
Cortex-A8	TI	OMAP-3530	Due to a hardware issue in an arithmetic operator in the iLF accelerator, the output of the loop filter algorithm is corrupted (truncation error). This operator is not used in any other block of the IVA2.2 subsystem. Other multimedia codecs (H264, RV9, WMV9, â¦) using iLF are not impacted by this bug. It is safe to use iLF for codecs other than VC1. Note 1: This bug does not create a noticeable impact on the video quality. Even if there is no visible impact on the video quality for the end-user, using iLF loop filter for VC1 encoding or decoding generates a video stream that is not bit exact as compared to the reference: SMPTE Standard for Television: Compressed Video Bitstream Format and Decoding Process. Note 2: iLF supports the WMV9 implementation, but not the whole VC-1 SMPTE standard, even if VC-1 was originally derived from WMV9.	iLF accelerator cannot be used for VC1 decoding and will not produce a bit exact output compliant with SMPTE standard. A SMPTE compliant bit stream can be achieved by using IVA2.2 software solution (iLF not used ,and loop filtering handled by DSP software). 52 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.133 VC1 En/De-coded Bit Stream Corrupted When iLF Is Used
Cortex-A8	TI	OMAP-3530	Due to faulty arbitration in the SBL (shared buffered logic: local interconnect of the ISP), some LSC coefficients can be incorrectly applied on the image. This issue appears only if the preview resizer is accessing the SBL simultaneously with LSC table prefetch. The issue appears randomly depending on the access sequencing between resizer access and LSC accesses. The occurrence of the issue increases with larger image size and smaller paxel size. The corrupted LSC coefficients are not random values, but value of a neighbor (the artifact is difficult to detect with regular values but can be clearly seen with a dedicated LSC pattern).	The workarounds consist of avoiding concurrent accesses to the SBL from the resizer and LSC which can be implemented using various methods. TI is currently validating the different options, and this section will be updated once the optimal workaround in terms of efficiency and software complexity has been confirmed. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 57 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.138 ISP: LSC Issue When Used Concurrently With Resizer
Cortex-A8	TI	OMAP-3530	The CCP2 Read-port cannot be used to read data from DDR into CCDC as image data is dropped randomly, causing final image corruption. This issue only affects OEMs requiring the data path from DDR through CCDC. This issue will impact sensors that require throughput greater than 83 Mpix/sec, which is only possible with CSI2-based sensors. There is no issue for CSI2 sensors that require throughput greater than 83Mpix/sec â in this case, processing is OTF. This will not impact CCP2 sensors based on CCP2 throughput limitations.	Use an alternate data path for ISP. Use read-back path in Preview Module. TI is continuing to study implementation impact for future releases. 58 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.141 ISP CCDC DRAM Read-Port Issue
Cortex-A8	TI	OMAP-3530	The Lens Shading Correction (LSC) module in CCDC cannot be used simultaneously with the Preview-to-Resizer path, as simultaneous accesses can result in data corruption. The LSC data is randomly dropped, resulting in a color-shifted final image. This issue only occurs when LSC is used simultaneously with Preview-to-Resizer.	TI is investigating a work-around in which the LSC in CCDC is used along with the Resizer in mem-2-mem operation. Other possible work-around options for OEM/3P imaging software are possible: â¢ Use the LSC available in the Preview module. â¢ Modify the sensor timings to adjust the Resizer/CCDC timing so that the issue does not occur. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 59 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.142 ISP Lens Shading Correction Issue
Cortex-A8	TI	OMAP-3530	The SDRC auto-refresh counter is not automatically triggered when the SDRC configuration is restored after a CORE OFF. Not refreshing the memory may result in data corruption after some time, which would cause system instability. This issue is caused by the SDRC state machine remaining in an incorrect state after a reset (either warm or cold).	A manual MR write command to SDRAM should be issued as soon as the device wakes up from OFF mode. This will automatically transition the SDRC state machine to the correct state i.e., resuming regular auto-refresh commands. This should be implemented in two steps: â¢ Read the SDRC_MR_p register content. â¢ Write back the SDRC_MR_p register with the value read in the previous step. In order to conform to JEDEC constraints regarding AR intervals (see slide JEDEC Standard No. 209), it is mandatory that the SDRC issues automatic self-refresh entries on inactivity periods for HS devices. This should be done by enabling automatic self-refresh entries on timeout of Auto_cnt (CLKCTRL field of SDRC_POWER register set to 0x2) AND defining this time out value to 1 (AUTOCOUNT field of SDRC_POWER register set to 0x1) prior to any transition to OFF mode. Note: Because of the SDRC design, an atomic PRECHARGE command is issued automatically prior to any MR command. There is no need to account for concurrent accesses that any other initiator in the SOC could generate. 60 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.144 SDRC Does Not Send Auto-refresh When OMAP Wakes-up From OFF Mode
Cortex-A8	TI	OMAP-3530	CONTROL_REVISION register contains the same value (0x00000010) for each silicon revision.	Use CONTROL_IDCODE, which is upgraded for each silicon revision and documented in the OMAP35x Technical Reference Manual (literature number SPRUF98 . SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 61 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.145 CONTROL_REVISION Register Not Aligned With Silicon Revision
Cortex-A8	TI	OMAP-3530	Upon performing a software reset by setting the OTG_SYSCONFIG:SOFTRESET bit, â¢ The hsusb_stp pin will remain low instead of going high as expected. â¢ The reset command will not be sent to the PHY as it should be (the module should send 0x69 or 0x61 and nothing is actually sent). There is no real impact on the USB link functionality except for the two items above. Only software resets through the OTG_SYSCONFIG:SOFTRESET bit field are impacted (cold or warm resets are not impacted).	Use the ULPI RegAddr and ULPI RegData registers to manually send the reset command to the PHY. As soon as this is done, LINK and PHY can begin negotiating and functioning normally. 62 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.146 HS USB OTG Software Reset Is Not Fully Functional
Cortex-A8	TI	OMAP-3530	By default, the CKE pad is in safe mode after Power On Reset. A pull-up is connected to it, so its default level is high. The ROM Code never configures it. In case the booting image contains a Configuration Header which configures a CHRAM section, the ROM Code can configure external RAM according to the parameters located in CHRAM section. In case the platform boots from NAND, it can allow for example the ROM Code to directly copy the booting image into external RAM. Because the ROM Code does not configure this pad, the CKE signal does not reach the external RAM. There is no functional impact at boot time. There is no limitation at run-time. The CHRAM section defines the setting for register SDRC_POWER at physical address 0x6D00 0070. The SW designer must ensure that any special feature involving CKE signaling is OFF (at boot time only). â¢ SDRC_POWER must turn OFF all auto-count feature (CLKCTRL field = 0). â¢ SDRC_POWER must disable the Power Down mode of the target memory, via CKE (PWDENA field = 0).	There is no workaround for this issue. The functionality "configuration & boot from external RAM" remains operational following the basic rules indicated above. After booting, the application can properly configure the CKE pad and configure a more optimized refresh policy. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 63 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.148 CKE PAD Is Not Set When Initializing External RAM
Cortex-A8	TI	OMAP-3530	In case the booting image contains a Configuration Header which contains itself a CHRAM section, the ROM Code can configure external RAM according to the parameters located in CHRAM section. In case the platform boots from NAND, it can allow for example the ROM Code to directly copy the booting image into external RAM. The CHRAM section contains all the values to initialize the SDRC module. When setting the SDRC_POWER register, the ROM Code does not read the value contained in the Configuration header but applies instead a hard coded value set to 0xC1. This value configures the SDRC as follows: â¢ High power/High Bandwidth Mode (HPHB) â¢ Power down mode feature disabled â¢ Enable clock â¢ No auto-count feature turned on â¢ Enter self-refresh when hardware idle request â¢ Enter self-refresh when a warm reset is applied â¢ Auto-count = 0 There is no chance to configure SDRC_POWER register with a different value than the one described above.	There is no workaround for this issue. 64 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.149 ROM Code: SDRC_POWER Register Is Initialized With Hardcoded Value
Cortex-A8	TI	OMAP-3530	When configured in slave transmitter mode, the I2C_STAT:XUDF will not be set as expected if an underflow occurs. Only slave transmitter mode is impacted. Master transmitter mode is not impacted. The impact is rather low as the user can rely on I2C_STAT:XRDY interrupt status bit instead.	Use the I2C_STAT:XRDY interrupt bit instead of XUDF when in slave transmitter mode. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 65 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.150 I2C : I2C_STAT:XUDF Is Not Functional in Slave Transmitter Mode
Cortex-A8	TI	OMAP-3530	3 Timings do not follow the JEDEC standard: â¢ tRP: Precharge command period on power down â JEDEC standard: 0 to 7 â Current implementation: Fixed to 2 â Impact analysis: No impact, tolerated by memory components (checked with memory vendors) â¢ tRFC: Auto-refresh period on self-refresh â JEDEC standard: 0 to 31 â Current implementation: tRFC depends on the delay with the next SDRC command. tRFC min is 1 clock period. tRFC minimum period on self-refresh can be controlled through tCKE (tRFCmin=tCKE) (in the range of tCKE [0 to 7]) â Impact analysis: No impact, tolerated by memory components (checked with memory vendors) â¢ tWR: Write Recovery time on power down â Issue description: tWR is asynchronous, collides with power-down entry and corrupts the last write operation â Impact analysis: Random system crash	Disable power-down PWDENA=0. This will impact power consumption, variably depending on use case, and memory type: â¢ Use case IDLE: power impact less than 0.1mA â¢ Use case FULL-ACCESS-RATE: power impact less than 1mA For specific MEDIUM-ACCESS-RATE use-cases, the power impact can be minimized using an alternate software work-around: â¢ AUTOCOUNT=0, SRFRONIDLEREQ=1, CLKCTRL=1, EXTCLKDIS=1, PWDENA=0 â¢ Theory: play with AUTOCOUNT value to trade performance against power savings â¢ Power impact ~1mA All the above numbers are correlated by memory vendors' measurements. In all uses cases, the proposed software work-arounds are robust and have less than 1mA power impact. 66 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.152 SDRC Timings Are Not Aligned With JEDEC Standard
Cortex-A8	TI	OMAP-3530	The I2C is configured as master transmitter. After serving a XRDY/XDR interrupt (FIFO empty), from the data sent on OCP, one, two or several bytes sent from the memory to the I2C interface are lost. The bytes lost are always the first transmitted on the OCP, when serving the XRDY/XDR interrupts. The occurrence of the bug is related to the coincidence of the moment when data is sent on the OCP and the moment when the most significant bit of a byte is sent on the I2C, always when starting serving the XRDY/XDR interrupt. Ideally, no data should be lost when transmitted from the OCP to the I2C. However, one, two or several bytes at the beginning of a transmission from the OCP to I2C are lost, if the moment when they are put on the OCP coincides with the transmission of the most significant bit of a byte on the I2C.	A workaround exists for the interrupt mode of operation. Before serving the XRDY/XDR interrupts, until also XUDF status bit is set. This marks the clearance of the internal shift register and polls the Status Register â XUDF bit, from the local host, after receiving an XRDY or XDR Note. For the data transmission using DMA, there is no available software workaround. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 67 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.155 I2C: Data Lost on Transmission From Memory to I2C Interface
Cortex-A8	TI	OMAP-3530	: This issue concerns HSUSBHOST controller of OMAP35x and more specifically the EHCI controller (Only HS ports are impacted). The issue occurs after a Suspend when trying to Resume the bus (Host initiating the Resume) and also when doing RemoteWakeup (Device initiating the Resume). The HSUSBHOST exits the resume/wakeup sequence without checking the USB bus LineState to ensure that it is in High Speed Idle state after having put the PHY in High Speed state. This error scenario will occur when there is a delay in PHY indicating the controller that the bus has switched to High Speed, and during that time the host is about to send an SOF packet. Both TLL and PHY modes are impacted.	: The clear of the âForceResumeâ bit in PORTSC register must be done at the beginning of the Port- SOF counter boundary, knowing that PortSOF counter is out of sync after a Suspend with GlobalSOF counter (PortSOF counter is stopped during Suspend while GlobalSOF counter continues counting). The FrameIndex counter is based on GlobalSOF counter (SOF counters are counting the 125us delay of a micro-frame). Only FrameIndex counter can be accessed by Software. Two Workarounds can be listed for this issue (See flow diagrams and SW programming sequences below): â¢ Workaround 1: â Advantage: No limitation on the number of HS port usage. â Disadvantage: This workaround applies only to the to Suspend/Resume case and Suspend/RemoteWakeup case is not supported. This is because where within the PortSOF counter the HW will set the Resume bit is not known. â¢ Workaround 2: â Advantage: This workaround applies to both Suspend/Resume and Suspend/RemoteWakeup cases. â Disadvantage: Limitation to have only one HS port used (No limitation on the number of FS port usage as OHCI controller is not concerned). This is because EHCI controller has to be stopped by SW before clearing portSC.FPR. Workaround 1 detailed description: Any Write access to the âPort Suspendâ and âPort Force Resumeâ bits in the PORTSC register must be done at the beginning of a micro-frame. This ensures that the Clear of âForceResumeâ bit is done at the beginning of PortSOF counter. Workaround 1 SW implementation: â¢ Suspend/Resume case SW implementation: 1. Read FRINDEX register. 2. Keep polling FRINDEX register to make sure that the register value has incremented from the value read in Step (1). 3. Set the PORTSC.suspend bit. 4. Wait for the required suspend time. 5. When software is ready to issue resume, Read FRINDEX register. 6. Keep polling FRINDEX register to make sure that the register value has incremented from the value read in Step (5). 7. Set PORTSC.FPR bit. 8. Wait for at least 20ms (as specified by the USB 2.0 Spec). 9. Read FRINDEX register. 10. Keep polling FRINDEX register to make sure that the register value has 68 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.157 EHCI Controller- Issue in Suspend Resume Protocol
Cortex-A8	TI	OMAP-3530	: A pulse (0.4us) is seen after control module I/O pad configuration restore sequence is completed upon wakeup from Device OFF mode. This pulse is seen on the pin corresponding to GPIO_28 = ETK_D14 and GPIO_29 = ETK_D15 when the line is programmed to maintain the line high through internal pull-up. This "pulse" corresponds to the line being driven temporary by the pull-down instead of expected pull-up. Condition of occurrence of the issue: The device wakes up from OFF mode and the user wants to maintain the line to high level using the internal pull-up. Note: This issue does not occur when: â¢ Device is not going to OFF mode â¢ Device goes to OFF mode but OMAP is not driving the line (line is driven by other IC) â¢ Device goes to OFF mode and user wants to maintain the line to low-level Root cause: This is identified as an issue in the control module save and restore implementation since handshake mechanism between prcm and control module is launched even before the restoration of the last padconf-x register is complete. Handshake mechanism refers to a signal generated by the control module to the PRCM to notify the completion of the restoration of the pad configuration The pulse occurs since control module asserts pull-down control of the pad before it re-activates the pull-up control upon the completion of restore sequence. Since pull-down is asserted for some time, the I/O pad toggles from High to Low then to High again causing the pulse on the I/O pad.	: No issue if line is driven low during OFF transitions. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 71 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.159 Pull-up Not Maintained On GPIO_28/29 Pin During Padconf Restore
Cortex-A8	TI	OMAP-3530	: When OMAP wakes up from OFF mode, a spurious transition (on the order of a nanosecond) may occur on the pads internally muxed to a GPIO. The conditions for this spurious transition to occur depend on: â¢ The GPIO setup (GPIO is input, or output driving 1 or 0) â¢ The PRCM settings concerning the power domains state transitions (HW or SW) â¢ The configuration of the pad where the GPIO is muxed Note: All GPIO blocks including GPIO block1 which is in the WU domain are impacted by this issue. Root cause: An internal race condition exists between the control signals of the pad upon wake up from system OFF mode, which leads to a possible spurious transition on the signal at the padâs boundary. The case where a pad OFF mode configuration is used (OFFENABLE =1) but with an override configuration different from the GPIOâs configuration in active mode is a valid option and is out of the scope of this errata as we only consider the case where we want the signal to stay constant all the time (same state during active and OFF mode).	: GPIO belongs to GPIO1 in the WKUP domain (GPIO_0 to GPIO_31) â¢ Do not use the padconf OFF override: CONTROL_PADCONF_X[9] resp CONTROL_PADCONF_X[25]: OFFENABLE bit='0' GPIO belongs to GPIO2 to GPIO6 in the PER domain â¢ Workaround 1 (Recommended option): Use automatic HW transition with Automatic HW wakeup: CM_CLKSTCTRL_PER=0x3 and define a WU dependency between WU domain and PER domain (PM_WKDEP_PER[4]: EN_WKUP=1). Pad Off mode override function must be disabled: CONTROL_PADCONF_X[9] resp CONTROL_PADCONF_X[25]: OFFENABLE bit='0' â GPIO maintaining a low level during OFF mode It is sw responsibility to ensure that the padconf_x value is written to 0x10C before initiating the transition to OFF (This means GPIO function is configured and pull-down activated on the pad) â GPIO maintaining a high level during OFF mode Sequence before transition to OFF mode 1. Save context of the GPIO module. 2. Configure pull-up in padconf, padconf_x: 0x11C (Note: This can be done before the OFF transition decision is done. One way to proceed is GPIO driver always sets a pull-up in padconf when the GPIO_DATAOUT is set to '1') 3. Turn GPIO in input GPIO_OE=1 4. Select Safe mode function, padconf: 0x11F Sequence after OFF mode at device wake-up 1. Complete restoration of the GPIO context 2. Turn back GPIO in output GPIO_OE=0 (Not needed if step1 and step3 of sequence before transition to OFF mode is done in that order) 3. Select GPIO function, padconf_x: 0x11C â¢ Workaround 2 (This option is valid either for SW supervised transition using force wakeup or automatic HW transition) Disable the Pad Off mode override function and ensure that the mode is changed to safe mode before transitioning to OFF mode by following sequence described here after. 1. Save context of the GPIO module. 72 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.160 GPIO Pad Glitch/Spike Upon Wake-Up From System OFF Mode
Cortex-A8	TI	OMAP-3530	: When the I2C_CON:I2C_EN bit is reset during the I2C module reconfiguration, some synchronization signals are not properly reset. This can generate a wrong RDR interrupt when the next transfer begins (before RRDY interrupt and stop condition).	: During the reconfiguration of the module, perform a software reset of the module (I2C_SYSC:SRST) instead of just resetting the I2C_CON:I2C_EN bit. 74 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.161 I2C: Wrong RDR Interrupt After Disabling the Module With I2C_EN
Cortex-A8	TI	OMAP-3530	: VPx_TRANXDONE_ST interrupt is generated too early (immediately in worst case) if the HW counter (in Voltage Processor) used to wait for voltage ramp duration is incorrect. The HW counter could be incorrect in the following scenarios: â¢ The voltage update is done through Voltage Processor force-update command. â¢ Smart-Reflex was previously enabled. This limitation impacts the low-to-high OPP transitions as SW waits for TRANXDONE interrupt generation before changing the frequencies. The risk is that high frequency is configured while high voltage is not yet fully ramped. High-to-low OPP transitions are not functionally impacted by this HW limitation.	: Upon Low-to-High OPP transitions, SW shall add a delay (software wait loop) when receiving the VPx_TRANXDONE_ST interrupt and before increasing the frequencies. This delay needs to be calculated according to: â¢ PMIC slew rate for voltage ramp-up â¢ Delta between âlowâ voltage and âhighâ voltage â¢ Delay already introduced by SW execution (ISR, call to set_module_frequency...) SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 75 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.162 Voltage Processor TRANXDONE Interrupt Occurs Too Early
Cortex-A8	TI	OMAP-3530	: ARM SWAP instructions executed concurrently with another initiator traffic going through SMS VRFB can create a deadlock in some corner cases. Conditions of occurrence of the issue: 1. ARM executes a SWAP instruction to a non cacheable SDRAM location. This is translated to an OCP ReadEx that should be followed by an unlocking write. 2. Once the ReadEx is issued by the SMS toward the SDRAM controller the arbitration is locked on the ARM SMS thread (class 1 group 0) until unlocking write is received. 3. If VRFB is full before unlocking write is received and accepted by MCU SMS thread (class 1 group 0) then SMS will assert threadbusy_all preventing the unlocking write to be received and accepted by ARM SMS thread (class 1 group 0). 4. VRFB does not de-assert threadbusy_all in case FULL condition is due to a SMS FIFO destination being full and locked (that can not be granted on SDRC arbitration access) by the open ReadEx on the ARM SMS thread (class 1 group 0). Note: SWP instruction is not generated by compiler then no risk that swap instruction is generated anywhere outside specific assembly call.	: Replace SWP instructions (locked access) by LDREX/STREX (Exclusive access). Based on ARM documentation LDREX and STREX are supported to shared and non-shared memory. Non-shared memory can be used when the processes to be synchronized are running on the same processor. When the processes to be synchronized are running on different processors, shared memory must be used. 76 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.164 SMS ReadEx Deadlock
Cortex-A8	TI	OMAP-3530	: Like any other module, upon assertion of idle_req from the PRCM, the USB OTG module, if it is inactive, will answer immediately by asserting idle_ack. Upon idle_req de-assertion, the module will de-assert idle_ack immediately too. In the specific case where the USB OTG autoidle feature is enabled at module level (OTG_SYSCONFIG[0]:AUTOIDLE = 1), and where the idle_req is de-asserted very shortly after assertion (less than four L3 clock cycles), the module will never de-assert the idle_ack anymore. Note:by default after an HW reset (at boot time or upon wakeup from OFF), the OTG_SYSCONFIG:AUTOIDLE bit is automatically set to 1.) This kind of short idle_req pulse can occur randomly during run time, when the CORE is going to retention and is awoken immediately for example. In this case, not de-asserting the idle_ack signal will stop the CORE entering retention again. This issue is specific to the USB OTG module.	: Disable the autoidle feature at module level (OTG_SYSCONFIG[0]:AUTOIDLE = 0). If the USB module is not used at all, disable its interface clock at PRCM level. By doing so it will always stay in idle mode. Perform a dummy read of any USB OTG register. This will re-enable the clock inside the module, which will then de-assert its idle_ack signal. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 77 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.166 HS USB OTG : Idle_req / idle_ack Mechanism Potentially Broken When Autoidle Is Enabled
Cortex-A8	TI	OMAP-3530	: Upon any source of HW reset (at boot time or when coming back from OFF mode for example), the reset value of the OTG_SYSCONFIG:AUTOIDLE bit is 1 (autoidle feature enabled). The behavior should be the same when applying a SW reset to the module through the OTG_SYSCONFIG:SOFTRESET bit. Because of an implementation bug, and because the AUTOIDLE and SOFTRESET bits are in the same OTG_SYSCONFIG register, the value defined for the AUTOIDLE bit while performing the SW reset gets over-written into it after SW reset is over. For example : if the AUTOIDLE bit is 0 and a SW reset is performed. AUTOIDLE bit should be reset to 1. â¢ If the SW reset is performed by writing 0x2 in OTG_SYSCONFIG, AUTOIDLE will be un-expectedly reset to 0. â¢ If the SW reset is performed by writing 0x3 in OTG_SYSCONFIG, AUTOIDLE will be reset to 1 as expected.	: There is no workaround. When performing the SW reset, just write the AUTOIDLE bit at the value you expect it to be after reset. 78 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.167 HS USB OTG : OTG_SYSCONFIG:AUTOIDLE Bit Not Correctly Reset
Cortex-A8	TI	OMAP-3530	: The VLD engine for H.264 decoder doesnât throw up the data parsing errors as and when they occur in a macro block, instead the errors are reported in header parsing after decoding few subsequent macro blocks. This Issue is applicable only for the error streams, which normally occurs in streaming applications. There is a delay in reporting the data parsing errors from the VLD engine side: On a given erroneous stream, The MSVC reference decoder fails at the macro block (N). On the same stream, iVLCD would not report the error so VLD will miss the error on macro block (N), continue decoding, then finally meet a contradiction in later macro block. CAVLD decoder will miss specific error patterns, which is happening in this stream. While decoding coeff_token for which nC is 8 or higher, error checking for out-of-table is not activated by mistake.	: There is no S/W workaround. When an error is detected during the header parsing on the DSP, the info about the exact erroneous MB is not available. Hence the decoder has to do the error concealment for all the MBâs in that slice on the DSP. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 79 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.168 IVA iVLCD Cannot Detect Errors
Cortex-A8	TI	OMAP-3530	: As long as the UART RX FIFO is not empty, the UART will not assert its TX DMA request. This means that in scenario using the DMA in both RX and TX, no UART transmission will occur until the RX fifo is emptied. This can cause deadlock situation if the software leaves some bytes in the RX FIFO.	: Software must make sure to always empty the RX FIFO when using the UART in full duplex mode. 80 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.169 UART Not Asserting Its TX DMA Request When RX FIFO Is Not Empty
Cortex-A8	TI	OMAP-3530	: IVA2 may go to Retention during a brief period between "a completion of an EDMA write transfer" and "a deassertion of DMA request (MCBSP_DMA for example)" . The deassertion of DMA request could be delayed by making consecutive accesses (Write or Read) to the low-speed peripherals (e.g., consecutive non-posted writes to GPTimerx from DSP or from MPU if an EDMA write transfer and this GPTimerx use same L4 thread, i.e. McBSP1 and GPTimer1) while EDMA is transferring some data. The DMA request is then de-asserted while the IVA2 has gone to retention but WUGEN memorizes that the DMA request was asserted. When a new DMA is asserted while IVA is in IDLE state then the WUGEN cannot see it because it considers that the DMA is still asserted so it doesn't serve it and doesn't wake-up the IVA2.	: Workaround 1: Add a dummy Read access to the same peripheral for each EDMA write transfer for one EDMA request to the peripheral by using EDMA chaining function. When the deassertion of the EDMA request is delayed by other accesses (Write or Read) to the low-speed peripheral, WUGEN sets IVA SS in Standby State without waiting of the actual completion of the EDMA transfer. If a dummy Read access to the same peripheral is added after each EDMA write transfer to the peripheral then WUGEN sets IVA SS in Standby State after the dummy Read access completion. At this time, the EDMA write transfer should be finished and also the EDMA request is deasserted absolutely. A race between IVA goes to idle and the deassertion of the EDMA request can be avoided. Note: A dummy Read access to the peripheral should be added for each EDMA write transfer for one EDMA request. Therefore, there is possibility to decrease the performance. Workaround 2: Enable DMATRUECOMPEN, ITCINTEN and TCINTEN. All EDMA write request is posted-write in default. Enabling DMATRUECOMPEN changes EDMA write request into a non-posted write. The write request which is affected by DMATRUECOMPEN can be enabled/disabled by using ITCINTEN and TCINTEN That is, if ITCINTEN=1 and DMATRUECOMPEN=1 then intermediate write events can be non-posted write requests. And also if TCINTEN=1 and DMATRUECOMPEN=1 then final write event can be a non-posted write request. Therefore, even the service for EDMA write transfer is delayed by other accesses (Write or Read) to the low-speed peripheral, WUGEN sets IVA SS in Standby State with waiting the completion of this EDMA write transfer by enabling DMATRUECOMPEN, ITCINTEN and TCINTEN. Note: TCC interrupt is common for both intermediate requests (enabled with ITCINTEN) and final request (enabled with TCINTEN). Therefore, there is no way to get only the interrupt for final request when both ITCENTEN and TCINTEN are enabled. To generate the interrupt only with final event, additional use of PaRAMs is required. The method depends on the transfer synchronization dimension (that is, ASync or ABsync): â¢ Case1: In case of Async transfer and Bcnt !=1 or Ccnt !=1, and would like to get the interrupt only with the final event, 3 or more linked PaRAMs are needed. â¢ Case2: In case of ABsync transfer and Ccnt !=1, and would like to get the interrupt only with the final event, 2 or more linked PaRAM are needed. â¢ Case3: In other case (i.e. Async transfer and Bcnt =1, Async transfer and Ccnt =1, or ABsync transfer and Ccnt =1), there is no need to care about the PaRAM setting to get the interrupt of final event. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 81 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.170 IVA2 Does Not Wake-Up After It Goes to IDLE While DMA Request Is Still Asserted
Cortex-A8	TI	OMAP-3530	: A-LAW decompression cannot be performed in the PREVIEW module if data comes from the CCDC (PRV_PCR[2] SOURCE = 0x0). This is a hardware defect in the PREVIEW module.	: Workaround 1: Do not use A-LAW decompression if data path is CCDC->PRV, but you can transfer RAW data from CCDC to PRV. Workaround 2: A-LAW decompression in the PREVIEW module can be used by changing the data path to CCDC- >memory->PRV instead of CCDC->PRV. 82 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.173 ISP: A-LAW Decompression Cannot be Performed in the PREVIEW Module
Cortex-A8	TI	OMAP-3530	: The ISP applies a SW reset (ISP_SYSCONFIG[1]:SOFT_RESET or CCP2_SYSCONFIG[1] SOFT_RESET or CSI2_SYSCONFIG[1] SOFT_RESET) immediately without checking if there is ongoing OCP traffic. Incomplete OCP transactions may be generated when the reset occurs in the middle of an L3 OCP burst. Incomplete OCP transactions stalls the L3 interconnect or cause a timeout condition.	: SW needs to first stop all ISP traffic before doing a SW reset. Idea is to block the OCP interface to avoid transfer are on going when reset is applied. To do that, MMU mapping error mechanism is used. MMU is programmed to generate an IRQ when an address which is unmapped in MMU table hit the MMU. Then all MMU tables are trashed so that IRQ will happen on the next OCP access (and access will block the OCP port). Once the IRQ happen, no transfer is on going by construction and reset can be applied. Following sequence should be applied: 1. Configure the MMU in manual mode so that it requests translation entries from the CPU by triggering an IRQ. 2. When an access arrives, the MMU will stall the OCP port on a clean OCP boundary. 3. The CPU doesn't provide the translation entry: that ensure that the OCP traffic has been stopped. 4. Wait 1000 cycles to make sure all responses have been returned. 5. Issue a SW reset. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 83 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.174 SW Reset Done While ISP Processing Is Ongoing Can Cause OCP Protocol Violations
Cortex-A8	TI	OMAP-3530	: The CCDCPRV_2_RSZ_OVF event is continuously triggered when the resizer is used in memory to memory mode. This event cannot be masked individually: all SBL events must be masked to prevent continue CPU interruption. That prevent proper monitoring of other SBL events (overflow conditions).	: Overflow events donât need to be monitored continuously. It is enough to monitor them once per frame to decide is a given frame can be used or if it must be dropped and eventually the ISP restarted. Monitoring should be done when then respective end of frame event has occurred (i.e. after a H3A-AF done check the overflow status of the H3A AF FIFO). 84 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.175 SBL_PCR [24]CCDCPRV_2_RSZ_OVF Goes High as Soon as RSZ_CNT[28]INPSRC Is Set to 1
Cortex-A8	TI	OMAP-3530	: The PRV data read from memory behaves incorrectly when it receives a end of frame pulse. This impacts use case where PRV processes a frame from memory while CCDC sends a new one to HIST or H3A. It is not possible to have concurrently Memory -> PRV and CCDC-> HIST/H3A. This issue will impact high quality still image capture with multiple and concurrent processing passes.	: Avoid that the CCDC frame ends while PRV is processing data (by synchronizing the modules). Or don't use the failing combination. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 85 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.176 PRV Pixel Data Read from Memory When CCDC Video Port Is Active
Cortex-A8	TI	OMAP-3530	: When an overflow occurs during the write of H3A module in H3A buffers in SDRAM, next write of H3A module does not start at the beginning of the buffer but where last overflow occurred. Some write on next buffers can happen and it corrupts next data. That typically happens when the system is heavily loaded and the Resizer is used in upscaling mode. In fact, the Resizer has the highest priority inside the ISP and H3A has a low priority class. H3A may not gain access to the OCP port when the Resizer outputs data at high rates. That causes FIFO overflows and potentially the buffer overrun.	: H3A FIFO overflows and not expected in normal utilization. As long as no overflows there's no issue. Workaround 1: â¢ Rework the use case to not have an overflow â¢ Increase H3A windows (Paxelsâ size) to decrease the bandwidth and avoid overflow Workaround 2: â¢ Double each H3A buffer size allocated in SDRAM to prevent bad writes on next buffers. 86 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.177 H3A Buffer Overrun
Cortex-A8	TI	OMAP-3530	: In some cases, user is not able to access DDR memory after warm-reset. This situation occurs while the warm-reset happens during a read access to DDR memory. In that particular condition, DDR memory does not respond to a corrupted read command due to the warm reset occurrence but SDRC is waiting for read completion. SDRC is not sensitive to the warm reset, but the interconnect is reset on the fly, thus causing a misalignment between SDRC logic, interconnect logic, and DDR memory state. Root cause description: A corrupted read transaction is issued to a closed row: (address0, bank0) instead of the expected read access, violating protocol. Failure signature: Once the failure occurs and system has restarted, memory content is not accessible. SDRC registers can be accessed successfully, until 1st access to memory location is performed. After 1st access to memory is done, SDRC is stuck.	: Steps to perform before a SW reset is triggered, if user needs to generate a SW reset and keep DDR memory content: 1. Set SDRC_POWER[SRFRONIDLEREQ]=1 //enable self-refresh on idle request 2. Set PRCM CM_ICLKEN1_CORE[SDRC]=0 //put SDRC in idle 3. Wait until PRCM CM_IDLEST1_CORE[SDRC]=1 //wait until SDRC goes to idle 4. Generate SW reset Steps to perform after warm reset occurs: if HW warm reset is the source, apply below steps before any accesses to SDRAM 1. Reset SMS and SDRC (a) set SMS_SYSCONFIG[1].SOFTRESET=0x1, wait until SMS_SYSSTATUS[0].RESETDONE = 0x1 (b) set SDRC_SYSCONFIG[1].SOFTRESET=0x1, wait until SDRC_SYSSTATUS[0].RESETDONE = 0x1 2. Re-initialize SMS, SDRC and memory (if SW warm reset is the source, SDRAM can be accessed reliably with no additional operation since user ensure above sequence before applying the warm reset). Note: DDR memory content is lost upon HW warm-reset (WDT, secure violation, â¦). SDRC_POWER[SRFRONRESET] value does not matter. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 87 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.178 Accesses to DDR Stall in SDRC After a Warm-reset
Cortex-A8	TI	OMAP-3530	: OCP Write transactions to FIFO register gets killed internally causing short packet transmission. The failure happens when the below events occur in the same cycle. â¢ RxPktRdy bit of the RX EP (with AutoClear enabled) is being cleared after DMA completes unloading FIFO. â¢ Data transactions happening in the USB bus. â¢ FIFO is being loaded by software through OCP slave. This results in short packet transmission or USB data corruption. Note: The MCU Reads to FIFO are not impacted by this bug.	: Use only DMA or only OCP Slave to load and unload FIFO. For better throughput good option will be to use DMA for up to 8EPs since the USB core has 8 DMA channels. For application with more than 8 EPs, assign only RX EPs to MCU and DMA can be assigned either RX or TX EPs. If MCU needs to load FIFO, it should check no DMA RX channel is active at that time. MCU should disable all the DMA RX channels and then proceed to loading FIFO. 88 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.180 High-Speed USBOTG Short Packet Issue
Cortex-A8	TI	OMAP-3530	: Below is the sequence performed to observe the issue: â¢ Perform Enumeration as a HOST. â¢ Perform USB Reset, Read the device descriptor, check for OTG defined specific test-VID/PID. â¢ Set test mode according the found PID (Program the test mode register in the USBOTGHS.) Now the DP-DM data lines are not in the expected states. Hence programming of TestMode J results in the Data-Lines permanently toggle between J and K state.	: Program the PHY OPMODE to 10 using the ulpi extended register access before programming the TESTMODE registers in HOST Mode. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 89 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.181 Standard OTG Compliance Electrical Tests for HOST Mode Will Fail
Cortex-A8	TI	OMAP-3530	: The GPMC supports 4- or 8-bit error correction BCH code. 4-bit error mode is using a wrong polynomial, as a result for this mode the GPMC will: â¢ On page write, generate incorrect ECC parity. â¢ On page read, generate an incorrect syndrome. This bug prevents having correct error location.	: No workaround for this issue. 90 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.183 GPMC Has Incorrect ECC Computation for 4-Bit BCH Mode
Cortex-A8	TI	OMAP-3530	: An issue in the USBHOST memory access arbiter prevents EHCI and OHCI Host Controllers from working simultaneously. As a result one cannot connect a HS and a FS USB devices on the USBHOST.	: No workaround exists for the generic use-case. For low-throughput requirement a SW arbitration scheme can be implemented. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 91 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.185 HS USB: ECHI and OHCI Controllers Cannot Work Concurrently
Cortex-A8	TI	OMAP-3530	: Once enabled (CM_FCLKEN3_CORE.EN_TS = 0x1,), the PRCM provide the 32Khz clock to the clock tree made of Thermal sensor+ MMC1/2/3. As soon as 32Khz clock is provided to MMC module then debouncing operation is started. Once debouncing is completed, then interface clock is ungated at module level and OCP clock is enabled internally to the MMC module (while MMC module is not used). This is creating unexpected over-consumption (100uA/MMC instance measured). The auto gating stays inefficient as long as module is not enabled.	: Each time thermal sensor is used, the MMC instances which are not used should be enabled then disabled (write CM_ICLKEN1_CORE.EN_MMCn = 0x1, CM_FCLKEN1_CORE.EN_MMCn = 0x1, wait until CM_IDLEST1_CORE.ST_MMCn = 0x0 then write CM_ICLKEN1_CORE.EN_MMCn = 0x0, CM_FCLKEN1_CORE.EN_MMCn = 0x0) to avoid over-consumption due to OCP logic being un-necessarily clocked. 92 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.186 MMC OCP Clock Not Gated When Thermal Sensor Is Used
Cortex-A8	TI	OMAP-3530	: Context save operation saves the pad configuration register contents to the scratch pad memory, that will be used at the context restore operation after OFF mode exit. Sometimes randomly after context save operation, CONTROL_PAD_CONF_ETK14 register is not saved into scratch pad memory. This register contains pad configuration information for 2 pads : etk_d14 and etk_d15. This is impacting only CONTROL_PAD_CONF_ETK14, all other padconf registers are saved and restored as expected. The failure signature is this register not saved: the scratch pad memory keep value saved during previous OFF transition. It is not a register content corruption. When waking-up from OFF mode, CONTROL_PAD_CONF_ETK14 is restored with old value (or non-initialized RAM value for first time). CaseA: Issue occurs randomly when CORE_L4_ICLK/4 (default) (CONTROL_PADCONF_OFF[2]. WKUPCTRLCLOCKDIV=0, default). Caused by the polling for context save completion. Issue does not occur if a delay is added just before SAVEDONE bit polling. CaseB: Issue occurs always When CORE_L4_ICLK/2 (CONTROL_PADCONF_OFF[2]. WKUPCTRLCLOCKDIV= 1). No workaround available. Root cause description: Case A: Failure occurs when OCP port is accessed for context save operation at same time as last save access of the SAR mechanism is performed. The OCP access is delaying the completion of the save of CONTROL_PAD_CONF_ETK14 register. In that case SAR never ended and SAVEDONE bit is wrongly returned. Case B: Wake-up control clock is CORE_L4_ICLK/2, SAR is wrongly completed before saving last context. For caseA and caseB, result is current CONTROL_PAD_CONF_ETK14 is not saved in scratchpad @0x480025F8 and previous value is kept in scratchpad.	: Wake-up control clock = CORE_L4_ICLK/4 AND Do not access any SCM registers before context save completed following recommended sequence below. 1. Ts = 2*(1/core_l4_iclk_freq)* X*200 (X=4 when CONTROL_PADCONF_OFF[2]. WKUPCTRLCLOCKDIV= 0) â¢ Example: 21.2us for 83MHz CORE_L4_ICLK 2. Enable padconf save operation: CONTROL_PADCONF_OFF[1]:STARTSAVE='1' 3. Wait for Ts Delay + 10% (additional step) 4. Poll SAVEDONEBIT='1' 5. Read padconf_OFF save for etk_d14/15 @0x480028A0 is equal to CONTROL_PADCONF_ETK_D14 @0x480025F8 (a) If padconf_OFF save equal CONTROL_PADCONF_ETK_D14 then Sequence is completed successfully (b) If padconf_OFF save NOT equal to CONTROL_ and Go back to step 1 (restart a new save) SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 93 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.187 Context Save Operation Randomly Failing for CONTROL_PAD_CONF_ETK14
Cortex-A8	TI	OMAP-3530	: I2C4_SCL low period is fixed by hardware then cannot be modified by software. Due to IO cell influence, I2C4_SCL AC timing is shorter than expected. As a result the standard AC timing (SCL minimum low period) in FS mode is not met. Please see OMAP3530 Data Manual for exact I2C4 AC timings.	: There is no workaround for I2C4. I2C4 is dedicated for SmartReflex and expected to connect with Power IC. Design review was done and concluded that there is no problem when OMAP is interfaced with TPS659xx. 94 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.188 I2C4 Does Not Meet I2C Standard AC Timing in FS Mode
Cortex-A8	TI	OMAP-3530	: Due to IO cell influence, I2C1 to 3 SCL low period can be shorter than expected. As a result, I2C AC timing (SCL minimum low period) in FS mode may not meet the timing configured by software.	: I2C1 to 3, SCL low period is programmable and proper adjustments to the SCLL/HSSCLL values can avoid the issue. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 95 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.189 I2C1 to 3 SCL Low Period Is Shorter in FS Mode
Cortex-A8	TI	OMAP-3530	: For High Secure devices, CONTROL_SEC_CTRL[0:1] are described as OCO (One time Configurable after power on reset Only). In current implementation, these bits are reset when device is coming back from OFF mode. No restoration is performed by the HW when coming back from OFF resulting to CONTROL_SEC_CTRL[0:1] are back to reset value after a WU from OFF mode. CONTROL_SEC_CTRL[0] is used to freeze secure watchdog count and default value for this bit is SWD NOT freezed. If the secure Watchdog was frozen before an OFF mode transition, the SWD will be re-enabled again unexpectedly when the device is waking-up from OFF mode. The Secure Watchdog will generate a warm reset when the counter expires. Note: Issue is systematic. Content of CONTROL_SEC_CTRL[0:1] is correctly maintained to their previous value during OFF period. The reset value is applied after WU when the isolation cells between power domains are released.	: CONTROL_SEC_CTRL[0:1] are not reliable and must not be used. The Secure Watchdog can be disabled by sw. Secure Watchdog is in the wakeup domain then it can be configured only once after power on reset and will kept disabled until next power on reset. Recommended procedure is to use PA or PPA call to SW SEC_SERVICE_SEC_WD_DISABLE() once after power on reset. Note: This WA is mandatory for HS devices not using Secure Watchdog functionality (goal it to keep the Secure Watchdog always disabled). No WA is needed in case Secure Watchdog is used in the system and reload of the Secure Watchdog is managed accordingly. This errata is not impacting Secure Watchdog capability. 96 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.190 Unexpected Warm Reset Assertion on HS Devices
Cortex-A8	TI	OMAP-3530	: Warm_reset is not asserted for same duration depending if it is a secure_Warm_reset (SSM, SWD) or a Global_Warm_reset (all other sources than secure). Global_warm_reset behavior is consistent with TRM description while Secure_Warm_reset has simplified logic (RSTTIME1 only is taken into account). Impact: Warm_reset released before VDDs are stabilized which can lead to unpredictable behavior (mainly MPU crash). However secure_Warm_reset during OFF should never happen except in case of attack during OFF on a HS and system hanging in that particular context looks acceptable. Expected behavior: Warm reset assertion duration is (OFFmodeSetupTime+RSTTIME1)*32Khz cycles. This formula is valid for all warm reset source except SWD reset and secure violation reset (SSM). For WD reset and secure violation reset (SSM) PRM_VOLTSETUP2[15:0]:OFFMODESETUPTIME is ignored and formula is: RSTTIME1*32KHz.	: No WA needed since secure_Warm_reset during OFF is not happening with a correct configuration. In any case RSTTIME1 can be enlarged to match VDD ramp-up requirement. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 97 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.191 Warm Reset Assertion Time When Warm Reset Happen During OFF Mode
Cortex-A8	TI	OMAP-3530	: In case of PER domain, due to a missed dependency if McBSP external clock is the only enabled permanent clock of PER PD, then CORE PD is prevented to transition to idle and therefore into OSWR. Such issue disappears if at least one other permanent clock of PER PD is enabled. Note: A permanent clock is a functional clock that can stay active while the corresponding entity managing it, CM, can go into idle. That is, a permanent clock can stay running while CM internal FSMs are clock-gated and even when CORE domain goes to retention. For WD reset and secure violation reset (SSM) PRM_VOLTSETUP2[15:0]:OFFMODESETUPTIME is ignored and formula is: RSTTIME1*32KHz.	: Enable a permanent clock in PER domain when McBSP external clock is used. To minimize power consumption impact, a 32KHz clock should be selected and enabled (fclken = â1â) without enabling the module (iclken = â0â). In such way, only small 32KHz clock tree contributes to power consumption increasing. 98 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.192 Missed Dependency With McBSP External Clock Avoid Transition to OSWR
Cortex-A8	TI	OMAP-3530	: MPU interrupt controller is not able to sort the input interrupt under idlereq pulse application. The sequence which creates this situation is: 1. When there is a pulse of idlereq (one or two clock cycles) applied after coming out of idle state. 2. There is change in input interrupt. Impact: The input interrupt can not be sorted until the internal OCP clock starts running. Interrupt to CPU will be delayed till the OCP clock starts running. The OCP clock can start running if Another Idlereq pulse greater than two clock cycles.	: Disabling auto-gating (INTCPS_SYSCONFIG[0]:AUTOIDLE=0) feature which will allow the change in idlereq to be sampled. This can be done right before executing the idle instruction to avoid power consumption impact. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 99 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.193 MPU Cannot Exit From Standby
Cortex-A8	TI	OMAP-3530	: There is an issue when sDMA channel is disabled on the fly, sDMA enters standby even through FIFO Drain is still in progress. SW WA is to put sDMA in NoStandby before a logical channel is disabled, then put it back to SmartStandby after the channel finishes FIFO draining. The issue only happens when FIFO draining is used and sDMA is configured SRC sync, BufferingEnabled and SmartStandby.	: Put sDMA in NoStandby before a logical channel is disabled, then put it back to SmartStandby right after the channel finishes FIFO draining. This issue can be avoided when one of the conditions (sDMA FIFO drain function enabling, SmartStandby, or On-the-fly channel disabling) is removed. 100 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.194 sDMA FIFO Draining Does Not Finish
Cortex-A8	TI	OMAP-3530	: After suspend sequence, USB3320 USB PHY goes correctly in low-power mode: â¢ DP Line goes High and DM line remains Low (J state) â¢ Rbias Voltage = 0 V Whereas OMAP HOST controller exit from suspend mode (while it is expected to keep in low power mode). OMAP Host state (exited from low power mode) is inconsistent with PHY state (low power mode) resulting in a lockup situation. Resuming the port has no effect as HOST controller has already exited from low-power mode. Root cause: Delay in assertion of DIR causes USBHOST ULPI interface to exit ULPI Low Power mode. USB3320 USB PHY assert DIR signal 3 clock cycle after STP signal is de-asserted.	: There is no workaround. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 101 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.195 HSUSB Interoperability Issue With SMSC USB3320 PHY
Cortex-A8	TI	OMAP-3530	: IVA is allowed to transition to sleep as soon as the last pending IRQ was handled and the clear command was sent. If latency is added to clear the interrupt source due to system activity, then IVA2 will transition to sleep before the interrupt source is cleared, meaning that the interrupt line is not de-asserted when IVA goes to sleep but will be released later on. In that particular condition (interrupt line active when IVA goes to sleep), then this interrupt line is no longer able to generate a WU event to the IVA. The IVA will ignore the activity on that line until it is woken-up by another source.	: Whenever IVA clears interrupt, IVA needs to read back the same register. This ensures the interrupt is always cleared before IDLE entry. This WA is implemented in TI DSP Bridge for GP-Timer and mailbox interrupt. Similar sequence needs to be applied by user in the ISR to all other possible interrupt sources. 102 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.196 IVA2 Does Not Wake-up After It Goes to IDLE While an Interrupt Line Is Not Cleared
Cortex-A8	TI	OMAP-3530	: The POWERVR SGX Bus interface contains an MMU address translation function which works on 4KB page allocations. The page table entries are setup and located in external DRAM memory and are fetched on demand as requests are made, there is a cache within the POWERVR SGX which keeps the most recently used entries. When an internal requester makes a request in virtual space the address is tested with the cached entries. If there is a hit then the physical high order address bits are returned and combined with the lower address bits of the virtual address bits to form the external physical address access. If there is a cache miss then the MMU must make an external fetch to memory to update the on chip cache, when this memory fetch completes the original memory access can proceed. The POWERVR SGX has 7 parallel memory request sources that feed into the MMU translation logic, so at any one time there can be a maximum of 7 parallel request sources that can all exhibit a page miss at the same time. The MMU contains a 3 bit counter to keep track of cache-miss requests (7 requesters). However there are scenarios where the request sources generate multiple cache miss-requests causing the 3 bit counter to overflow and miss service requests. Ultimately multiple passes through normal and miss phases together with various contributing memory latency can result in the counter not returning to zero and the MMU will lockup in the MMU miss phase. This will block all further accesses and the core will lock up. This could result in lock up of the POWERVR SGX image processing pipeline and may result in system hang.	: If the core is forced to an idle state (in terms of TA and 3D processing) before a cache invalidate is issued by setting , the occurrence of the lockup is substantially reduced. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 103 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.197 POWERVR SGXâ¢ : MMU Lockup on Multiple Page Miss
Cortex-A8	TI	OMAP-3530	: When the USB OTG is physically connected to a host with a cable, and a software cold reset is performed (PRM_RSTCTRL[2] RST_DPLL3), then the ULPI link with the PHY may get stuck. The PHY state machines go into an unknown state. Root cause: During the relock time of the DPLL3 following the cold reset, the system clock (or system clock divided by 2) is the L3 clock provided to all modules (including the USB OTG module). At the same moment the USB OTG HW automatically sends ULPI commands to the PHY. The conjunction of sending ULPI commands while the DPLL is not yet locked can potentially end up in timing violations in the PHY. The probability for this failure to occur is very low for the following reasons: â¢ A SW cold reset must be performed, which is not supposed to happen during run time. â¢ The device embedding OMAP needs to be connected with a cable to a host when the cold reset happens. â¢ Even if these conditions are met, experiments have shown that the timing violation will likely occur once every several thousand cold resets.	: Turning off USB_V1P8 LDO before issuing the software cold reset will eliminate the issue by turning off the ULPI clock at boot 104 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.198 HS USB OTG: ULPI LINK Possibly Sticks After DPLL3 SW Reset if USB Cable Stays Connected
Cortex-A8	TI	OMAP-3530	: When the USBHOST module is set to smart-standby mode, and it is ready to enter the standby state (i.e., all ports are supported and all attached devices are in suspend mode), it may incorrectly assert the Mstandby signal too early while there are ongoing residual OCP transactions. If this condition occurs, the internal state machine may go to an undefined state and the USB link may be stuck upon the next resume.	: The software should explicitly disable (pause) the USB HOST OCP initiator activity by disabling the schedules (USBCMD[5]ASE = 0, USBCMD[4]PSE=0) just before suspending the connected ports and restoring their state after the USBHOST has entered smart-standby state. Software workaround sequence: â¢ Read USBCMD register and save it; â¢ Clear USBCMD[5]ASE and USBCMD[4]PSE bits; â¢ Wait for the USBSTS[15]ASS and USBSTS[14]PSS bits to reflect this change; â¢ Suspend the connected ports; â¢ Wait for the ports suspend to take effect (~3ms); â¢ Restore the USBCMD register SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 105 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.199 USB Host EHCI May Stall When Exiting Smart-standby Mode
Cortex-A8	TI	OMAP-3530	: The USB host module is AHB native. Therefore, there is an AHB2OCP bridge allowing to connect it to the OCP L3 interconnect. Both AHB and OCP masters are able to generate single accesses (R/W) as well as bursts, depending on the configuration, as well as address ranges. Under some specific L3 latency conditions, when a USB host write is followed by a USB host single read (not burst read), then the read can be lost in the AHB/OCP bridge. When this happens, the internal state machines of the module go into an undefined state and the EHCI stalls; ongoing transfers are stopped, and new transfers cannot be scheduled anymore. This situation will only occur when both following conditions happen simultaneously: â¢ The module is performing a write followed by a single AHB read. â This can happen when processing control messages (Transfer descriptions in memory are updated (written) by the host when being processed and an 8-byte command is fetched by the host (2 single AHB reads)) â This can also happen for any OUT transfer (bulk, isochronous, interrupt) depending on data payload size and maximum Tx packet size parameter (TxMaxP) â¢ Congestion peaks occur in the system, generating back pressure at the host boundary with the interconnect â This can typically happen when high priority initiators like Display Subsystem and/or Camera are running heavy use cases in parallel of USB transfers. This issue does not impact IN transfers.	: Define ((payload size) modulo (MaxP size)) >=16 bytes. If ((payload size) modulo (MaxP size))< 16 bytes, then dummy data can be added to the buffer in order to achieve ((payload size)modulo (MaxP size)) >= 16 bytes. However this is not always possible, typically for control transfers, for which payload size is fixed to 8 bytes. In this case, it is only possible to reduce the failure occurrence by: â¢ removing un-necessary control commands (like get_device_state upon suspend exit) â¢ avoiding enumeration during peak-bandwidth demanding use cases Once the issue has occurred, the only way to recover will be to reset the USB host module and re-enumerate. 106 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.200 USB Host EHCI May Stall When Running High Peak-Bandwidth Demanding Use Cases
Cortex-A8	TI	OMAP-3530	: If the OTG module is in SmartStandby Mode ( OTG_SYSCONFIG.MIDLEMODE = 0x2) when an OTG DMA channel is enabled ( DMA_CNTL.DMA_EN) very near a USB SUSPEND condition, the MStandby signal may assert while there is residual OCP traffic initiated by the DMA. This illegal traffic causes the OTG DMA to stall.	: Ensure the module cannot enter standby mode while DMA transfers are active. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 107 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.201 USB OTG DMA May Stall When Entering Standby Mode
Cortex-A8	TI	OMAP-3530	: This occurs when the DPLL3 is in Manual Lock mode (CM_AUTOIDLE_PLL[AUTO_CORE_DPLL] = 0). Due to a wrong isolation cell on the dpll3clkon signal between CM and PRM (TIE-LOW implemented instead of ISO_LATCH), the DPLL3 Lock state signal is not taken into account by the PRM when CORE goes OSWR (Open Switch Retention) or to the OFF state. Consequently, the PRM will consider that the DPLL3 is not locked and the DPLL3 input clock will be stopped. Impacts: â¢ CORE OSWR mode: DPLL3 cannot be kept Locked when CORE OSWR state if DPLL3 is set in Manual Lock mode â¢ CORE OFF mode: Architecture will not support a transition to OFF mode if DPLL3 is set in Manual Lock mode	: CORE OSWR and CORE OFF mode: DPLL3 must be set to Automatic mode when CORE goes to CORE OSWR or OFF state. However, DPLL3 will need to relock after Wakeup. 108 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.202 DPLL3 in Manual Lock Mode Cannot be Used When CORE Goes to OSWR or OFF State
Cortex-A8	TI	OMAP-3530	: When internal SWAKEUP event occurs while CORE DPLL is going to bypass, PRCM may report that DPLL3 is locked when it is not. This is due to a timing path of an internal signal that is not fitting into one L3 clock cycle. In that case, PRCM DPLL control FSM deasserts the SDRC_IDLEREQ signal before DPLL3 Lock state is set. The consequence is that SDRC is released from IDLE with bypass clock (which is too low), instead of the locked frequency. DLL may or may not lock based on Process Voltage Temperature conditions. This issue is seen when DPLL3 Automatic mode is enabled: CM_AUTOIDLE_PLL[AUTO_CORE_DPLL] = 1 or = 5.	: Case 1: Initialization (Device boot up) â¢ Disable DPLL3 automatic mode by default (CM_AUTOIDLE_PLL[AUTO_CORE_DPLL] = 0) â¢ This issue will not be faced since DPLL3 is always locked Case 2: Before CORE Voltage Domain Sleep Trasition to RETENTION or OFF mode After Disabling Smart Reflex: â¢ Reduce DPLL3 M2 Frequency to get L3 running at OPP2 Frequency (by changing M2 Divider value). This is increasing the period duration of one L3 clock cycle. â¢ Increase CORE Voltage to 1.2V. This is reducing the timing duration of the critical path signal, which will now fit to one L3 clock cycle. â¢ Enable DPLL3 Automatic Stop mode. This will ensure proper transition to RETENTION or OFF mode. In summary, L3 = OPP2 + VDD2 = 1.2V combination must be used: â¢ If OPP3 (L3=166 MHz, VDD2=1.15V): â Lower the frequency to 83MHz â Increase CORE Voltage to 1.2V â Enable DPLL3 Automatic Stop mode â¢ If OPP2 ( L3=83MHz, VDD2=1.05V): â Keep the frequency as it is (83MHz) â Increase CORE Voltage to 1.2V â Enable DPLL3 Automatic Stop mode Case 3: After CORE Voltage Domain Wakeup Transition from RETENTION or OFF mode Before Enabling Smart Reflex: â¢ Disable DPLL3 Automatic mode â¢ Restore previous DPLL3 M2 Frequency and CORE Voltage values Notes for all cases: â¢ Case 2 and Case 3 must be executed if there is a Voltage Domain transition. These cases cannot be executed if only a Power Domain transition is targeted. â¢ Due to another bug (See ), the following two scenarios must to taken into account: â Target state is OSWR and voltage transitioning is happening: Case 2 and Case 3 can be applied. â Target state is OSWR and voltage transitioning does not happen: Case 2 and Case 3 cannot be applied; Target state must be changed from OSWR to CSWR. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 109 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.203 PRCM DPLL Control FSM Removes SDRC_IDLEREQ Before DPLL3 Locks
Cortex-A8	TI	OMAP-3530	: After Peripheral Power Domain (PER-PD) is woken up from the OFF/OSWR state while Core Power Domain (CORE-PD) is kept active, write or read access to some internal memory (UART3 FIFO and sidetone memory inside McBSP2/3) does not work correctly. This leads to a corruption of transmit or receive data of UART3, or output from McBSP2/3 sidetone modules. Other logics behave properly. The cause of the issue is that memory control logic of UART3 FIFO and McBSP2/3 sidetone memory are not reset and remain uninitialized when PER-PD is woken up from OFF or OSWR state. The logics are properly reset when CORE-PD is coming back from OFF/OSWR state. They also get reset by warm-reset, but are not reset by a module level software reset.	: Do not allow PER-PD to go to OSWR/OFF as long as Core-PD is not switched to OFF/OSWR. When both CORE-PD and PER-PD goes into OSWR/OFF, PER-PD should be brought to active before CORE-PD. This can be done by configuring a wakeup dependency between PER-PD and WKUP-PD (PM_WKDEP_PER.EN_WKUP = 0x1) so that CORE-PD and PER-PD will wake up at the same time. Even with the above configuration, there is a small possibility that on transition to OFF mode, a wakeup event is generated at a time when PER-PD entered OFF/OSWR but CORE-PD is not. This timing window is very small (about 8 Âµs at most), but to ensure the correct operation in this corner case, this procedure is recommended. After waking up from CORE OFF/OSWR configuration: â¢ Check this condition to see if the previous Core-PD transition to OFF/OSWR was aborted (thus not actually reached OFF/OSWR state) PM_PREPWSTST_PER[1:0].LASTPOWERSTATEENTERED = 0x0 (PER domain was previously OFF) PM_PREPWSTST_CORE[1:0].LASTPOWERSTATEENTERED = 0x3 ( CORE domain was previously ON) â¢ If this corner case is detected, check the UART3 FIFO and/or McBSP2/3 sidetone functionally using their internal loopback features. For UART3 the internal loop back mode can be enabled by MCR_REG[4].LOOPBACK_EN For McBSP2/3 sidetone feature, digital loop back can be used. Two different words should be used (typically 0x55.. and 0xAA..) in the loop back test to confirm correct behaviour â¢ If error is detected by the above loopback tests, execute one of recovery sequences: â Generate warm-reset â Put the Core-PD and PER-PD to OSWR/OFF 110 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.204 PER Domain Reset Issue After Domain-OFF/OSWR Wakeup
Cortex-A8	TI	OMAP-3530	: When using McBSP in Slave mode and doing Power management (McBSP going to IDLE state), if the external CLKX clock is not provided by external peripheral component, McBSP cannot exit IDLE state. The consequence is that McBSP registers cannot be accessed anymore (except MCBSPLP_STATUS_REG[CLKMUXSTATUS] register). There is similar limitation on the CLKR when module is configured as a receiver.	: These workarounds are still valid by replacing CLKX by CLKR. There are three possible workarounds to avoid this situation. Workaround 1: Don't use the power management features of McBSP (SIDLEMODE field in MCBSPLP_SYSCONFIG_REG register set to NO-IDLE all the time). The impact of this workaround is that as McBSP transition to IDLE is avoided (SIDLEMODE=NO-IDLE), PRCM cannot transition the chip to Low Power mode. Workaround 2: Keep external CLKX clock always running during application (for example during an Audio Playback): â¢ At the beginning of the application (e.g. Audio Playback), keep CLKX always running by setting the external peripheral component register accordingly â¢ At the end of the application (e.g. Audio Playback), unload McBSP2 drivers and set XRST bit from SPCR2 to 0. Then stop CLKX in software (by setting external peripheral component register accordingly). The impact of this workaround is that the serial clock is kept active during whole application (e.g. Audio Playback). Workaround 3: If SIDLEMODE is used (at some value other than NO-IDLE), ensure McBSP registers can be accessed by reading/polling the MCBSPLP_STATUS_REG[CLKMUXSTATUS] register. If registers can not be accessed (CLKMUXSTATUS=1), take corrective actions in software, such as (re)enabling CLKX. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 111 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.205 McBSP Used in Slave Mode Can Create a Dead Lock Situation When Doing Power Management
Cortex-A8	TI	OMAP-3530	: The state of SGX FCLK is not considered in a DPLL3 bypass condition, so DPLL3 can be put in bypass mode even if SGX FCLK is still active, causing an unexpected SGX FCLK frequency drop. There is no issue when the SGX FCLK source is DPLL4 (Selected through CM_CLKSEL_SGX).	: There are two possible workarounds. The recommendation is to use Workaround #1, as it is more efficient in term of power consumption. Workaround #1: Clear the CM_AUTOIDLE_PLL[AUTO_CORE_DPLL] bit (that is, Auto Control Disabled) when SGX FCLK is enabled (CM_FCLKEN_SGX[EN_SGX]='1') and set it back to the expected automatic PRCM control configuration when SGX FCLK is disabled. With this workaround, L3 gating will still be possible while DPLL3 is kept in locked state. Workaround #2: DPLL3 can be forced to stay in a locked state by enabling L3 interface clock for SGX (CM_ICLKEN_SGX[EN_SGX]='1'). However, this will be less efficient in terms of power consumption as the L3 clock tree is enabled. 112 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.206 DPLL3 Bypass Condition Does Not Consider State of SGX FCLK
Cortex-A8	TI	OMAP-3530	: In SCCB mode, if the XRDY/RRDY are not served during the address phase, the module starts to hold the bus by keeping SCL low (FIFO empty or full). Then, after serving these interrupts, the module does not continue the current transfer and blocks in this state. This bug appears only in applications where the module is used in SCCB mode. The bug is not appearing at all if interrupts are served before the address phase starts quickly enough to avoid entering this context.	: None. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 113 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.207 I2C: In SCCB Mode, Under Specific Conditions, the Module Might Hold the Bus by Keeping SCL Low
Cortex-A8	TI	OMAP-3530	: Expected behavior: The scenario occurs when the IDLEREQ is sent after serving an interrupt/DMA and system clock period is higher than ocp clock period (at least two times higher) and prescaler value > 4 (internal clock is sysclk/(PSC+1)). If there is no other interrupt or DMA request, the module enters the IDLE state and exits this idle with a wakeup generated from some event. Observed behavior: A spurious wakeup is asserted and maintained while no IRQ/DMA request is generated once the module is brought out of idle.	: If sysclk period and ocpclk period values are close, the prescaler PSC value of the I2C_PSC register should be programmed to any value less than or equal to 4. For higher values, bug may happen. There is no issue for prescaler value PSC = 1 (i.e. High Speed). 114 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.208 I2C: Spurious Wakeup Event When sysclk Period is Higher Than ocpclk Period
Cortex-A8	TI	OMAP-3530	: Expected behavior: Before starting a new transfer from another I2C device, one byte of data is written to TX FIFO. The module is addressed on a 10 bit address as a Slave transmitter (one of his addresses) and I2C clock blocking is enabled. After a repeated start condition SBLOCK is activated again for the second part of the address. Observed behavior: Given the addressing and SBLOCK conditions defined above, if the data put in FIFO has its MSB 0, the module makes a glitch on the SDA bus on the eighth bit (SDA is set to 0 for a short period) which can be interpreted as an illegal start/stop condition.	: The scenario described is a corner case and it may very seldom happen in applications. To avoid the situation, before a transfer is started on the I2C bus, all interrupts should have been cleared (part of the guideline given in the spec), or when I2C is a transmitter, no data should be placed in the FIFO without receiving the request to do so from the slave. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 115 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.209 I2C: Wrong Behavior When a Data With MSB 0 is Put in the FIFO Before a Ttansfer with SBLOCK is Started
Cortex-A8	TI	OMAP-3530	: Expected behavior: After a transfer on the I2C bus, where the module lost the arbitration during the address phase, a new transfer as a Master is programmed in I2C_CON by setting MST bit to 1, having the start bit STT in the I2C_CON register still unset. The STT bit can be set after a significant delay to point to the moment in which the transfer starts on the I2C bus. The module should only start the transfer on I2C after setting this STT start bit in I2C_CON. Observed behavior: The module starts the transfer on I2C before setting STT and immediately after setting the MST bit in the I2C_CON to 1.	: The MST and STT bits inside I2C_CON should be set to 1 at the same moment (avoid setting the MST to 1 while STT = 0). 116 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.1.1.210 I2C: After an Arbitration Lost the Module Starts Incorrectly the Next Transfer
Cortex-A8	TI	OMAP-3530	: If a 4-cycle instruction that can saturate is writing back its result in the same cycle as a 2-cycle instruction that can saturate, only the saturation condition for the 4-cycle instruction is recorded in the CSR.SAT bit and SSR.M1 or SSR.M2 control registers. In other words, if the 4-cycle instruction does not saturate, but the 2-cycle instruction does saturate, the fact that the 2-cycle instruction saturated is lost and is not recorded in the CSR.SAT and SSR.Mx bit-fields. The list of 4-cycle instructions that can mask the 2-cycle saturation condition is: â¢ SMPY32 â¢ CMPYR â¢ CMPYR1 â¢ DDOTPH2R â¢ DDOTPL2R The list of 2 cycle instructions that can set the saturation flags are: â¢ SMPY â¢ SMPYLH â¢ SMPYHL â¢ SSHVL â¢ SSHVR Note that the 2 cycle instruction must be started 2 cycles after the 4 cycle instruction in order for the conflict situation to occur. For example: CMPYR .M1 A0,A1,A2 NOP SSHVL .M1 A8,A9,A10 If the CMPYR instruction does not saturate, the saturation status of the SSHVL instruction will not be recorded. Note also that the 2 cycle and 4 cycle instructions must be issued on the same .M unit for this interference to occur. If the SSHVL instruction were on the .M2 unit, the saturation bit would be recorded correctly.	: Workaround is to make sure that no code has scheduled any of the instructions from the 4-cycle list to write back in the same cycle as the instructions in the 2-cycle list. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 117 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.1.1.211 4-cycle Saturating .M Unit Instructions May Mask 2-cycle Saturating. M Unit Instruction Saturation Bit Update
Cortex-A8	TI	OMAP-3530	: CASE A: When entering OFF_MODE, if a wake-interrupt is received in a specific window (3 sysClk cycles wide), a cold reset could be generated. CASE B: When device goes to OFF mode without hitting caseA already described, a cold reset could be generated while device is waking-up (precisely during Efuse sensing). The timing of the WU event is not playing any role on the occurrence of the issue (No case-B window). Case-B issue is related only with the WU from OFF sequence which is a pure HW sequence. During wake-up from OFF-MODE, PRCM (PRM logic) is not protected from efuse bits toggling during EFUSE-bit shifting. Exposed window duration: â¢ 600 last bits of the fuse chain in CASE B â¢ Entire efuse chain (~2500 short sensitive window) The failure depends on Fuse content. Any transition '1-'to-'0' or "0'-to-'1' during efuse shifting can cause a cold reset then a downgrade of OMAP35xx depending on value detected during the shifting. The failure also depends on SysClk frequency. The sysClk frequency defines what bits of the fuse chain will be detected.	: There is no workaround for CASE A, but probability of occurrence is very low because the interrupt should happen during a 3-system clock cycles window while the system is transitioning to OFF mode. The signature of the occurrence of CASE A is OMAP3530/25 rebooting in 3515/03 mode. This can be detected through the CM_CLKSEL_SGX register which becomes read only. In this case, the system can only recover through a power on reset. The workaround for case B consists of enabling the TLL Save and Restore mechanism: set PM_PWSTCRTL_CORE:SAVEANDRESTORE to 0x1. Setting this bit is sufficient; there is no need to enable OMAP3530 TLL or USB module clocks either. Enabling this bit will change the HW sequence of events executed upon wake up from OFF mode, thus avoiding the condition for this issue. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 121 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated Silicon Revision 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 4 Silicon Revision 3.0 Usage Notes and Known Design Exceptions to Functional Specifications 4.1 Usage Notes for Silicon Revision 3.0 Usage Notes highlight and describe particular situations where the device's behavior may not match presumed or documented behavior. This may include behaviors that affect device performance or functional correctness. These notes will be incorporated into future documentation updates for the device (such as the device-specific data manual), and the behaviors they describe will not be altered in future silicon revisions. Note: The peripherals supported on the various OMAP35x Application Processors are different. The user should only refer to usage notes and advisories pertaining to features supported on the specific device. For a complete list of the supported features of the OMAP35x Application Processors, see the device-specific data manuals. Some silicon revision 3.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 2.1, Usage Notes for Silicon Revision 3.1. 4.1.1 Display Controller Subsystem (DSS): Limitations Exist When Generating Horizontal and Vertical Timings On OMAP35x Applications Processor silicon revisions 3.0 and earlier, the display controller registers that control horizontal and vertical output timings (HBP, HFP, HSW, etc.) are not flexible enough to generate waveforms/timings required by some video display standards such as those of the Video Electronics Standards Association (VESA). Table 6 below describes which register fields are used to control the vertical and horizontal output timings, the current register field widths, and the required register field widths. Table 6. Display Controller Horizontal and Vertical Timing Control Register Fields Field Name DSS Register Field Field Width (Bits) Required Width (Bits) HBP DISPC_TIMING_H[27:20] 8 12 HFP DISPC_TIMING_H[15:8] 8 12 HSW DISPC_TIMING_H[5:0] 6 8 VPB DISPC_TIMING_V[27:20] 8 12 VFP DISPC_TIMING_V[15:8] 8 12 VSW DISPC_TIMING_V[5:0] 6 8 4.1.2 Camera ISP: IIR Filters in Auto Focus (AF) Engine Should Only Be Used for Auto-Focus On OMAP35x Applications Processor silicon revisions 3.0 and earlier, the AF engine IIR filters should only be used for auto-focus purposes. Any other use for the IIR filters is not supported. 4.1.3 High-Speed USB Host Subsystem: Some Limitations Exist When Connecting to External Devices On OMAP35x Applications Processor silicon revisions 3.0 and earlier, as shown in Figure 11, the OMAP35x device includes a high-speed universal serial bus (USB) OTG controller and a high-speed USB host subsystem. Note: USB Port 3 is not available on CUS package. 122 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com Silicon Revision 3.0 Usage Notes and Known Design Exceptions to Functional Specifications Device High-speed USB OTG controller Port0 Port1 High-speed USB host subsystem Port2 Port3 Figure 11. OMAP35x USB Modules The high-speed USB OTG controller supports a single USB port which uses a UTMI low-pin interface (ULPI) to connect to an off-chip transceiver (12-pin/8-bit single-data rate mode). As shown in Figure 12, USB Port 0 can be connected to the USB 2.0 PHY included in OMAP35x companion chips, e.g. TPS69xxx. Alternatively, USB Port 0 can be connected to discrete USB 2.0 PHYs which include a UTMI low-pin interface (ULPI) and are capable if sourcing an output clock. OMAP 12/8-pin ULPI (PHY Outputs Clock) USB PHY USB OTG Port0 Companion OTGController Chip OMAP 12/8-pin ULPI (PHY Outputs Clock) USB OTG OTG/HS/ Port0 FS/LS Discrete PHY OTGController Figure 12. Typical Uses for USB Port 0 As shown in Figure 13, the high-speed universal serial bus (USB) host subsystem supports up to three USB ports, each one of which can owned by one of two controllers: â¢ The EHCI controller, based on the Enhanced Host Controller Interface (EHCI) specification for USB Release 1.0, is in charge of high-speed traffic (480M bit/s) over either a UTMI port or a UTMI low-pin interface (ULPI) port. â¢ The OHCI controller, based on the Open Host Controller Interface (OHCI) specification for USB Release 1.0a, is in charge of full-speed/low-speed traffic (12/1.5M bit/s, respectively) over a serial interface. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 123 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated Silicon Revision 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com Both the OHCI and EHCI controllers can operate in parallel. Each of the three USB ports is owned by exactly one of the controllers at any time. Also, when a controller uses the UTMI port, the USB TLL block converts that port to a ULPI transceiver-less link logic (TLL) format. Please note the following functional limitations when using the high-speed USB host subsystem: â¢ On silicon revision 3.0 and earlier, if one port is configured in the ULPI mode, then all other ports must use the same configuration. Therefore, the ports must be configured high-speed mode or full-speed/low-speed mode. â¢ USB Port 3 cannot operate in ULPI mode; it can only operate in serial or ULPI TLL mode. Furthermore, USB Port 3 is not available in the CUS package. Device High-Speed USB Host subsystem USBTLL L4 Interface clock USBTLL_ICLK Functional clock USBTLL_FCLK High-speed USB Host controller PRCM L3 master interface US U B S H B O H S O T S _MICLK clock HS USB Host I/F pins L4 slave interface mu USBHOST_SICLK T clock Channel 2 ltip o mm3_xxx UTMI p ULPI TLL Functional clock le le US U B S H B O H S O T S _FCLK1 3 ve xin Serial Serial l hsusb3_tll_xxx g Functional clock USBHOST_FCLK2 OHCI controller Channel 1 mu mm2_xxx UTMI ULPI TLL T ltip op OHCI_IRQ Serial le Serial le hsusb2_tll_xxx 2 ve xin l g hsusb2_xxx ULPI ULPI MPU Interrupt requests EHCI subsystem controller INTC Channel 0 mu mm1_xxx UTMI ULPI TLL T ltip op Serial le le EHCI_IRQ Serial hsusb1_tll_xxx 1 ve xin L3 l g ULPI ULPI hsusb1_xxx interconnect L4-Core TLL_IRQ interconnect usb-007 Figure 13. High-Speed USB Host Subsystem Highlight As shown in Figure 14, USB Port 1 and Port 2 can be used to connect to external high-speed PHYs which include a ULPI port. However, in this case, the external USB PHY must be able to accept a source clock generated by the OMAP high-speed USB controller. Also, in this usage model the USB ports cannot support full-speed and low-speed operation. Therefore, using this approach, USB Port 1 and Port 2 cannot provide a fully compliant USB 2.0 Type-A receptacle; a high-speed USB hub would be required in this case; please see Figure 15. Note: USB Port 3 does not support ULPI mode. USB Port 3 is not available on CUS package. 124 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com Silicon Revision 3.0 Usage Notes and Known Design Exceptions to Functional Specifications OMAP ULPI HS 12-pin ULPI (A) (OMAP Outputs Clock) PHY Port1 12-pin ULPI ULPI HS (OMAP Outputs Clock) (A) Port2 PHY Not Available HSHostController(EHCI) Port3 A. USB port 3 does not support ULPI mode. Also, USB port 3 not available on CUS package. Figure 14. Connecting to High-Speed PHYs Using USB Ports OMAP ULPI HS HS/FS/LS 12-pin ULPI PHY Device or (OMAP Outputs Clock) Port1 Receptacle HS/FS/LS 12-pin ULPI Not Used Device or (OMAP Outputs Clock) Port2 HS USB Receptacle HUB HS/FS/LS Not Available Device or Port3 Receptacle A. USB port 3 does not support ULPI mode. Also, USB port 3 not available on CUS package. Figure 15. Connecting to a High-Speed USB Hub SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 125 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated Silicon Revision 3.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 4.2 Silicon Revision 3.0 Known Design Exceptions to Functional Specifications Some silicon revision 3.0 applicable advisories have been found on a later silicon revision. For more details, see Section 3.2, Silicon Revision 3.1 Known Design Exceptions to Functional Specifications. Table 7. Silicon Revision 3.0 Advisory List Title ...................................................................................................................................... Page	3.1.1.165 Unexpected Cold-Reset Is Generated When Device Is Coming Back from OFF Mode
Cortex-A8	TI	OMAP-3530	Due to a DPLL integration issue, leakage is detected on VDDS_DPLL_DLL (MPU/IVA) and VDDS_DPLL_PER (per DPLLs) rails when DPLL is placed in low-power stop mode. This issue is due to DPLL going to fast relock mode instead of going to low-power stop mode. Notes: â¢ Device OFF mode and CORE DPLL are not impacted.	There is currently no workaround in place, but under evaluation, this section will be updated. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 127 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.0.1.137 DPLL Leakage When Placed in Low-Power Stop Mode
Cortex-A8	TI	OMAP-3530	When Vpp is increased to 2.2V to program the CPFROM bits, the in-rush peak current observed on the Vpp line can slew up to more than 250mA in the first ~400ms. Note: This is a preliminary measurement, and additional characterization is in progress. This issue will only affect OEMs using CPFROM bits, and confirmation regarding whether the Vpp supply rail from PMIC can support the in-rush current transient is pending.	There is no workaround for this issue. 128 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	3.0.1.138 CPFROM In-Rush Current Issue
Cortex-A8	TI	OMAP-3530	When OMAP35x goes to OFF mode, a wakeup event can be missed. While transitioning to OFF mode, a window existing between GPIO (in peripheral domain) going to OFF and the IO wakeup chain is activated: â¢ For a 19.2MHz system clock, this window is 4Îs, in which a wakeup event can be missed â¢ Impacts all device GPIOs except for GPIOs from GPIO block 1: GPIO_[31:0] This does not impact a wakeup event connected to the wakeup domain.	Use a GPIO from block 1 to trigger an OFF Wakeup event. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 129 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	3.0.1.151 Missed Wake-up Event When Going Into OFF Mode
Cortex-A8	TI	OMAP-3530	The USB TLL Save-And-Restore (SAR) + USBHOST TLL locks up system during CORE_OFF and suspend to RAM. A hardware issue in the TLL block causes a deadlock during the automatic hardware context saving of the TLL block. On second hardware SAR, the save mechanism does not function as expected; this is causes a lock-up in the SAR. This issue impacts the OHCI TLL, PHY, and EHCI TLL modes. This does not impact HS PHY mode.	There is no workaround for EHCI mode (HS TLL). OHCI (FS TLL or FS PHY modes) : In OHCI mode, software Context / Restore is functional and will be integrated as part of mainline releases. This is a full workaround for the hardware issue. 130 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications 5 Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 2.0 of the OMAP35x Applications Processor. Note: The peripherals supported on the various OMAP35x Applications Processor devices are different. The user should only refer to usage notes and advisories pertaining to features supported on the specific device. For a complete list of the supported features of the OMAP35x Applications Processor, see the device-specific data manuals. 5.1 Usage Notes for Silicon Revision 2.1 SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 131 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated Silicon Revision 2.1 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 5.2 Silicon Revision 2.1 Known Design Exceptions to Functional Specifications Some silicon revision 2.1 applicable advisories have been found on a later silicon revision. For more details, see Section 4.2, Silicon Revision 3.0 Known Design Exceptions to Functional Specifications. Table 8. Silicon Revision 2.1 Advisory List Title ...................................................................................................................................... Page	3.0.1.152 USB TLL Save-and-Restore Issue
Cortex-A8	TI	OMAP-3530	Note: This issue only applies in cases where the sys_clkout1 pin of the OMAP35x device is required during boot. The SYS_BOOT[6] pin is not accessible via the register map, therefore the ROM code cannot change the pad configuration according to the XTAL mode. Furthermore, the clock is never provided to the SYS_CLKOUT1 pin and not propagated to the companion chip, prohibiting the ROM code to accurately program the companion chip for peripheral boot (USB or MMC boot).	No workaround. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 133 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	2.1.1.120 Peripheral Boot Issue When Using External Crystal
Cortex-A8	TI	OMAP-3530	The length of the root key hash has been extended on the OMAP35x architecture. During peripheral booting the ROM Code sends out an ASIC ID which - among other information - contains also the root key hash. The length of this hash field in the ASIC ID is correctly set to 20bytes but the 4 last bytes are all zero. There is no known limitation as the root key hash field inside the ASIC ID is not necessary for peripheral booting.	There is no workaround for this issue. 134 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	2.1.1.122 ROM Code: Incomplete ASIC ID
Cortex-A8	TI	OMAP-3530	The context restore procedure will fail if the On-Chip Memory (OCM) RAM is OFF after wakeup. The OCM RAM will be off after wakeup if bits MEM1ONSTATE and MEM2ONSTATE in the PM_PWRSTCTRL_CORE register are set to OFF (0x0) before going to sleep.	The application software must make sure that the bits MEM1ONSTATE and MEM2ONSTATE are set to ON (0x3) or RETENTION (0x1) before putting the CORE domain to sleep. There is no need to set the MEMORYCHANGE bit in the same register. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 135 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	2.1.1.123 ROM Code: Context Restore Failure if OCM RAM Is OFF After Wakeup
Cortex-A8	TI	OMAP-3530	The multiple block read transfer, in polling and interrupt mode, does not work correctly on MMC1 and MMC2. A Data CRC error is generated due to some corrupted data, when the read buffer (two 512-bytes portions) of the MMC controller is full. If the buffer is not free, the MMC controller stops the clock and the card stops to send data to . The clock will be re-enabled only when one portion will be emptied and then the transfer will restart. The output clock and data enable are generated on same internal clock edge. The data enable signal must be re-asserted before the first clock edge of the input clock (feedback clock) in order to sample the data correctly. Hold buffers have been added on data enable signal that makes data enable arrival after the first clock edge. It leads that the first data is not sampled on clock restart. This issue depends on the pattern written and the output data width (1-, 4- or 8-bits mode). For example, Pattern written: 0x2800, Pattern read: 0x0801. No data are read by the MPU into the read buffer in order to fill the 2 portions. The data enable signal is de-asserted and the output clock is disabled. â¢ In 1-bit mode, the failure occurs on the second data of third block when the MPU starts to read the data. â¢ In 4-bits mode, the failure occurs on the third data of third block when the MPU starts to read the data. This issue is related to the integration of the IP and is not a functional bug. Therefore, MMC3 is not impacted.	There is no workaround for this issue. 136 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	2.1.1.128 MMC: Multiple Block Read Operation Issue
Cortex-A8	TI	OMAP-3530	There is no functional impact, but there is leakage current of approximately 20mA from SIM_VDDS to VDDS due to an isolation issue.	There is no workaround for this issue. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 137 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	2.1.1.135 Isolation Issue Between SIM_VDDS and VDDS
Cortex-A8	TI	OMAP-3530	The CPU revision code register should return the same value for both ES2.0 and ES2.1 samples. However, the version of the cortexA8 core is incorrectly read. The results of the read are shown in Table 9. Table 9. CPU Revision Code Register Readings EXPECTED READING ACTUAL READING ES2.0 Silicon ID 0x411fc081- r1p1 0x411fc081- r1p1 ES2.1 Silicon ID 0x411fc081- r1p1 + bug fixes 0x411fc082 - r1p2	There is no workaround for this issue. 138 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	2.1.1.141 CPU Revision Code Register Does Not Return Same Value for ES2.0 and ES2.1 Samples
Cortex-A8	TI	OMAP-3530	By default, the ROM Code is able to boot from MMC1, configured in 1 bit mode interface. In case the booting image contains a Configuration Header which configures a CHMMCSD section, the MMC1 interface can be configured in 8 bits mode. So the ROM Code is supposed to be able to switch from 1bit bus width to 8 bits bus width at the booting phase on MMC. The DAT4-DAT7 pins of MMC1 are powered by the MMC1a power supply. The ROM Code does not turn ON this power supply. Moreover, pad interface 3V power supply voltage stability is not checked and can lead to booting instability. Configuring the MMC1 interface at boot-time in 8-bit mode with a configuration header should be avoided. Functionality seems OK but the absence of power supply may cause an untimely ageing of IO pads.	There is no workaround. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 139 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications www.ti.com 6 Silicon Revision 2.0 Usage Notes and Known Design Exceptions to Functional Specifications This section describes the usage notes and advisories that apply to silicon revision 2.0 of the OMAP35x Applications Processor. Note: The peripherals supported on the various OMAP35x Applications Processor devices are different. The user should only refer to usage notes and advisories pertaining to features supported on the specific device. For a complete list of the supported features of the OMAP35x Applications Processor, see the device-specific data manuals. 6.1 Usage Notes for Silicon Revision 2.0 Silicon revision 2.0 applicable usage notes have been found on a later silicon revision. For more details, see Section 5.1, Usage Notes for Silicon Revision 2.1. 6.2 Silicon Revision 2.0 Known Design Exceptions to Functional Specifications Some silicon revision 2.0 applicable advisories have been found on a later silicon revision. For more details, see Section 5.2, Silicon Revision 2.1 Known Design Exceptions to Functional Specifications. Table 10. Silicon Revision 2.0 Advisory List Title ...................................................................................................................................... Page	2.1.1.145 ROM Code: MMC1 Interface Configured in 8 Bits Mode Is Not Recommended at Boot Time.
Cortex-A8	TI	OMAP-3530	The PRCM fails to release the MPU reset after a number of Global Warm Reset iterations. This failure is random and can occur on any device type at any SYS_CLK frequency (i.e., 12 MHz, 19.2 MHz, 26 MHz, etc). However, the issue only occurs when DPLL3 (CORE DPLL) and DPLL4 (PER DPLL) are locked prior to generating a global software warm reset. This issue is not seen when DPLL3 is configured in bypass or locked mode and DPLL4 is in low-power stop mode before the Global Warm Reset has been applied. Note: This issue affects all sources of Global Warm Reset (i.e,. global software warm reset, watchdog timer reset, external global warm reset, IcePick warm reset, etc.).	Avoid Global software Warm Reset assertion or any source of Global Warm Reset while both DPLL3 and DPLL4 are locked. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 143 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	2.0.1.80 Device Stalls After a Warm Reset
Cortex-A8	TI	OMAP-3530	There is an incorrect signal connection to control the SDIv2 analog complex IO. As a result, FlatLink3G mode is not functional. Other serial modes (CMADS 1000, 2000) are not impacted.	There is no workaround for this issue. 144 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	2.0.1.82 SDI: Incorrect Control of SDI Analog Complex IO
Cortex-A8	TI	OMAP-3530	After any Warm Reset, the chip will branch to secure ROM Code. Since the secure ROM code does not exist on GP devices, the MPU will remain stuck in a loop. No debug can be performed. The ROM code does not correctly manage the different resets. For a Warm Reset, the ROM code interprets the reset as a wake-up reset. The ROM code then tries to proceed to the context restore, interpreting data stored in scratchpad memory. If the data stored in scratchpad contains rubbish, the ROM code will attempt to restore them.	The scratchpad memory from physical address 0x48002910 to 0x480029FF must be cleared by the application after a Power On Reset. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 145 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	2.0.1.104 ROM Code: MPU Is Stuck in Secure Mode After Warm Reset on GP Device
Cortex-A8	TI	OMAP-3530	The VBUS detection timeout in ROM Code is too short (1ms) compared to the T2 debouncing time (30ms) which prevents the start of USB booting after board Power-On Reset. The USB boot functions correctly on subsequent nRESPWRON since T2 holds the VBUS status.	Apply a second nRESPWRON to the MPU. The feasability of this workaround depends on the capability of the hardware. 146 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	2.0.1.105 ROM Code: VBUS Detection Timeout too Short
Cortex-A8	TI	OMAP-3530	When using TPS69xxx PHY, USB peripheral booting is functional only with a 26MHz system clock.	Use another PHY (ISP1504) or 26MHz clock frequency. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 147 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	2.0.1.106 USB: Peripheral Booting Dependent Upon System Clock Frequency
Cortex-A8	TI	OMAP-3530	The internal RAM can be turned OFF, even when the chip is completely ON, running the normal application. After a wake-up, the ROM code needs to access internal RAM. The ROM code detects the RAM has been turned off and then tries to turn it on. This operation is not performed correctly, causing the OCM RAM not to be turned ON. The ROM code loops infinitely, waiting for the RAM to be ON.	Before applying any sleep mode, the application must ensure that the OCM RAM is configured to be ON when the chip is ON. 148 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	2.0.1.108 ROM Code: OCM RAM Is Not Turned ON Correctly After Wakeup
Cortex-A8	TI	OMAP-3530	The booting image can contain a configuration header that can enable the ROM code to configure SDRC. When trying to configure the SDRC, the ROM code grabs a semaphore that is stored in scratchpad memory, but this semaphore was not initialized at POR. The value stored in this register may prevent the ROM code from booting or performing wake-up reset when SDRC restoration is necessary.	To prevent any wake-up problem, the software must delete the semaphore content after POR. However, there is no workaround to prevent any freeze at POR if a configuration header is defined in the booting image. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 149 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	2.0.1.109 ROM Code: Semaphore Is Not Initialized in Scratchpad Memory
Cortex-A8	TI	OMAP-3530	The booting image that is stored on the MMC can contain a software booting configuration (SWBCFG) [a specific data header that is located just before the booting code]. This SWBCFG is interpreted by the ROM code. The SWBCFG contains 2 important fields: MMC clock and MMC bus width. When setting the MMC bus width to 4, or 8 bits, the ROM code may fail to boot on certain MMC or SD devices. This failure depends on the MMC type. When switching to 4 or 8-bit bus width, the busy signal (present on DAT0 line) is asserted by the MMC. Some MMC devices need more than 100 Îs to be operational after having changed the bus width. After 60 Îs, the ROM code tries to read data from MMC without checking the busy signal level, and the read operation fails. MMC1 and MMC2 are impacted.	Use the MMC in 1-bit mode at booting phase. 150 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 SPRZ278F â February 2008 â Revised October 2010 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated www.ti.com	2.0.1.110 ROM Code: MMC Booting Using 4 /8-Bit Bus May Fail
Cortex-A8	TI	OMAP-3530	Due to an integration issue (test signal not tied to the right value), a higher level than expected of missed branch predictions are generated.	There is no workaround. SPRZ278F â February 2008 â Revised October 2010 OMAP3530/25/15/03 Applications Processor â Silicon Revision 3.1.2 151 Submit Documentation Feedback Copyright Â© 2008â2010, Texas Instruments Incorporated	2.0.1.114 Cortex-A8 r1p1 Exhibits Higher Level of Missed Branch Prediction
Cortex-A8	TI	TPS65910	: The standard specifies that the I2C transfer should restart on a start event in all cases. The current design does not support two consecutive Start conditions. This can cause the first real access after such a glitch to be corrupted. DescriptionJEEHEHRECONSTRUCT: An unexpected glitch on SDA and SCL can generate a wrong start event. In the current design, the SCL line must toggle two times to detect a new start event and completely restart the I2C access; hence the real start event is not detected in the case of a single SCL toggle.	: Repeat I2C access. 2 TPS65910 Silicon Errata ES1.1 SWCZ010A â May 2011 â Revised January 2014 Submit Documentation Feedback Copyright Â© 2011â2014, Texas Instruments Incorporated www.ti.com DCDC o/p voltage can go higher than programmed value 2	Glitch on SDA-SCL not managed correctly by the I2C IP
Cortex-A8	TI	TPS65910	: VDDI, VDD2, and VIO output programmed voltage level can go higher than expected or crash, when coming out of PFM to PWM mode or using DVFS. DescriptionJEEHEHRECONSTRUCT: When DCDC CLK SYNC bits are 11/01: â¢ VIO 3-MHz oscillator is the source clock of the digital core and input clock of VDD1 and VDD2 â¢ Turn-on of VDD1 and VDD2 HSD PFET is synchronized or at a constant phase shift â¢ Current pulled though VCC1+VCC2 is I (VDD1)+ I (VDD2) load load â¢ The 3 HSD PFET will be turned-on at the same time, causing the highest possible switching noise on the application. This noise level depends on the layout, the VBAT level, and the load current. The noise level increases with improper layout. When DCDC CLK SYNC bits are 00: â¢ VIO 3-MHz oscillator is the source clock of digital core â¢ VDD1 and VDD2 are running on their own 3-MHz oscillator â¢ Current pulled though VCC1+VCC2 average of I (VDD1)+I (VDD2) load load â¢ The switching noise of the 3 SMPS will be randomly spread over time, causing lower overall switching noise.	: Set DCDCCTRL_REG [1:0] = 00. SWCZ010A â May 2011 â Revised January 2014 TPS65910 Silicon Errata ES1.1 3 Submit Documentation Feedback Copyright Â© 2011â2014, Texas Instruments Incorporated	DCDC o/p voltage can go higher than programmed value
Core	Manufacturer	Chip	Details	Workaround	Failure
Cortex A-9	NXP	IMX6DQ	Normally, the VDDARM_CAP supply takes only approximately 40 Î¼s to raise to the correct voltage when exiting from Deep Sleep (DSM) mode, if the LDO is enabled. If the LDO bypass mode is selected, the VDDARM_CAP supply voltage will drop to approximately 0 V when entering and when exiting from DSM, even though the VDDARM_IN supply is already stable, the VDDARM_CAP supply will take about 2 ms to rise to the correct voltage.	The software workaround to prevent this issue it to switch to analog bypass mode (0x1E), prior to entering DSM, and then, revert to the normal bypass mode, when exiting from DSM.	Analog: Transition from Deep Sleep Mode to LDO Bypass Mode may cause the slow response of the VDDARM_CAP output
Cortex A-9	NXP	IMX6DQ	The Global Timer can be programmed to generate an interrupt request to the processor when it reaches a given programmed value. Due to the erratum, when the Global Timer is programmed not to use the auto-increment feature, it might generate two interrupt requests instead of one. Conditions: The Global Timer Control register is programmed with the following settings: â¢ Bit[3] = 1âb0 â Global Timer is programmed in âsingle-shotâ mode â¢ Bit[2] = 1âb1 â Global Timer IRQ generation is enabled â¢ Bit[1] = 1âb1 â Global Timer value comparison with Comparator registers is enabled â¢ Bit[0] = 1âb1 â Global Timer count is enabled With these settings, an IRQ is generated to the processor when the Global Timer value reaches the value programmed in the Comparator registers. The Interrupt Handler then performs the following sequence: 1. Read the ICCIAR (Interrupt Acknowledge) register 2. Clear the Global Timer flag 3. Modify the comparator value to set it to a higher value 4. Write the ICCEOIR (End of Interrupt) register Under these conditions, due to the erratum, the Global Timer might generate a second (spurious) interrupt request to the processor at the end of this Interrupt Handler sequence.	Because the erratum only happens when the Global Timer is programmed in âsingle-shotâ mode, that is, when it does not use the auto-increment feature, a first possible workaround could be to program the Global Timer to use the auto-increment feature. If this solution does not work, a second workaround could be to modify the Interrupt Handler to avoid the offending sequence. This is achieved by clearing the Global Timer flag after having incremented the Comparator register value. Then, the correct code sequence for the Interrupt Handler should look as below: 1. Read the ICCIAR (Interrupt Acknowledge) register 2. Modify the comparator value to set it to a higher value 3. Clear the Global Timer flag 4. Clear the Pending Status information for Interrupt 27 (Global Timer interrupt) in the Distributor of the Interrupt Controller. 5. Write the ICCEOIR (End of Interrupt) register	ARM: 740657âGlobal Timer can send two interrupts for the same event
Cortex A-9	NXP	IMX6DQ	Under very rare conditions, a faulty optimization in the CortexÂ®-A9 store buffer might lead to data corruption. Conditions: The code sequence which exhibits the failure requires at least five cacheable writes in 64-bit data chunk: â¢ Three of the writes must be in the same cache line â¢ Another write must be in a different cache line â¢ All of the above four writes hit in the L1 data cache â¢ A fifth write is required in any of the above two cache lines that fully writes a 64-bit data chunk With the above code sequence, under very rare circumstances, this fifth write might get corrupted, with the written data either being lost, or being written in another cache line. The conditions under which the erratum can occur are extremely rare, and require the coincidence of multiple events and states in the Cortex-A9 micro-architecture. As an example: letâs assume A, Aâ, Aâ, and Aâââ are all in the same cache lineâB and Bâ are in another cache line. The following code sequence might trigger the erratum: STR A STR Aâ STR Aââ STR B STR Aâââ (or STR Bâ) At the time where the first four STR are in the Cortex-A9 store buffer, and the fifth STR arrives at a very precise cycle in the Store Buffer input stage, then the fifth STR might not see its cache line dependency on the previous STR instructions. Because of this, in cases when the cache line A or B gets invalidated due to a coherent request from another CPU, the fifth STR might write in a faulty cache line, causing data corruption. An alternative version of the erratum might happen even without a coherent request â In the case when the fifth STR is a 64-bit write in the same location as one of A, Aâ, Aââ, then the erratum might also be exhibited. Note that this is a quite uncommon scenario because it requires a first write to a memory location that is immediately and fully overwritten.	A software workaround is available for this erratum that requires setting bit[6] in the undocumented Diagnostic Control register, placed in CP15 c15 0 c0 1. The bit can be written in Secure state only, with the following Read/Modify/Write code sequence: Chip Errata for the i.MX 6Dual/6Quad and i.MX 6DualPlus/6QuadPlus, Rev. 6.1, 06/2016 MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x40 MCR p15,0,rt,c15,c0,1 When this bit is set, the âfast lookupâ optimization in the Store Buffer is disabled, which will prevent the failure to happen. Setting this bit has no visible impact on the overall performance or power consumption of the processor.	ARM: 743622âFaulty logic in the Store Buffer may lead to data corruption
Cortex A-9	NXP	IMX6DQ	Overflow detection logic in the Performance Monitor Counters is faulty, and under certain timing conditions, the overflow may remain undetected. In this case, the Overflow Flag Status register (PMOVSR) is not updated as it should, and no interrupt is reported on the corresponding PMUIRQ line. It is important to notice that the Cycle counter is not affected by this erratum.	The main workaround for this erratum is to poll the performance counter. The maximum increment in a single cycle for a given event is 2. Therefore, polling can be infrequent as no counter can increment by more than 2^32 in fewer than 2 billion cycles. If the main usage model for performance counters is collecting values over a long period, then polling can be used to collect values (and reset the counter) rather than waiting for an overflow to occur. Polling can be done infrequently and overflow avoided. If the main usage model for performance counters relies on presetting the counter to some value and waiting for an overflow to occur, then polling can be used to detect when an overflow event has been missed. An overflow can be determined to have been missed if the unsigned value in the counter is less than the value preset into the counter. Again, polling can be done infrequently because of the number of cycles it would need for this check to fail. In the case that the erratum was triggered and an overflow event was missed, that counter sample can be thrown away or the true value can be reconstructed. An alternative workaround is to configure two counters to be triggered by the same event, staggering their initial count values by 1. This will result in the rollover being triggered by at least counter. This alternative workaround works for all Cortex-A9 events but the three following ones, due to the fact these three events can increment by 2 in a single cycle: - 0x68 â Instructions coming out of the core renaming stage - 0x73 â Floating-point instructions - 0x74 â NEON instructions For these 3 events, only the first workaround is applicable to fix the defect.	ARM/MP: 751469 â Overflow in PMU counters may not be detected
Cortex A-9	NXP	IMX6DQ	In an MPCore configuration with two or more processors working in SMP mode with maintenance operation broadcast enabled, if a processor is interrupted while executing an ICIALLUIS operation, and performs another broadcast maintenance operation during its Interrupt Service Routine, then this second operation might not be executed on other processors in the cluster. Conditions: The erratum requires an MPCore configuration with two or more CPUs working in SMP mode. One processor has interrupts enabled, and Cache and TLB maintenance broadcast enabled too (ACTLR.FW=1âb1). This processor executes an ICIALLUIS (invalidates all instruction caches Inner Shareable to Point of Unification). This instruction is executed on the processor, and also broadcast to other processors in the MPCore cluster. The processor then receives an interrupt (IRQ or FIQ), which interrupts the ICIALLUIS operation. During the Interrupt Service Routine, the processor executes any other Cache or TLB maintenance operation which is also broadcast to other processors in the MPCore cluster. If the other processors in the cluster receive this second maintenance operation before having completed the first ICIALLUIS operation, then the erratum occurs, as the other processors will not execute the second maintenance operation. This is because there is no âstackingâ mechanism for acknowledge answers between the processors, so that the acknowledge request sent to signify the completion of the ICIALLUIS will be interpreted by the originating processor as an acknowledge for the second maintenance operation.	A software workaround is available for this erratum that involves setting bit[11] in the undocumented Diagnostic Control register, placed in CP15 c15 0 c0 1. This bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x800 MCR p15,0,rt,c15,c0,1 When it is set, this bit prevents CP15 maintenance operations to be interrupted. Using this software workaround is not expected to cause any visible impact on the system.	ARM/MP: 751472âAn interrupted ICIALLUIS operation may prevent the completion of a following broadcast operation
Cortex A-9	NXP	IMX6DQ	Under very rare timing circumstances, the automatic Data prefetcher might cause address hazard issues, possibly leading to a data corruption or a deadlock of the processor. Conditions: The erratum can only happen when the Data Cache and MMU are enabled in the following cases: â¢ On all memory regions marked as Write-Back Non-Shared, when the Data Prefetcher in L1 is enabled (ACTLR[2]=1âb1), regardless of the ACTLR.SMP bit. â¢ On all memory regions marked as Write-Back Shared, when the Data Prefetch Hint in L2 is enabled (ACTLR[1]=1âb1), and when the processor is in SMP mode (ACTLR.SMP=1âb1).	The workaround for this erratum requires not enabling the automatic Data Prefetcher by keeping ACTRL[2:1]=2âb00, which is the default value on exit from reset. Although this feature might show significant performance gain on a few synthetic benchmarks, it usually has no impact on real systems. It means, this workaround is not expected to cause any visible impact on final products.	ARM: 751473âUnder very rare circumstances, Automatic Data prefetcher can lead to deadlock or data corruption
Cortex A-9	NXP	IMX6DQ	Under rare conditions, a watchpoint on the second part of an unaligned access that crosses a 4 KB page boundary and that is missed in the micro-TLB for the second part of its request might be undetected. The erratum requires a previous conditional instruction that accesses the second 4 KB memory region (= where the watchpoint is set), is missed in the micro-TLB, and is condition failed. The erratum also requires that no other micro-TLB miss occurs between this conditional failed instruction and the unaligned access. This implies that the unaligned access must hit in the micro-TLB for the first part of its request.	In case, a watchpoint is set on any of the first 3 bytes of a 4 KB memory region, and unaligned accesses are not being faulted, then the erratum might happen. The workaround then requires setting a guard watchpoint on the last byte of the previous page, and dealing with any âfalse positiveâ matches as and when they occur.	ERR003723 ARM: 751476âMay miss a watchpoint on the second part of an unaligned access that crosses a page boundary
Cortex A-9	NXP	IMX6DQ	A microTLB entry might be corrupted following an ASID switch, possibly corrupting subsequent MMU translations. The erratum requires execution of an explicit memory access, which might be speculative. This memory access misses in the TLB and cause a translation table walk. The erratum occurs when the translation table walk starts before the ASID switch code sequence, but completes after the ASID switch code sequence. In this case, a new entry is allocated in the microTLB for the TLB entry for this translation table walk, but corresponding to the old ASID. Because the microTLB does not record the ASID value, the new MMU translation, which should happen with the new ASID following the ASID switch, might hit this stale microTLB entry and become corrupted. Note that there is no Trustzone Security risk because the Security state of the access is held in the microTLB, and cannot be corrupted.	The workaround for this erratum involves adding a DSB in the ASID switch code sequence. The ARM architecture only mandates ISB before and after the ASID switch. Adding a DSB prior to the ASID switch ensures that the Page Table Walk completes prior to the ASID change, so that no stale entry can be allocated in the micro-TLB. The examples in the ARM Architecture Reference Manual for synchronizing the change in the ASID and TTBR need to be changed as follows: The sequence: Change ASID to 0 ISB Change Translation Table Base Register ISB Change ASID to new value becomes DSB Change ASID to 0 ISB Change Translation Table Base Register ISB DSB Change ASID to new value the sequence: Change Translation Table Base Register to the global-only mappings ISB Change ASID to new value ISB Change Translation Table Base Register to new value becomes Change Translation Table Base Register to the global-only mappings ISB DSB Change ASID to new value ISB Change Translation Table Base Register to new value and the sequence: Set TTBCR.PD0 = 1 ISB Change ASID to new value Change Translation Table Base Register to new value ISB Set TTBCR.PD0 = 0 becomes Set TTBCR.PD0 = 1 ISB DSB Change ASID to new value Change Translation Table Base Register to new value ISB Set TTBCR.PD0 = 0	ARM: 754322âPossible faulty MMU translations following an ASID switch
Cortex A-9	NXP	IMX6DQ	The ISB is implemented as a branch in the Cortex-A9 micro-architecture. This implies that events 0x0C (software change of PC) and 0x0D (immediate branch) are asserted when an ISB occurs. This is not compliant with the ARM architecture.	Count ISB instructions along with event 0x90. The user should subtract this ISB count from the results obtained in events 0x0C and 0x0D, to obtain the precise count of software change of PC (0x0C) and immediate branches (0x0D).	ARM: 725631âISB is counted in Performance Monitor events 0x0C and 0x0D
Cortex A-9	NXP	IMX6DQ	The ARM Debug Architecture specifies registers 838 and 839 as âAlias of the MainID registerâ. They should be accessible through the APB Debug interface at addresses 0xD18 and 0xD1C. In Cortex-A9, the two alias addresses are not implemented. A read access at any of these two addresses returns 0, instead of the MIDR value. Note that read accesses to these two registers through the internal CP14 interface are trapped to UNDEF, which is compliant with the ARM Debug architecture. So, the erratum only applies to the alias addresses through the external Debug APB interface.	The workaround for this erratum requires always accessing the MIDR at its original address, 0xD00, and not at any of its alias addresses.	ERR003726 ARM: 729817âMainID register alias addresses are not mapped on Debug APB interface
Cortex A-9	NXP	IMX6DQ	When the processor is in debug state, an instruction written to the ITR after a Load/Store instruction that aborts gets executed on clearing the SDABORT_l, instead of being discarded.	There are a selection of workarounds with increasing complexity and decreasing impact. In each case, the impact is a loss of performance when debugging: â¢ Do not use stall mode â¢ Do not use stall mode when doing load/store operations â¢ Always check for a sticky abort after issuing a load/store operation in stall mode (the cost of this probably means the above second workaround is a preferred alternative) â¢ Always check for a sticky abort after issuing a load/store operation in stall mode, before issuing any further instructions that might corrupt important target state (such as, further load/store instructions, instructions that write to âliveâ registers [VFP, CP15, etc.])	ARM: 729818âIn debug state, next instruction is stalled when sdabort flag is set, instead of being discarded
Cortex A-9	NXP	IMX6DQ	Event 0x74 counts the total number of Neon instructions passing through the register rename pipeline stage. Due to the erratum, the âstallâ information is not taken into account. So, one Neon instruction that remains for n cycles in the register rename stage is counted as n Neon instructions. As a consequence, the count of event 0x74 might be corrupted, and cannot be relied upon. The event is also reported externally on PMUEVENT[38:37], which suffers from the same inaccuracy.	No workaround is possible to achieve the required functionality of counting how many Neon instructions are executed (or renamed) in the processor.	ERR003728 ARM: 740661âEvent 0x74 / PMUEVENT[38:37] may be inaccurate
Cortex A-9	NXP	IMX6DQ	Event 0x68 counts the total number of instructions passing through the register rename pipeline stage. Under certain conditions, some branch-related instructions might pass through this pipeline stage without being counted. As a consequence, event 0x68 might be inaccurate, lower than expected. The event is also reported externally on PMUEVENT[9:8], which suffers from the same inaccuracy. Conditions: The erratum occurs when the following conditions are met: â¢ Events are enabled â¢ One of the PMU counters is programmed to count event 0x68 â number of instructions passing through the register rename stage. Alternatively, an external component counts, or relies on, PMUEVENT[9:8]. â¢ A program, containing the following instructions, is executed: â A Branch immediate, without Link â An ISB instruction â An HB instruction, without Link and without parameter, in Thumb2EE state â An ENTERX or LEAVEX instruction, in Thumb2 or Thumb2EE state â¢ The program executed is causing some stalls in the processor pipeline Under certain timing conditions specific to the Cortex-A9 micro-architecture, a cycle stall in the processor pipeline might âhideâ the instructions mentioned above, thus ending with a corrupted count for event 0x68, or a corrupted value on PMUEVENT[9:8] during this given cycle. If the âhiddenâ instruction appears in a loop, the count difference can be significant. As an example, letâs consider the following loop: loop mcr 15, 0, r2, cr9, cr12, {4} adds r3, #1 cmp.w r3, #loop_number bne.n loop The loop contains four instructions; so, the final instruction count should (approximately) be four times the number of executed loops. In practice, the MCR is causing a pipeline stall that âhidesâ the branch instruction (bne.n); so, only three instructions are counted per loop, and the final count appears as three times the number of executed loops.	No workaround is possible to achieve the required functionality of counting how many instructions are precisely passing through the register rename pipeline stage.	ARM: 740663âEvent 0x68 / PMUEVENT[9:8] may be inaccurate
Cortex A-9	NXP	IMX6DQ	Under very rare circumstances, a deadlock can happen in the processor when it is handling a minimum of seven PLD instructions, shortly followed by one LDM to an uncacheable memory location. The LDM is treated as uncacheable in the following cases: â¢ The LDM is performed while the Data Cache is OFF â¢ The LDM is targeting a memory region marked as Strongly Ordered, Device, Normal Memory Non-Cacheable, or Normal Memory Write-Through â¢ The LDM is targeting a memory region marked as Shareable Normal Memory Write-Back, and the CPU is in AMP mode. Conditions: The code sequence that exhibits this erratum requires at least seven PLDs, shortly followed by one LDM, to an uncacheable memory region. The erratum happens when the LDM appears on the AXI bus before any of the seven PLDs. This can possibly happen if the first PLD is a miss in the micro-TLB; in that case, it needs to perform a TLB request which might not be serviced immediately because the mainTLB is already performing a Page Table Walk for another resource (for example, instruction side), or because the PLD request itself to the mainTLB is missing and causing a Page Table Walk. Also note that the above conditions are not sufficient to recreate the failure, as additional rare conditions on the internal state of the processor are necessary to exhibit the errata.	The primary workaround might be to avoid the offending code sequence, that is, not to use uncacheable LDM when making intensive use of PLD instructions. In case the above workaround cannot be done, another workaround for this erratum can be to set bit[20] in the undocumented Control register, which is placed in CP15 c15 0 c0 1. This bit needs to be written with the following Read/Modify/Write code sequence: MRC p15,0,r0,c15,c0,1 ORR r0,r0,#0x00100000 MCR p15,0,r0,c15,c0,1 Setting this bit causes all PLD instructions to be treated as NOPs, with the consequence that code sequences usually using the PLDs, such as the memcpy() routine, might suffer from a visible performance drop.	ARM: 743623âBad interaction between a minimum of seven PLDs and one Non-Cacheable LDM can lead to a deadlock
Cortex A-9	NXP	IMX6DQ	An imprecise external abort received while the processor is ready to enter into WFI state might cause a processor deadlock. Explicit memory transactions can be completed by inserting a DSB before the WFI instruction. However, this does not prevent memory accesses generated by previously issued PLD instructions page table walks associated with previously issued PLD instructions or as a result of the PLE engine. If an external abort is returned as a result of one of these memory accesses after executing a WFI instruction, the processor can cause a deadlock.	A possible workaround for this erratum is to protect all memory regions that can return an imprecise external abort with the correct MMU settings, to prevent any external aborts.	ARM: 743626âAn imprecise external abort, received while the processor enters WFI, may cause a processor deadlock
Cortex A-9	NXP	IMX6DQ	About the DBGPCSR register, the ARM architecture specifies that: â¢ DBGPCSR[31:2] contains sampled value of bits [31:2] of the PC. The sampled value is an instruction address plus an offset that depends on the processor instruction set state. â¢ DBGPCSR[1:0] contains the meaning of PC sample value, with the following permitted values: â 0b00 ((DBGPCSR[31:2] << 2) - 8) references an ARM state instruction â 0bx1 ((DBGPCSR[31:1] << 1) - 4) references a Thumb or ThumbEE state instruction â 0b10 IMPLEMENTATION DEFINED This field encodes the processor instruction set state, so that the profiling tool can calculate the true instruction address by subtracting the appropriate offset from the value sampled in bits [31:2] of the register. In Cortex-A9, the DBGPCSR samples the target address of executed branches (but possibly still speculative to data aborts), with the following encodings: â¢ DBGPCSR[31:2] contains the address of the target branch instruction, with no offset â¢ DBGPCSR[1:0] contains the execution state of the target branch instruction: â 0xb00 for an ARM state instruction â 0xb01 for a Thumb2 state instruction â 0xb10 for a Jazelle state instruction â 0xb11 for a Thumb2EE state instruction	The debugger tools can find the expected PC value and instruction state by reading the DBGPCSR register, and consider it as described in the Description section. No fix scheduled Linux BSP Status: Software workaround is not needed because this erratum will never be encountered in normal device operation. Software workaround not applicable to the BSP since it is a debug feature. Users should use the ARM recommended workaround if using this debug feature in their application	ERR003732 ARM: 751471âDBGPCSR format is incorrect
Cortex A-9	NXP	IMX6DQ	A conditional LDREX might set the internal exclusive monitor of the Cortex-A9 even when its condition fails. So, any subsequent STREX that depends on this LDREXcc might succeed when it should not.	The workaround for this erratum can be not to use conditional LDREX along with non-conditional STREX. â¢ If no conditional LDREX is used, the erratum cannot be triggered. â¢ If conditional LDREX is used, the associated STREX should be conditional too with the same condition, so that even if the exclusive monitor is set by the condition failed LDREX, the following STREX will not be executed because it will be condition failed too. For most situations this will naturally be the case anyway.	ERR003733 ARM: 751480âConditional failed LDREXcc can set the exclusive monitor
Cortex A-9	NXP	IMX6DQ	When two outstanding read memory requests to device or non-cacheable normal memory regions are issued by the Cortex-A9, and the first one receives an imprecise external abort, then the second access might falsely report an imprecise external abort. Conditions: The erratum can only happen in systems which can generate imprecise external aborts on device or non-cacheable normal memory regions accesses.	There is no practical software workaround for the failure.	ARM: 752519âAn imprecise abort may be reported twice on non-cacheable reads
Cortex A-9	NXP	IMX6DQ	The Cortex-A9 implements a small counter that ensures the external visibility of all stores in a finite amount of time, causing an eventual drain of the merging store buffer. This is to avoid an earlier issue, where written data could potentially remain indefinitely in the Store Buffer. This store buffer has merging capabilities, and will continue merging data as long as the write accesses are performed in the same cache line. The issue that causes this erratum is that the draining counter is reset each time a new data merging is performed. When a code sequence is looping, and keeps on writing data in the same cache line, then the external visibility of the written data might not be ensured. A livelock situation might consequently occur in case any external agent is relying on the visibility of the written data, and that the writing processor cannot be interrupted while doing its writing loop. Conditions: The erratum can only happen on normal memory regions. Two example scenario, which might trigger the erratum, are described below: â¢ The processor keeps on incrementing a counter: writing the same word at the same address. The external agent (possibly another processor) is polling on this address, waiting for any update of the counter value to proceed. The store buffer will keep on merging the updated value of the counter in its cache line, so that the external agent will never see any updated value, possibly leading to livelock. â¢ The processor writes a value in a given word to indicate completion of its task, then keeps on writing data in an adjacent word in the same cache line. The external agent keeps on polling the first word memory location to check when the processor has completed its task. The situation is the same as above, as the cache line might remain indefinitely in the merging store buffer, creating a possible livelock in the system.	The recommended workaround for this erratum involves inserting a DMB operation after the faulty write operation in code sequences that might be affected by this erratum. This ensures visibility of the written data by any external agent.	ERR003735 ARM: 754323âRepeated Store in the same cache line may delay the visibility of the Store
Cortex A-9	NXP	IMX6DQ	The Sticky Pipeline Advance bit is bit[25] of the DBGDSCR register. This bit enables the debugger to detect whether the processor is idle. This bit is set to 1 every time the processor pipeline retires one instruction. A write to DBGDRCR[3] clears this bit. The erratum is that the Cortex-A9 does not implement any debug APB access to DBGDRCR[3].	There is no practical workaround for this erratum. The only possible way to reset the Sticky Pipeline Advance bit is to assert the nDBGRESET input pin on the processor. This obviously has the side effect to reset all debug resources in the concerned processor, and any other additional Coresight components nDBGRESET is connected to.	ERR003736 ARM: 756421âSticky Pipeline Advance bit cannot be cleared from debug APB accesses
Cortex A-9	NXP	IMX6DQ	The ARM architecture specifies that ARM opcodes of the form 11110 100x001 xxxx xxxx xxxx xxxx xxxx are âUnallocated memory hint (treat as NOP)â if the core supports the MP extensions, as the Cortex-A9 does. The errata is that the Cortex-A9 generates an UNDEFINED exception when bits [15:12] of the instruction encoding are different from 4âb1111, instead of treating the instruction as a NOP.	A possible workaround for this erratum is to modify the instruction encoding with bits[15:12]=4.b1111, so that the instruction is truly treated as a NOP by the Cortex-A9. If the instruction encoding cannot be modified, the UNDEFINED exception handler has to cope with this case, and emulate the expected behavior of the instruction, that is, do nothing (NOP), before returning to normal program execution.	ARM: 757119âSome âUnallocated memory hintâ instructions generate an UNDEFINED exception instead of being treated as NOP
Cortex A-9	NXP	IMX6DQ	In the Data cache, parity error detection is faulty. Parity error may not be not detected when the line exits from the Data cache, due to a line replacement, or due to a coherent request from another processor or from the ACP, or because of a CP15 cache clean operation.	There is no workaround for this erratum.	ERR003738 ARM/MP: 751475âParity error may not be reported on full cache line access (eviction / coherent data transfer / cp15 clean operations)
Cortex A-9	NXP	IMX6DQ	Data linefills are returned as 4-beat bursts of 64-bit data on the AXI bus. When the first three beat of data are valid, and the fourth one aborts, then the abort is not detected by the processor logic and no abort exception is taken. The processor then behaves as if no abort is reported on the line. It can allocate the line in its Data Cache, and use the aborted data during its program flow. Conditions: The processor needs to work with Data Cache enabled, and access some cacheable memory regions (Write Back, either Shared or Non-Shared). The memory system underneath the processor needs to be able to generate aborts in this memory region, and must be able to generate aborts with a granularity smaller than the cache line.	None	ARM: 751470âImprecise abort on the last data of a cache linefill may not be detected
Cortex A-9	NXP	IMX6DQ	The double linefill feature is controlled by bit 30 of the Prefetch Control Register. The L2C-310 cache line length is 32-byte. Therefore, by default, on each L2 cache miss, L2C-310 issues 32-byte linefills, 4 x 64-bit read bursts, to the L3 memory system. L2C-310 can issue 64-byte linefills (double linefills), 8 x 64-bit read bursts, on an L2 cache miss. When the L2C-310 is waiting for the data from L3, it performs a lookup on the second cache line targeted by the 64-byte linefill. When it misses in the L2 cache, it identifies a victim for future allocation. If such a victim already contains a dirty entry, the latter must be evicted before the second part of the double linefill is allocated. For this purpose, the double linefill slot issues a request to the Eviction Buffer. Due to this erratum, such an eviction request can be missed, leading to the loss of dirty data in the L2 cache. Conditions: This problem occurs when the following conditions are met: â¢ The double linefill feature is enabled. â¢ The L2 cache contains dirty data.	The only workaround to this erratum is to disable the double linefill feature. This is the behavior by default.	ERR003740 ARM/PL310: 752271âDouble linefill feature can cause data corruption [i.MX 6Dual/6Quad only]
Cortex A-9	NXP	IMX6DQ	The âHigh Priority for SO and Dev readsâ feature can be enabled by setting the bit[10] of the PL310 Auxiliary Control Register to 1. When enabled, it gives priority to Strongly Ordered and Device reads over cacheable reads in the PL310 AXI master interfaces. When PL310 receives a continuous flow of SO or Device reads, this can prevent cacheable reads, which are misses in the L2 cache, from being issued to the L3 memory system. Conditions: The erratum occurs when the following conditions are met: â¢ The bit[10] âHigh Priority for SO and Dev reads enableâ of the PL310 Auxiliary Control Register is set to 1 â¢ PL310 receives a cacheable read that is a miss in the L2 cache â¢ PL310 receives a continuous flow of SO or Device reads that take all address slots in the master interface	A workaround is only necessary in systems that are able to issue a continuous flow of SO or Device reads. In such a case, the workaround is to disable the âHigh Priority for SO and Dev readsâ feature. This is the behavior by default.	ARM/PL310: 729815âThe âHigh Priority for SO and Dev readsâ feature can cause Quality of Service issues to cacheable read transactions
Cortex A-9	NXP	IMX6DQ	In the ARM L2 cache controller, PL310, hazard checking is done on bits [31:5] of the address. When a read with Normal Memory (cacheable or not) attributes is received by PL310, hazard checking is performed with the active writes of the store buffer. If an address matching is detected, the read is stalled till the write completes. Due to this erratum, a continuous flow of writes can stall a read targeting the same memory area. Conditions: The erratum occurs when the following conditions are met: â¢ PL310 receives a continuous write traffic targeting the same address marked with Normal Memory attributes â¢ While treating this flow, PL310 receives a read targeting the same 32-byte memory area	There is no workaround for this erratum. A workaround is not expected to be necessary for this erratum either.	ERR003743 ARM/PL310: 754670âA continuous write flow can stall a read targeting the same memory area
Cortex A-9	NXP	IMX6DQ	The ARM architecture, and general rules of coherency, requires reads to the same memory location to be observed in order. Due to some internal replay path mechanisms, the Cortex-A9 can see a read access bypassed by a following read access to the same memory location, thus not observing the values in program order. Conditions: It can only happen on memory regions marked as Normal Memory Write-Back Shared.	The vast majority of multi-processing code is not written in a style which exposes the erratum. So, the erratum is expected to affect very specific areas of code which rely on this read ordering behavior. A first workaround for this erratum consists in using LDREX instead of standard LDR in volatile memory places where a strict read ordering is required. An alternative solution consists in inserting a DMB between the affected LDR which requires this strict ordering rule. This is the recommended workaround for tool chains integration.	ARM/MP: 761319âOrdering of read accesses to the same memory location may not be ensured
Cortex A-9	NXP	IMX6DQ	Under certain timing circumstances, a data or unified cache line maintenance operation by MVA targeting an Inner Shareable memory region might fail to proceed up to either the Point of Coherency or to the Point of Unification of the system. This is likely to affect self modifying code. Conditions: The erratum requires a Cortex-A9 MPCore configuration with two processors or more, working in SMP mode, with the broadcasting of CP15 maintenance operations enabled. The following scenario illustrates how the erratum can happen: â¢ One CPU performs a data or unified cache line maintenance operation by MVA targeting a memory region that is locally dirty. â¢ A second CPU issues a memory request targeting this same memory location within the same time frame. A race condition might occur, resulting in the cache operation not being performed up to the specified Point, either Coherency or Unification. The following maintenance operations are affected: â¢ DCIMVAC: Invalidate data or unified cache line by MVA to PoC â¢ DCCMVAC: Clean data or unified cache line by MVA to PoC â¢ DCCMVAU: Clean data or unified cache line by MVA to PoU â¢ DCCIMVAC: Clean and invalidate data or unified cache line by MVA to PoC The erratum might arise when the second CPU is performing either of: â¢ A read request resulting from any Load instruction; the Load can be a speculative one. â¢ A write request resulting from any Store instruction. â¢ A data prefetch resulting from a PLD instruction; the PLD might be a speculative one.	To work around this erratum, ARM recommends to: â¢ Ensure there is no false sharing (on a cache line size alignment) for both self modifying code and data to be cleaned to an external agent, like a DMA engine. â¢ Set bit[0] in the undocumented SCU diagnostic control register located at offset 0x30 from the PERIPHBASE address. Setting this bit disables the âmigratory bitâ feature. This forces a dirty cache line to be evicted to the lower memory subsystemâwhich is both the point of coherency and the point of unificationâwhen it is being read by another processor. Note that this bit can be written, but is always Read as Zero. â¢ Insert a DSB instruction in front of the cache maintenance operation. Note that if the cache maintenance operation is executed within a loop with no other memory operations, ARM only recommends adding a DSB prior to entering the loop. Note that the atomicity between the DSB and the cache maintenance operation might not be ensured because an interrupt may still be taken between the two instructions. However, setting the âdisable migratory lineâ bit and inserting the DSB in front of the cache maintenance operation will very significantly decrease the probability to trigger the erratum when false sharing for writes to either self-modifying code memory regions or DMA regions, on a cache line granularity, which is likely to be the case. With these workarounds, the likely occurrence of this erratum is sufficiently low that the erratum does not limit or severely impair the intended use of specified features.	ERR004325 ARM/MP: 764369âData or unified cache line maintenance operation by MVA may not succeed on an Inner Shareable memory region
Cortex A-9	NXP	IMX6DQ	Event 0x68 counts the total number of instructions passing through the Register rename pipeline stage. The erratum is that MRC and MCR instructions are not counted in this event. The event is also reported externally on PMUEVENT[9:8], which suffers from the same defect.	No workaround is possible to achieve the required functionality of counting how many instructions are precisely passing through the register rename pipeline stage, when the code contains some MRC or MCR instructions.	ERR004326 ARM/MP: 761321âMRC and MCR are not counted in event 0x68
Cortex A-9	NXP	IMX6DQ	CP14 read accesses to the DBGPRSR and DBGOSLSR registers generate an unexpected UNDEFINED exception when the DBGSWENABLE external pin is set to 0, even when the CP14 accesses are performed from a privileged mode.	The workaround for this erratum consists in temporarily setting the DBGSWENABLE bit to 1 so that the DBGPRSR and DBGOSLSR registers can be accessed as expected. There is no other workaround for this erratum.	ARM/MP: 764319âRead accesses to DBGPRSR and DBGOSLSR may generate an unexpected UNDEF
Cortex A-9	NXP	IMX6DQ	Preload Data (PLD) instructions prefetch and allocate any data marked as Write-Back (either Write-Allocate or Non-Write-Allocate, Shared or Non-Shared), regardless of the processor configuration settings, including the Data Cache Enable bit value.	In the case where a system is impacted by this erratum, a software workaround is available which consists in setting bit [20] in the undocumented Control register, which is placed in CP15 c15 0 c0 1. This bit needs to be written with the following Read/Modify/Write code sequence: MRC p15,0,r0,c15,c0,1 ORR r0,r0,#0x00100000 MCR p15,0,r0,c15,c0,1 Setting this bit causes all PLD instructions to be treated as NOPs, with the consequence that code sequences usually using the PLDs, such as the memcpy() routine, might suffer from a visible performance drop. So, if this workaround is applied, ARM strongly recommends restricting its usage to periods of time where the Data Cache is disabled.	ERR005175 ARM/MP: 771221âPLD instructions may allocate data in the Data Cache regardless of the Cache Enable bit value
Cortex A-9	NXP	IMX6DQ	According to the ARM architecture, any change in the Authentication Status Register should be made visible to the processor after an exception entry or return, or an ISB. Although this is correctly achieved for all debug-related features, the ISB is not sufficient to make the changes visible to the trace flow. As a consequence, the WPTTRACEPROHIBITEDn signal(s) remain stuck to their old value up to the next exception entry or return, or to the next serial branch, even when an ISB is executed. A serial branch is one of the following: â¢ Data processing to PC with the S bit set (for example, MOVS pc, r14) â¢ LDM pc ^	To work around the erratum, the ISB must be replaced by one of the events causing the change to be visible. In particular, replacing the ISB by a MOVS PC to the next instruction will achieve the correct functionality.	ARM/MP: 771224âVisibility of Debug Enable access rights to enable/disable tracing is not ensured by an ISB
Cortex A-9	NXP	IMX6DQ	On Cortex-A9, when a cacheable read receives an external abort, the aborted line is allocated as invalid in the Data Cache, and any allocation in the Data Cache clears the internal exclusive monitor. So, if a program executes a LDREX/STREX loop which keeps on receiving an abort answer in the middle of the LDREX/STREX sequence, then the LDREX/STREX sequence never succeeds, leading to a possible processor livelock. As an example, the following code sequence might exhibit the erratum: loop LDREX ... DSB STREX CMP BNE loop .... LDR (into aborting region) The LDREX/STREX does not succeed on the first pass of the loop, and the BNE is mispredicted, so, the LDR afterwards is speculatively executed. So, the processor keeps on executing: LDR to aborting region (this speculative LDR now appears âbeforeâ the LDREX and DSB) LDREX DSB STREX The LDR misses in L1, and never gets allocated as valid because it is aborting The LDREX is executed, and sets the exclusive monitor The DSB is executed. It waits for the LDR to complete, which aborts, causing an allocation (as invalid) in the Data Cache, which clears the exclusive monitor The STREX is executed, but the exclusive monitor is now cleared, so the STREX fails The BNE might be mispredicted again, so the LDR is speculatively executed again, and the code loops back on the same failing LDREX/STREX sequence. Conditions: The erratum happens in systems which might generate external aborts in answer to cacheable memory requests. If the program reaches a stable state where the internal exclusive monitor keeps on being cleared in the middle of the LDREX/STREX sequence, then the processor might encounter a livelock situation. In practice, this scenario seems very unlikely to happen because several conditions might prevent the erratum from happening: â¢ Usual LDREX/STREX code sequences do not contain any DSB, so that it is very unlikely that the system would return the abort answer precisely in the middle of the LDREX/STREX sequence on each iteration. â¢ Some external irritators (for example, interrupts) might happen and cause timing changes which might exit the processor from its livelock situation. â¢ Branch prediction is very usually enabled, so the final branch in the loop will usually be correctly predicted after a few iterations of the loop, preventing the speculative LDR to be issued, so that the next iteration of the LDREX/STREX sequence will succeed. Workarounds: The following two workarounds are available for this erratum: â¢ Turn on the branch prediction. â¢ Remove the DSB in the middle of the LDREX/STREX sequence. If a DSB is truly required, it is strongly recommended to place it before the LDREX/STREX sequence, and implement the LDREX/STREX sequence as recommended by the ARM architecture. Proposed Solution: No fix scheduled Linux BSP Status: Software workaround implemented in Linux BSP codebase in all releases. Software workaround is to enable branch prediction which is enabled by default in the BSP GA release	The following two workarounds are available for this erratum: â¢ Turn on the branch prediction. â¢ Remove the DSB in the middle of the LDREX/STREX sequence. If a DSB is truly required, it is strongly recommended to place it before the LDREX/STREX sequence, and implement the LDREX/STREX sequence as recommended by the ARM architecture.	ERR005185 ARM/MP: 771225âSpeculative cacheable reads to aborting memory region clear the internal exclusive monitor, may lead to livelock
Cortex A-9	NXP	IMX6DQ	PARITYFAIL signal bits [7] and [6] are expected to report parity errors occurring on the BTAC and GHB RAMs, when the parity error detection logic is enabled (ACTLR[9]=1âb1). The erratum is that the Parity Enable bit, ACTLR[9], is not taken into account by the logic driving PARITYFAIL[7:6]. As a consequence, any parity error on the BTAC or GHB RAM will be reported on PARITYFAIL[7] or [6], even when parity error detection is not enabled. Conditions: The erratum happens on all configurations that have implemented parity support on the BTAC or GHB RAMs when dynamic branch prediction is enabled (SCTLR[11]=1âb1).	Because parity errors on the BTAC and GHB RAMs are not reported when the dynamic branch prediction is not enabled, the workaround consists in enabling parity error detection (ACTLR[9]), prior to enabling dynamic branch prediction (SCTLR[11]). In systems where branch prediction is enabled while parity error detection remains disabled, the workaround consists in ignoring any assertion on the PARITYFAIL[7:6] bits.	ERR005187 ARM/MP: 771223âParity errors on BTAC and GHB are reported on PARITYFAIL[7:6], regardless of the Parity Enable bit value
Cortex A-9	NXP	IMX6DQ	The PL310 L2 cache controller implements error logic to indicate errors have occurred when accessing the L2 cache RAM array. The following error information is available when accessing the RAM array: â¢ DATAERR (or DATAERR[3:0] if data banking is implemented) from Data RAM â¢ TAGERR[7:0] (or TAGERR[15:0] if 16 ways are implemented) from Tag RAM â¢ Parity error on Tag or Data RAM if parity is implemented This information is associated with each individual RAM access, and is only meant to be sampled by the PL310 internal access requestor at precise cycles, depending on the programmable latencies of the accessed RAM (see Technical Reference Manual (TRM) for more information on RAM latencies). More specifically, when an eviction is handled by the PL310 eviction buffer, both Tag and Data RAMs are accessed to get the whole eviction information. When either DATAERR or TAGERR is asserted high, or a tag parity error is detected during that process, the error information is captured by the eviction buffer, which cancels the corresponding eviction as a result. Due to this erratum, the eviction buffer can incorrectly sample error information. As a result, an eviction can be wrongly cancelled and dirty data can be lost, leading to data corruption. Note that data parity error is not part of this erratum. The reason is that this type of error information is not taken into account by the eviction buffer. This means that an eviction is always sent to the L3 memory system, regardless of whether a Data parity error has been detected or not, when accessing its data in the L2 cache. Conditions: The erratum occurs when the following conditions are met: â¢ The L2 cache contains dirty cache lines â¢ The eviction buffer accesses Tag and Data RAMs to get dirty cache line information before replacement â¢ While the eviction buffer accesses the RAMs, a tag parity error is detected, or DATAERR or TAGERR are asserted HIGH, but this error information is not meant to be captured by the eviction buffer (it may be directed to another PL310 block or DATAERR may be transiently asserted high before the end of the Data RAM latency period) â¢ The eviction buffer incorrectly samples the error information and cancels the corresponding eviction	The following two software workarounds are available for systems affected by this erratum: â¢ Use write-through memory attributes for all cacheable accesses targeting PL310. â¢ Disable the logic responsible for generating RAM errors. This can imply disabling parity in PL310 and/or disabling DATAERR and TAGERR generation in the RAM array, depending on the implementation.	ARM/PL310: 780370âDATAERR, TAGERR, and Tag parity errors are incorrectly sampled by the eviction buffer, leading to data corruption
Cortex A-9	NXP	IMX6DQ			Software workaround not implemented in Linux BSP. Functionality or mode of operation in which the erratum may manifest itself is not used. The erratum only affects configurations which implement the parity support option. i.MX6 parity is not supported. In the Freescale Linux implementation, the parity error detection is disabled and GIC parity interrupt 125, is masked in the BSP. The parity feature is disabled by default and should not be enabled
Cortex A-9	NXP	IMX6DQ	The PL310 Store Buffer does not have any automatic draining mechanism. Any written data might consequently remain in this buffer, invisible to the rest of the system. In case an L3 external agent keeps on polling this memory location, waiting to see the update of the written data to make any further progress, then a system livelock might happen. Conditions: The erratum can only happen on Normal Memory regions. The following scenario is an example which can exhibit the erratum, where an L3 agent might loop infinitely waiting for the notification from CPU for an unbounded amount of time: â¢ An L3 agent is waiting for notification from CPU before making progress. â¢ CPU attached to PL310 issues such notification via a write access, which stays in PL310 store buffer. â¢ No additional activity forcing the store buffer to drain is received by PL310.	If a write access needs to be made visible to an L3 external agent, the workaround for this erratum consists of using a Cache Sync operation in order to force the PL310 Store Buffer to drain. This is illustrated in the following pseudo-code sequence: STR // to be made visible to L3 DSB CACHE_SYNC. In r3p2, a counter is implemented so that slots are automatically drained after 256 cycles of presence in the store buffer. The i.MX 6Dual/6Quad has PL310-BU-00000-r3p1-50rel0.	ERR005199 ARM/MP: 769419âNo automatic Store Buffer drain, visibility of written data requires an explicit Cache Sync operation [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	When prefetch feature is enabled (bits [29:28] of the Auxiliary or Prefetch Control Register set HIGH), the prefetch offset bits of the Prefetch Control Register (bits [4:0]) permits to configure the advance taken by the prefetcher compared to the current cache line. Refer to the TRM for more information. One requirement for the prefetcher is not to go beyond a 4 KB boundary. If the prefetch offset is set to 23 (5'b10111), this requirement is not fulfilled and the prefetcher can cross a 4 KB boundary. This problem occurs when the following conditions are met: 1. One of the Prefetch Enable bits (bits [29:28] of the Auxiliary or Prefetch Control Register) is set HIGH. 2. The prefetch offset bits are programmed with value 23 (5'b10111).	A workaround for this erratum is to program the prefetch offset with any value except 23.	ARM/MP: 765569âPrefetcher can cross 4 KB boundary if offset is programmed with value 23
Cortex A-9	NXP	IMX6DQ	The LDM PC ^ instructions with base address register write-back might be counted twice in the PMU event 0x0A, which is counting the number of exception returns. The associated PMUEVENT[11] signal is also affected by this erratum, and might be asserted twice by a single LDM PC ^ instruction with base address register write-back.	There is no workaround to this erratum.	ERR005382 ARM/MP: 775419âPMU event 0x0A (exception return) might count twice the LDM PC ^ instructions with base address register write-back
Cortex A-9	NXP	IMX6DQ	Under certain micro-architectural circumstances, a data cache maintenance operation that aborts, followed by an ISB and with no DSB occurring between these events, might lead to processor deadlock. Conditions: The erratum occurs when the following conditions are met: â¢ Some write operations are handled by the processor, and take a long time to complete. The typical situation is when the write operation (STR, STM, â¦) has missed in the L1 Data Cache. â¢ No memory barrier (DMB or DSB) is inserted between the write operation and the data cache maintenance operation mentioned in condition 3. â¢ A data cache maintenance operation is performed, which aborts due to its MMU settings. â¢ No memory barrier (DMB or DSB) is inserted between the data cache maintenance operation in previous condition and the ISB in next condition. Any other kind of code can be executed here, starting with the abort exception handler, following the aborted cache maintenance operation. â¢ An ISB instruction is executed by the processor. â¢ No memory barrier (DMB or DSB) is inserted between the ISB in previous condition and the read or write operation in next condition. â¢ A read or write operation is executed. With the above conditions, an internal âData Side drain requestâ signal might remain sticky, causing the ISB to wait for the Data Side to be empty, which never happens because the last read or write operation waits for the ISB to complete.	A simple workaround for this erratum is to add a DSB at the beginning of the abort exception handler.	ARM/MP: 775420âA data cache maintenance operation that aborts, followed by an ISB and without any DSB in-between, might lead to deadlock
Cortex A-9	NXP	IMX6DQ	Under certain timing circumstances, a processor might deadlock when the execution of a write to a Strongly Ordered memory region is followed by the speculative execution of a Load-Exclusive or a Store-Exclusive instruction that is mis-speculated. The mis-speculation can be due to either the Load-Exclusive or Store-Exclusive instruction being conditional, and failing its condition code check, or to the Load-Exclusive or Store-Exclusive instruction being speculatively executed in the shadow of a mispredicted branch. Conditions: The erratum requires the following conditions: â The processor executes a write instruction to a Strongly Ordered memory region â The processor speculatively executes a Load-Exclusive or Store-Exclusive instruction that is either: a) A conditional instruction b) An instruction in the shadow of a conditional branch. â The Load-Exclusive or Store-Exclusive instruction is cancelled because the speculation was incorrect, because either: a) The conditional Load-Exclusive or Store-Exclusive instruction failed its condition-code check b) The conditional branch was mispredicted, so that all subsequent instructions speculatively executed must be flushed, including the Load-Exclusive or Store-Exclusive. The erratum also requires additional timing conditions to be met. These are specific to each platform, and are not controllable by software. These timing conditions includes the fact that the response to the Strongly Ordered write from the external memory system must be received at the same time as the mis-speculation is identified in the processor.	The recommended workaround is to place a DMB instruction before each Load-Exclusive / Store-Exclusive loop sequence, to ensure that no pending write request can interfere with the execution of the Load-Exclusive or Store-Exclusive instructions. The implementation of this workaround can be restricted to code regions which have access to Strongly Ordered memory.	ERR005385 ARM/MP: 782772âA speculative execution of a Load-Exclusive or Store-Exclusive instruction after a write to Strongly Ordered memory might deadlock the processor
Cortex A-9	NXP	IMX6DQ	Under certain conditions specific to the Cortex-A9 micro-architecture, a write operation that updates a Cacheable translation table entry might cause both the old and the new translation entry to be temporarily invisible to translation table walks, thus erroneously causing a translation fault. Conditions: The erratum occurs when the following conditions are met: â¢ The processor has its Data Cache and MMU enabled. â¢ The TTB registers are set to work on Cacheable descriptors memory regions. â¢ The processor is updating an existing Cacheable translation table entry, and this write operation hits in the L1 Data Cache. â¢ A hardware translation table walk is attempted. The hardware translation table walk can be either due to an Instruction fetch, or due to any other instruction execution that requires an address translation, including any load or store operation. This hardware translation walk must attempt to access the entry being updated in condition 2, and that access must hit in the L1 Data Cache. In practice, this scenario can happen when an operating system (OS) is changing the mapping of a physical page. The OS might have an existing mapping to a physical page (the old mapping), but wants to move the mapping to a new page (the new mapping). To do this, the OS might: 1. Write a new translation entry, without cancelling the old one. At this point the physical page is accessible using either the old mapping or the new mapping. 2. Execute a DSB instruction followed by an ISB instruction pair, to ensure that the new translation entry is fully visible. 3. Remove the old entry. Due to the erratum, this sequence might fail because it can happen that neither the new mapping, nor the old mapping, is visible after the new entry is written, causing a Translation fault.	The recommended workaround is to perform a clean and invalidate operation on the cache line that contains the translation entry before updating the entry, to ensure that the write operation misses in the Data Cache. This workaround prevents the micro-architectural conditions for the erratum from happening. Interrupts must be temporarily disabled so that no interrupt can be taken between the maintenance operation and the translation entry update. This avoids the possibility of the interrupt service routine bringing the cache line back in the cache. Note that inserting a DSB instruction immediately after writing the new translation table entry significantly reduces the probability of hitting the erratum, but it is not a complete workaround.	ERR005386 ARM/MP: 782773âUpdating a translation entry to move a page mapping might erroneously cause an unexpected translation fault
Cortex A-9	NXP	IMX6DQ	A write to Strongly Ordered memory region, followed by the execution of an LDREX instruction, can cause the âSTREX passedâ event to be signaled even if no STREX instruction is executed. As a result, the event 0x63 count might be faulty, reporting too many âSTREX passedâ events. This erratum also affects the associated PMUEVENT[27] signal. This signal will report the same spurious events. Conditions: The erratum occurs when the following conditions are met: â¢ The processor executes a write instruction to a Strongly Ordered memory region. â¢ The processor executes an LDREX instruction. â¢ No DSB instruction is executed, and there is no exception call or exception return, between the write and the STREX instructions. Under these conditions, if the write instruction to Strongly Ordered memory region receives its acknowledge (BRESP response on AXI) while the LDREX is being executed, the erratum can happen.	The workaround for this erratum is to insert a DMB or DSB instruction between the write to Strongly Ordered memory region and the LDREX instruction.	ERR005387 ARM/MP: 782774âA spurious event 0x63, âSTREX passed,â can be reported on an LDREX that is preceded by a write to Strongly Ordered memory region
Cortex A-9	NXP	IMX6DQ	When JTAG_TCK is not toggling after power-on reset (POR), the ARM PMU, PTM, and ETB stay in their disabled states so various debug and trace functions are not available.	Provide at least 4 JTAG_TCK clock cycles following POR if the PMU, PTM and ETB functions will be used. A free-running JTAG_TCK can also be used.	ARM: Debug/trace functions (PMU, PTM and ETB) are disabled with absence of JTAG_TCK clock after POR
Cortex A-9	NXP	IMX6DQ	A processor which continuously executes a short loop containing a DMB instruction might prevent a CP15 operation broadcast by another processor from making further progress, thus causing a denial of service. The erratum requires the following conditions: â¢ Two or more processors are working in SMP mode (ACTLR.SMP=1) â¢ One of the processors continuously executes a short loop containing at least one DMB instruction. â¢ Another processor executes a CP15 maintenance operation that is broadcast. This requires that this processor has enabled the broadcasting of CP15 operations (ACTLR.FW=1) For the erratum to occur, the short loop containing the DMB instruction must meet all of the following additional conditions: â¢ No more than 10 instructions other than the DMB are executed between each DMB â¢ No nonconditional Load or Store, or conditional Load or Store which pass the condition code check, are executed between each DMB When all the conditions for the erratum are met, the short loop creates a continuous stream of DMB instructions. This might cause a denial of service, by preventing the processor executing the short loop from executing the received broadcast CP15 operation. As a result, the processor that originally executed the broadcast CP15 operation is stalled until the execution of the loop is interrupted. Note that because the process issuing the CP15 broadcast operation cannot complete operation, it cannot enter any debug mode, and cannot take any interrupt. If the processor executing the short loop also cannot be interruptedâfor example if it has disabled its interruptsâor if no interrupts are routed to this processor, this erratum might cause a system livelock.	This erratum can be worked around by setting bit[4] of the undocumented Diagnostic Control register to 1. This register is encoded as CP15 c15 0 c0 1. This bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x10 MCR p15,0,rt,c15,c0,1 When it is set, this bit causes the DMB instruction to be decoded and executed like a DSB. Using this software workaround is not expected to have any impact on the overall performance of the processor on a typical code base. - Inserting a nonconditional Load or Store instruction in the loop between each DMB - Inserting additional instructions in the loop, such as NOPs, to prevent the processor from seeing back-to-back DMB instructions. - Making the processor executing the short loop take regular interrupts.	ERR007006 ARM/MP:794072-- Short loop including a DMB instruction might cause a denial of service
Cortex A-9	NXP	IMX6DQ	When the MMU is disabled, the ARM processor must follow some architectural rules regarding speculative fetches and the addresses to which these can be initiated. These rules avoid potential read accesses to read-sensitive areas. For more information about these rules, see the description of âBehavior of instruction fetches when all associated MMUs are disabledâ in the ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition. A Cortex-A9 processor usually operates with both the MMU and branch prediction enabled. If the processor operates in this condition for any significant amount of time, the BTAC (branch target address cache) will contain branch predictions. If the MMU is then disabled, but branch prediction remains enabled, these stale BTAC entries can cause the processor to violate the rules for speculative fetches. The erratum can occur only if the following sequence of conditions is met: 1. MMU and branch prediction are enabled. 2. Branches are executed. 3. MMU is disabled, and branch prediction remains enabled.	The recommended workaround is to invalidate all entries in the BTAC, by executing a BPIALL operation (invalidate entire branch prediction array) followed by a DSB, before disabling the MMU. Another possible workaround is to disable branch prediction when disabling the MMU, and keep branch prediction disabled until the MMU is re-enabled.	ERR007007 ARM/MP: 794073 -- Speculative instruction fetches with MMU disabled might not comply with architectural requirements
Cortex A-9	NXP	IMX6DQ	Under certain timing circumstances specific to the Cortex-A9 microarchitecture, a write request to an Uncacheable, Shareable, Normal memory region might be executed twice, causing the write request to be sent twice on the AXI bus. This might happen when the write request is followed by another write into the same naturally aligned doubleword memory region, without a DMB between the two writes. The repetition of the write usually has no impact on the overall behavior of the system, unless the repeated write is used for synchronization purposes. The erratum requires the following conditions: â¢ A write request is performed to an Uncacheable, Shareable, Normal memory region. â¢ Another write request is performed into the same naturally doubleword-aligned memory region. This second write request must not be performed to the exact same bytes as the first store. A write request to Normal memory region is treated as Uncacheable in the following cases: 1. The write request occurs while the data cache is disabled. 2. The write request is targeting a memory region marked as Normal Memory Non-Cacheable or Cacheable Write-Through. 3. The write request is targeting a memory region marked as Normal Memory Cacheable Write-Back and Shareable, and the CPU is in AMP mode.	There are several possible workarounds: 1. Add a DMB after clearing a communication variable: STR r0, [r1] ; clear the communication variable DMB ; ensure the previous STR is complete Also, any IRQ or FIQ handler must execute a DMB at the start to ensure the clearing of any communication variable is complete. 2. Ensure there is no other data using the same naturally aligned 64-bit memory location as the communication variable: ALIGN 64 communication_variable DCD 0 unused_data DCD 0 LDR r1,= communication_variable 3. Use a Store-Exclusive to clear the communication variable, rather than a non-Exclusive store.	ARM/MP: 794074 --A write request to Uncacheable Shareable memory region might be executed twice
Cortex A-9	NXP	IMX6DQ	Under very rare timing circumstances, a data corruption might occur on a dirty cache line that is evicted from the L1 Data Cache due to another cache line being entirely written. The erratum requires the following conditions: â¢ The CPU contains a dirty line in its data cache. â¢ The CPU performs at least four full cache line writes, one of which is causing the eviction of the dirty line. â¢ Another CPU, or the ACP, is performing a read or write operation on the dirty line. The defect requires very rare timing conditions to reach the point of failure. These timing conditions depend on the CPU micro-architecture, and are not controllable in software: â¢ The CPU must be in a transitional mode that might be triggered by the detection of the first two full cache line writes. â¢ The evicted line must remain stalled in the eviction buffer, which is likely to be caused by a congested write traffic. â¢ The other coherent agent, either another CPU in the cluster or the ACP, must perform its coherency request on the evicted line while it is in the eviction buffer. This erratum only occurs when two or more processors are enabled.	This erratum can be worked round by setting bit[22] of the undocumented Diagnostic Control Register to 1. This register is encoded as CP15 c15 0 c0 1. The bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x00400000 MCR p15,0,rt,c15,c0,1 When this bit is set, the processor is unable to switch into Read-Allocate (streaming) mode, which means this erratum cannot occur. Setting this bit could possibly result in a visible drop in performance for routines that perform intensive memory accesses, such as memset() or memcpy(). However, the workaround is not expected to create any significant performance degradation in most standard applications.	ARM (CA9): 845369 â Under very rare timing circumstances, transition into streaming mode might create a data corruption
Cortex A-9	NXP	IMX6DQ	Under very rare circumstances, full cache line writes from (at least) 2 processors on cache lines in hazard with other requests may cause arbitration issues in the SCU, leading to processor deadlock. To trigger the erratum, at least three agents need to be working in SMP mode, and accessing coherent memory regions. Two or more processors need to perform full cache line writes, to cache lines which are in hazard with other access requests in the SCU. The hazard in the SCU happens when another processor, or the ACP, is performing a read or a write of the same cache line. The following example describes one scenario that might cause this deadlock: - CPU0 performs a full cache line write to address A, then a full cache line write to address B - CPU1 performs a full cache line write to address B, then a full cache line write to address A - CPU2 performs read accesses to addresses A and B Under certain rare timing circumstances, the requests might create a loop of dependencies, causing a processor deadlock.	This erratum can be worked around by setting bit[21] of the undocumented Diagnostic Control Register to 1. This register is encoded as CP15 c15 0 c0 1. The bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x200000 When this bit is set, the âdirect evictionâ optimization in the Bus Interface Unit is disabled, which means this erratum cannot occur. Setting this bit might prevent the Cortex-A9 from utilizing the full bandwidth when performing intensive full cache line writes, and therefore a slight performance drop might be visible. In addition, this erratum cannot occur if at least one of the following bits in the Diagnostic Control Register is set to 1: - bit [23] â Disable Read-Allocate mode - bit [22] â Disable Write Allocate Wait mode	ARM (CA9): 761320âFull cache line writes to the same memory region from at least two processors might deadlock the processor
Cortex A-9	NXP	IMX6DQ	When selected, the Write Context ID event (event 0x0B) of the Performance Monitoring Unit (PMU) increments a counter whenever an instruction that writes to the Context ID register, CONTEXTIDR, is architecturally executed. However this erratum means that an instruction that reads the Context ID register also updates this counter. The erratum can happen under the following conditions: 1. A PMU counter is enabled, by setting the PMCNTENSET.Px bit to 1 (x identifies a single event counter, and takes a value from 0 to 7). 2. The âWrite Context IDâ event is mapped to this selected PMU counter: a. The chosen PMU counter is selected, by setting PMSELR.SEL to x (the same value as in condition 1). b. The âWrite Context IDâ event is mapped to this selected PMU, by setting PMXEVTYPER.evtCount to 0x0B. 3. The PMU is enabled, by setting the PMCR.E bit to 1. 4. A read access occurs to the CONTEXTIDR. In this situation the PMU updates the counter when it should not.	There is no workaround for this erratum. The Freescale Linux BSP does not enable this optional profiling feature by default. Users may add support for this profiling feature as required, but should ensure the multiple ARM errata impacting the ARM PMU are considered.	ARM: 795769 - âWrite Context ID" event is updated on read access
Cortex A-9	NXP	IMX6DQ	DBGPRSR.SR, bit [3], is the Sticky Reset status bit. The ARM architecture specifies that the processor sets this bit to 1 when the non-debug logic of the processor is in reset state. Because of this erratum, the Cortex-A9 processor sets this bit to 1 when the debug logic of the processor is in reset state, instead of when the non-debug logic of the processor is in reset state.	No software workaround available as this erratum is related to a debug feature. Users should not rely on the DBGPRSR.SR bit during the debug session.	ERR009743 ARM: 799770 - DBGPRSR Sticky Reset status bit is set to 1 by the CPU debug reset instead of by the CPU non-debug reset
Cortex A-9	NXP	IMX6DQ	When parity is implemented and enabled in the PL310 Level-2 Cache Controller, for each read from the Data RAM, parity of the read data DATARD[255:0] is compared with stored parity bits in dedicated RAMs present on DATAPRD[31:0]. If the comparison does not match, the error is reported using an interrupt mechanism consisting of dedicated registers (Raw and Masked Interrupt registers). This erratum occurs when the following conditions exist: 1) Parity is enabled (bit[21] of the Auxiliary Control Register is set to 1) 2) Read access latency on Data RAM is programmed with a value > 0x0 (bits [6:4] of the Data RAM Latency Register) When the conditions above are met, parity checking between DATARD and DATAPRD occurs during a two cycle window, including one cycle earlier than expected. If, in the early cycle, DATARD and DATAPRD are not stable yet, parity comparison might fail. In this case, an error is reported by the Interrupt registers, where no actual error exists.	The following software workarounds can be used to avoid this erratum: 1) Disable parity by setting bit [21] of the Auxiliary Control Register to 0 (this is the default condition). 2) Program the read access latency of the Data RAM to the minimum value acceptable for the implementation plus one (bits [6:4] of the Data RAM Latency Control Register). Note that this workaround can affect performance.	ARM/PL310: 796171 When data banking is implemented, data parity errors can be incorrectly generated
Cortex A-9	NXP	IMX6DQ	In the CAAM block, the availability of the AES, DES and RC4 crypto accelerators are controlled by the EXPORT_CONTROL fuse. If this fuse is blown these crypto accelerators are not available. There is also a CAAM CHANUM register (AES is bits [3:0], DES is bits [7:4] and RC4 is bits [11:8]) that shows the number of crypto accelerators available for each type of crypto operation. When this fuse is blown, this register should show that there are 0 of each encryption accelerator. However, it actually shows that 1 is available.	Software should check the EXPORT_CONTROL fuse in OCOTP to determine if the crypto accelerators are available or not instead of reading the CAAM CHANUM register.	ERR004320 CAAM: Three encryption functions may show up as available, even though they are not
Cortex A-9	NXP	IMX6DQ	CAAM secure memory has settable access permissions. One setting is to create a protected key partition, which can be accessed by CAAM to read a key, but that cannot be read or written by any other hosts. The purpose is to provide a place to store secret keys that cannot be compromised by any software. In order to store a key into such a partition, which does not allow a write access to occur, there is an access bit labeled SMBLOB (Secure Memory Blob), which allows CAAM to write data to the partition from a decapsulated blob, or to read the data from the partition in order to package it into a blob. The issue found is that CAAM logs a read access error into a status register when it decapsulates a blob and writes the contents to the protected key partition. This logging of the read access error into a status register does not appear to have any other affect. It does not prevent the blob contents from being correctly written to the protected key partition.	The software workaround for this erratum is to clear the error code after the blob is decapsulated by reading the status register and ignoring its contents.	CAAM: False read access error
Cortex A-9	NXP	IMX6DQ	The internal 16 Kb RAM (CAAM - Secure memory) does not support wrapped accesses.	The Internal 16 Kb RAM accesses (CAAM) should not be cached. Users should ensure that the MMU table does not have this 16 Kb region mapped as cacheable memory region to prevent incorrect accesses.	ERR004348 CAAM: Internal 16 Kb RAM (CAAM) does not support wrapped accesses
Cortex A-9	NXP	IMX6DQ	The CAAM can issue several transactions with different AXI-IDs but its AXI master port does not handle interleaved data properly. The faulty behavior is expected to occur when working in DDR interleaving mode. For example, one access with ID X is directed to DDR0, while almost simultaneously, another access with different AXI-ID is passed to the second DDR controller. This way the data âbeatsâ of the two AXI-IDs may be replied interleaved. CAAM has two sources of transactionsâfirst, the Job Queue controller, which fetches jobs and prepares descriptors to be run, and second, the DECO, which executes the descriptors. With a single DECO, there are less chances of the Job Queue controller and DECO to overlap while performing AXI read requests.	There are two workarounds for this issue. They both prevent CAAM from issuing multiple AXI read transactions with different AXI-IDs. The workarounds are as follows: â¢ Workaround 1: The first workaround is to only issue a single descriptor to CAAM at a time. CAAM will not pre-fetch a second descriptor, as there is no second descriptor. HAB uses this approach. HAB in i.MX 6 Series only issues one descriptor at a time. â¢ Workaround 2: The second workaround is for cases where multiple descriptors will be issued to CAAM, (for example, a Linux device driver). In this case, CAAM can be configured to only issue one AXI transaction at a time by setting the CAAM AXI pipeline depth to 1. This will prevent multiple outstanding transactions, and thus multiple transactions with different AXI-IDs. This is done by setting the AXIPIPE field of the CAAM Master Configuration Register (MCFGR) to 1. The workaround seems to have minimal impact on the performance.	CAAM: CAAM cannot handle interleaved READ data âbeatsâ returned by two different slaves in the system, in reply to two different AXI-ID accesses
Cortex A-9	NXP	IMX6DQ	When entering Wait/Stop mode with power gating of the ARM core(s), if an interrupt arrives during the power-down sequence, the system could enter an unexpected state and fail to resume.	Use REG_BYPASS_COUNTER (RBC) to hold off interrupts when the PGC unit is in the middle of the power-down sequence. The counter needs to be set/cleared only when there are no interrupts pending. The counter needs to be enabled as close to the WFI (Wait For Interrupt) state as possible. The following equation can be used to aid determination of the RBC counter value: RBC_COUNT Ã (1/32K RTC Frequency) â¥ (25 + PDNSCR_SW2ISO) Ã (1/IPG_CLK Frequency) PDNSCR_ISO2SW = PDNSCR_ISO = 1 (counts in IPG_CLK clock domain)	ERR006223 CCM: Failure to resume from Wait/Stop mode with power gating
Cortex A-9	NXP	IMX6DQ	When software tries to enter Low-Power mode with the following sequence, the SoC enters Low-Power mode before the ARM core executes the WFI instruction: 1. Set CCM_CLPCR[1:0] to 2âb00 2. ARM core enters WFI 3. ARM core wakeup from an interrupt event, which is masked by GPC or not visible to GPC, such as an interrupt from a local timer 4. Set CCM_CLPCR[1:0] to 2âb01 or 2âb10 5. ARM core executes WFI Before the last step, the SoC enters WAIT mode if CCM_CLPCR[1:0] is set to 2âb01, or STOP mode if CCM_CLPCR[1:0] is set to 2âb10.	Software workaround: 1) Software should trigger IRQ #32 (IOMUX) to be always pending by setting IOMUX_GPR1_GINT 2) Software should then unmask IRQ #32 in GPC before setting CCM Low-Power mode 3) Software should mask IRQ #32 right after CCM Low-Power mode is set (set bits 0â1 of CCM_CLPCR)	CCM: When improper low-power sequence is used, the SoC enters low power mode before the ARM core executes WFI
Cortex A-9	NXP	IMX6DQ	Certain applications require the source clock of the LVDS Display Bridge (LDB) to be modified to accommodate various display clock frequency requirements. The clock source can be modified by programming an asynchronous clock multiplexer (CCM_CS2CDR[LDB_DIx_CLK_SEL]) in software. Asynchronous multiplexers or glitchy multiplexers, enable the clock to switch immediately after the multiplexer select is changed. Because both clock sources to the multiplexer are asynchronous, switching the clocks from one source to the other can cause a glitch to be generated, regardless of the input clock source. This immediate switch of two asynchronous clock domains can cause the output clock to glitch. If the input and output clocks are not gated, this clock glitch can propagate to the logic that follows the clock multiplexer, causing the logic to behave unpredictably. A clock gate has not been implemented after the asynchronous clock multiplexer for the LDB_DI0_IPU clock and LDB_DI1_IPU clocks. Due to the absence of this clock gate on this LDB_DIx_IPU clock path, a glitch generated when the clock source is switched, can lock up the LDB divider causing a loss of the LDB_DIx_IPU clock under certain conditions.	The input and output clocks to the asynchronous clock multiplexer are required to be gated prior to switching the source clock. The recommended software workaround is to shut down the clocks to the asynchronous clock multiplexor (CS2CDR: LDB_DIx_CLK_SEL) by disabling the respective PLLs and PFDs prior to performing the clock switch. After the clock switch is performed the input and output clocks of the multiplexer are re-enabled. Users must ensure that the PFDs are reset after the respective PLLs are locked. It is recommended to perform the LDB clock switch early in the boot process to minimize the clocking impact. Please refer to Engineering Bulletin EB821 : LDB Clock Switch Procedure and i.MX6 Asynchronous Clock Switching Guidelines for further details on the issue and recommended software workaround procedure. No fix scheduled Linux BSP Status: Software workaround integrated in Linux BSP codebase starting in release imx_3.0.35_4.1.0	ERR009219 CCM: Asynchronous clock switching can cause unpredictable behavior [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	When using DMA to transfer data to the TXFIFO, if the data is written to the TXFIFO during an active eCSPI data exchange, this can cause a glitch in the TXFIFO empty signal, resulting in the TXFIFO read pointer (TXCNT) not updating correctly, which in turn results in the current transfer getting resent a second time.	This errata is only seen when the SMC (Start Mode Control) bit is set. A modified SDMA script with TX_THRESHOLD = 0 and using only the XCH (SPI Exchange) bit to initiate transfers prevents this errata from occurring. There is an associated performance impact with this workaround. Testing transfers to a SPI-NOR flash showed approximately a 5% drop in write data rates and a 25% drop in read data rates.	ERR009165 eCSPI: TXFIFO empty flag glitch can cause the current FIFO transfer to be sent twice
Cortex A-9	NXP	IMX6DQ	According to the eCSPI specifications, when eCSPI is set to operate in the Slave mode (CHANNEL_MODE[x] = 0), the SS_CTL[x] bit controls the behavior of burst completion. In the Slave mode, the SS_CTL bit should control the behavior of SPI burst completion as follows: â¢ 0âSPI burst completed when (BURST_LENGTH + 1) bits are received â¢ 1âSPI burst completed when the SS input is negated Also, in BURST_LENGTH definition, it is stated âIn the Slave mode, this field takes effect in SPI transfer only when SS_CTL is cleared.â However, the mode SS_CTL[x] = 1 is not functional in Slave mode. Currently, BURST_LENGTH always defines the burst length. According to the SPI protocol, negation of SSB always causes completion of the burst. However, due to the above issue, the data is not sampled correctly in RxFIFO when {BURST_LENGTH+1}mod32 is not equal to {actual burst length}mod32. Therefore, setting the BURST_LENGTH parameter to a value greater than the actual burst does not resolve the issue.	There is no workaround except for not using the SS_CTL[x] = 1 option in the Slave mode. The accurate burst length should always be specified using the BURST_LENGTH parameter.	eCSPI: Burst completion by SS signal in slave mode is not functional
Cortex A-9	NXP	IMX6DQ	When the ECSPI is configured in master mode and the burst length is configured to a value 32n+1 (where n=0,1, 2,â¦), the ECSPI will transmit the portions of the first word in the FIFO twice. For example, if the transmit FIFO is loaded with: [0] 0x00000001 [1] 0xAAAAAAAA And the burst length is configured for 33 bits (ECSPIx_CONREG[BURST_LENGTH]=0x020), the ECSPI will transmit the first bit of word [0] followed by the entire word [0], then transmit the data as expected. The transmitted sequence in this example will be: [0] 0x00000001 [1] 0x00000001 [2] 0x00000000 [3] 0xAAAAAAAA	Do not use burst lengths of 32n+1 (where n=0,1, 2,â¦).	ERR009606 eCSPI: In master mode, burst lengths of 32n+1 will transmit incorrect data
Cortex A-9	NXP	IMX6DQ	When the AUS bit is set, the address lines of the EIM are unshifted. By default, the AUS bit is cleared and address lines are shifted according to port size (8, 16 or 32 bits). Due to an error, the address bits 27:24 are shifted when AUS=1. For example, CPU address 0xBD00_0000 ([A27:20]=1101 0000 becomes 0xB600_0000 ([A27:20]=0110 0000) on the EIM bus, because A[27:25] is shifted to [A26:24] and A[23:0] is not shifted. As a result A[24] is missed.	â¢ Use the AUS = 0 mode (default) while connecting the address signals without a shift (for example, A0âA0 and A1âA1). â¢ For AUS=1, for devices larger than 32 MB, it is necessary to build a memory map that takes this shifting into consideration and does not include A[24] line.	EIM: AUS mode is nonfunctional for devices larger than 32 MB
Cortex A-9	NXP	IMX6DQ	During boundary scan test, a subset of the EIM signals will not be driven as outputs causing the test to fail. The affected signals are: EIM_A[24:16], EIM_DA[15:0], EIM_EB[3:0], EIM_RW, EIM_WAIT and EIM_LBA. This group of signals is incorrectly configured with a drive strength value (DSE) of 3âb000, which causes the signals to be Hi-Z.	Because the signals listed above cannot be driven as outputs, interconnect tests on these signals can only be performed if the external devices connected to these pins can drive them as inputs. The boundary scan test generation tool should be configured to test these signals as input-only, if possible. Test of any of the signals that cannot be driven by an external device should be disabled in the boundary scan test generation tool to prevent generation of an incorrect test pattern.	ERR009218 EIM: Signals fail to drive as outputs during boundary scan test
Cortex A-9	NXP	IMX6DQ	The theoretical maximum performance of 1 Gbps ENET is limited to 470 Mbps (total for Tx and Rx). The actual measured performance in an optimized environment is up to 400 Mbps.	There is no workaround for the throughput limitation. To prevent overrun of the ENET RX FIFO, enable pause frame.	ENET: 1 Gb Ethernet MAC (ENET) system limitation
Cortex A-9	NXP	IMX6DQ	When the MAC receives shorter frames (size 64 bytes) at a rate exceeding the average line-rate burst traffic of 400 Mbps the DMA is able to absorb, the receiver might drop incoming frames before a Pause frame is issued.	The application might want to implement some flow control to ensure the line-rate burst traffic is below 400 Mbps if it only uses consecutive small frames with minimal (96 bit times) or short Inter-frame gap (IFG) time following large frames at such a high rate. The limit does not exist for frames of size larger than 800 bytes.	ERR005783 ENET: ENET Status FIFO may overflow due to consecutive short frames
Cortex A-9	NXP	IMX6DQ	The ENET module provides a 4-channel IEEE 1588 compliant timer that supports event input capture and output compare mode. The capture/compare feature requires the ENET 1588 clock to latch in the correct IEEE 1588 counter value to the Timer Compare Capture Register (ENET_TCCRn). Due to an integration issue, the ENET 1588 clock and Channel 2 event capture/compare signal are both connected to the same GPIO16 pin.	None. Channels 1, 3, and 4 can be used for the event capture instead.	ENET: ENET 1588 channel 2 event capture mode not functional
Cortex A-9	NXP	IMX6DQ	If the ready bit in the transmit buffer descriptor (TxBD[R]) is previously detected as not set during a prior frame transmission, then the ENET_TDAR[TDAR] bit is cleared at a later time, even if additional TxBDs were added to the ring and the ENET_TDAR[TDAR] bit is set. This results in frames not being transmitted until there is a 0-to-1 transition on ENET_TDAR[TDAR].	Code can use the transmit frame interrupt flag (ENET_EIR[TXF]) as a method to detect whether the ENET has completed transmission and the ENET_TDAR[TDAR] has been cleared. If ENET_TDAR[TDAR] is detected as cleared when packets are queued and waiting for transmit, then a write to the TDAR bit will restart TxBD processing.	ERR006358 ENET: Write to Transmit Descriptor Active Register (ENET_TDAR) is ignored
Cortex A-9	NXP	IMX6DQ	The ENET block generates many interrupts. Only one of these interrupt lines is connected to the General Power Controller (GPC) block, but a logical OR of all of the ENET interrupts is connected to the General Interrupt Controller (GIC). When the system enters Wait mode, a normal RX Done or TX Done does not wake up the system because the GPC cannot see this interrupt. This impacts performance of the ENET block because its interrupts are serviced only when the chip exits Wait mode due to an interrupt from some other wake-up source.	All of the interrupts can be selected by MUX and output to pad GPIO6. If GPIO6 is selected to output ENET interrupts and GPIO6 SION is set, the resulting GPIO interrupt will wake the system from Wait mode.	ENET: Only the ENET wake-up interrupt request can wake the system from Wait mode [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	While using ESAI transmit or receive and an underrun/overrun happens, channel swap may occur. The only recovery mechanism is to reset the ESAI.	Underrun/overrun in the ESAI should be prevented at the system level. If channel swap occurs, the ESAI must be reset according to the reset procedure documented in the reference manual.	ERR008000 ESAI: ESAI may encounter channel swap when overrun/underrun occurs
Cortex A-9	NXP	IMX6DQ	Any exclusive operation to PSRAM or other RAM typeâs connected to the EIM returns an incorrect response of âEXOKAYâ, indicating that exclusive writes are always successful.	Use DDR or OCRAM memories when performing exclusive accesses.	EXSC: Exclusive accesses to certain memories are not supported to full AXI specification
Cortex A-9	NXP	IMX6DQ	If a write access to the EIM address region is denied due to the CSU access control policy, then, all subsequent write accesses to the EIM region will write unintended data.	To prevent unpredictable behavior, prior to accessing the EIM region, set all bits in the EIM CSU_CSL field to 1 so that all accesses are allowed. Specifically: EIM: CSU_CSL31[23:16] = 0xff	ERR005828 EXSC: Protecting the EIM memory map region causes unpredictable behavior
Cortex A-9	NXP	IMX6DQ	FlexCAN does not transmit a message that is enabled to be transmitted in a specific moment during the arbitration process. The following conditions are necessary for the issue to occur: â¢ Only one message buffer is configured to be transmitted â¢ The write which enables the message buffer to be transmitted (write on Control/Status word) happens during a specific clock during the arbitration process. â¢ After this arbitration process occurs, the bus goes to the Idle state and no new message is received on the bus. For example: 1. Message buffer 13 is deactivated on RxIntermission (write 0x0 to the CODE field from the Control/Status word) [First write to CODE] 2. Reconfigure the ID and data fields 3. Enable the message buffer 13 to be transmitted on BusIdle (write 0xC on CODE field) [Second write to CODE] 4. CAN bus keeps in Idle state 5. No write on the Control/Status from any message buffer happens. During the second write to CODE (step 3), the write must happen one clock before the current message buffer 13 to be scanned by arbitration process. In this case, it does not detect the new code (0xC) and no new arbitration is scheduled. The problem can be detected only if the message traffic ceases and the CAN bus enters into Idle state after the described sequence of events. There is no issue if any of the conditions below holds: â¢ Any message buffer (either Tx or Rx) is reconfigured (by writing to its CS field) just after the Intermission field. â¢ There are other configured message buffers to be transmitted â¢ A new incoming message sent by any external node starts just after the Intermission field.	To transmit a CAN frame, the CPU must prepare a message buffer for transmission by executing the following standard 5-step procedure: 1. Check if the respective interrupt bit is set and clear it. 2. If the message buffer is active (transmission pending), write the ABORT code (0b1001) to the CODE field of the Control/Status word to request an abortion of the transmission. Wait for the corresponding IFLAG to be asserted by polling the IFLAG register or by the interrupt request if enabled by the respective IMASK. Then read back the CODE field to check if the transmission was aborted or transmitted. If backwards compatibility is desired (MCR[AEN] bit negated), just write the INACTIVE code (0b1000) to the CODE field to inactivate the message buffer, but then the pending frame might be transmitted without notification. 3. Write the ID word. 4. Write the data bytes. 5. Write the DLC, Control and CODE fields of the Control/Status word to activate the message buffer. 6. The workaround consists of executing two extra steps: 7. Reserve the first valid mailbox as an inactive mailbox (CODE=0b1000). If RX FIFO is disabled, this mailbox must be message buffer 0. Otherwise, the first valid mailbox can be found using the "RX FIFO filters" table in the FlexCAN chapter of the chip reference manual. 8. Write twice INACTIVE code (0b1000) into the first valid mailbox. NOTE The first mailbox cannot be used for reception or transmission process.	FlexCAN: FlexCAN does not transmit a message that is enabled to be transmitted in a specific moment during the arbitration process
Cortex A-9	NXP	IMX6DQ	The NANDF_DQS output is only enabled in program operation for Toggle mode, but the Set Feature command also needs to use the NANDF_DQS signal to write data to the Toggle NAND flash. So the Set Feature command in Toggle mode is not supported.	None	GPMI: GPMI does not support the Set Feature command in Toggle mode
Cortex A-9	NXP	IMX6DQ	Accessing GPU2D when it is power-gated will cause a deadlock in the system.	GPU2D should not be mistakenly accessed by software when power-gated.	ERR004341 GPU2D: Accessing GPU2D when it is power-gated will cause a deadlock in the system
Cortex A-9	NXP	IMX6DQ	GPU2D supports BLIT acceleration by using the Graphics Device Interface (GDI) API. When using the stretch blit GDI API, if the stretch factor is exactly an integer, the resulting image has rendering errors.	There are no software workarounds that completely resolve the issue. The filter blit API can be used instead of the stretch blit for BLIT acceleration; however, there will be a performance impact and might not be suitable for all applications. The issue is not observed when the stretch blit for BLIT acceleration is not used.	GPU2D: Image quality degradation observed for stretch blits when the stretch factor is exactly an integer [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	The GPU3D L1 cache assumes that all memory requests are 16 bytes. If a request is 16 bytes, there are no issues since the data boundary lines up evenly. If a request is not aligned to 16 bytes, the memory controller will split those unaligned requests into two requests, doubling the number of requests processed internally in L1 cache.	Tune applications to access L1 cache and memory requests at 16 byte boundaries to prevent this issue (slight performance impact).	ERR004300 GPU3D: L1 cache performance drop [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	This issue causes a data alignment error under the following two corner case conditions: â¢ The last 16 bytes of the cache line are being sent to the memory controller when it is not ready â¢ The memory controllerâs âReadyâ signal is asserted for one cycle. It then reads 8 bytes of data and then the âReadyâ signal becomes de-asserted again. In the design, the memory controller uses the address of the last 8 bytes as the address of the entire cache line. When either of these conditions happens, the last 8 bytes of data are paired with the address of the subsequent cache line, and the entire cache line gets written to the wrong location. The likelihood of hitting this corner case is significantly reduced if the GPU3D core and shader clocks run at the same frequency.	None	GPU3D: L1 cache âWrite Address Dataâ pairing error [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	Texture attributes might be incorrectly reported by the Setup Engine, when the maximum X and/or Y vertex is very large (X or Y vertex greater than 8 million pixels), and consequently the Texture Engine might sample black texels.	No workaround at this time.	ERR005216 GPU3D: Black texels in Android App Singularity 3D [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	An intdone interrupt must be generated by the AHB Audio DMA when a DMA stop is requested and a series of AHB transfers is in progress in the AHB bus. Here, AHB Audio DMA does not generate an interrupt (intdone=1, register AHB_DMA_INT) after software forces the DMA to stop (stop_dma_transaction, register AHB_DMA_STOP) between individual AMBA AHB DMA transfers. For instance, assume that the AHB DMA has performed a series of AHB BUS transfers and its internal FIFO is full. The AHB DMA starts requesting more AHB BUS transfers only when the FIFO threshold is reached. In this time period, from the time when the FIFO is full to the time when AHB DMA starts requesting more transfers, any DMA stop request from software is not registered, and the AHB Audio DMA does not generate the intdone bit interrupt, although it stops requesting transactions. Conditions: â¢ Setup the system memory with low bandwidth audio (audio sampling rate: 32 kHz, two active channels) â¢ Configure the AHB Audio DMA with a data buffer larger than twice the configured FIFO size â¢ Start an Audio DMA transfer â¢ Wait for the AHB audio DMA to get bus access and to fill its internal FIFO â¢ Set stop_dma_transaction bit field (AHB_DMA_STOP register)	Poll IH_AHBDMAAUD_STAT0 bit 2 to check when DMA transaction is complete	HDMI: 9000446457âAudio DMA does not generate an interrupt after software stops DMA transaction
Cortex A-9	NXP	IMX6DQ	When AHB audio DMA Master uses incrementing bursts of unspecified lengths (INCR) and receives an ERROR response in idmahresp[1:0], it does not stop the AHB operation and continues to request data from the AHB BUS until a software forces a stop condition through the AHB_DMA_STOP register. Internally, these requested samples are not forwarded to the AHB Audio DMA Master FIFO, as a consequence an FIFO empty condition is created. This stops the audio samples in the HDMI link. Conditions: â¢ Setup the system memory with audio samples â¢ Start an Audio DMA transfer with incrementing burst of unspecified length (INCR) and all channels enabled (channel allocation = 0xFF) â¢ Force the Slave to send an ERROR in idmahresp[1:0]	For 2 channels and the whole range of sample rates supported (from 32k to 192k), the workaround consists of setting a threshold of 126 and using unspecified INCR instruction only (other types of INCR forbidden). For multi channel (4, 6, or 8 channels) and the whole range of sample rates supported (from 32k to 192k), the workaround consists in setting a threshold of 126 and using INCR4 instructions only (other types of INCR forbidden). The threshold mentioned above is programmed in the register AHB_DMA_THRSLD 0x00123603 bit[7:0]. The register of INCR type is AHB_DMA_CONF0 0x00123600, with bit 0 cleared (â0â) and with the bits 2:1 determining the INCR type.	ERR003745 HDMI: 9000440660âAudio DMA fails to stop after ERROR detection
Cortex A-9	NXP	IMX6DQ	Each time one writes to some FC registers, and depending on the clock relation of sfr clk and tmds clk, some of these train of pulses (when these registers are configured in sequence), might not be caught by the arithmetic unit while it is busy processing/updating the first ones, so, it gets wrong video timing values, although the registers FC_* hold correct values. Even a soft reset will not make the arithmetic unit update correctly. Video will still pass correctly to the HDMI, but packets would not because the frame composer is holding internally incorrect video timing and this will quickly build up and overflow the packet FIFOs.	Solution is, after all controller configuration has been done, write three-four times the same value to any of the above registers (say FC_INVIDCONF with the correct same value three-four times), and then perform soft reset to clock domains.	HDMI: 8000504668âThe arithmetic unit may get wrong video timing values although the FC_* registers hold correct values
Cortex A-9	NXP	IMX6DQ	The initial DMA burst read transaction address is set using the AHB_DMA_STRADDR0-3 registers. The final DMA burst read transaction address is set using the AHB_DMA_STPADDR0-3 registers. If (AHB_DMA_STPADDRX - AHB_DMA_STRADDRX > 8K), then HDMI will not generate the AHB audio DMA done interrupt.	The Configuration should obey the following limitation: AHB_DMA_STPADDRX - AHB_DMA_STRADDRX < 8 KB.	ERR004323 HDMI: The DMA burst read transaction address region is limited to 8 KB
Cortex A-9	NXP	IMX6DQ	Due to an issue related to the synchronization between the clock domains to which the HDMI Tx FIFO belongs, incorrect fetches of data from the external memory might be generated for filling up this FIFO, possibly causing its overflow. Workarounds: For 2 channels and the whole range of sample rates supported (from 32k to 192k), the workaround consists of setting a threshold of 126 and using unspecified INCR instruction only (other types of INCR forbidden). For multi channel (4, 6, or 8 channels) and the whole range of sample rates supported (from 32k to 192k), the workaround consists in setting a threshold of 126 and using INCR4 instructions only (other types of INCR forbidden). The threshold mentioned above is programmed in the register AHB_DMA_THRSLD 0x00123603 bit[7:0]. The register of INCR type is AHB_DMA_CONF0 0x00123600, with bit 0 cleared (â0â) and with the bits 2:1 determining the INCR type. Proposed Solution: No fix scheduled Linux BSP Status: Software workaround integrated in Linux BSP codebase starting in release imx_3.0.35_4.1.0	For 2 channels and the whole range of sample rates supported (from 32k to 192k), the workaround consists of setting a threshold of 126 and using unspecified INCR instruction only (other types of INCR forbidden). For multi channel (4, 6, or 8 channels) and the whole range of sample rates supported (from 32k to 192k), the workaround consists in setting a threshold of 126 and using INCR4 instructions only (other types of INCR forbidden). The threshold mentioned above is programmed in the register AHB_DMA_THRSLD 0x00123603 bit[7:0]. The register of INCR type is AHB_DMA_CONF0 0x00123600, with bit 0 cleared (â0â) and with the bits 2:1 determining the INCR type.	HDMI: HDMI Tx audio may have noise due to audio DMA FIFO overflow
Cortex A-9	NXP	IMX6DQ	The HDCP specification requires that a feature support search procedure be performed to enable an HDCP link with Features 1.1 active. The HDCP transmitter has to read the HDCP receiver BCAPS to check if it supports Features 1.1, and if this is the case and the HDCP transmitter desires to use Features 1.1, it must enable them on the HDCP receiver by writing 0x02 in the HDCP I2C Ainfo register. It has been found that the HDCP transmitter is using the local configuration register (A_HDCPCFG0.en11 feature bit field register) and sending that data on the Ainfo register, ignoring that the remote HDCP Features 1.1 support has been indicated on the I2S BCAPS register.	To avoid this problem, the software should previously check BCAPS by reading A_HDCPOBS3.FEATURES_1_1 to ensure whether the receiver can support features 1.1 or not. If it does not support, then it should not set A_HDCPCFG0.en11 feature.	ERR005172 HDMI: Under certain circumstances, the HDCP may transmit incorrect Ainfo value, causing a failure on the receiver side
Cortex A-9	NXP	IMX6DQ	The tmds reset effect after the frame composer controller registers 0x1000~0x100D setting is that in fc_arithlogicunit the fc_arithlogicunit_div units will be reset: //RSR COMMENT numseqonhtotal = (Htotal - ctrlperiod - LDGB)/(ctrlperiod+ LDGB + dataperiod + TLGB) fc_arithlogicunit_div #(14,5,10) u01_div( .itmdsrstz (itmdsrstz), .itmdsclk (itmdsclk), .idividend (htotalminusctrltotal[13:0]), .idivisor ({3'd0,ctrlplusdata[10:0]} ), .istart (regupdatearithunit[1] ), .oquotient (wi01quotient[4:0] ), .orest (wi01rest[9:0] ), .odone (wi01done ) ); ... ... //RSR COMMENT restofpacketsonhblankwextctrl = (Hblank - extctrlperiod -LDGB - numseqonhblank * (ctrlperiod + LDGB + dataperiod + TLGB) -ctrlperiod - LDGB -TLGB)/32 fc_arithlogicunit_div #(10,5,2) u32_div( .itmdsrstz (itmdsrstz ), .itmdsclk (itmdsclk ), .idividend (wi32dividend[9:0]), .idivisor (10'd32 ), .istart (regi31done ), .oquotient (wi32quotient[4:0]), .orest (/*UNCONNECTED*/ ), .odone (/*UNCONNECTED*/ ) ); //END Division counters******************************************************** The fc_arithlogicunit_div when receive the tmds reset will force theiroutputs to zeros: ... ... //Hold division values********************************************************* always @ (posedge itmdsclk or negedge itmdsrstz) begin if (!itmdsrstz) begin oquotient[(QUOTIENTWIDTH-1):0] <= {QUOTIENTWIDTH{1'b0}}; orest[(RESTWIDTH-1):0] <= {RESTWIDTH{1'b0}}; odone <= 1'b0; end else begin if (wdone) begin oquotient[(QUOTIENTWIDTH-1):0] <=regquotient[(QUOTIENTWIDTH-1):0]; orest[(RESTWIDTH-1):0] <=regdividend[(RESTWIDTH-1):0]; end odone <= wdone; end end//end always hold value So, these units that calculate the remaining periods for the insertion of packets will not have incorrect outputs and will make the frame composer operate incorrectly and cause packet queue overflow.	The programming flow should be: 1. Program all the controller registers including the frame composer registers. 2. Assert software resets 3. Write (3 or 4 times) in FC_INVIDCONF the final value (this will make sure that the update pulse for the fc_arithlogicunit_div that will update the fc_arithlogicunit_div units is generated) 4. If frame composer packet queue overflow still occurs, then repeat steps 2 and 3	HDMI: Clarification on HDMI programming procedure to avoid FIFO overflow
Cortex A-9	NXP	IMX6DQ	When the AHB Audio DMA is started, by setting to 1âb1 for the first time the register field AHB_DMA_START.data_buffer_ready, the AHB Audio DMA will request data from the AHB bus to fill its internal AHB DMA FIFO.It is possible that a AHB DMA FIFO read action occurs during the time window between the first sample stored on the AHB DMA FIFO and when the AHB DMA FIFO has stored, at least, the number of configured audio channels in samples. If this happens, the AHB DMA FIFO will reply with samples that are currently on the AHB Audio FIFO and will repeat the last sample after the empty condition is reached.	This procedure assumes that all of the buffers provided to the AHB audio DMA through the AHB_DMA_STRADDR and AHB_DMA_STPADDR registers obey to the rule: (AHB_DMA_STPADDR - AHB_DMA_STRADDR+1) == n x NumberOfChannelEnabled Where n must be an integer. Note that this is only a re-affirmation of a stated usage restriction of AHB audio DMA. The initial ACR packets will contain a null N value but lab tests show that no issues arise from this fact. If for any reason underflow occurs (AHB FIFO empty rises), you must perform the START PROCEDURE. â¢ Initial configuration â Write 8âh00 to ADDR_AUD_N3 â Write 8âh00 to ADDR_AUD_N2 â Write 8âh00 to ADDR_AUD_N1 â Write to ADDR_AUD_CTS3 â Write to ADDR_AUD_CTS3 â Write to ADDR_AUD_CTS2 â Write to ADDR_AUD_CTS1 â¢ START PROCEDURE â Write 8âh00 to ADDR_AUD_N3 â Write 8âh00 to ADDR_AUD_N2 â Write 8âh00 to ADDR_AUD_N1 (starts new DMA operation set the AHB_DMA START bit) â Wait for FIFO full â Program N write to ADDR_AUD_N3 â Write to ADDR_AUD_N2 â Write to ADDR_AUD_N1	HDMI: HDMI AHB Audio DMA stream misalignment on system initialization
Cortex A-9	NXP	IMX6DQ	When an AHB slave performs a read access operation on the register bank, the data is sampled one SFR clock cycle earlier than required, consequently the data returned may be invalid. The AHB Slave read operation returns incorrect data when SRM/revocation memory read accesses through software registers in the address range 0x00125020 - 0x0012671F. Note this issue only affects the registers associated with HDCP functions. Other HDMI functions are not affected.	For reliable read operations, use the ARM core read command twice targeting the same address, discard the first data read value, and use the second read value.	HDMI: 9000482480âARM core read operation returns incorrect data for certain HDCP registers
Cortex A-9	NXP	IMX6DQ	When the I2C module is programmed to operate at the maximum clock speed of 400 kHz (as defined by the I2C spec), the SCL clock low period violates the I2C spec of 1.3 uS min. The user needs to reduce the clock speed to get the SCL low time to meet the 1.3us I2C minimum required. This behavior means the SoC is not compliant to the I2C spec at 400 kHz.	In order to exactly meet the clock low period requirement at fast speed mode, SCL must be configured to 384 KHz or less. The following clock configuration meets the I2C specification requirements for SCL low for i.MX 6 products: â¢ I2C parent clock PERCLK_ROOT = 24 M OSC â¢ perclk_podf = 1 â¢ PERCLK_ROOT = 24M OSC/perclk_podf = 24 MHz â¢ I2C_IFDR = 0x2A â¢ I2C clock frequency = 24 MHz/64 = 375 kHz	ERR007805 I2C: When the I2C clock speed is configured for 400 kHz, the SCL low period violates the I2C specification
Cortex A-9	NXP	IMX6DQ	DDR3, LPDDR2, MIPI_HSI, USB_HSIC, and ENET I/O interfaces are of the DDR I/O type, thus having the option to work in DDR input mode. This mode requires setting the DRAM_VREF to half the I/O voltage. This reference pad is used in all DDR type I/O interfaces. Since all I/O interfaces do not have a common voltage, configuring more than two I/O interfaces to DDR input mode might not work. Conditions: De-assertion of POR_B when the SoC is powered-up.	Configure the DDR_INPUT bit in IOMUXC for MIPI_HSI, USB_HSIC, and ENET to â0,â that is, CMOS input type.	I/O: MIPI_HSI, USB_HSIC, and ENET I/O interfaces should not be configured to Differential input mode
Cortex A-9	NXP	IMX6DQ	The IPU DMA Controller (IDMAC) module has a burst issue when using NI/PI 420/422 formats to perform write operations using Sensor Multi FIFO Controller (SMFC) channels (CH0, CH1, CH2 and CH3). The IDMAC cannot correctly divide the current burst into two bursts when crossing the 4k boundary. When this happens, the image will show some black pixels.	Either - set Y stride line & UV stride to 16 bytes aligned when format is NI/PI 420/422 using SMFC channel or - change the IDMAC burst size of the particular pixel formats from 32 pixels to 16 pixels If the IDMAC bandwidth is enough, there's no impact on the capture performance - it's just a system bandwidth consumption increase due to low payload bursts. But if the IDMAC bandwidth is critical, that is, IDMAC cannot handle 2x number of bursts on time, it will impact on capture performance The capture performance is reduced when the burst size is halved. However this workaround is preferred as the other workaround would be intrusive to software and some existing user space applications would need to be modified.	ERR009623 IPU: IDMAC burst errors when crossing a 4k boundary using NI/PI 420/422 formats [i.MX 6DualPlus/6QuadPlus Only]
Cortex A-9	NXP	IMX6DQ	The MIPI pixel clock driven by CCM cannot be gated. This results in a potential glitch or an unknown clock frequency when the MIPI pixel clock is changed in CCM.	Apply software reset to MIPI in case the aclk_emi_podf or aclk_emi_sel in the CCM are modified.	MIPI: Glitch or unknown clock frequency on MIPI input clock may occur in case the CCM source clock is modified
Cortex A-9	NXP	IMX6DQ	The MIPI CSI2 circuit is enabled by default with all the D-PHY data lanes active and will only disable the lanes that are not required when HS clock is available.	None.	ERR005190 MIPI: CSI2 Data lanes are activated before the HS clock from the CSI Tx side (camera) starts
Cortex A-9	NXP	IMX6DQ	On short packets, the WC[15:0] header field delivers the actual data payload of the packet. However, In long packets, the same field is used to indicate the size of the packetâs payload. Video Mode packet scheduler prevents Generic long packets to be generated with a size higher than 16âhFFEE. This size limit is imposed by the video mode packet scheduler since the maximum line size is 16âhFFFF minus additional security margins. The core is incorrectly filtering the short packets with WC field higher than 16âhFFEE since the size protection is applied without considering that this field now contains data and not packet size. Short packet commands are erroneously transmitted in DSI link with WC field equal to 16âhFFEE when this value is higher than 16âhFFEE.	If a generic short packet with packet data (WC fields) higher that 16âhFFEE is required, the application should disable the video mode transmission and use command mode transmission to issue the command.	MIPI: Corruption of short command packets with Word Count (WC) greater than 16âhFFEE, during video mode transmission by the MIPI Generic Interface
Cortex A-9	NXP	IMX6DQ	The issue appears when a DSI device, which is in reverse mode, sends a long packet with no payload. When receiving this packet, the DSI host controller checks the 16bit CRC field of the packet and incorrectly issues an error.Although there is no apparent reason for a device to send a long packet with no payload, there is no restriction in the DSI specification that forbids this. Also, there is no data loss resulting from this bug, since a long packet with no payload carries no data. The only inconvenience is that a CRC error is asserted in the bit crc_err of the register ERROR_ST1.	To avoid the assertion of the CRC error, disable verification of CRC reception errors in bit en_CRC_rx of the register PCKHDL_CFG. When disabling the CRC verification on the receive path, users should be aware that the CRC verification will be disabled for all reverse packets and not limited just to the long packets with no payload.	ERR005192 MIPI: Reverse direction long packets with no payload incorrectly issue a CRC error for MIPI DSI
Cortex A-9	NXP	IMX6DQ	The bits for setting video mode and command mode are assumed to be static during use and have no synchronization mechanism. These correspond to bit 0 of VID_MODE_CFG (address 0x1C) and bit 0 of register CMD_MODE_CFG register (address 0x24). these bits should only be changed while the digital core is in reset.	Setting PWR_UP register (address 0x04) to 0x00 keeps the controller under reset so that en_video_mode and en_cmd_mode can be changed free of any timing violations resulting from Clock-Domain Crossing. After those changes, PWR_UP can be set to 0x01 again, leading the controller to start working with the new configuration.	MIPI: The bits for setting the MIPI DSI video mode cannot be changed on the fly
Cortex A-9	NXP	IMX6DQ	For an incorrectly programmed configuration that enables the Null Packets and disables the Multiple Packets, the delay calculation is incorrectly done. Calculation of the delay time applied to the synchronization events when the Null Packets are enabled does not consider that the delay should only be applied when Multiple Packets are also enabled. This inaccuracy in the delay time might lead to an eventual overlap of current line with next line transmission resulting in the corruption of the packets.	This problem only occurs when an incorrect configuration is applied to the controller. The problem can be avoided only by activating the Null Packets, if Multiple Packets are also enabled.	ERR005194 MIPI: On MIPI DSI, there is a possible corruption of the video packets caused by overlapping of the current line over the next line, if the configuration is programmed incorrectly when using the DPI interface
Cortex A-9	NXP	IMX6DQ	When the HBP programmed timing is shorter than the time required to transmit the smallest blanking packet (6 bytes long packet), the controller incorrectly sends a blanking packet. This incorrect behavior models the HBP for a longer period than expected while the core should decide not to send any blanking packet. The transmission of blanking packet under these conditions can only be observed in Video Synchronous Mode with pulses.	HSA and HBP should be programmed with values higher than 10 lane byte cycles. The 10 lane byte clock corresponds to the transmission of a Horizontal Sync Start packet (4 bytes) followed by the smallest blanking packet (6 bytes).	MIPI: Incorrect blanking packet may be sent by the MIPI DSI interface
Cortex A-9	NXP	IMX6DQ	Data types from 0x13 to 0x17 are reserved but not considered invalid in the CSI-2 specification. However, the MIPI CSI controller raises an interrupt due to an err_id* being flagged when a packet with one of these data types is received. Data types from 0x13 to 0x17 should be processed without an error notification of this kind.	To avoid the interrupt, err_id* can be masked by setting the bits 12 to 15 of the MASK2 register. Bits 12 to 15 of the ERR2 register also should be ignored when reading. But, this procedure hides the occurrence of an err_id* error caused by the reception of other unidentified or unimplemented data type.	ERR005196 MIPI: Error Interrupt generated by the MIPI CSI interface for certain legal packet types
Cortex A-9	NXP	IMX6DQ	The data sent through Null or Blanking data packets do not activate âdvalidâ signal. CSI-2 Host controller implementation currently activates âdvalidâ for payload of any kind of long packet. The IP should match what is described in the databook and âdvalidâ should not be activated by Null and Blanking data.	The âdvalidâ signal can be filtered by configuring the following IPU data type registers: â¢ IPU_CSI0_DI__CSI0_MIPI_DI1 â¢ IPU_CSI0_DI__CSI0_MIPI_DI2 â¢ IPU_CSI0_DI__CSI0_MIPI_DI3	MIPI: Null and Blanking data packets activate âdvalidâ signal
Cortex A-9	NXP	IMX6DQ	CRC errors can occur in the MIPI CSI-2 4-lane configuration. These errors occur during an inactive phase of the bus. When using the 4-lane configuration with long data packet video, an internal counter indicating the number of received payload data continues counting even after the long data packet ends until the next packet comes in. This will cause a count overflow producing a CRC error for the last received packet. The CRC error only occurs when all of the following conditions are met: 1) MIPI CSI-2 is configured to use 4 data lanes. 2) Vertical blanking before the frame end (FE) is >=0x40000/CSI_CLK0 period. 3) No line start and line end short packets occur during the frame. The functionality of the receive data is not impacted; only the CRC is in error.	Implement any of the following: 1) Adjust the CSI transmit output timing to make sure the vertical blanking before the frame (FE) is <0x40000/CSI_CLK0 period. 2) Make sure each line has both a line start (LS) and line end (LE). 3) Ignore the CRC error if you confirm the CRC error is due to the operating conditions described above in the Description.	ERR009704 MIPI: CSI-2: CRC error produced in 4-lane configuration
Cortex A-9	NXP	IMX6DQ	MLB Multi frame per sub-buffer mode is not supported.	Do not use Multi frame per sub-buffer mode. The user should set the MFE bit to â0â in the Channel Allocation Table (CAT) in order to avoid this issue.	MLB: Multi frame per sub-buffer mode is not supported
Cortex A-9	NXP	IMX6DQ	The measure unit counts cycles of an internal ring oscillator. The measure unit readout is used to fine tune the delay lines for temperature/voltage changes for both DDR3 and LPDDR2 interfaces. When operating at low frequencies (below 100 MHz), the measure unit counter might overflow due to an issue in the overflow protection logic. As a result, an incorrect measure value will be read.	To workaround this issue, following steps should be performed by software: 1. Prior to reducing the DDR frequency (528 MHz), read the measure unit count bits (MU_UNIT_DEL_NUM). 2. Bypass the automatic measure unit when below 100 MHz, by setting the measure unit bypass enable bit (MU_BYP_EN). 3. Double the measure unit count value read in step 1 and program it in the measure unit bypass bit (MU_BYP_VAL) of the MMDC PHY Measure Unit Register, for the reduced frequency operation below 100 MHz. Software should re-enable the measure unit when operating at the higher frequencies, by clearing the measure unit bypass enable bit (MU_BYP_EN). This code should be executed out of Internal RAM or a non-DDR based external memory.	ERR005778 MMDC: DDR Controllerâs measure unit may return an incorrect value when operating below 100 MHz
Cortex A-9	NXP	IMX6DQ	The ARCR_GUARD bits of MMDC Core AXI Re-ordering Control register (MMDC_MAARCR) are used to ensure better DDR utilization while preventing starvation of lower priority transactions. After reordering is performed on previous read/write DDR transactions, the specific outstanding transaction will first obtain the maximum score in âdynamic score mode" and then wait for additional ARCR_GUARD count before achieving the highest priority. Due to a design issue, the ARCR_GUARD counter doesn't count up to the pre-defined value in the ARCR_GUARD bit field as expected. Therefore, the aging scheme optimizes the transaction reordering only up to the default aging level (15) and assigns a highest priority tag to the outstanding transaction.	Software should always program the ARCR_GUARD bits as 4'b0000. That means the accesses which have gained the maximum dynamic score will always become the highest priority after achieving the default highest aging level (15).	MMDC: ARCR_GUARD bits of MMDC Core AXI Re-ordering Control register (MMDC_MAARCR) doesn't behave as expected
Cortex A-9	NXP	IMX6DQ	When disabling the Dynamic Q Depth Adjustment, DBI reads to the Segmented Buffer Depth Port Logic registers return all zeros versus returning the hardwired default value. Internally the DBI read access clears these registers, overwriting the default value with all zeros. Clearing these registers results in all zeros being returned for subsequent PCIe Cfg reads. Following is an example scenario for this erratum: 1. Issue a PCIe Cfg read to any Port Logic Segmented Buffer Depth register. The read data value returned to the requester is the hardwired default value. 2. Issue a DBI read to same Port Logic Segmented Buffer Depth register. The read data value returned to the requester is all zeros. 3. Issue a PCIe Cfg read to same Port Logic Segmented Buffer Depth register. The read data value returned to the requester is all zeros.	None	ERR003747 PCIe: 9000436491âReading the Segmented Buffer Depth Port Logic registers returns all zeros
Cortex A-9	NXP	IMX6DQ	Root ports which have address bus widths < 64 drop inbound memory requests, when the address of the request is greater than the implemented address bus width. This feature is to prevent address aliasing when requests with addresses above 4 GB are received. When this feature is used in conjunction with address translation (iATU or xATU), inbound memory TLPs that violate this address check rule are dropped but no error is reported. Conditions: Issue an inbound memory TLP that has an address larger than the AMBA or RTRGT1 address bus width.	None	PCIe: 9000427578âRoot ports with address translation drop inbound requests, without reporting an error
Cortex A-9	NXP	IMX6DQ	Each Interrupt Status Register contains 32-bit status bits, allowing for the status of 32 individual interrupt vectors to be reported. The status bits are RW1C bits and are set when an MSI Interrupt vector is received, and are cleared by software writing a 1 to the bit. The setting of a status bit takes precedence over the clearing of a status bit. The precedence given to setting of the status bits resulted in the setting of a single status bit in the register, preventing any other status bits from being cleared at the same time. As a result, if an MSI interrupt is being logged in a status bit, and during the same clock cycle, software also attempts to clear another status bit in the same Status Register, then the status bit corresponding to the MSI interrupt is set but the status bit being written by software is not cleared and remains set. As a result, even though software has written a 1 to the status bit, the status bits remains set, reporting that an MSI interrupt has been received, even though software has serviced the Interrupt Request. This issue only occurs if the setting of a status bit and the clearing of another status bit within the same Interrupt Status Register happens during the same clock cycle.	Read and clear status bit until it is read as cleared.	ERR003749 PCIe: 9000426180âMSI Interrupt Controller Status Register bit not cleared after being written by software
Cortex A-9	NXP	IMX6DQ	When multiple PM_PME TLPs are received by an RC, the PME Requester ID of the first received PM_PME is overwritten with the Requester ID of the subsequent PM_PME in the PME Requester ID field of the Root Status register. The correct operation is to store the Requester ID of the initial PM_PME and only update the PME Requester ID field, once software has cleared the PME Status bit to acknowledge the receipt of the initial PM_PME TLP. Following is an example scenario for this erratum: 1. Send two PM_PME TLPs with different Requester IDs upstream to the core. 2. Read back the contents of the Root Status Register. The PME Status and PME Pending bits should both be set to 1. The Requester ID in the PME Requester ID field corresponds to the second PM_PME and not the initial PM_PME received by the core.	If multiple devices requested a power mode state change, possibly some of them would not get served if the requester ID is overwritten. However, according to Section 5.3.3.3 of PCIe Specification, all agents that are capable of generating PM_PME must implement a PME Service Timeout mechanism to ensure that their PME requests are serviced within a reasonable amount of time. If there is a time-out, the PM_PME TLP should be re-sent. So, this should not be an issue.	PCIe: 9000413207âPME Requester ID overwritten when two PMEs are received consecutively
Cortex A-9	NXP	IMX6DQ	The completion timeout mechanism defined in Section 2.8 of PCIe Base Specification version 2.1 describes a method to allow a requester to recover from a scenario where it does not receive all completions to a non-posted request. In the AXI or AHB bridge module, this triggers an error response to the original request on the slave interface. There is a separate completion timeout interface that passes information about the request that has been timed out from the PCIe Core to the AXI or AHB Bridge. The Bridge cannot process valid completions and completion timeouts in parallel and so, if a completion timeout is received at the same time as a valid completion is passed into the bridge, it must be stored and processed later. There is only a single storage element available for a completion timeout in the bridge. If a second completion timeout is passed into the bridge before it processes the first, the second timeout will overwrite the first completion timeout in the storage element. This results in the information associated with the first timeout being lost and no response is returned on the AHB or AXI slave interface for the original request. Following is an example scenario for this erratum: 1. Issue a continuous stream of outbound MemRd requests targeting the AXI or AHB Slave interface. 2. Correctly return completions back to back for all but two of these requests. 3. Wait for the timeout mechanism to trigger for the two requests that do not receive completions.	None	ERR003753 PCIe: 9000405932âAXI/AHB Bridge Slave does not return a response to an outbound non-posted request
Cortex A-9	NXP	IMX6DQ	The AHB/AXI Bridge RAM is sized at configuration time to support inbound read requests with a maximum size of CX_REMOTE_RD_REQ_SIZE. When this limit is violated the core responds with UR status, when it should respond with CA status.	None.	PCIe: 9000403702âAHB/AXI Bridge Master responds with UR status instead of CA status for inbound MRd requesting greater than CX_REMOTE_RD_REQ_SIZE
Cortex A-9	NXP	IMX6DQ	The PCI Express AER Capability register âUncorrectable Error Severityâ (at offset 0x0C) has the wrong default value for the âUncorrectable Internal Errorâ bit. It should be 1âb1. Uncorrectable Internal Error is an optional feature that the PCI Express block does not support, but it must default to 1âb1 anyway.	None.	ERR003755 PCIe: 9000402443âUncorrectable Internal Error Severity register bit has incorrect default value
Cortex A-9	NXP	IMX6DQ	The PCI Express Specification is unclear regarding the transmission of Idle Symbols when a directed state transition occurs in the Recovery.Idle state. This can sometimes result in temporary loss of synchronization between link partners when transitioning from L0 to Detect, through the Disabled, Hot Reset, Configuration, or Loopback states. Section 4.2.6.4.4 of the PCI Express Specification states that Recovery.Idle Transmitter sends Idle data on all configured Lanes. Note: If directed to other states, Idle Symbols do not have to be sent before transitioning to the other states (that is, Disable, Hot Reset, Configuration, or Loopback). The PCI Express block chooses to send Idle symbols, as the specification does not prohibit the sending of Idle symbols.	None.	PCIe: 9000387484âLTSSM: Software-initiated transitions to Disabled, Hot Reset, Configuration, or Loopback states sometimes take longer than expected
Cortex A-9	NXP	IMX6DQ	The VDM âID Match Modeâ of the iATU allows inbound ID-routed VDMs to be translated without explicit knowledge of the Bus, Device, or Function number of the target function. ID-routed VDMs contain the destination ID in bits [31:16] of Header DWORD3. This mode is not functional and the iATU requires the actual ID of the destination Bus, Device, and function to be known and programmed as bits [63:48] of the iATU region Base Address. Following is an example scenario for this erratum: 1. Setup an inbound iATU region with the type field set to match messages and the vendor ID match mode bit set to 1. 2. Send a message that matches the bits [47:ATU_REG_WD] of the region base, but that does not match bits [63:48]. The message will not be translated.	Program the required destination ID in bits [31:16] of the region Upper Base Address Register.	ERR003757 PCIe: 9000448152âInternal Address Translation Unit (iATU): Inbound Vendor Defined Message (VDM) âID Match Modeâ is not functional
Cortex A-9	NXP	IMX6DQ	Following is an example scenario for this erratum: 1. Downstream Port sends PME_Turn_Off message, Upstream Port sends PM_Enter_L23 DLLPs. 2. Downstream Port sends PM_Request_Ack DLLPs and does not move to Electrical Idle. 3. Upstream Port moves into Transmitter Electrical Idle and is waiting for Receiver Electrical Idle. 4. Downstream Port moves to Recovery and sends TS OSs.	None	PCIe: 9000441819âUpstream Port does not transition to Recovery after receiving TS OSs during âENTER_L2 negotiationâ
Cortex A-9	NXP	IMX6DQ	Outbound TLPs created at the vendor message interface (VMI) or the MSI interface are always subject to translation by the iATU. In PCI Express block configurations with an AHB/AXI interface and a 32-bit slave address bus width, the iATU incorrectly only considers the lower 32 bits of the 64-bit VMI or MSI address, when determining whether to translate the outbound TLP or not. The VMI always uses 64 bits of the vend_msg_data input. These 64 bits of data are placed in DW3 and DW4 of the message TLP header and are treated by the iATU as an address. When the lower 32 bits on vend_msg_data match an enabled iATU region, then the resulting TLP is incorrectly translated, regardless of the upper 32 bits. All of the 64-bits should have been checked in the iATU. Following is an example scenario for this erratum with respect to VMI interface: 1. Setup any outbound iATU region (any type, any target address) 2. Send a message using VMI where the lower 32 bits of the message match the iATU region 3. The resulting Vendor Message TLP will be translated by the iATU regardless of the value of the upper 32 bits on vend_msg_data Following is an example scenario for this erratum with respect to MSI interface: 1. Setup any outbound iATU region of any type where the lower 32 bits of the base address of the region match the lower 32 bits of the MSI address for any function within the device 2. Stimulate a MSI request 3. The resulting TLP will match the iATU region target specification and not the MSI address of the function	Program an iATU region to generate the MSI and then write to that region to generate the message.	ERR003759 PCIe: 9000439510âInternal Address Translation Unit (iATU) can sometimes overwrite Outbound (Tx) Vendor Messages and MSIs
Cortex A-9	NXP	IMX6DQ	The core does not support Atomic Ops that are targeted towards the RTRGT0, because RTRGT0 can only process one DWORD requests. Therefore, any Atomic Op request targeting the RTRGT0 interface should receive a CPL with CA completion status. There is an issue when the core receives an Atomic Op request that is poisoned (EP bit is set to 1) and the request is targeting the RTRGT0 interface. The core correctly disregards the poisoned status as the CA response is a high priority error. However, the poisoned bit causes the internal filter to treat the request as UR instead of CA.	None.	PCIe: 9000439175âPoisoned Atomic Op requests targeting RTRGT0 receive UR response instead of CA response
Cortex A-9	NXP	IMX6DQ	The core moves ahead even when it does not receive the same non-PAD lane number in two consecutive TS Ordered Sets (OS) in the Link configuration process. Scenario Setup: â¢ The link is in the link training phase. â¢ Remote partner sends TS OS without the same non-PAD lane number in any two consecutive TS OS on any active lane. â¢ The core moves ahead regardless of the non-PAD lane number not being the same in two consecutive TS OS.	None. This issue will not lead to any compliance failures.	ERR004297 PCIe: 9000336356âLink configuration sometimes proceeds when incorrect TS Ordered Sets are received
Cortex A-9	NXP	IMX6DQ	Figure 3-15 in Section 3.5.2.2. âHandling of Received DLLPsâ of the PCI Express base Specification 3.0, indicates when a bad DLLP error should be reported. It should occur when the calculated CRC is not equal to the received value. The core correctly reports a bad DLLP error under this scenario. However, it also sets it if the Physical Layer reports a packet error during reception of the DLLP or if the DLLP ends with an ENDB symbol and not an END symbol. These extra conditions should not result in the reporting of a bad DLLP error.	None required, there are no adverse side effects.	PCIe: 9000471173âBad DLLP error status checking is too strict
Cortex A-9	NXP	IMX6DQ	Upstream ports are responsible for initiating entry into the L1 low-power state. The core implements an idle timer mechanism to trigger entry into the L1 state when L1 ASPM is enabled. If this timer has triggered but the port has not yet negotiated entry into the L1 low power state, and a link down event occurs, then the port will attempt to enter L1 again as soon as the link has resumed operation. This attempted L1 entry occurs, even though L1 ASPM is no longer enabled for the link (because of the link down reset). Conditions: Scenario setup: â¢ After link-up, enable L1 ASPM. â¢ Allow the link to go idle. Eventually, the port begins to request L1 entry by sending PM_Active_State_Request_L1 TLPs. â¢ Do not acknowledge the PM_Active_State_Request_L1 TLPs, but bring the link down by forcing the remote partner into the detect state. â¢ Allow the link to retrain to L0. â¢ After the link has retrained, the port will again attempt entry into the L1 ASPM state, even though L1 ASPM is now disabled.	None, but a graceful resumption of normal operation is expected.	ERR004299 PCIe: 9000493959âL1 ASPM incorrectly entered after link down event during L1 ASPM entry negotiation
Cortex A-9	NXP	IMX6DQ	The PCIe base specification states that before the L1 state can be entered, the Retry buffer must be empty. For PM Directed L1 Entry 5.3.2.1. Entry into the L1 State The Downstream component then waits until it receives a Link Layer acknowledgement for the PMCSR Write Completion, and any other TLPs it had previously sent. The component must retransmit a TLP out of its Data Link Layer Retry buffer if required to do so by Data Link Layer 15 rules. For ASPM L1 Entry 5.4.1.2.1. Entry into the L1 State The Downstream component must wait until it receives a Link Layer acknowledgement for the last TLP it had previously sent (the retry buffer is empty). The component must retransmit 30 a TLP out of its Data Link Layer Retry buffer if required by the Data Link Layer rules. In Addition For Entry into The L0s State 5.4.1.1.1. Entry into the L0s State No TLP is pending to transmit over the Link, or no FC credits are available to transmit any TLPs. This can be interpreted as meaning the retry buffer should be empty. This is because it might be necessary to retransmit a TLP over the link, until a TLP has been acknowledged. The core does not wait for the retry buffer to be empty before commencing L0s or L1 entry. Conditions: Scenario Setup: 1. Transmit a TLP from the DWC_pcie core 2. Suppress Ack/Nak transmission from the Link Partner. 3. Initiate PM directed L1, ASPM L0s or ASPM L1 entry. 4. The core will enter the appropriate low power state, even though it still has TLPs in the retry buffer.	This defect has no adverse side effects, rather a strict interpretation of the specification. The only consequence is that L0S (PCI Express Link Power State) will be exited prematurely if this condition is hit however will re-enter if the condition to enter prevails. So, just an early exit out of L0S but not functional problems or data corruption or compliance failure.	PCIe: 9000470913âPower Management Control: Core might enter L0s/L1 before Retry buffer is empty
Cortex A-9	NXP	IMX6DQ	A DLLP Ack can be missed by the core on the receive path when it is immediately followed by EIOS. Conditions: After the Ack, two EIOS are seen on the PIPE interface. In this scenario, the Ack is missed by the RX logic, causing the corresponding TLP to be re-transmitted from the Tx replay buffer. Eventually, the link recovers from this event, as the receiver on the other side drops the re-transmitted TLP as a duplicate TLP. If the missed frame is a TLP, no ACK will be sent to the link partner, resulting in re-transmission of the TLP from the link partner.	No workaround. Also should not cause any compliance issues.	PCIe: 9000487440âTLP sometimes unnecessarily replayed
Cortex A-9	NXP	IMX6DQ	In the PCIe2 PHY, the rx0_eq[2:0] pins are controlled by the PCS, which currently drives these to a fixed value of 3âb000. This removes the capability to change RX equalization if any compliance issues are encountered.	The workaround is to override the RX_EQ settings, accordingly, using control registers inside the PHY: RX_OVRD_IN_HI - 0x1006 10:8 - RX_EQ[2:0] 11 - RX_EQ_OVRD	ERR004489 PCIe: 9000505660âPCIe2 receiver equalizer settings
Cortex A-9	NXP	IMX6DQ	When the remote link partner enters Recovery.rcvrlock from the L0 state and transmits only two TS1 Ordered Sets (OS), the core can sometimes miss the second TS1 OS and therefore, delay its entry into Recovery.rcvrlock. Conditions: Scenario Setup: â¢ The remote link partner enters Recovery.rcvrlock from the L0 state and transmits only two TS1 OSs â¢ The remote link partner then unusually moves to ElecIdle and de-asserts the PIPE signal rxvalid in Recovery.RcvrLock â¢ The expected response from the core is that it will transition to Recovery.rcvrlock on receipt of the two TS1 OSs â¢ The core receives a SKP OS or EIEOS that was inserted between the two TS1 Ordered Sets.	None. This is an unusual verification setup, and in a real system the remote partner must keep sending TS1 OSs in Recovery.RcvrLock and then the core will move to Recovery after receiving 2 TS1 OSs.	PCIe: 9000514662âLTSSM delay when moving from L0 to recovery upon receipt of insufficient TS1 Ordered Sets
Cortex A-9	NXP	IMX6DQ	The PCI Express base specification states in section 3.5.2.1 âIf REPLAY_NUM rolls over from 11b to 00b, the Transmitter signals the Physical Layer to retrain the Link, and waits for the completion of retraining before proceeding with the replay.â In the core, there are scenarios where the first TLP to be replayed might be replayed a fourth time before the link is retrained. This happens because the replay buffer logic requests the link to retrain at the same time that it begins a replay. If the link does not begin to retrain quickly enough, the first TLP of the replay might be transmitted again prior to link retraining. Conditions: Scenario Setup: 1. Transmit a series of TLPs from the core. 2. Send a Nak DLLP for the first TLP to initiate a replay. 3. Wait for the replay to begin. 4. Send a Nak DLLP for the first TLP to again initiate a replay. 5. Repeat steps (3) and (4) two more times. 6. After sending the fourth NAK, in some circumstances the first replayed TLP might be seen before the link begins to retrain.	None, the link recovers gracefully.	PCIe: 9000507633âTLP might be replayed an extra time before core enters recovery
Cortex A-9	NXP	IMX6DQ	The digital to analog clock domain transfer of the frequency updates is susceptible to meta-stability errors as the transfer is done through a FIFO. During initial power-up, the FIFO ensures proper alignment by delaying the read pointer until the write clock has started. For correct operation of pointers, it is required that there are five edges of the write clock in two edges of the read clock. When a rate change occurs from Gen1 to Gen2 or vice versa, the clock frequencies switch. During this switching, it is possible (depending upon internal clock tree delay in the PHY digital logic) that there are six write clock edges between two clock edges of the read clock. This causes the pointers to move out of sync and for some process/voltage/temperature corners can result in continuous corrupted reads of frequency update inputs to CDR phase mixer. Once the pointers are misaligned, the condition will persist until the clocks are disabled or another phase shift occurs in clock phases as a result of rate change. The end result is the CDR loses lock in L0 state.	From Cold start (LTSSM starts in Detect state): â¢ Disable MAC/LTSSM. â¢ Disable MAC/Gen2 support. â¢ Release MAC/LTSSM. â¢ Wait for MAC to enter L0. â¢ From L0, initiate MAC entry to Gen2 if EP/RC supports Gen2. â¢ Wait 2 ms (LTSSM timeout is 24 ms, PHY lock is ~5 Î¼s in Gen2). â¢ If (MAC/LTSSM.state == Recovery.RcvrLock) && (PHY/rx_valid == 0), then pulse PHY/rx_reset. Transition to Gen2 is stuck. Enter L2 from L0: â¢ Driver receives/requests entry to L2. â¢ Wait 2 ms (LTSSM timeout is 24 ms, PHY lock is ~10 Î¼s in Gen1). â¢ If (MAC/LTSSM.state == Recovery.RcvrLock) && (PHY/rx_valid == 0), then pulse PHY/rx_reset. Transition to Gen1 is stuck. Exit from L2 to L0: â¢ Driver receives/requests exit from L2. â¢ Disable MAC Gen2 support. â¢ Release LTSSM to wake-up from L2. â¢ Wait for entry to L0 and then repeat process of entering Gen2 from cold start case (going through Detect). 1. Disable RX in the PHY by CREG write: Address=16âh1005, Data=16âh0028 2. Enable RX in the PHY by CREG write: Address=16âh1005, Data=16âh0000 PHY rx_valid read: â¢ Sample rx_valid in the PHY by CREG read: Address=16âh100D, Data Mask=16âh0001 (rx_valid is bit 0) MAC software registers: 1. Disable/enable LTSSM: write app_ltssm_enable. 2. Disable Gen2 (read/write link capability/status register): 3. Link in L0 event (driver should know this when the data link layer starts): 4. Request change to Gen2: (Cfg Directed Speed Change enabled. Write Gen2 Control Register DEFAULT_GEN2_SPEED_CHANGE). 5. Read LTSSM state (xmlh_ltssm_state[4:0]. 6. Negotiate L2 entry/exit (software controlled D3).	ERR005184 PCIe: Clock pointers can lose sync during clock rate changes
Cortex A-9	NXP	IMX6DQ	The PCIe core might send less than 32 TS2 ordered sets during link retraining and speed changing if the remote partner sends more TS1 ordered sets than expected. This occurs when the âExtended Synchâ bit cleared in PCIe and set at the remote partner. Scenario Setup: â¢ Link partners agree to do speed change negotiation and move to Recovery. â¢ The remote partner stays in Recovery.RcvrLock longer and sends more TS1s (for example, Extended Synch bit is set). â¢ In Recovery.RcvrCfg state core will send less than 32 TS2s before transition to Recovery.Speed	In current PCIe core, there is no signal indicating that remote partner has âExtended Synchâ bit set per PCIe base spec. The workaround is to know in advance if the link partner has the âExtended Synchâ bit set and in that case set that bit in the PCIe also. The âExtended Synchâ is intended for a logic analyzer. It may be used if there are repeaters on the link.	ERR005186 PCIe: The PCIe Controller Core Does Not Send Enough TS2 Ordered Sets During Link Retrain And Speed Change
Cortex A-9	NXP	IMX6DQ	Under the condition where the core enters L1 and is then directed to immediately exit due to a pending TLP transmission, the LTSSM misses the PhyStatus pulse because of the gated core_clk in clk_rst.v. Scenario Setup: â¢ LTSSM enters L1 and indicates to the PHY to change Powerdown to P1. â¢ Core immediately gets a wake-up event and wants to exit from L1. To make the transition into Recovery, the core needs to receive PhyStatus back from the PHY â¢ The PHY changes Powerdown to P1 and asserts PhyStatus back to Core. â¢ LTSSM moves to Recovery state and indicates to the PHY to change Powerdown to P0 â¢ core_clk is gated off immediately after LTSSM enters Recovery. This can happen as a result of the logic in the clk_rst module that is performing glitch-less clock switch on aux_clk â¢ The PHY changes Powerdown to P0 and asserts PhyStatus back to core. â¢ LTSSM misses the PhyStatus because core_clk is still gated off by the clk_rst module.	Increase the programming of the âLow Power Entrance Countâ field of the âPort Force Link Registerâ (maximum is 255). This delays the entry into L1 and prevents the problem from occurring. The âLow Power Entrance Countâ field is for Power Management state to wait for these many clock cycles for the associated completion of a configuration write to D-state register to go low power. The longer delay is to ensure that the completion TLP can be sent by the core to avoid immediate waking-up after entering L1.	PCIe: The PCIe Controller cannot exit successfully L1 state of LTSSM when the Core Clock is removed
Cortex A-9	NXP	IMX6DQ	Hardware Autonomous Speed Disable bit Attributes in PCIe Base Specification Rev 2.0 were RW/RsvdP. In Rev 3.0 it is changed to RWS/RsvdP. Scenario Setup: â¢ âNo soft resetâ bit is programmed to 0 on any function. â¢ âHardware Autonomous Speed Disableâ bit is programmed to 1, if the component does not want to adjust the Link speed autonomously. â¢ Train the Link to Hot Reset. â¢ Core will have a Link down reset which causes non-sticky reset.	No workaround, no effect on software but non compliance with standard.	ERR005189 PCIe: PCIe Gen2/Gen3 Hardware Autonomous Speed Disable Bit In Configuration Register is not sticky
Cortex A-9	NXP	IMX6DQ	When PCIe works as Root Complex, it can exit L2 mode only through reset. Since PCIe does not have a dedicated reset control bit, it cannot exit L2 mode.	The PCIe can be put into PDDQ mode to save PCIe PHY power and wake up only by the OOB (Out of Band) wakeup signal (since wakeup by a beacon from link partner is not supported) driven from the link partner (End Point). This signal could be used as a GPIO interrupt to exit this mode. The limitation of this workaround is that the link partner cannot be put into L2 mode.	PCIe: PCIe does not support L2 power down [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	Per the PCI Specification, unimplemented mask register bits in the MSI capability should be reserved. All mask bits in the core are implemented with read-write attribute, regardless of the number of MSI vectors requested. The PCI-SIG compliance test CFG 4.0.1 expects the reserved bits to be read-only and consequently fails if less than the maximum number of MSI vectors are requested by the core.	Request maximum number of MSI vectors by writing the Multiple Message Capable field of the MSI Control Register with a value of 0x5 via the DBI register. Apply a mask on the writable mask bits in accordance with the value of cfg_multi_msi_cap.	ERR007554 PCIe: MSI Mask Register Reserved Bits not read-only
Cortex A-9	NXP	IMX6DQ	iATU Enabled (CX_INTERNAL_ATU_ENABLE =1) bit 28 (CFG_SHIFT_MODE) is enabled in the IATU_REGION_CTRL_2_OFF_OUTBOUND_0 register. The implementation of the Enhanced Configuration Address Mapping (ECAM) feature violates the PCIe specification requirement that all reserved fields should always be "0". The basic idea is that the Bus/Device/Function (BDF) address is shifted 4 bits down so that the entire Cfg space can be mapped into a 256 MB region, rather than requiring multiple address translation tables, or a 4GB translation space. The BDF is then supposed to be shifted back up from bits 27:12 to 31:16 in the outgoing TLP (actually Bytes 8 and 9 in the Cfg TLP). The core does not do this translation correctly when the CFG Shift bit is set in an iATU entry.	None.	PCIe: iATU - Optional programmable CFG Shift feature for ECAM is not correctly updating address (9000642041)
Cortex A-9	NXP	IMX6DQ	When the core is in L0 and receives two TS ordered sets followed by erroneous data, the core does not transition to Recovery immediately. The core will wait for the 128 us timeout and then move to Recovery if the core continuously receives erroneous data. Scenario Setup: Linkup to L0 Send two TS ordered sets to the core Send some erroneous data to the core immediately Continue sending erroneous data to the core for 128 us	None	ERR007556 PCIe: Core Delays Transition From L0 To Recovery After Receiving Two TS OS And Erroneous Data (9000597455)
Cortex A-9	NXP	IMX6DQ	16-bit, 32-bit, or 64-bit PIPE I/F (CX_NB >= 2) Gen1/Gen2 Mode (CX_GEN3_MODE = 2) When running at Gen1 or Gen2 speed, if the valid core data width on a lane is 2s (two symbols) or higher and the Extended Synch bit is set in the Link Control Register, then the core sends one extra FTS (4097 instead of 4096) when exiting L0s. Scenario Setup: 1. Set the Extended Synch bit in the Link Control Register. 2. Enable L0s ASPM by setting Link Control Register bit 0 to 1. 3. Bring the link to L0 at Gen1 or Gen2 speed and leave the link idle. 4. The controller goes to L0s after an L0s entry latency timeout. 5. Initiate a TLP transmission. 6. The controller wakes up and sends 4097 FTS.	None	PCIe: Extra FTS sent when Extended Synch bit is set (9000588281)
Cortex A-9	NXP	IMX6DQ	When the downstream port (DSP) core enters Configuration.Linkwidth.Accept, it immediately starts sending TS1 with non-PAD lane number.	None	ERR007559 PCIe: Core sends TS1 with non-PAD lane number too early in Configuration.Linkwidth.Accept State (9000574708)
Cortex A-9	NXP	IMX6DQ	When the core's LTSSM is in Recovery.RcvLock or Recovery.RcvCfg, and it receives TS Ordered sets, it does not check whether the link and lane numbers of the received TS Ordered Sets match what is being transmitted on those same lanes. Scenario Setup: Core is in link state "Recovery.RcvLock" or "Recovery.RcvCfg" and receives TS Ordered Sets with link and lane number not matching what is being transmitted on those same Lanes. The absence of link and lane number match checks in Recovery.RcvrLock and Recovery.RcvrCfg states only affects single lane configurations (CX_NL = 1). All configurations are not affect, as stated in the Impacted Configurations section above.	None	PCIe: Link and lane number-match not checked in recovery (9000569433)
Cortex A-9	NXP	IMX6DQ	When the remote link partner enters Recovery.rcvrlock from the L0 state and transmits only two TS1 Ordered Sets (OS), the core can sometimes miss the second TS1 OS and therefore delay its entry into Recovery.rcvrlock. Scenario Setup: The remote link partner enters Recovery.rcvrlock from the L0 state and transmits only two TS1 OS's The remote link partner then unusually moves to ElecIdle and de-asserts the PIPE signal rxvalid in Recovery.RcvrLock The expected response from the core is that it will transition to Recovery.rcvrlock on receipt of the two TS1 OS's The core receives a SKP OS or EIEOS that was inserted between the two TS1 Ordered Sets. Note: This is an unusual verification setup, and in a real system the remote partner must keep sending TS1s in Recovery.RcvrLock and then core will move to Recovery after receiving 2 TS1s.	None	ERR007575 PCIe: LTSSM delay when moving from L0 to recovery upon receipt of insufficient TS1 Ordered Sets (9000514662)
Cortex A-9	NXP	IMX6DQ	DLLP ACK frame is missed on the RX path. After the ACK, two EIOS are seen on the pipe interface. In this scenario, the ACK is missed by the RX logic, causing to the corresponding TLP to be re-transmitted from the TX replay buffer. Eventually, the link recovers from this event, as the receiver on the other side drops the re-transmitted TLP as a duplicate TLP. If the missed frame is a TLP, no ACK will be sent to the link partner, resulting in re-transmission of the TLP from the link partner.	None	PCIe: DLLP/TLP can be missed on RX path when immediately followed by EIOS (9000487440)
Cortex A-9	NXP	IMX6DQ	In rare cases, the PCIe link may go down after a warm reset occurs.	Prior to executing a warm reset, clear the IOMUXC_GPR1[REF_SSP_EN] to disable the PCIe reference clock. Once the warm reset is complete and the clocks are stable again, re-enable the PCIe reference clock by setting IOMUXC_GPR1[REF_SSP_EN] to 1.	ERR008587 PCIe: Random link down after warm reset [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	The PRE clock will be paused for several cycles when turning on the PU domain LDO from power down state. If PRE is in use at that time, the IPU/PRG cannot get the correct display data from the PRE.	If the PRE is in use the PU domain LDO must not be switched off. To help reduce the power consumption, software can disable the GPU/VPU clocks.	PRE: GPU3D, GPU2D and VPU cannot be power-gated if the PRE is in use [i.MX 6DualPlus/6QuadPlus Only]
Cortex A-9	NXP	IMX6DQ	The ENABLE bit in the HW_PRE_CTRL register can be set by hardware or software. The software operation has a higher priority. If the hardware flow tries to set this bit while the software is writing any bits in the HW_PRE_CTRL register at same time, the hardware operation will be ignored. The hardware operation is only valid for one pre_clk cycle. Once this occurs the ENABLE bit cannot be set unless the entire display channel (PRE+PRG+IPU) is restarted.	Prevent software writing to the HW_PRE_CTRL register during the problematic hardware write window. For cases in which the PRE input line number is greater than 9, the software will read the STORE_BLOCK_Y status in the HW_PRE_STORE_ENGINE_STATUS register and verify it is within a safe window before writing to the SDW_UPDATE bit in the HW_PRE_CTRL register. For cases in which the PRE input line number is less than or equal to 9, the software will write to the SDW_UPDATE bit (as well as any other PRE registers) in the flip/buffer-switch interrupt handler, that is, the IPU end of frame (EOF) interrupt in the current software implementation. For on-the-fly switch cases, similar to the less than or equal to 9 case, writes to the HW_PRE_CTRL register will be in the so-called on-the-fly configuration interrupt, that is, the same IPU end of frame (EOF) interrupt in the current software implementation.	ERR009624 PRE: ENABLE bit cannot be set in a special case, when the EN_REPEAT bit is set [i.MX 6DualPlus/6QuadPlus Only]
Cortex A-9	NXP	IMX6DQ		For the ROM NAND boot, there is no software workaround for this issue. For a hardware workaround, implement an external watchdog or other reset watch (such as via a PMIC). On a successful boot, the processor toggles the external watchdog through an I/O mechanism (for example, a GPIO) which prevents the watchdog from detecting a timeout. If a boot failure occurs, the external watchdog times out, thus resetting the processor. For other occurrences in application code, the following procedure should be followed to change the clock configuration for the enfc_clk_root: 1) Gate (disable) the GPMI/BCH clocks in register CCM_CCGR4. 2) Gate (disable) the enfc_clk_root before changing the enfc_clk_root source or dividers by clearing CCM_CCGR2[CG7] to 2âb00. This disables the iomux_ipt_clk_io_clk. 3) Configure CCM_CS2CDR for the new clock source configuration. 4) Enable enfc_clk_root by setting CCM_CCGR2[CG7] to 2âb11. This enables the iomux_ipt_clk_io_clk. 5) Enable the GPMI/BCH clocks in register CCM_CCGR4	ROM: When booting from NAND flash, enfc_clk_root clock is not gated off when doing the clock source switch [i.MX 6Dual/6Quad Only] Description For raw NAND boot, ROM switches the source of enfc_clk_root from PLL2_PFD2 to PLL3. The root clock is required to be gated before switching the source clock. If the root clock is not gated, clock glitches might be passed to the divider that follows the clock mux, and the divider might behave unpredictably. This can cause the clock generation to fail and the chip will not boot successfully. This problem can also occur elsewhere in application code if the root clock is not properly gated when the clock configuration is changed. Projected Impact: The chip might not successfully boot from a NAND flash device. If the application code changes the enfc_clk_root configuration without gating the clocks appropriately (described in the workaround), accesses to a NAND device may fail. Workarounds: For the ROM NAND boot, there is no software workaround for this issue. For a hardware workaround, implement an external watchdog or other reset watch (such as via a PMIC). On a successful boot, the processor toggles the external watchdog through an I/O mechanism (for example, a GPIO) which prevents the watchdog from detecting a timeout. If a boot failure occurs, the external watchdog times out, thus resetting the processor. For other occurrences in application code, the following procedure should be followed to change the clock configuration for the enfc_clk_root: 1) Gate (disable) the GPMI/BCH clocks in register CCM_CCGR4. 2) Gate (disable) the enfc_clk_root before changing the enfc_clk_root source or dividers by clearing CCM_CCGR2[CG7] to 2âb00. This disables the iomux_ipt_clk_io_clk. 3) Configure CCM_CS2CDR for the new clock source configuration. 4) Enable enfc_clk_root by setting CCM_CCGR2[CG7] to 2âb11. This enables the iomux_ipt_clk_io_clk. 5) Enable the GPMI/BCH clocks in register CCM_CCGR4 Proposed Solution: ROM boot fixed in i.MX 6Dual/6Quad silicon revision 1.3 Linux BSP Status: No BSP software workaround
Cortex A-9	NXP	IMX6DQ	For a NAND boot, the ROM code verifies FCB (Firmware Configuration Block) using Hamming Checking. For every single byte within FCB, there is an associated parity byte. Only the least significant 5 bits of the parity byte are valid. However, the ROM code uses the whole 8 bits of the parity bytes for the Hamming Checking. Thus, if a bit flip occurred on any of the most significant 3 bits (bits 7/6/5) of any parity bytes, the Hamming Checking will fail. The MSB 3 bits of parity byte should not be considered in the checking process. So the ROM code may interpret a valid FCB as an invalid one.	Burn more FCB copies(4/8) into the NAND chip to increase the possibility that ROM can find a valid one.	ERR007220 ROM: NAND boot may fail due to incorrect Hamming Checking implementation in the ROM code [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	The internal boot ROM uses the general-purpose timer (GPT) as a timing reference for event and timeout measurement during the boot process. The ROM uses the 32 kHz clock as the clock source for the GPT. There will be a short period during device power-up when the SoC will be using the internal ring oscillator until the crystal oscillator is running. Once the crystal oscillator is running, the SoC will automatically switch from the internal oscillator to the crystal oscillator. Consequently, there will be a period of time when the SoC will be booting and using the internal ring oscillator as its reference clock and the ROM code will be dependent on that clock. The internal ring oscillator is less accurate than a crystal oscillator and may be up to two times faster than a 32 kHz external crystal oscillator. The ROM code assumes the reference clock is 32 kHz, so in the presence of a faster reference clock some delays or timeout configurations in the ROM code will be shorter than expected and may affect SD/MMC boot, NAND boot, and One NAND boot. NOR and SPI-NOR boot modes are not affected by this issue because these modes do not use timeouts. The potential effects are: 1. The SD/MMC card specification may be violated if the SD/MMC card Nac parameter is larger than 50 ms, or if its initialization time is greater than 500 ms. 2. According to the SD 3.0 specification, the controller should wait a minimum of 5 ms after disabling SDCLK before re-enabling SDCLK when voltage switching. In the worst case, the ROM code may only wait 2.5 ms. 3. According to the SD 3.0 specification, the timeout for a CMD6 data transaction response is 100 ms. In the worst case, the ROM code may timeout after 50 ms and therefore not conform to the specification. 4. One NAND boot may fail if the One NAND memory tRD1 is greater than 1.5 ms. 5. NAND boot may fail if the NAND memory tRST parameter is greater than 11 ms or if its tR parameter is greater than 1 ms.	SDMMC boot: 1. SD/MMC: Choose an SD/MMC card for which the Nac parameter is to be specified less than 50 ms and its initialization time is less than 500 ms. 2. Choose the âSD/SDXC Speedâ SDR12/SDR25 fuse configuration instead of SDR50/SDR104 when booting from an SD 3.0 card. SDR12/SDR25 is the default configuration. See i.MX6 device reference manual Fuse Map chapter for details on these fuses. If SD Card operation at a higher speed is desired, the SD/MMC can be reconfigured after ROM boot. Note that these fuses are also affected by ERR005645. 3. Boot from SPI-NOR initially then switch to SD/MMC, or One NAND once the external 32 kHz clock is stable. 4. Extend the assertion of POR_B until the 32 kHz crystal oscillator is running and stable. 5. Provide an external stable 32 kHz clock input prior to de-assertion of POR_B. OneNAND boot: 1. OneNAND: Choose a OneNAND memory with tRD1 less than 1.5 ms. 2. Boot from SPI-NOR initially then switch to SD/MMC, or One NAND once the external 32 kHz clock is stable. 3. Extend the assertion of POR_B until the 32 kHz crystal oscillator is running and stable. 4. Provide an external stable 32 kHz clock input prior to de-assertion of POR_B. NAND boot: 1. NAND: Choose a NAND memory with tRST less than 11 ms and tR less than 1 ms. Blow the i.MX6 âReset Timeâ fuse if the NAND device tRST is less than 6 ms. See i.MX6 device reference manual Fuse Map chapter for details on this fuse. 2. Boot from SPI-NOR initially then switch to SD/MMC, NAND or One NAND once the external 32 kHz clock is stable. 3. Extend the assertion of POR_B until the 32 kHz crystal oscillator is running and stable. 4. Provide an external stable 32 kHz clock input prior to de-assertion of POR_B.	ROM: 32 kHz internal oscillator timing inaccuracy may affect SD/MMC, NAND, and OneNAND boot [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	When booting in SD/SDXC boot mode, users cannot set the SD clock speed to Normal mode (SDR12). Selecting the SDR12 boot switch setting for BOOT_CFG1[3:2] in the fuse table will default to the High Speed mode (SDR25) due to an incorrect mapping in the boot ROM.	None. The minimum SD clock speed supported is high-speed mode (SDR25) for initial booting in SD/SDXC boot mode. When booting with an SD card that only supports SD clock speed in Normal mode (SDR12), users need to be aware of the revised SD/SDXC boot mode switch settings for BOOT_CFG1[3:2] given in Table 5. The automatic switch from high speed to normal speed is transparent to the user. Table 5. Revised SD/SDXC Boot Mode Switch Settings for BOOT_CFG1[3:2] BOOT_CFG1[3:2] SD/SDXC Boot Speed 0x SDR25 SDR50 SDR104	ROM: Normal SD clock speed (SDR12) not selectable in SD/SDXC boot mode
Cortex A-9	NXP	IMX6DQ	In case the primary image authentication fails, ROM will try to perform a WDOG reset and boot with the secondary image. However ROM does not set the SRE bit of watchdog control register which might cause a WDOG reset failure occasionally and result in ROM staying in an endless loop.	There are no software workarounds for this issue, instead the user will need to reboot the IC, which will force a second iteration of the secondary boot.	ERR005768 ROM: In rare cases, secondary image boot flow may not work due to mis-sampling of the WDOG reset [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	The phase fractional dividers (PFDs) used in PLL2 and LL3 can go into an unknown state if they are not properly reset before being used as clock sources. â¢ PFD is in an unknown state during boot. â This outcome affects the boot sources within the chip (for example, eMMC, NAND). â The ROM boot code fails to properly reset the PFDs, which are used for the bootable sources within the processor (for example, SD, eMMC). In rare circumstances, this has the potential of putting the PFDs into an unknown state whereby the boot sources do not receive correct clocks and the processor subsequently fails to boot. There are additional conditions this PFD issue can be triggered, outside the boot process, if the application software does not correctly reset the PFDs. â¢ Reprogramming PLL2/ PLL3 When PLL2/PLL3, which generate the PFD clocks, are powered up from the power down state or made to go through a relock cycle due to PLL reprogramming, in rare circumstances the PFDs can enter into a similar unknown state. It is therefore required that customer application software reset the respective PFDs using the PFDx_CLKGATE bits. The PFDs can be in the clock gated state during PLL relock, but must remain clock gated until after lock is achieved. â¢ Suspend & Resume with PLL2/PLL3 bypassed The PFDs can also lose state if the PLL is configured in BYPASS mode and the PFDs are not reset correctly. If the PLL is bypassed when entering suspend, the customer application software must ensure that the respective PFDx_CLKGATE bits are set. If the PLL is not BYPASSED, then the suspend/resume functionality is not affected. See the engineering bulletin, Configuration of Phase Fractional Dividers (EB790) for procedural details : http://fsls.co/doc/EB790.	â¢ Workaround #1âImplement and boot the system from SPI, I2C, Parallel NOR or SATA. Covers all boot sources. â¢ Workaround #2âUtilize the i.MX 6Dual/6Quadâs watchdog timer in Serial Downloader mode. Covers all boot sources except NAND. â¢ Workaround #3âUtilize an external watchdog timer or other reset source. Covers all boot sources. Table 7. Boot source and workaround mapping BOOT_CFG1[7:4] Boot source Available workaround mapping OneNAND (EIM) #1: Boot from SPI, Parallel NOR, I2C or SATA #2: Internal Watchdog Reset #3: External Watchdog Reset 010x SD/eSD/SDXC #1: Boot from SPI, Parallel NOR, I2C or SATA #2: Internal Watchdog Reset #3: External Watchdog Reset 011x MMC/eMMC #1: Boot from SPI, Parallel NOR, I2C or SATA #2: Internal Watchdog Reset #3: External Watchdog Reset 1xxx NAND #1: Boot from SPI, I2C,Parallel NOR or SATA #2: Not available for NAND #3: External Watchdog Reset SSD/Hard Disk (SATA) #1: Boot from SPI, Parallel NOR, I2C or SATA Serial ROM (I2C/SPI) #1: Boot from SPI, Parallel NOR, I2C or SATA Workaround #1âBoot from SPI, I2C or SATA: For the SPI/I2C, Parallel NOR, or SATA workaround, the application can boot entirely from SPI/I2C, Parallel NOR, or SATA. This corrects the issue. If the user needs to do the full boot from eMMC, SD, or NAND, then a small boot loader patch can be booted from SPI/I2C, Parallel NOR or SATA that resets the PFDs and then runs the eMMC, SD, or NAND flash boot function in ROM again. Patch information follows in the âLinux BSP Statusâ section. Users without the ability to boot from SPI/I2C or SATA (fully or to load the patch) should implement either an SPI/I2C/SATA/Parallel NOR boot source or one of the other workarounds below	ROM: ROM code uses nonreset PFDs to generate clocks, which may lead to random boot failures [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ			â¢ Users who do not or cannot use SPI/I2C or SATA as a boot source option can use this option. â¢ The i.MX 6Dual/6Quad contains a watchdog timer which can be activated via fuse whenever the processor enters Serial Downloader mode. The Watchdog timer begins a 90-second countdown and, if nothing interrupts this process, the part resets. â¢ For the watchdog timer workaround, on the rare occurrence of a PFD-related (or other) boot failure, the processorâs ROM falls through to Serial Downloader mode. This occurs in either secure boot or nonsecure boot devices. If the WDOG_ENABLE eFuse has been set to 1, then, on entering Serial Downloader mode, the watchdog begins a fixed 90-second countdown. If no external source interrupts this countdown, the watchdog timer expires and resets the part. Because the PFD-related error, if encountered, does not exhibit âmemory,â the subsequent boot operates correctly. No software is required to enable this functionality, only the setting of the WDOG_ENABLE eFuse to 1. â¢ This workaround applies for all boot sources except NAND boot (either SLC or MLC). For NAND boot, the user must implement either the SPI, I2C, or SATA workaround, or the external Watchdog workaround in #3 below. â¢ Use the following steps to understand how the watchdog timer will work in your system: 1. The user must not set BOOT_CFG3[2] (Boot Frequencies). They must be left at default. 2. The user programs the WDOG_ENABLE eFuse to 1. Note this is a permanent fuse setting which means the watchdog will begin countdown upon entering Serial Downloader mode anytime the chip enters this mode and must be stopped by software to prevent reboot. 3. The WDOG_ENABLE timer has a fixed 90-second countdown. This countdown cannot be changed in hardware, only via a software command. â¢ Because it is assumed a boot failure has occurred and the ROM has dropped into Serial Downloader mode, it is assumed no software is available to reset this 90-second countdown â¢ During the countdown, the unit will continuously poll for a USB connection on USB OTG1. If no activity is detected during the 90-second window, the watchdog expires and the ARM core is reset. â¢ If no boot error occurs, then Serial Downloader mode will not be entered and the Watchdog will not begin its countdown. Only when Serial Downloader mode is entered will the watchdog begin a countdown. NOTE Note: If the WDOG_ENABLE fuse is set, users who utilize the Freescale Manufacturing Tool or a customized version of the tool must ensure the kernel that is downloaded via the tool contains the instruction to turn off the watchdog timer. Otherwise, the watchdog will continue to count down and reset the part. Workaround #3âUtilize an external Watchdog reset or other external reset: The user implements an external watchdog or other reset watch such as via a PMIC. On a successful boot, the processor toggles the external watchdog through some I/O mechanism (for example, a GPIO) which prevents the watchdog from firing. If a boot failure occurs, the external watchdog will expire, thus resetting the processor. Proposed Solution: ROM Boot PFD reset issue is fixed in Silicon revision 1.3. Application software is still required to perform a PFD reset in Silicon revision 1.3 under the following conditions: â¢ Reprogramming (relocking) PLL2/PLL3 â¢ Implementing Suspend & Resume functionality with PLL2/PLL3 bypassed Linux BSP Status: Boot loader patch for SPI/I2C, Parallel NOR and SATA boot and the U-boot patch with the correct procedure to reset the PFDs is available for the Linux BSP GA release
Cortex A-9	NXP	IMX6DQ	The issue occurs when the two conditions below are both met: â¢ EIM NOR boot with plug-in is used, and â¢ Plug-in was specified running in the on-chip RAM (OCRAM). The ROM sets 0x907000 as the initial address of the source image (0x8000000 was expected) after pu_irom_hwcnfg_setup is called. The problem occurs when the plug-in calls this function again.	There are two workarounds for this issue: â¢ Modify the initial address to 0x8000000 (EIM nor base address) in the plug-in before pu_irom_hwcnfg_setup is called, or â¢ Specify the plug-in runs in EIM NOR directly instead of in internal RAM	ROM: EIM NOR boot may fail if plug-in is used
Cortex A-9	NXP	IMX6DQ	This issue occurs only when the first block in the firmware area (not FCB) is bad. If the first block of firmware area is bad, then ROM will skip to the next block to get the first 4KB data. After reading the next data block, ROM returns to the first block (which was the bad block) and ECC checking fails. Afterward, ROM will go to secondary boot because it is a NAND boot device which supports secondary boot. So firmware2 will work in this case if a secondary boot image has been burned into NAND. When the first block of the firmware area is bad, and the NAND page size is 4K or lower, this condition will occur. A bad block which is not the first one in firmware area will not cause this condition.	1. Burn the correct firmware address in FCB to ensure the first block of firmware is not bad. 2. Burn firmware2 into NAND. The possibility of both the first block of firmware1 and the first block of firmware2 being bad is highly unlikely.	ERR008506 ROM: Incorrect NAND BAD Block Management [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	RTC_XTALI picks up noise during crystal start up, during power up, and the boot sequence. Once the RTC crystal is stable and running, no noise interference is observed. The noise causes the RTC oscillator to output noise to an automatic multiplexer where the internal ring oscillator and the RTC oscillator are connected. If the noise contains frequency components higher than approximately 500 kHz, the output of the automatic multiplexer sends high frequency signals which causes General Purpose Timer (GPT) to count at a significantly faster rate than 32 kHz and causing a premature GPT timeout interrupt. The premature interrupt results in the boot ROM being redirected to USB serial download mode.		ROM: SD/EMMC/NAND prematurely times out during boot [i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	When a COMRESET or a COMWAKE is sent by the Host, it does not always send six bursts, but sometimes only five. It has been observed when OOB detection has failed, such as when COMWAKE is missed, or an error state or retry occurs. NOTE While this behavior is sufficient to complete OOB, it technically does not meet the SATA specification.	None.	ERR003761 SATA: 9000433864âCOMRESET and COMWAKE do not always contain six bursts
Cortex A-9	NXP	IMX6DQ	According to Section 10.11.3.1 of AHCI Specification, when an incoming SDB FIS has the N-bit set and the PMP value does not match the current port, the SATA Host controller should discard the FIS. Currently, the core delivers the FIS to the received FIS area.	Software should ignore BAD FIS.	SATA: 9000450053âIn SDB FIS with N-bit set, non-matching PMP field is not discarded
Cortex A-9	NXP	IMX6DQ	When software issues a SRST command while the device is sending a DMA Setup FIS (for a NCQ read command), it is possible that the PDMA module does not assert a tx_sync_esc signal to the Link layer, resulting in the subsequent Rx Data FIS not being SYNC-escaped. This is due to tx_xrdycoll=1 (while the TX FIFO is being cleared) in P_Idle causing a transition to CFIS_SyncEscape2, while tx_sync_esc is asserted only in the CFIS_SyncEscape state.	Wait until the command completes before issuing a SRST, or use COMRESET/Port Reset instead.	ERR003763 SATA: 9000448817âSoft Reset command does not SYNC-escape incoming data FIS
Cortex A-9	NXP	IMX6DQ	If PhyRdy goes low during reception of a non-data FIS, the ERR_I (Recovered Data Integrity) bit is set. Since deassertion of PhyRdy is not recoverable at any time, the ERR_I bit should not be set. However, according to the AHCI specification, the INFS bit should still be set if PhyRdy goes low during a non-data FIS.	Software can ignore the P#IS.INFS and P#SERR.ERR_I bits when the P#IS.PRCS bit is set.	SATA: 9000447882âERR_I bit set when PhyRdy goes low during non-data FIS reception
Cortex A-9	NXP	IMX6DQ	If any of the bits of the P#IS register is set when software issues global reset by setting GHC.HR=1, then the corresponding IS.IPS bit remains set, causing an erroneous interrupt (when GHC.IE=1) due to the p#_vint signal being registered/delayed from the Port module.	Generate global reset when all P#IS and IS bits are cleared.	ERR003765 SATA: 9000447627âGlobal reset does not clear IS.IPS register bits when P#IS is non-zero
Cortex A-9	NXP	IMX6DQ	When an outgoing TX data arriving at the Link Layer collides with an incoming Slumber power mode request, then the expected behavior for the Host is to ignore the request and send X_RDY. This causes the device to abort the power request. However, even though the response to this power request is correct, when the two events occur in the same exact cycle and internal tx_dp_rdy is also high, and at the same time, the Link State Machine is IDLE, then an internal flag is incorrectly set. Setting this flag affects a subsequent Partial mode request such that after normal power mode negotiation of the subsequent Partial request, if successful and not PMNAK, the core in some cases will assert both phy_partial and phy_slumber requests at the same time. In other cases, the core will assert just phy_slumber, instead of phy_partial. Both are incorrect behavior; only phy_partial should be asserted in this case.	Disable power modes.	SATA: 9000446485âphy_partial, phy_slumber incorrectly asserted for a power mode
Cortex A-9	NXP	IMX6DQ	As stated in Section 5.2.2.6 of AHCI Specification: âIf increments of hCccComplete are targeted for the same cycle as the clearing of hCccComplete to 0h, the final value shall be 0h. The additional completions are aggregated into the CCC interrupt that will be signaled imminently.â The core does not aggregate the additional completions into the same interrupt. When the device returns an SDB FIS with multiple NCQ command completions (multiple SACT bits are cleared) and CCC is enabled, if a subset of those multiple bits causes IS.CCC=1 interrupt, then the remaining bits are still counted as completions through hCccComplete register increments, possibly causing more IS.CCC interrupts to be generated.	None.	ERR003767 SATA: 9000446482âhCccComplete cleared, incorrectly incremented
Cortex A-9	NXP	IMX6DQ	If the PRD size is larger than the FIS size, then the SATA AHCI core asserts a PRD interrupt erroneously in the middle of a PRD data transfer. If one PRD spans more than one data FIS, the PRD interrupt asserts after the first data FIS, due to prd_i_done_q being set at the beginning of a data transmission instead of after the PRD transfer has completed.	Software ignores IS.DPS=1.	SATA: 9000445811âErroneous PRD interrupt assertion
Cortex A-9	NXP	IMX6DQ	If COMINIT is asserted during an RX data transfer (or any event causing the TX FIFO to be cleared, such as a COMRESET), then it is possible that during the TX FIFO clearing, tx_push_af=1 for one clock cycle. This causes p_dma_rrdy to negate for one clock cycle, and if this coincides with p_dma_wrresp=1, then p_dma_wrresp is extended for one extra clock cycle (so two cycles instead of one). This causes a tag FIFO coherency problem that can be fixed only by an asynchronous reset/power up.	None.	ERR003770 SATA: 9000451535âHang due to FIFO count change, when FIFO is cleared
Cortex A-9	NXP	IMX6DQ	If a software-issued soft reset collides with an incoming FIS, the core might hang and not transmit R_RDY when X_RDY is received. The behavior is caused by the Link asserting rx_firstdw and rx_dvalid for the FIS to the TCHK module after srst_req_asic=1.	Use COMRESET if commands are outstanding instead of soft reset.	SATA: 9000451305âHang after incoming FIS and soft reset
Cortex A-9	NXP	IMX6DQ	When both the Host and Device are idle and there is a collision of a Partial request from the Device and a Slumber request from software, then it is possible that both phy_partial and phy_slumber are asserted at the same time.	Disable power modes.	ERR003772 SATA: 9000451274âPower mode request collision causes assertion of phy_partial, phy_slumber
Cortex A-9	NXP	IMX6DQ	If software requests a Soft Reset and the Device sends a PMREQ at the same time, then it is possible that the SATA AHCI core could hang and only send SYNCs. This is a very rare case where the Soft Reset arrives in the Link Layer, a few cycles before the Power Request arrives from the Device. This behavior causes the Link state machine to move to sending SYNCs while waiting for SYNCs, but because it is left IDLE, the Device has already sent SYNCs and the Host should not check for them.	Use COMRESET instead of Soft Reset.	SATA: 9000451526âHang after Soft Reset and PM Request from the Device
Cortex A-9	NXP	IMX6DQ	After suspend and resume, the SATA PHY may fail to recognize the attached SATA device. There exists a limitation in the SATA PHY that a power-down sequence can only be initiated by the hardware after entering Slumber Mode. Slumber Mode is not a mandatory feature and is not supported by all SATA devices. The consequence of this limitation is, in the suspend phase, the PHYâs reference clock will be stopped without the following necessary steps having been executed: â¢ Power down the RX PLL and RX block â¢ Power down the TX block â¢ Power down the MPLL â¢ Then set mpll_ck_off to 1âb1 and suspend the reference clock The state of the PHY on resume is undefined when these steps fail to occur.	Workaround #1: Turn off/on the SATA_VPH power supply during suspend/resume. Removing and restoring power to the SATA PHY causes the PHY to reset. This workaround requires a controllable power supply for SATA_VPH and software modification to control the supply. Workaround #2: Add a SATA PHY CR-RESET in the resume through software. This will reset the PHY and allow the link to resume. After resume is initiated, the following steps are required: â¢ Wait a minimum of 100 us to allow the MPLL time to lock â¢ Perform the PHY CR reset â¢ Wait an additional 100 us to allow the RX PLL to lock (polling CR register bit ârx_pll_stateâ This workaround has the disadvantage that since the PHY is not actually powered-down, there will be increased power consumption (approximately 21 mW on a Freescale reference design) compared to workaround #1. Workaround #3: power-down is initiated from Slumber mode, the PHY performs suspend/resume correctly. This workaround requires software modification.	ERR007966 SATA:SATA speed negotiation fails after suspend and resume â[i.MX 6Dual/6Quad Only]
Cortex A-9	NXP	IMX6DQ	When a read command returns less data than specified in the PRDs (for example, there are two PRDs for this command, but the device returns a number of bytes which is less than in the first PRD), the second PRD of this command is not read out of the PRD FIFO, causing the next command to use this PRD erroneously. For some ATA and ATAPI commands that can return less data than requested legally, this underflow case is not an error case but normal operation, and it should complete without errors (as opposed to most commands where such a condition is considered an error). The following commands are known to legally return less read data than requested: 1) ATAPI commands used to return sense data (for example, Request Sense, Inquiry, Mode Sense) 2) ATA streaming commands (for example, READ STREAM EXT, READ STREAM DMA EXT)	Use only one PRD for each command. There may be buffer allocation failures when mass read/write commands are issued when only one PRD per command is forced. To prevent the allocation failures, pre-allocate one 64 kb buffer used for mass read/write commands.	ERR009598 SATA: PRD not flushed from PRD FIFO at command list underflow
Cortex A-9	NXP	IMX6DQ	If the SNVS_LP module logic is reset while the processor is in a Powered-On state, the SNVS_LP will set the PMIC_ON_REQ signal during power-up to OFF (low). If PMIC_ON_REQ is being used in the design to control an external PMIC, this will cause the PMIC to turn main power to the processor off when power is removed and then restored to SNVS_LP. The SNVS_LP module logic is not reset during a power-on reset (POR) due to the nature of its function. This condition is created when the following sequence of events occurs: 1) Software issues a reset to the SNVS_LP logic by setting the HPCOMR[4] bit to 1 (which is LP_SWR). This clears the SNVS_LP registers and the bit returns to 0. 2) Then the power to VDD_SNVS_IN is removed and restored while the rest of the processor remains powered. This is a controllable event, because the application can avoid condition 1.	If VDD_SNVS_IN is powered from a supply other than VDDHIGH_IN (like a coin cell), then the sequence described above must be avoided.	SNVS: SNVS_LP resets to the power OFF state
Cortex A-9	NXP	IMX6DQ	When the SSI is configured in AC97, 16-bit mode, the Rx data is received in bits [19:4] of the RxFIFO, instead of [15:0] bits.	The data should be shifted to the right location by the SDMA script or by the software in case of direct access to the register.	ERR003778 SSI: In AC97, 16-bit mode, received data is shifted by 4-bit locations
Cortex A-9	NXP	IMX6DQ	The data in SSI gets corrupted in the following configuration: â¢ SSI is configured to AC_97 mode â¢ Transmitter and receiver are enabled â¢ The IPG_CLK and external clock ratio is higher than 1:8 The internal âignore_time_slotâ signal might deassert for 1 cycle between frames. This might result in ambiguous behavior where the synchronization and identification of âignore_time_slotâ requires 4 ipg_clk cycles to fit in a half cycle of the external clock.	Do not use the following configuration: â¢ SSI is configured to AC_97 mode â¢ Transmitter and receiver are enabled â¢ The IPG_CLK and external clock ratio is higher than 1:8	SSI: AC97 receive data may be wrong when clock ratio between external clock to ipg is higher than 1:8
Cortex A-9	NXP	IMX6DQ	In I2S mode, with one FIFO in use, data is in the format left channel, right channel, left channel, right channel. If an under-run occurs, then the left and right channels will transmit the same previous data until new data is written to the FIFO. If the new data is valid as the right channel starts to transmit, a channel swap occurs. Likewise when receiving data, if an overrun occurs and the FIFO is emptied as the right channel data is being received, a channel swap occurs.	Use SSI in two-channel mode (TCH_EN = 1) with two FIFOs enabled (TFEN1=1, TFEN0=1). With two FIFOs in use, left channel transmit data is from FIFO0, right channel transmit data is from FIFO1. When an under-run occurs, the left channel will transmit the previous data in FIFO0, while the right channel will transmit the previous data in FIFO1. When new data is written into FIFO0/FIFO1, the left channel data is always from FIFO0, and right channel data is always from FIFO1, preventing channel swapping from occurring. Likewise when receiving data, left channel data is always stored in FIFO0 and right channel data is always stored in FIFO1.	ERR008990 SSI: Channel swap in single FIFO mode when an underrun or overrun occurs
Cortex A-9	NXP	IMX6DQ	When the IC works as a USB host and one High Speed device is connected, software can put it into Suspend mode and it can wake up by a Host Resume or a remote wakeup. The UTM block drives FS-K during resume and drives SE0 as the end of the resume. Meanwhile UTM bypasses the DP/DN lines to USB controller. Once the controller detects the SE0, it will switches to High Speed. Once UTM detects it switches to High Speed, it will stop driving SE0. After that, the controller starts to send SOF through UTM. If the controller sends the SOF too fast, while the external device might still be in Full Speed mode, the SOF signal level will be 800mV which will be recognized as a High Speed disconnection. The USB controller may send the SOF packet during that period, but according to USB2.0 spec, DP/DN should keep in IDLE (SE0 state) for 1.333 Î¼s after resume to avoid this issue (the device must switch to High Speed in 1.333 Î¼s).	The UTM block has a configurable bit (HW_USBPHY_CTRL.ENHOSTDISCONDETECT) to enable/disable the High Speed disconnection detection circuit. This bit should be used to disable this in Suspend, and enable after resume.	USB: Wrong HS disconnection may be generated after resume
Cortex A-9	NXP	IMX6DQ	When VBUS is applied without any other supplies, incorrect communication states are possible on the data (DP/DN) signals. If VDDHIGH_IN is supplied, the problem is removed.	Apply VDDHIGH_IN if battery charge detection is needed. Otherwise, disable charger detection by setting the EN_B bit in USB_ANALOG_USBx_CHRG_DETECTn to 1.	ERR006281 USB: Incorrect DP/DN state when only VBUS is applied
Cortex A-9	NXP	IMX6DQ	The USB host core operating in streaming mode might underrun while sending the data packet of an OUT transaction. The host then retries the OUT transaction according to the USB specification. This issue occurs during the OUT retry. The USB host might hang on OUT retry if the data buffer start address is not 4-byte aligned. This applies to both the host controller and the OTG controller in host mode.	â¢ Set the host TXFIFO threshold to a large value (TXFIFOTHRES in the TXFILLTUNING register). This increases the tolerance to bus latency and avoids a FIFO underrun. â¢ Set the Stream Disable bit (SDIS) to 1 in the USBMODE register. This forces the controller to load an entire packet in the FIFO before starting to transmit on the USB bus. Hence, the FIFO never underruns. This somewhat reduces the maximum bandwidth of the USB, because there is idle time when the controller waits for the entire packet to be loaded.	USB: Host non-doubleword âaligned buffer address can cause host to hang on OUT Retry
Cortex A-9	NXP	IMX6DQ	In device mode, The PHY can be put into Low Power Suspend when the device is not running or the host has signaled suspend. The PHY Low power suspend bit (PORTSC1.PHCD) will be cleared automatically when the host initials resume. Before forcing a resume from the device, the device controller driver must clear this bit. In host mode, the PHY can be put into Low Power Suspend when the downstream device has been placed into suspend mode (PORTSC1.SUSP) or when no downstream device is connected. Low power suspend is completely under the control of software. To place the PHY into Low power mode, software needs to set PORTSC1.PHCD bit, set all bits in USBPHY_PWD register and set the USBPHY_CTRL.CLKGATE bit. When a remote wakeup occurs after the Suspend (SUSP) bit is set while the PHY Low power suspend bit (PHCD) is cleared, a USB interrupt (USBSTS.PCI) will be generated. In this case, the PHCD bit will NOT be set because of the interrupt. However, if a remote wakeup occurs after the PHCD bit is set while the USB PHY Power-Down Register (USBPHY_PWD) and the UTMI clock gate (USBPHY_CTRL.CLKGATE) bit is cleared, a remote wakeup interrupt will be generated. In this case, all the bits in the HW_USBPHY_PWD register and the USBPHY_CTRL.CLKGATE bit will be set, even after the remote wakeup interrupt is generated, which is incorrect.	To place the USB PHY into low power suspend mode, the following sequence should be performed in an atomic operation (interrupts should be disabled during these three steps): 1. Set the PORTSC1.PHCD bit 2. Set all bits in the USBPHY_PWD register 3. Set the USBPHY_CTRL.CLKGATE bit	ERR004535 USB: USB suspend and resume flow clarifications
Cortex A-9	NXP	IMX6DQ	If a receive FIFO overrun occurs (due to a busy condition on the system bus) when the USB controller is in Device mode, the controller may stop responding to host tokens, causing current transactions to time out. This situation will be recovered after FIFO is not overrun.	Set Stream Disable mode (USB_nUSBMODE[SDIS]=1) to prevent receive FIFO overruns.	USB: Timeout error in Device mode
Cortex A-9	NXP	IMX6DQ	uSDHC3 and uSDHC4 clock-gating controls (CG and MOD_EN_OV) in CCM are gating RAWNAND and APBADMA clocks. â¢ apbhdma.hclk controlled by usdhc3_clk_root CGR â¢ rawnand.u_bch_input_apb_clk controlled by usdhc3_clk_root CGR â¢ rawnand.u_gpmi_input_apb_clk controlled by usdhc3_clk_root CGR â¢ rawnand.u_gpmi_bch_input_bch_clk controlled by usdhc4_clk_root CGR	uSDHC3 and uSDHC4 clock-gating controls should not be configured to gate the clocks in case RAWNAND and APBADMA are used. There are two registers in CCM that need to be configured accordingly: â¢ CCGR: Gating of the clock according to power mode â¢ CMEOR: Enable/Disable dynamic clock gating	ERR004364 uSDHC: Limitations on uSDHC3 and uSDHC4 clock-gating
Cortex A-9	NXP	IMX6DQ	When a multi-block read command is triggered, the controller starts to send read commands and receives data from the card. After one block of data is received, the expected block count number will be updated (minus 1). Meanwhile the DMA engine starts to fetch the ADMA descriptors through the AHB bus. The descriptor contains two AHB SINGLE bus accesses for ADMA2 and one AHB SINGLE bus access for ADMA1. The DMA engine then loads the expected block count. If the total latency of these AHB SINGLE bus accesses is longer than the latency for one block to be read from the card, an incorrect block count is loaded by the DMA engine.	Use SDMA (or ADMA1) in case the AHB latency is larger than the âminimal time for one blockâ.	uSDHC: ADMA Length Mismatch Error may occur for longer read latencies
Cortex A-9	NXP	IMX6DQ	Wrong interrupt is generated sometimes when context switching to H.264 encoder, during multi-instance. For example, â¢ From decoders (which use NAL unit, such as H.264, AVC, and VC1) to H.264 encoder â¢ From H.264 to H.264 with different instance â¢ H.264 dec to RV dec and RV dec to H.264 enc There are two modes in SPP (Stream Pumping processor) of VPU: direct mode and descriptor mode. SPP âsdma_ctrlâ block generates internal interrupt when switching from direct mode to descriptor mode. The interrupt keeps high and this affects H.264 encoder (H.264 encoder uses descriptor mode).	Before start of H.264 encoder from direct mode, clear the register that generates interrupt by software reset.	ERR004345 VPU: Wrong interrupt is generated sometimes when context switch- ing to H.264 encoder, during multi-instance
Cortex A-9	NXP	IMX6DQ	The bitstream of Sorenson Spark codec has two versions: Version 0 and Version 1. This issue causes the VPU to fail to decode Version 0 bitstream (sequence initialization error) because the VPU cannot find the start code and returns the SEQ_INIT error for decoding a Version 0 bitstream. The VPU can decode a Version 1 bitstream.	No software workaround.	VPU: Cannot decode Sorenson Spark Version 0 bitstream
Cortex A-9	NXP	IMX6DQ	VPU will not work in case of: â¢ Smaller chunk size (less than 8 bytes) bitstreaming process in SPP (streaming pump processing) mode â¢ Low bit rate â¢ Low-resolution video application	If the remaining bitstream in the bitstream buffer is less than 8 bytes, then the application should fill 0âs until there are 8 bytes in the buffer. This will allow VPU to read out and decode properly.	ERR004361 VPU: VPU does not work in case of smaller chunk size in SSP (stream- ing pump processing)
Cortex A-9	NXP	IMX6DQ	Causes a macro-block of P-picture decoding error which results in degradation of visual quality. Conditions: This bug occurs when all of the following conditions are true at the same time: â¢ The sign bias flag for the neighborhood macro-block (MB) of the reference frame differs from the sign bias flag of the current MB in the reference frame â¢ The motion vector of neighborhood MB is not zero (left or above) â¢ The (negated) motion vectors in the left and above MBs are same	A VPU firmware workaround exists which requires the VPU to run at 350MHz for decoding 1080p@30fps for video that displays this issue.	VPU: Causes a macro-block of P-picture decoding error
Cortex A-9	NXP	IMX6DQ	In order to initiate a software reset through WDOG, the SRS bit should be written twice.	The WDOG SRS software reset bit should be written twice within one period of the 32 kHz clock.	ERR004346 WDOG: WDOG SRS bit requires to be written twice
Cortex A-9	TI	OMAP4470	If a General Purpose Timer (GPTimer) is in posted mode (TSICR.POSTED=1), due to internal resynchronizations, values read in TCRR, TCAR1 and TCAR2 registers right after the timer interface clock (L4) goes from stopped to active may not return the expected values. The most common event leading to this situation occurs upon wake up from idle. GPTimer non-posted synchronization mode is not impacted by this limitation. This limitation also impacts read from Watchdog timers WCRR registers. All the watchdog timers support only POSTED internal synchronization mode. There is no capability to change the internal synchronization scheme to NON-POSTED by software. The 32KSYNCNT_CR register is also impacted by this limitation, since the 32K sync timer is always in posted synchronization mode.	Software has to wait at least (2 timer interface clock cycles + 1 timer functional clock cycle) after L4 clock wakeup before reading TCRR, TCAR1 or TCAR2 registers for GPTimers in POSTED internal synchronization mode, and before reading WCRR register of the Watchdog timers . The same workaround must be applied before reading 32KSYNCNT_CR register of the 32K sync module.	1.1 Delay needed to read some GP timer, WD timer and sync timer registers after wakeup
Cortex A-9	TI	OMAP4470	Because of a glitchy structure inside the UART module, accessing the MDR1 register may create a dummy underrun condition and freeze the UART in IrDa transmission. In UART mode, this may corrupt the transferred data(received or transmitted).	To ensure this problem does not occur, the following software initialization sequence must be used each time MDR1 must be changed: 1. If needed, setup the UART by writing the required registers, except MDR1 2. Set appropriately the MDR1.MODE_SELECT bit field 3. Wait for 5 L4 clock cycles + 5 UART functional clock cycles 4. Clear TX and RX FIFO in FCR register to reset its counter logic 5. Read RESUME register to resume the halted operation Step 5 is for IrDA mode only and can be omitted in UART mode.	1.2 MDR1 access can freeze UART module
Cortex A-9	TI	OMAP4470	Minimum number of pixels for MIPI command mode from the video port should be greater than 1 (at least 2). Image with less than 2 pixels is not expected to be used in a real applicative use case.	If sending a single pixel is needed, the OCP L4 slave port can be used (through CPU or sDMA).	1.3 DSI: Minimum Of 2 Pixels Should Be Transferred Through DISPC Video Port
Cortex A-9	TI	OMAP4470	Transfer using tearing effect cannot be cancelled (writing TE_SIZE to 0). Writing TE_SIZE would have no effect and transfer would continue.	Always wait for tearing effect to complete before changing any configuration.	1.4 DSI: Cancel Tearing Effect Transfer
Cortex A-9	TI	OMAP4470	RX FIFO fullness can be incorrect just after a FIFO read. FIFO fullness should be read only once at the beginning of the transfer. Other accesses during a transfer are not guaranteed.	Use only programming model provided in Programming Model section in the TRM.	1.5 DSI: RX FIFO Fullness
Cortex A-9	TI	OMAP4470	This register must not be written twice when TxByteClkHS is stopped to avoid L4 OCP port deadlock.	User must check that the TxByteClkHS clock is activated before initiating any write access to DSI_TIMING2 register. To ensure the TxByteClkHS clock is active, the user must check: 1. PLL is locked (DSI_PLL_STATUS register; DSI_PLL_LOCK bit) 2. DSIPHY must be in ON power state (PWRCMDON). 3. Clock/Data lane positions are correctly set (DSI_COMPLEXIO_CFG1.xxx_POSITION).	1.6 DSI: Access Restriction On DSI_TIMING2 Register
Cortex A-9	TI	OMAP4470	Executing a FIFO flush does not properly clean the logic, thus resulting in unpredictable behavior of the module.	User must perform module software reset when a transfer is aborted.	1.7 DSI: Tx FIFO Flush Is Not Supported
Cortex A-9	TI	OMAP4470	In case of destination synchronized transfer on the write port (or source sync with SDMA.DMA4_CCRi[25] BUFFERING_DISABLE = 1), if a transaction error is reported at the last element of the transaction, the channel is not automatically disabled by DMA.	Whenever a transaction error is detected on a transaction on the write side of the channel i, software must disable the channel(i) by setting the DMA4_CCRi[7] ENABLE bit to 0.	1.8 sDMA Channel Is Not Disabled After A Transaction Error
Cortex A-9	TI	OMAP4470	The first packet in command mode is not sent due to inaccurate clock gating. Root cause description: In command mode when DDR_CLK_ALWAYS_ON and IF_EN are set to 1, DDR clock is not present immediately after the IF_EN bit is set to 1 but when the first HS packet from OCP is ready to be sent to PPI HS link. The DDR_CLK_PRE field is used between the start of the DDR clock and the assertion of the data request signal. After the time defined by the DDR_CLK_PRE field, the clock lane is always present until the IF_EN bit is set to 0. So, there is a delay between IF_EN set to 1 and assertion of the clock lane.	In case of command mode where DDR clock should be provided to peripheral before data, the workaround is to program DDR_CLK_PRE =! 0. The value of DDR_CLK_PRE must take into account the different timings: TCLK_PREPARE, TCLK_ZERO. Sequence to enable the DSI: 1. Set the ForceTxStopMode bit to 1 (DSI_TIMING1 register). This asserts the ForceTxStopMode. 2. Enable virtual channel in command mode / Enable DSI interface. 3. Poll the ForceTxStopMode bit to 0 (DSI_TIMING1 register) until deassertion of the ForceTxStopMode bit. The hardware resets this bit at the end of the counter value. 4. Send SOF(0x00000000) packet in command mode.	1.9 DSI SOF Packet Not Send
Cortex A-9	TI	OMAP4470	SIMCOP LDC module doesn't reach 100 MPix/s target in bilinear mode for YUV420 data.	Use LDC in YUV422 mode.	1.10 SIMCOP Lens Distortion Correction issue
Cortex A-9	TI	OMAP4470	The SOFTRESET bit of the SYSCONFIG register inside CBUFF (CBUFF_HL_SYSCONFIG[0] SOFTRESET) is set to 0x0 (reset done state) after reset only if CBUFF is out of IDLE. While CBUFF slave data port is in IDLE, the SOFTRESET bit is always set to 0x1 (status bit gives an ongoing reset, but reset is finished).	Ignore status of the the SOFTRESET bit. After a software reset, wait a few cycles before using the module.	1.11 ISS: SOFTRESET Bit Status Not Working For Circular Buffer
Cortex A-9	TI	OMAP4470	The SOFTRESET bit of the SYSCONFIG register inside BTE (BTE_HL_SYSCONFIG[0] SOFTRESET) is set to 0x0 (reset done state) after reset only if BTE is out of IDLE. While BTE slave data port is in IDLE, the SOFTRESET bit is always set to 0x1 (status bit gives an ongoing reset, but reset is finished).	Ignore the status of the SOFTRESET bit. After a software reset, wait a few cycles before using the module.	1.12 ISS: SOFTRESET Bit Status Not Working For Burst Translation Engine
Cortex A-9	TI	OMAP4470	Debug read operations should not impact the internal state of the module. That cannot be guaranteed because debug reads of some locations can impact DMA requests. Also, some read accesses may be stalled for a long time while ISP operation is ongoing.	To avoid read access from being stalled, the CPU must have the priority. This can be configured in the ISP5_MPSR register. Dummy accesses during frame processing lead to data corruption however response is given immediately. This register can be used to avoid stalling debug accesses. Dummy data is returned in that case but does not hurt functionality because debug accesses do not make sense while ISP5 is processing data.	1.13 ISS State Can Be Corrupted During Debug Mode
Cortex A-9	TI	OMAP4470	DSI engine is not always detecting the first VSYNC HSYNC signals received on the video port in video mode.	Because before first VSYNC rising edge, one HSYNC is transmitted and clock is transmitted during that HSYNC period, the workaround is to have the HSYNC period of DISPC longer than the timing described below: • Configuration with line buffers: 3 VP_PCLK + 6 VP_CLK + 6 DSI_CLK • Configuration without line buffers: 3 VP_PCLK + 2 VP_CLK There is no need to take care of some timings related to enabling the IF_EN, VC_EN, LCD output of the DSIPC.	1.14 DSI VSYNC HSYNC Detection In Video Mode
Cortex A-9	TI	OMAP4470	When two video ports are available at the input of the DSI protocol engine, the two streams are interleaved by the DSI protocol engine. Only one video mode is supported by the current implementation on VP1 only. VP2 cannot be in video mode even if VP1 is not in video mode.	No	1.15 Dual Video Mode
Cortex A-9	TI	OMAP4470	The buffer handshake feature in the DISPC avoids underflow of the DISPC DMA FIFO. The fullness of the DISPC DMA FIFO is checked before providing data to the pipeline when STALL signal is inactive. When the FIFO hand check feature is activated, the pixel transfer to the DSI module during STALL inactivity period can be stopped (no DISPC_PCLK pulse) and restarted when there is enough data in the FIFO. The DSI protocol engine is configured in command mode. On video port 1 in command mode, when DISPC_DIVISOR1.PCD = 2, DISPC_CONFIG1.BUFFERHANDCHECK = 1 and DSI_CTRL.VP_CLK_RATIO = 0, the FRAMEDONE IRQ might not be triggered and TE_SIZE counter might not be decremented to 0. This is caused by a deadlock between the DISPC and DSI modules during the transfer of the last pixel of a line On video port 2 in command mode, when DISPC_DIVISOR2.PCD = 2, DISPC_CONFIG2.BUFFERHANDCHECK = 1 and DSI_CTRL2.VP_CLK_RATIO = 0, the FRAMEDONE IRQ might not be triggered and TE_SIZE counter might not be decremented to 0. This is caused by a deadlock between the DISPC and DSI modules during the transfer of the last pixel of a line. The DSI protocol engine sends a STALL to the DISPC (stall mode); in parallel the DISPC stops the pixel clock to the DSI because it is waiting for its FIFO DMA to be refilled (buffer handcheck feature). When FIFO DMA is refilled, the DISPC being in stall mode does not provide back the pixel clock to the DSI to deassert the stall and it does not send the last pixel to the DSI.	DISPC_DIVISORi[7:0] PCD = 2 is not supported, where i = 1 to 3. DISPC should be set to DISPC_DIVISORi[7:0] PCD = 3 or above and DSI_CTRLi[4] VP_CLK_RATIO to 0x1.	1.16 Deadlock Between DISPC And DSI When PCD = 2, VP_CLK_RATIO = 0
Cortex A-9	TI	OMAP4470	When coming out of off mode, the memory controllers assume connected SDRAMs to be in self-refresh mode. The EMIF receives a DEVICE_OFFWKUP_CORERSTACTST signal from the PRCM defining if an EMIF cold reset was due to a global reset or to exiting off mode; • In case of a global cold reset, the full SDRAM init phase is performed. • In case of off mode exit, only the self-refresh exit sequence is performed and auto-refresh commands are immediately sent. If the memory was in deep power-down state during the chip off mode, the sequence performed by EMIF could result in an unexpected behavior on the memory side. Exit from DPD actually requires the same full init sequence as after a global cold reset.	Software workaround: • Before getting into off mode, force the value stored in the control module EMIF_SDRAM_REF_CTRL.REG_INITREF_DIS to 1. – This forces the value for the EMIF register to 1 when its content is restored when returning from off mode. • When returning from off mode, and before making any access to the memory in DPD state: 1. Put CORE PLL in MN bypass mode CM_CLKMODE_DPLL_CORE.DPLL_EN = 0x4. 2. Program the DLL override CM_DLL_CTRL.DLL_OVERRIDE = 1. 3. Force the configuration field EMIF_SDRAM_CONFIG.REG_SDRAM_TYPE register to 0x1 (reserved), then back to 0x4 (LPDDR2-S4) or 0x5 (LPDDR2-S2) according to memory configuration. This forces the controller back into its init state instead of self-refresh state. 4. Reconfigure EMIF_SDRAM_REF_CTRL.REG_INITREF_DIS to 0. 5. Perform normal init phase as from global cold reset.	1.17 Deep Power-Down Support During Off Mode
Cortex A-9	TI	OMAP4470	RTA (retention till access) feature is not supported and leads to device stability issues when enabled. The following modules are embedding memories with RTA support: • MPU subsystem (cache memories) • OCM RAM • SGX • Display subsystem • HS USB OTG • IVA-HD subsystem • Face detect • Imaging subsystem • DMM • DSP subsystem • AESS	PRM_LDO_SRAM_<Memory Voltage Domain>_SETUP[0] DISABLE_RTA_EXPORT default value is loaded by an eFuse value. The fuse value disables this RTA feature, so these bits must be kept at default value.	1.18 RTA Feature Is Not Supported
Cortex A-9	TI	OMAP4470	Due to design issue MMCHS_HCTL.HSPE bit does not work as intended. This means that the configuration must always be the normal speed mode configuration (MMCHS_HCTL.HSPE=0).	None	1.19 MMCHS_HCTL.HSPE Is Not Functional
Cortex A-9	TI	OMAP4470	When in YUV4:2:0 format in 1D burst, the DISPC DMA skips lines when fetching Chroma sampling.	If YUV4:2:0-1D burst is required: • Set DISPC_VIDp_ATTRIBUTES[22]DOUBLESTRIDE to 0x0 and DISPC_VIDp_ATTRIBUTES[13:12]ROTATION to 0x1 or 0x3	1.20 Wrong Access In 1D Burst For YUV4:2:0-NV12 Format
Cortex A-9	TI	OMAP4470	The DSI-PHY has an internal LDO. This LDO is used to convert 1.8V coming from VDDS_DSI input into 1.2V for appropriate DSI voltage level. An internal LDOPWRGOOD signal output by the DSI_PHY indicates the status of the LDO (LDO is up or is down). This signal should be connected to the DSI protocol engine for IRQ reporting (LDO_POWER_GOOD_IRQ). This signal is not connected to the DSI protocol engine and input of protocol engine is tied to 0x0.	There is no workaround to check HW status of DSI LDO. The LDO_POWER_GOOD_IRQ should be disabled by keeping or setting DSI_IRQENABLE.LDO_POWER_GOOD_IRQ_EN to 0x0.	1.21 Status of DSI LDO Is Not Reported to DSI Protocol Engine
Cortex A-9	TI	OMAP4470	When a break frame is sent in the middle of data transfers (DMA based),in pipelined flow or synchronized flow, one Tx data frame will be overwritten at the transmitter side by an all-zeros frame (break is received correctly). Table 1-1. Data Corruption Example Transmitted Data: Received Data: 0x77CFA0B0 0x77CFA0B0 0xDFFC7B49 0x00000000 <- break frame and data last 0x5BE7AD07 0x5BE7AD07 0x7F7F1BC8 0x7F7F1BC8 .... ....	No workaround identified.	1.22 HSI Break Frame Corrupt OnGoing Transfer
Cortex A-9	TI	OMAP4470	The counter configuration capabilities include start (begin counting), stop (halt counting), and load (set time-out period). It is not possible to disable the frame time-out and tailing bit error counters. Setting value 0 in HSR counters (HSR_COUNTERS_Pp[23:20]TB = 0x0 and HSR_COUNTERS_Pp[19:0]FT = 0x0) disables those counters, whereas errors keep being generated with this value. In transient setup phases where TX and RX data rates are still not aligned, false errors may be reported by HSR. Because HSR halts the reception upon an error (until the error is acknowledged) communication will be broken. In such circumstances, inability to disable error detection may be a critical problem.	To disable error reporting: • Set HSR_COUNTERS_Pp[19:0] FT counter to max value (0xFFFFF) • Set HSR_COUNTERS_Pp[23:20] TB error to min value (0x0)	1.23 HSI Error Counters Cannot Be Disabled
Cortex A-9	TI	OMAP4470	When transferring a data on McPDM uplink path, if the McPDM uplink path is reset by MCPDM_CTRL.SW_UP_RST, uplink FIFO is correctly reset but the dma pending signal is kept asserted. This can result in an invalid access by the host DMA to uplink FIFO. The same applies to DMIC if reset by DMIC_CTRL.SW_DMIC_RST.	Follow the programming model below to disable and enable the channels: • Disable the channels: – Set the MCPDM_CTRL.SW_xx_RST bit to 1. – Disable all channels. – Set the MCPDM_CTRL.SW_xx_RST bit to 0. • Enable the channels: – Set the MCPDM_CTRL.SW_xx_RST bit to 1 – Enable necessary channels. – Set the MCPDM_CTRL.SW_xx_RST bit to 0. Note: SW_xx_RST is either MCPDM_CTRL_SW_UP_RST, CPDM_CTRL_SW_DN_RST, or DMIC_CTRL.SW_DMIC_RST.	1.24 McPDM/DMIC Issue With Software Reset With SW_xx_RST
Cortex A-9	TI	OMAP4470	UART TX with a DMA THRESHOLD default configuration of 64 bytes would result in extra DMA Req assertion when FIFO tx_full is switched from high to low. This is because of the TX THRESHOLD added in ES2.0 compared to ES1.0.	Use TX_THRESHOLD+TRIGGER_LEVEL <= 63 (TX FIFO Size - 1).	1.25 UART: Extra Assertion of UARTi_DMA_TX Request
Cortex A-9	TI	OMAP4470	Software initiated read/write accesses to the PHY ULPI registers (that is, when using USB OTG ULPIReg registers) may be wrongly mixed up with USB OTG Tx traffic. Due to this corruption the USB OTG will detect a Vbus error or a Babble error (logged in IntrUSB register), and halts the communication. Hardware initiated accesses to the PHY ULPI registers are not impacted because they occur during connect, disconnect, suspend, and resume, when there is no USB traffic. Only software initiated accesses are impacted, and only when there is on-going USB Tx transfers.(including SOF in host mode) Software initiated accesses during connect, disconnect, suspend, and resume are not impacted. Host and peripheral modes are impacted.	If possible do not use software initiated reads/writes to access the PHY ULPI registers. Depending on the PHY, there may be a possibility to access these registers by I2C. If the USB OTG is host, another workaround consist in putting the bus in suspend mode with low-power mode disabled when willing to read/write an ULPI PHY register: • Disable PHY low-power mode (Power:EnableSuspendM=0) • Execute USB SUSPEND. • Do the ULPI register read/write • Execute USB RESUME • Restore Power:EnableSuspendM. If the USB OTG is peripheral, another workaround consists in using the 1-2us time frame after reception of SOF, before any transfer begins on the bus: • Enable the SOF interrupt • Program the ULPIReg registers except the ULPIRegControl:D0 bit • When the SOF interrupt fires, set the ULPIRegControl:D0 bit to make the access • Disable the SOF interrupt	1.26 USB OTG Software Initiated ULPI Accesses To PHY Registers Can Halt the Bus
Cortex A-9	TI	OMAP4470	The prefetch error event (PREFETCH_ERROR) is triggered when the gain table is read too slowly from SDRAM. When this event is pending the module should go into transparent mode, meaning LSC should copy input pixels to output pixels (output=input). Actually, when the prefetch error event occurs the LSC module outputs black pixels.	None	1.27 ISS-SIMCOP: ISS-LSC Not Transparent After Prefetch Error Event
Cortex A-9	TI	OMAP4470	When an RX wake-up mechanism is used for the UART module, the first character received can be lost.	This is a known behavior and is dependant on the speed of response of the PRCM module to a wakeup. The CTS wake-up mechanism should be preferred when it is possible.	1.28 UART: In an RX Wake-up Mechanism, the First Received Character Can be Lost
Cortex A-9	TI	OMAP4470	The issue occurs during concurrent accesses of CPU0 and CPU1 as described below. If one CPU fetches code from external RAM while the other CPU requires the access to the EMIF firewall (configuring its register REGUPDATE_CONTROL), then both CPUs hang. The issue occurs because when REGUPDATE_CONTROL.BUSY_REQ is activated, the interconnect blocks the accesses. Because the two CPUs of the MPUSS use the same bridge before the L3 interconnect, this bridge is saturated if one CPU is accessing external RAM.	The workaround is to make sure that the other CPU is not doing external accesses through EMIF when a CPU is updating the EMIF firewall. The issue does not occur with the other initiators because they do not share the bridge before the L3 interconnect.	1.29 Platform Hangs When CPU Tries To Configure The EMIF Firewall
Cortex A-9	TI	OMAP4470	If bus keeper mode is used (programmed through CONTROL_LPDDR2IO*_*.LPDDR2IO*_GR*_WD) after leaving open switch retention, it is necessary to reset the DDR PHY. Otherwise the LPDDR2 memory cannot be accessed.	If bus keeper mode is used, issue a PHY reset after leaving OSWR, set bit [10] to 1 at the following address (using read modify write to this register to keep other bits): • Assert PHY reset for EMIF1 @ x 4C00 0060 • Assert PHY reset for EMIF2 @ x 4D00 0060 Because this resets the command line, this reset must be done when memory is in self-refresh mode.	1.30 DDR PHY Must be Reset After Leaving OSWR
Cortex A-9	TI	OMAP4470	If data is stalled inside an asynchronous bridge because of back pressure, it may be accepted multiple times, thus creating pointer misalignment that corrupts next transfers on that data path until the next reset of the system (no recovery procedure once the issue is hit, the path remains consistently broken). The async bridge can be found on the path between MPU to L3 interconnect (to EMIF) and Cortex M3 to L3 interconnect (to EMIF). In the OMAP4460 and OMAP4470 devices, direct path from MPU to EMIF (through memory adapter in MPU-SS) is replacing MPU-to-DMM path, which was taking place in the OMAP4430. Hence, in an OMAP4460 or OMAP4470 device, this bug is not impacting the direct path from MPU to EMIF (through memory adapter in MPU-SS). This situation can happen only when the idle is initiated by a master request disconnection (which is trigged by software when executing WFI).	All the initiators connected through async bridge must ensure that data path is properly drained before issuing WFI. This condition is met if one strongly ordered access is performed to the target right before executing the WFI.	1.31 Async Bridge Corruption
Cortex A-9	TI	OMAP4470	It is not possible to perform USB transactions with a FS device on port USB_B1/B2. EHCI is able to detect the device, reset it and find that it is a FS device. SW will then hand off the port to OHCI by setting PORTSC[5]:PO (PORT OWNER) bit. OHCI is able to detect the connection, but then cannot communicate with the device. When the PHY switches to FsLsSerialMode, the ULPI DIR signal will go to 1 forever. In HS mode, if DIR is 1, then the ULPI DATA switch to "input only" mode. This input only configuration is wrongly kept after switching to FsLsSerialMode, hence USB transactions cannot occur. Attaching a FS device directly to an OHCI port is working fine.	Only attach FS devices to OHCI ports, or use a HS hub to interface between EHCI ports and LS/FS/HS devices.	1.32 USB HOST - Impossible To Attach a FS Device To An EHCI Port. Handoff To OHCI Is Not Functional
Cortex A-9	TI	OMAP4470	When entering USB suspend mode, the EHCI will automatically ask the PHY to enter low power mode (PHY function control register bit suspendM is reset). The PHY will then cut the ULPI_CLK after a minimum of 5 clock cycles.(no maximum specified). On the other hand, the EHCI embeds a counter counting up to 18 before cutting the internal clock after suspend signal is asserted. Since the PHY cuts the clock prematurely, the counter is not reaching 18. However, the first suspend and resume will work correctly. At the second suspend sequence, since the counter has maintained the value (thanks to retention flops), the counter reaches 18 and cuts the clock internally. As a consequence, the internal state machine does not transition to the correct state causing the next resume to fail. Both host initiated resume and remote wakeup are impacted by this issue.	After setting the suspend bit, switch the internal clock supply from the external ULPI_CLK provided by the PHY to the internal 60 MHz clock. This will allow the internal counter to reach 18. Then after 1ms, switch back to the external ULPI_CLK. This switch can be done thanks to the CM_L3INIT_HSUSBHOST_CLKCTRL[25:24]:CLKSEL_UTMI_P1/2 bits. During the application of the WA, the CM_L3INIT_HSUSBHOST_CLKCTRL[9:8]OPTFCLKEN_UTMI_P1/2_CLK optional clocks need to be enabled.	1.33 USB HOST EHCI - Port Resume Fails On Second Resume Iteration
Cortex A-9	TI	OMAP4470	There is no H/W mechanism preventing violating below I2C Bus clear standard requirement. If the data line (SDA) is stuck LOW, the master should send 9 clock pulses. The device that held the bus LOW should release it sometime within those 9 clocks. If not, then use the HW reset or cycle power to clear the bus. Sys_Warmreset doesn't reset the I2C IP at Phoenix level, it does at IC level. Resetting the IP at Phoenix PMIC would avoid such situation, but this is partial answer as many other I2C slave devices could be addressed during Warm reset without any sensitivity to this sys_warmreset pin. No other reset source possible at Phoenix level to reset the I2C controller (only Cold Reset). So, once the situation is reached, IC is seeing bus busy status bit.	I2C SW handler could be programmed to detect such a locked situation. In this case, it will check the Bus Busy bit and issue the needed clock pulses.	1.34 System I2C hang due to miss of Bus Clear support
Cortex A-9	TI	OMAP4470	There are some fails while suspending then resuming on going HSI communication on both HST and HSR initiatives. If this is the HST initiative: 1. It is possible to suspend then resume communication by disabling then enabling active HST FIFOs through HST_MAPPINGf [0] ENABLE bit. Transmission stops as soon as TX FIFO is disabled (ENABLE bit equal to 0x0) and resumes as soon as TX FIFO is re-enabled (ENABLE bit equal to 0x1). 2. It is not possible to suspend then resume safely by setting HST mode to SLEEP. Writing HST_MODE_Pp[1:0] MODE_VAL = 0x0 (SLEEP) does not have any impact on transmission that continues. If it is the HSR initiative: 1. It is not possible to suspend then resume communication by disabling then enabling active HSR FIFOs through HSR_MAPPINGf [0] ENABLE bit. Disabling the RX FIFO does not stop the transmission (by dropping the READY line). The data keeps being sent by HST and HSR simply discards it. By the way, no RX mapping error is generated. Transmission did not actually stop and frame is lost by HSR. 2. It is not possible to suspend then resume safely by setting HSR mode to SLEEP. Writing HSR_MODE_Pp[1:0] MODE_VAL = 0x0 (SLEEP) stops any ongoing transfer unconditionally which may result in loss of frame(s) once the transfer is resumed.	If this is the HST initiative: It is not possible to configure MODE_VAL bit to SLEEP with active data transfers because it has no impact. The only way to suspend then resuming a HSI communication with HST is to disable then re-enables active TX FIFOs. If this is the HSR initiative: There is no way to suspend then resume the receiver without data loss.	1.35 HSI: Issues In Suspending and Resuming Communication (HSR and HST)
Cortex A-9	TI	OMAP4470	There is a bug in HSI IP;once the SW reset bit is set through the HSI_SYSCONFIG[1] SOFTRESET bit, the SW reset is not propagated well if there is an on-going reception. If the reception never ends (synchronization loss, interrupted transmission from transmitter...), then this is a deadlock, the SW reset is not propagated and there is no OCP access possible.	Use the HW reset from the PRCM instead of the local SW reset.	1.36 HSI: Issue with SW reset
Cortex A-9	TI	OMAP4470	The DMA4 channel generates an unexpected transaction on WR port under the following 2 scenarios : • Scenario 1 1. Software synchronization : Bit fields SYNCHRO_CONTROL and SYNCHRO_CONTROL_UPPER are set to 0 in register DMA4_CCRi Channel element number : Bit field CHANNEL_ELMNT_NBR is set to 0x9 in register DMA4_CENi Channel frame number : Bit field CHANNEL_FRAME_NBR is set to 0x1 in register DMA4_CFNi Element size : Bit field DATA_TYPE is set to 0x2 in register DMA4_CSDPi Destination addressing mode : Bit field DST_AMODE is set to 0x1 in register DMA4_CCRi Destination is packed : Bit field DST_PACKED is set to 0x1 in register DMA4_CSDPi Destination endianism : Bit field DST_ENDIAN is set to 0x0 in register DMA4_CSDPi Destination burst enable : Bit field DST_BURST_EN is set to 0x1 in register DMA4_CSDPi Destination start address : Register DMA4_CDSAi is set to 0xabcd0000 Disable graphics operation : Bit fields CONSTANT_FILL_ENABLE and TRANSPARENT_COPY_ENABLE are set to 0x0 in register DMA4_CCRi The channel has got an ERR response on the WR port before the end of block transfer. The channel has gone for clean abort and got disabled. The same channel has been configured with soft-sync and included in the channel chaining (This channel is not the head of the chain). When this channel gets enabled through the link, the channel is writing the data out as soon as it fetches the data from Read side. It is expected that the channel should go with burst transfer, but it is going for single transfers This results in a performance issue as DMA is executing single transfers instead of burst transfers. This performance issue is also observed while using the channel with destination synchronization and prefetch enabled. 2. Destination sync with Prefetch enabled : Bit field SEL_SRC_DST_SYNC is set to 0x0 ; Bit fields SYNCRO_CONTROL_UPPER and SYNCRO_CONTROL should not be set to 0x0 ; Bit field PREFETCH is set to 0x1 in register DMA4_CCRi The other settings remain same as in use case #a described above • Scenario 2 The channel has got an ERR response on the WR port before the end of block transfer. The channel has gone for clean abort and got disabled. The same channel has been configured with destination-sync with prefetch enabled and included in the channel chaining (This channel is not the head of the chain). When this channel gets enabled through the link, the read port will start its transaction. If the HWR request to this channel comes before the channel gets its first response, the channel will start a WR transaction with byte enable 0. Also, the internal data counters get updated and the corresponding data will never come out of DMA4. The Data FIFO locations are also not recovered. This results in a Data Integrity issue.	There is a software workaround to solve this issue 1. Work around to resolve both Data Integrity and Performance issue : 52 Bugs SWPZ025E – July 2012 – Revised September 2013 Copyright © 2012–2013, Texas Instruments Incorporated Public Version www.ti.com DMA4 generates unexpected transaction on WR port • Dummy enable-disable for an aborted Channel. i.e. On abort, configure the channel as soft sync with No of frames = 0 and enable the channel by writing 0x1 into the ENABLE bitfield of register DMA4_CCRi. Wait for the Address Misaligment Interrupt. The channel is now ready for reuse. • Ensure that clean drain happens for a channel that is or is to be used as part of a channel chain. i.e. ensure that the abort conditions never occur for this channel • If a channel gets aborted, do not reuse the channel in a chain • Don't use channel chaining 2. Work around to resolve the data integrity only. Disable prefetch in all channels that are part of a channel chain	1.37 DMA4 generates unexpected transaction on WR port
Cortex A-9	TI	OMAP4470	This Bug can occur only in a channel that is part of a channel chain. If channel chaining is not used, this bug is never seen. An exact corner case sequence of events must occur. The sequence is: • The channel is enabled and then aborted*. • This same channel is now configured as part of a channel chain (it should not be the head of the channel chain). • The channel is configured as "software synchronized" or "hardware synchronized at destination with prefetch enabled" • The channel gets enabled through linking. * Following is the subset of abort conditions for this scenario: • The channel is disabled in the middle of transaction and channnel is not a drain candidate. • The channel gets a transaction error on write port but not at the end-of-block transaction. • The channel gets a read transaction error and is not a drain candidate.	The software workaround is to configure DMA4 to be in no-standby or force-standby mode before clearing the PAUSE bit. The DMA4 can be reverted back to smart-standby mode after a certain period (after detecting DMA4_CSR[15:15] of corresponding channel to be 0 or ensuring DMA4_CCR[7:7] bit of corresponding channel to be 0. This ensures descriptor load completion or channel termination.)	1.38 DMA4 channel fails to continue with descriptor load when Pause bit is cleared
Cortex A-9	TI	OMAP4470	The next CBUFF ready window event (IRQ_CTXx_READY) is generated once CPU clears the CBUFF ready (IRQ_CTXx_READY)and after the CPU writes in the current ended window (setting the CBUFF_CTX_CTRL_i [10] DONE bit to 0x1).	The number of CBUFF windows to use in write mode for a given context is two windows.	1.39 CBUFF Ready Window Event in Write Mode
Cortex A-9	TI	OMAP4470	Ongoing transactions may be interrupted when a software reset is performed while there is still active traffic generated by the CSI-2 receiver. Interruption of ongoing transactions typically leads to a general OMAP hang that can only be recovered by a device reset.	Software must ensure that there is no ongoing traffic before performing a software reset. In particular, the CSI-2 receiver must be reset to resume normal operation after a CSI-2 FIFO overflow. There may be remaining data in the FIFO, and therefore ongoing traffic, when the software driver receives the overflow interrupt. To avoid creating a system hang, software must either: • Wait for several 1000s of L3 cycles before performing the software reset after an overflow or • Use the ISS level software reset	1.40 CSI-2 Receiver Executes Software Reset Unconditionally
Cortex A-9	TI	OMAP4470	The TLL bit-stuffing emulation feature (enabled by default after reset in the TLL_CHANNEL_CONF_i[11] ULPINOBITSTUFF bit) is broken. It must be disabled, that is, bit-stuffing must be disabled on all enabled TLL channels. However, disabling bit-stuffing on a TLL channel induces an asymmetry in the number of transmitted bits between the TLL channel and the other ports (ULPI or HSIC), which may result in an underrun or overrun errors. This could be the case while transferring data pattern where bit-stuffing is heavily used, like a white image (full of 11111...).	Disable TLL bit-stuffing on all enabled TLL channels: TLL_CHANNEL_CONF_i[11] ULPINOBITSTUFF = 1 and do not use at the same time one TLL port and one ULPI port or one HSIC port.	1.41 USB Host TLL Bit-stuffing Feature Is Broken
Cortex A-9	TI	OMAP4470	If unexpected VD, Start of frame signal, caused by noise comes before finishing the previous frame statistics, the H3A module hangs.	ISP full reset is necessary to exit from H3A hang state.	1.42 ISP H3A Hangs Due to Unstable Vertical Sync Signal
Cortex A-9	TI	OMAP4470	After the GPIO is configured in smart-idle (or smart-idle with wake-up) and the system goes into MPU inactive mode (idle), the GPIO does not generate any IRQ again if any of the register bits of both interrupt line raw status registers (GPIO_IRQSTATUS_RAW_0 or GPIO_IRQSTATUS_RAW_1) is set. In the case of a GPIO configured in smart-idle wake-up mode (GPIO_SYSCONFIG[4:3]=0x3), the wake-up associated to the GPIO IRQ event will not even occur.	Note: In the below paragraph, 'x' stands for 0 or 1 being the 1st interrupt to be handled, either MPU or DSP, 'y' refers to the other interrupt line. Upon an interrupt reported through GPIO_IRQSTATUS_x, do the following: • Read out GPIO_IRQSTATUS_x => status_value_x • Write status_value_x to GPIO_IRQSTATUS_x (clear the enabled status bits) • Read out GPIO_IRQSTATUS_SET_y=> enable_value_y • Write status_value_x and NOT enable_value_y to GPIO_IRQSTATUS_y By doing so, user clears the unused interrupt status bits for the other interrupt line. An extension to this workaround is to clear GPIO_IRQSTATUS_y (all the bits) when the corresponding interrupt line (most of the time the DSP, that is, 2nd interrupt line) is not used, at each time GPIO_IRQSTATUS_x is cleared. Note: Clearing GPIO_IRQSTATUS_0 (respectively 1) is done by writing 0xFFFFFFFF to this register. It will automatically clear GPIO_IRQSTATUS_RAW_0 (respectively 1) consequently.	1.43 GPIO IRQ Not Generated After MPU Idle if IRQSTATUS Bits Not Cleared
Cortex A-9	TI	OMAP4470	When DSI PLL is under locking, SYS_CLK can be observed on the hardware observability but once PLL is locked the hardware observability signal does not change and still show SYS_CLOCK. DSI PLL is not available on hardware observability.	No workaround is available.	1.44 DSI PLL Signal is Not available on Hardware Observability Pads
Cortex A-9	TI	OMAP4470	The equation for layer blending when upper layer is a premultiplied with a global alpha: LYR(result) = A(global) * LYR(upper) + (1 -“ (A(global) * A(pixel))) * LYR(lower) Where: • A(global) is alpha of upper layer • A(pixel) is pixel alpha of upper layer • (1 -“ (A(global) * A(pixel))) is the first complement of A(global * A(pixel)) • When A(global) = 0 P(result) should be P(lower). Calculation leads to 0xff * P(lower) which can have 1-bit error if P(lower) > (full range)/2 (0x80 for 8-bit) • When A(global) = 0xff P(result) should be P(upper). Calculation leads to 0xff * P(upper) + (1-A(pixel)) * P(lower) For example, 8-bit multiplication-with-rounding leading to 1-bit error in case Operand > (full range) / 2. 0x8c * 0xff = 0x8B74 final resulting after rounding is 0x8B instead of 0x8C.	No workaround is available.	1.45 Blending Calculation Error When Premultiply Alpha is Used
Cortex A-9	TI	OMAP4470	When the system enters off mode, the save-and-restore (SAR) process comes into play. During the save sequence, the USB host content must be saved (even if the module was not in use). The saved content is automatically restored upon the next wakeup from off mode. When the save of the USB context occurs, an extra pulse of UTMI_root clock coming from USB DPLL is entering the IP, and generates a minor corruption. This corrupted context is saved and restored later. Upon each save thereafter, the corrupted context is corrupted further. This is a cumulative process. At least three consecutive saves (with no wakeup of USB in-between) are needed for introducing a fatal corruption. This corruption will impact the next use of the USB module: it could be while resuming a suspended device, or it could be upon the enumeration of a new device. The exact failure is not predictable: disconnection or stalls have been observed. TLL and external PHY modes are impacted.	The workaround is to only perform the SAR-save of the USB registers if the USB bus has been resumed since the last wakeup from OFF mode. If the USB has been left untouched in-between the previous wakeup from OFF, and the next OFF mode entry, then do not perform the USB registers SAR-save. (However the regular SAR-save is still needed for PRCM and other registers. Just skip the USB part) By doing so, the SAR-restore process is always restoring valid data.	1.46 HS USB: Multiple OFF Mode Transitions Introduce Corruption
Cortex A-9	TI	OMAP4470	DISPC and RFBI are configured in smart-idle mode. After sending an image to the panel through the RFBI interface, the DISPC end-of-frame interrupt and RFBI end of transfer occur. After software sets the DSS in off state but no off state is not reached, DSS CM stays in idle transition, CM_DSS_DSS_CLKCTRL[17:16] IDLEST = 0x1 because RFBI is not acknowledging idle request.	After transfer of image completes, set the RFBI mode into bypass mode by setting the DISPC_CONTROL1[16] GPOUT1 and DISPC_CONTROL1[15] GPOUT0 bits to 0x1.	1.47 DSS Block in "Idle Transition" State when using RFBI I/F
Cortex A-9	TI	OMAP4470	A protocol violation between SmartReflex and voltage processor can happen when a global warm reset occurs during a transaction. Consequences are: • VP_xx_TRANXDONE_ST interrupt from the PRCM is no longer generated when a force update voltage from VP is performed. • SmartReflex does not request voltage change anymore. SmartReflex and voltage processor have a handshake protocol. SmartReflex indicates to voltage processor when voltage update is valid. Voltage processor acknowledges this request. Protocol violation appears when warm reset is asserted before acknowledge. This is because SmartReflex is warm reset-sensitive while voltage processor is cold reset-sensitive.	SmartReflex must be disabled before a software-controlled warm reset. For other warm resets, the issue cannot be avoided, but during reboot the following sequence can be performed to recover: • Initiate a Force Update and check TRANXDONE interrupt success (optional). If it is not successful then: • Initiate a software global cold reset.	1.48 Deadlock Between SmartReflex™ and Voltage Processor
Cortex A-9	TI	OMAP4470	The refresh rate is programmed in the EMIF_SDRAM_REF_CTRL[15:0] REG_REFRESH_RATE parameter taking into account frequency of the device. When a warm reset is applied on the system, the OMAP processor restarts with another frequency and so the frequency is not the same. Due to this frequency change, the refresh rate will be too low and could result in an unexpected behavior on the memory side.	The workaround is to force self-refresh when coming back from the warm reset with the following sequence: • Set EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x2 • Set EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM to 0x0 • Do a dummy read (loads automatically new value of sr_tim) This will reduce the risk of memory content corruption, but memory content can't be guaranteed after a warm reset. When OMAP is back to active mode with correct OPP configuration, EMIF registers need to be re- program according to the OPP and respect workaround for i735 bug.	1.49 Refresh Rate Issue After Warm Reset
Cortex A-9	TI	OMAP4470	When the EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE bit field is set to 0x2, self-refresh mode is activated. In that case, EMIF puts the SDRAM into self-refresh mode if no access is performed during EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM number of DDR clock cycles. If during a small window the following three events occur: • The EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM counter expires • And frequency update is requested (CM_SHADOW_FREQ_CONFIG1[0] FREQ_UPDATE set to 1) • And OCP access is requested Then it causes unstable clock on the DDR interface.	To avoid the occurrence of the three events, the workaround is to disable the self-refresh when requesting a frequency change. Before requesting a frequency change the software must program EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x0. When the frequency change has been done, the software can reprogram EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x2.	1.50 System May Hang During EMIF Frequency Change
Cortex A-9	TI	OMAP4470	When the EMIF is going in IDLE state and the following three events occur: • Frequency update is requested (CM_SHADOW_FREQ_CONFIG1[0] FREQ_UPDATE set to 1). • And a warm reset occurs. • And a system access is requested. Then the EMIF will not properly reset internal FIFO. The EMIF may answer to the request when returning from reset not expected by the system; it creates protocol error or data corruption.	In case of software warm reset, software can check that no frequency change is ongoing before initiating the warm reset. In case of watchdog timer reset, there is no workaround to recover, a cold reset is needed.	1.51 DDR Access Hang After Warm Reset
Cortex A-9	TI	OMAP4470	Due to wrong timings, all register accesses transitioning through the L4 interconnect toward DSS are not reliable. DSS registers access done through the L4 interconnect are not supported	DSS register access should be addressed through the L3 interconnect.	1.52 DSS Configuration Registers Access Through the L4 Interconnect
Cortex A-9	TI	OMAP4470	LCD1 output supports gamma correction. The color look-up table (CLUT) is shared between the BITMAP to RGB conversion module on GFX pipeline and Gamma correction on the LCD1 output. LUT table can be loaded by SW through DISPC slave port (interconnect) or by DISPC master port using the DISPC DMA. However, LCD1 gamma correction LUT loading is not working properly and require to enable GFX pipeline for LUT loading. Depending on the load mode (DISPC_CONFIG1[2:1] LOADMODE) used, GFX pipeline can then be disabled after 1st frame.	There are two workaround treatments depends on the load mode for gamma correction LUT and frame data (see Table x-xx Workaround/Load mode settings ) Table 1-2. Workaround/Load mode settings Load Mode GFX Enable Condition Workaround ( DISPC_CONFIG1[2:1]LOADMODE) 0x0 (load LUT and data every frame) Always Enabled WA1 0x1 (load LUT for first frame and change loadmode to 2) Enable required for first frame only WA2 0x2 (load frame data only) Enable required for first frame only. WA2 0x3 (load LUT and data for first frame and change Enable required for first frame only. WA2 loadmode to 2) WA1 To use gamma correction on LCD1 output, software must: 1. Enable the GFX pipeline by setting DISPC_GFX_ATTRIBUTES[0] ENABLE to 0x1. 2. Set the GFX base address (DISPC_GFX_BA_i[31:0] BA) to an accessible frame buffer. 3. Set the GFX window to minimum size by configuring the DISPC_GFX_SIZE[27:16] SIZEY and DISPC_GFX_SIZE[11:0] SIZEX bits. 4. If the GFX pipeline is not to be displayed, set GFX LYR to bottom LYR in LCD1 overlay by setting appropriate DISPC_GFX_ATTRIBUTES[27:26] ZORDER bit field and make GFX fully transparent by setting the global alpha of the GFX to 0x00 in the DISPC_GLOBAL_ALPHA[7:0] GFXGLOBALALPHA bit field. WA2 To use gamma correction on LCD1 output, software must: 1. Enable the GFX pipeline by setting DISPC_GFX_ATTRIBUTES[0] ENABLE to 0x1. 2. Set the GFX base address (DISPC_GFX_BA_i[31:0] BA) to an accessible frame buffer. 3. Set the GFX window to minimum size by configuring the DISPC_GFX_SIZE[27:16] SIZEY and DISPC_GFX_SIZE[11:0] SIZEX bits. 4. If the GFX pipeline is not to be displayed, set GFX LYR to bottom LYR in LCD1 overlay by setting appropriate DISPC_GFX_ATTRIBUTES[27:26] ZORDER bit field and make GFX fully transparent by setting the global alpha of the GFX to 0x00 in the DISPC_GLOBAL_ALPHA[7:0] GFXGLOBALALPHA bit field. 5. When DISPC_IRQSTATUS[8]PALETTEGAMMALOADING_IRQ =0x1 then disable GFX pipeline	1.53 LCD1 Gamma Correction Is Not Working When GFX Pipe Is Disabled
Cortex A-9	TI	OMAP4470	LPDDR2 memories could be put in self-refresh mode for power savings. The number of cycles after which EMIF can start a self-refresh entry is software programmable (thanks to the power management timer for self-refresh: EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM register bit field). When exiting self-refresh mode, it is required that at least one refresh command is issued before entry into a subsequent self-refresh (as defined in the JEDEC LPDDR2 Specification) When this timer value is set to a value less than 0x6 (for VDD_CORE_L OPP100) or less than 0x5 (for VDD_CORE_L OPP50), the time between a self-refresh exit to the next immediate self-refresh entry does not allow the EMIF to perform a refresh command. As a consequence, data in LPDDR2 memory is not refreshed properly, and then data is corrupted in LPDDR2.	Using a value of EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM >= 6 for VDD_CORE_L OPP100 and a value of REG_SR_TIM >= 5 for VDD_CORE_L OPP50 avoid the occurrence of the issue.	1.54 Power Management Timer Value For Self-Refresh (SR_TIM)
Cortex A-9	TI	OMAP4470	Following a bug in the integration of I/Os cell for LPDDR2 clocks, a leakage increase can be observed on vddca_lpddr2 when OMAP is in open switch retention mode.	To prevent an increase in leakage, it is recommended to disable the pull logic for these I/Os except during off mode. So the default state of the I/Os (to program at boot) will have pull logic disable: CONTROL_LPDDR2IO1_2[18:17]LPDDR2IO1_GR10_WD = 00 CONTROL_LPDDR2IO2_2[18:17]LPDDR2IO2_GR10_WD = 00 When entering off mode, these I/Os must be configured with pulldown enable: CONTROL_LPDDR2IO1_2[18:17]LPDDR2IO1_GR10_WD = 10 CONTROL_LPDDR2IO2_2[18:17]LPDDR2IO2_GR10_WD = 10 When resuming from off mode, pull logic must be disabled.	1.55 Leakage Increase On LPDDR2 I/Os
Cortex A-9	TI	OMAP4470	If the sys_boot[5:0] pins are configured for booting from MMC1, then the boot on MMC1 may not happen (board dependency) and the ROM code jumps to the next device of the boot sequence. Indeed, depending on the voltage ramp, the ROM code may not wait long enough for SDMMC1_VDDS voltage to be stabilized at 3 V before checking the voltage level supplied to OMAP. In that case, the ROM code checks the SDMMC1_VDDS voltage too early, reads a bad level, and then jumps to 1.8-V configuration while the PMIC was configured to 3 V. The MMC1_PBIAS cell is in a bad state and prevents the sending of commands to the MMC1 bus. The ROM code switches to the next boot sequence.	No	1.56 MMC1 Booting May Be Bypassed Depending On VDD Ramp-up Delay
Cortex A-9	TI	OMAP4470	A bug has been identified in the interconnect agent handling the connect-disconnect protocol between an initiator and interconnect. When the disconnect protocol violation occurs, there is a dead lock and a system lockup is observed. The issue can occur in a corner case when the impacted module has started a transition to standby, for the L3 initiator on which it is attached, exactly at the time the initiator gets an event for exiting idle state. Such a situation can occur when the impacted initiator is generating short MStandby pulses (pulse durations less than one L4 clock cycle). DSS and ISS are the only initiators that are impacted.	L3_CLK1 must be kept in NO-IDLE when the DSS clock domain is ON. It can be switched back to HW_AUTO when the DSS clock domain is IDLE. L3_CLK2 must be kept in NO-IDLE when the ISS clock domain is ON. It can be switched back to HW_AUTO when the ISS clock domain is IDLE.	1.57 Disconnect Protocol Violation
Cortex A-9	TI	OMAP4470	ULPI RxCmds, from OMAP to USB device, convey the wrong ID bit after the save-and-restore sequence. When OMAP is in a low-power mode scenario (chip-OFF), in high-speed transceiverless link (TLL) connection, after the SAR phase, every RxCmd from the TLL to the peripheral conveys wrong ID field (for example, 0x0D instead of 0x4D), that is, the ID bit is 0 instead of 1. This is due to the TLL losing the value of ID during the SAR process. As long as the peripheral does not resample the ID (by toggling OTG_CTRL_i[0] IDPULLUP) after the restore, the ID bit keeps the wrong value 0 instead of 1. This results in sending the wrong RxCmd to the peripheral. Depending on the peripheral device design, it may consider or disregard the ID bit. The behavior and consequences depend on the device design.	Ensure that the OTG_CTRL_i [0] IDPULLUP bit is set to 1 before the SAR-save. By doing so, this bit is restored to 1 after every off mode. Then the ID bit is sampled and the Rxcmd is correct.	1.58 ULPI RxCmds Convey the Wrong ID Bit After Save-and-Restore Sequence
Cortex A-9	TI	OMAP4470	During DVFS transitions, the PRCM controller can hang if CORE DPLL dividers M2 and M5 are updated at once.	The recommended sequence is: • Update CM_SHADOW_FREQ_CONFIG2[7:3]DPLL_CORE_M5_DIV. • Set CM_SHADOW_FREQ_CONFIG2[0]GPMC_FREQ_UPDATE to 0x1. • Wait until CM_SHADOW_FREQ_CONFIG2[0]GPMC_FREQ_UPDATE becomes 0x0. • Update CM_SHADOW_FREQ_CONFIG1[15:11]DPLL_CORE_M2_DIV. • Set CM_SHADOW_FREQ_CONFIG1[0]FREQ_UPDATE to 0x1. • Wait until CM_SHADOW_FREQ_CONFIG1[0]FREQ_UPDATE becomes 0x0.	1.59 PRCM Hang at Frequency Update During DVFS
Cortex A-9	TI	OMAP4470	Due to a bad behavior of an internal signal, the Card Error interrupt bit MMCHS_STAT[28] CERR may not be set sometimes when an error occurred in the card response.	After responses of type R1/R1b for all cards and responses of type R5/R5b/R6 for SD and SDIO cards, software must read two registers: MMCHS_RSP10 and MMCHS_CSRE. When a MMCHS_CSRE[i] bit is set to 1, if the corresponding bit at the same position in the response MMCHS_RSP0[i] is set to 1, the host controller indicates a card error and software should proceed in the same way as if a CERR interrupt would have been detected in the MMCHS_STAT register.	1.60 Card Error Interrupt May Not Be Set Sometimes
Cortex A-9	TI	OMAP4470	When using AutoCMD12 mode in write transfer with ADMA and MMCHS_CMD[1] BCE is disabled, then the CMD12 command is not issued automatically after write transfer completion.	Instead of setting the MMCHS_CMD[2] ACEN bit to 0x1 to enable AutoCMD12 mode, software sends the CMD12 command at the end of write transfers (after the MMCHS_STAT [1] TC bit goes High).	1.61 In AutoCMD12 mode, the CMD12 Command Is Not Issued On Write Transfer Completion
Cortex A-9	TI	OMAP4470	Following a design issue on I/O muxing compiler, a glitch can occur on I/Os when switching them from the active mode to the off-mode override value. The glitch is present: • if the feature for pin state override during off mode is used CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y [25,9] OFFMODEENABLE = 1 • and the override value CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[27,11] OFFMODEOUTVALUE = 1 and the IO value when going to off mode was 1. There is no issue • if the override feature CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[25,9] OFFMODEENABLE = 0 is not used, • or if it is used to force a value which is different from the value before going to off mode. • or if it is used to force a 0 and the value before going to off mode was 0.	CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[25,9] OFFMODEENABLE = 1 should not be used on pad output pins driving glitch-sensitive signals if the same value is driven during active mode and off mode and is equal to 1. If CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[25,9] OFFMODEENABLE = 1, it is necessary to ensure that the CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[27,11] OFFMODEOUTVALUE is equal to 0 or is different from the value of the I/Os when going to off mode.	1.62 I/O Glitch Issue When Entering Off Mode
Cortex A-9	TI	OMAP4470	This problem impacts the HS USB Host HSIC interface. TLL and ULPI interfaces are not impacted. For this issue to occur, the following conditions must exist: • A USB device is attached to an OMAP HSIC interface. • The USB bus is suspended. • The PRCM asserts idle_req, and the USB host answers idle_ack. • The PRCM hardware automatically stops the interface clocks (ICLK). • Software disables the module by setting the CM_L3INIT_HSUSBHOST_CLKCTRL[1:0]:MODULEMODE bit fields to 0x0. • The PRCM automatically stops the mandatory functional clocks (FLCK). • Software stops the optional FCLK. • The module is then idle. The clock domain can possibly enter idle, then the power domain also can enter a low-power mode, and even the full OMAP. • The device generates a remote wakeup. The USB Host detects the remote wakeup condition asynchronously and generates a USBHOST_SWAKEUP to the PRCM. The PRCM deasserts idle_req, and restarts ICLK and mandatory FCLK, but not the optional FCLK. However, in the case of HSIC, the optional FCLK (CM_L3INIT_HSUSBHOST_CLKCTRL[10/9/8].OPTFCLKEN_UTMI_P3/2/1_CLK) is needed to generate the interrupt indicating to the system that the USB HOST is the wake-up source. Consequently, OMAP is woken up but does not acknowledge who is the wake-up source.	Do not rely on the asynchronous wake-up feature of the USB host module, but rather on the daisy-chain for detecting a remote wakeup. Set the wakeup-enable feature of the HSIC pads and enable the daisy-chain to generate a wakeup and an interrupt to the PRCM. Upon wakeup and interrupt from the daisy chain, if the wakeupevent bit is set for the HSIC pads, then restart the USB Host module and the UTMI_Px clock and resume the device.	1.63 HS USB Host HSIC Remote Wakeup Is Not Functional
Cortex A-9	TI	OMAP4470	When I2C module is used in HS master receive mode, and when smart-idle wakeup mode is set: • If reconfiguration of I2C_BUF[13:8] RXTRSH value is done while I2C_CON[15] I2C_EN = 0x1, and with no clearing of the RX buffer pointer. • I2C module does not wakeup from idle mode due to wrong pointers of RX Buffer (as RXTRSH was reconfigured with no actual cleaning of RX FIFO pointers from a previous transfer). As a consequence, I2C FIFO draining interrupt is not generated in Idle/WakeUp scenario.	Before reconfiguring the RXTRSH (Threshold value for FIFO buffer in RX mode): • Disable I2C controller by setting the I2C_CON[15] I2C_EN bit to 0x0 (this puts the controller in reset, clears the FIFOs, and sets the status bits to their default value) • Once the I2C module reconfiguration is done, reactivate the I2C controller by setting the I2C_CON[15] I2C_EN bit to 0x1 (module enabled).	1.64 I2C FIFO Draining Interrupt Not Generated
Cortex A-9	TI	OMAP4470	General-purpose (GP) timers in posted mode (GPT_TSICR[2] POSTED bit set to 0x1) with GPTi_ICLK (timer interface clock) and GPTi_FCLK (timer functional clock) clock frequency not respecting the ICLK < 4*FCLK ratio, can periodically report a random time from read accesses to counter register GPT_TCRR.	If ICLK < 4*FCLK ratio is not respected, then software should make sure that the posted mode is inactive (the GPT_TSICR[2] POSTED bit is set to 0x0) before any read access to the GPT_TCRR register.	1.65 Read Accesses to GP Timer TCRR Can Report Random Value When In Posted Mode
Cortex A-9	TI	OMAP4470	In video mode, the command mode packets, provided through the DSI protocol engine OCP port, can be interleaving during the blanking periods vertical and/or horizontal blanking periods of the video stream sequence. When TX FIFO on the OCP slave port is empty and if the first packet written to TX FIFO is less than 13 words when 1 data lane is active or 17 words when 2 data lanes are active or 25 words when 3 or 4 data lanes are active, only this packet will be sent on the HS link during the next blanking period enabled for command packet transfer. This is the only sent packet, because this packet is the only completely written packet when the FSM has read the last location of this packet from TX FIFO. Even if more packets are written in TX FIFO before the interleaving starts, these packets will not be sent during that blanking period.	No workaround is available. The impact is minor because: • When interleaving is done on a vertical blanking period (VSA, VFP, VBP), as these blanking are expressed in a number of lines, the remaining packet(s) in TX FIFO are sent on HS link during the next line blanking interval within the same blanking period or during the next one. • When interleaving is done on a horizontal blanking period (HSA, HFP, HBP), the remaining data in TX FIFO is sent on the next blanking period.	2.1 Issue with Transfer Of Multiple Command Packets Coming From Interconnect
Cortex A-9	TI	OMAP4470	The DSI protocol engine is based on the MIPI DSI ver. 1.01 specification. However the video mode using sync pulses is implemented using the timing described in MIPI DSI ver. 1.00 and not ver. 1.01: • The DSI protocol engine sends only HE packets (when enabled) during VACT and not during VSA, VFP, and VBP. • The DSI protocol engine sends VE (noted as VSE in MIPI DSI ver. 1.01 specification) during VSA and not during VBP. Figure 2.1 represents actual implementation and Figure 2.2 represents MIPI DSI ver. 1.01 specification. Figure 2-1. MIPI DSI 1.00 (Implemented) - Video Mode Interface Timing: Nonburst Transmission With Sync Start And End. t * (VSA + VBP + VACT + VFP) L t t t t L t t L L L tL tL L L B L V BL H BL V BL H BL H BL H BL H BL H L V Active video area P S LP S LP E LP S LP S LP S LP S LP S L S M P VSA lines VBP lines VFP lines tHBP t t t t L HSA HACT HFP H H H H H H H H S B RGB HFP S B RGB HFP S E S E A P A P VACT lines SWPZ025E – July 2012 – Revised September 2013 Limitations 85 Copyright © 2012–2013, Texas Instruments Incorporated Public Version Nonburst Video Mode Using Sync Pulses: NO HE Packets Sent VSA, VFP, And VBP Blanking. www.ti.com Figure 2-2. MIPI DSI 1.01 ( Not Supported) - Video Mode Interface Timing: Nonburst Transmission With Sync Start And End. t * (VSA + VBP + VACT + VFP) L t t t t t t t t L L L L L L L L V H H H H H H H H V H H H H H H H H H H H H H H B L V BL BL BL BL BL BL BL L S S S S S S S S S S S S S S S Active video area S S S S S S S S S P S LP LP LP LP LP L LP LP S A E S A E S A E E A E S A E S A E S A E S A E P M S VSA lines VBP lines VFP lines tHBP t t t t L HSA HACT HFP H H H H H H H S HSA S B RGB HFP S B RGB HFP S E S E P A P VACT lines	NA	2.2 Nonburst Video Mode Using Sync Pulses: NO HE Packets Sent VSA, VFP, And VBP Blanking.
Cortex A-9	TI	OMAP4470	BITMAP1, BITMAP2, and BITMAP4 are not supported by the graphics pipeline.	No workaround is available.	2.3 BITMAP1-2-4 Formats Not Supported By The Graphics Pipeline
Cortex A-9	TI	OMAP4470	When Graphics pipeline input pixel is in BITMAP format, it cannot output pixel at the rate of one pixel per each clock cycle when LCD = 1 and PCD = 1. The limitation is not applicable if PCD is greater than or equal to 2.	No workaround is available.	2.4 Limitation On DISPC Dividers Settings When Using BITMAP Format
Cortex A-9	TI	OMAP4470	HDQ/1-Wire protocols use a return-to-1 mechanism and it requires an external pullup resistor on the line. There is a timing limitation on this return-to-1 mechanism that requires a constraint on the external pullup resistor(R) and the capacitive load(C) of the wire.	There is a constraint in the design for the maximum allowed rise time of the wire. After writing data to the wire, the HDQ/1-Wire module samples the logic value of the wire 1 FSM (finite state machine) clock cycle later. The FSM expects to read back 1 value from the wire. This constraint must be taken into account, when calculating the pullup resistor(R) according to the capacitive load(C) of the wire. The maximum RC (pullup resistor and capacitive load) value should be calculated as follow: R <1200ns/(10e-12 + C)	2.5 HDQ™/1-Wire® Communication Constraints
Cortex A-9	TI	OMAP4470	Depending on McPDM FIFO value, a floor Noise in audio band at ~-80dB_fullscale may appear with one of these two following configurations: • Case 1: AESS is used for the McPDM transfers, 6 downlink channels of McPDM are enabled and McPDM downlink FIFO threshold is set to 1. • Case 2: AESS is not used for the McPDM transfers, 4 downlink channels of McPDM are enabled and McPDM downlink FIFO threshold is set to 1 or 2.	Case 1 workaround: • Set McPDM downlink FIFO threshold to 2 (floor noise goes back to ~ -130dB_fullscale) Case 2 workaround: • Set McPDM downlink FIFO threshold to 4 (floor noise goes back to ~ -130dB_fullscale)	2.6 Presence of a Floor Noise on Audio Band When Multiple McPDM Downlink Enabled
Cortex A-9	TI	OMAP4470	Overlay optimization does not work when resize processing is enabled on any 'Enabled' layer. When any of the 'Enabled' layers has bit field DISPC_p_ATTRIBUTES.RESIZEENABLE as nonzero it will neither be optimized nor participate in optimization of layers below.	For optimization to occur for a particular layer, make RESIZEENABLE as 0x0. With multiple layers enabled, make RESIZEENABLE for all the layers as 0x0 for every layer to participate in overlay optimization of itself or for the layers below it.	2.7 Overlay Optimization Limitations
Cortex A-9	TI	OMAP4470	In memory-to-memory operation, it is possible for WB pipe to write out pixel data faster than the rate at which VID/GFX DMA is fetching the pixel data. Under such a condition, the WB pipe should slow down by itself (by inserting necessary stalls) and should not cause an underflow at the VID DMA. The required behavior is: when VID/GFX pipelines are connected to WB in memory-to-memory mode (connected either directly or through overlay), there should not be any buffer underflow and no underflow interrupt should be generated. However the DISPC module deviates from this behavior and generates sporadic underflow interrupt. But buffer underflow never happens; there is no corruption of the data written back to the memory. Only undesired interrupts are generated due to this defect.	Software should disable the VID/GFX pipeline underflow interrupt by writing 0x0 in DISPC_IRQENABLE[20-12-10-6] bit if it is connected to the WB pipeline in memory-to-memory mode. Software should not consider the underflow interrupt generated in DISPC_IRQSTATUS[20-12-10-6] bit when in memory-to-memory mode	2.8 VID /GFX Pipeline Underflow Interrupt Generated When In WB Memory-to-memory Operation
Cortex A-9	TI	OMAP4470	The MIPI HSI specification explicitly requires run-time configurability to be supported for these HSR Frame Burst, HSR Frame Time-out, and HSR Tailing Bit counters. Update of HSR counters with new values while data traffic is ongoing results in spurious errors and/or data loss/corruption: • HSR Frame Burst Counter update: Spurious FT/TB errors and/or data loss/corruption • HSR Frame Timeout Counter update : Spurious FT/TB errors and/or data loss/corruption (observed only in pipelined flow) • HSR Tailing Bit Counter: Spurious FT/TB errors and/or data loss/corruption (observed only in pipelined flow)	No workaround is identified.	2.9 HSI: Run-time Change Of HSR Counter Values Damages Communication
Cortex A-9	TI	OMAP4470	From the MIPI HSI spec; the transmitter shall be able to transmit a break transmission regardless of the state of the READY signal. • Break frame will not be sent if the READY line is low and Tx FIFO is not empty. Inserting a break frame, in this configuration, will also override a frame in Tx FIFO. Refer to "Break frame corrupt ongoing transfer" errata. • Break frame will be sent if TX FIFO is empty and READY line is low.	No workaround is identified.	2.10 HSI Does Not Send Break Frame In Some Scenario
Cortex A-9	TI	OMAP4470	The refresh requirements for an LPDDR2 8-Gbit (single die) memory at high temperature (>85°C) conflicts with the current EMIF refresh policy and may result in a lock-up situation. This issue does not exist with 2-Gbit and 4-Gbit memories due to their lower t RFC(130 ns versus 210 ns).	There is no workaround.	2.11 EMIF: 8-Gbit (Single Die) Support
Cortex A-9	TI	OMAP4470	ECD3 fails to decode the bitstreams having the mismatch between CBP and CBF generated by non-TI encoder. The mismatch violates the H.264 CBP rule. But the mismatch can be correct in-practice / real-life /De-facto. It wrongly decodes the bitstream as error stream (instead of normal stream), but it never results in hang or crash. The decoded output have visual noticeable artifacts as many good slices are concealed. The issue occurs for H.264 MP/HP decoder decoding bitstream generated by non-TI encoder violating H.264 CBP rule. It does not occur for H.264 BP/MP/HP encoder as well as H.264 BP decoder.	No Workaround	2.12 ECD3 Fails To Decode Bitstreams Having Mismatch Between CBP and CBF
Cortex A-9	TI	OMAP4470	The overlay determine the blending effect by the following: If (Ae > 0x3fc) Result = Upper layer Elsif (Ae == 0x0) Result = Lower Layer Else Ae = Ap×(Upper layer) + (1-Ap)×(Lower layer) where Ae represents the effective Alpha, input of overlay. Ae is determined by two inputs parameters: Ap (pixel alpha) and Ag (global alpha). The Ap available at the input of overlay can come through two paths: 1. The scaler (in which case the highest and second highest values are 0x3ff and 0x3fb, respectively). 2. The parallel bypass path (in which case we can get pixel alpha values between 0x3fc and 0x3fe). The effective alpha value can only be in the range of 0x3fc – 0x3fe if the global alpha value is programmed as 0xff. As an inference from the above if Ae value (resulting as a multiplication of global alpha [Ag] and pixel alpha[Ap]) inside the TV overlay is between 0x3fc and 0x3fe, the blending logic treats this layer as opaque and blending does not occur.	None	2.13 TV Overlay Blending Limitation
Cortex A-9	TI	OMAP4470	The ISP pattern generator, which implements an internal data generation mechanism to test the external pins and can generate RAW data without the need for an external image sensor, is not functional.	None	2.14 ISP Pattern Generator Is Not Functional
Cortex A-9	TI	OMAP4470	Voltage drop can be observed when following conditions are met: • csix_dx/y_ pad pair(DXn, DYn on the figure below) is used in GPI mode (CONTROL_CAMERA_RX[20:19]/[17:16] CAMERARX_CSIx_CAMMODE=0x3) • One of the pair is connected to GND and another is pulled-up to High The signal level of the pad which is pulled-up is dropped due to the leakage of the component used in the off switch for the on-die termination between DXn and DYn. The leakage current (and the voltage drop) varies depending on PVT condition. Under the worst case condition, the leakage can be high enough to drop the signal level under VIH of the GPI buffer and causes functional failure. Figure 2-3. CSI PHY pad in GPI mode	1. Use different pad for GPI. 2. Use the pull-up resistor value smaller than or equal to 9k Ohm. It avoids the voltage drop and keeps the signal level above VIH. However this will be at the expense of increased current (up to 70uA in the worst case), as long as DXn and DYn are opposite in polarity. SWPZ025E – July 2012 – Revised September 2013 Limitations 99 Copyright © 2012–2013, Texas Instruments Incorporated Public Version Voltage Drop Observed On CSI PHY Pad In GPI mode www.ti.com	2.15 Voltage Drop Observed On CSI PHY Pad In GPI mode
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.1 LPDDR2 High Temperature Operating Limit Exceeded
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.2 Undesired McBSP slave mode behavior during reset without CLKR/CLKX
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.3 High-Speed Image Capture Use Case
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.4 MPU-EMIF Static Dependency Needed Around MPU WFI
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.5 Programming of CM_CLKSEL_DPLL_CORE[20]DPLL_CLKOUTHIF_CLKSEL
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.6 Power Delivery Network Verification
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.7 SmartReflex Parameters and SmartReflex Convergence Verification
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.8 PRCM Voltage Controller Uses MPU Slave Address
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.9 EMIF Programming to Allow 466 MHz
Cortex A-9	TI	OMAP4470	DESCRIPTION	WORKAROUND	3.10 McPDM Downlink Data Corrupted With TWL604x
Cortex A-9	TI	OMAP4460	If a General Purpose Timer (GPTimer) is in posted mode (TSICR.POSTED=1), due to internal resynchronizations, values read in TCRR, TCAR1 and TCAR2 registers right after the timer interface clock (L4) goes from stopped to active may not return the expected values. The most common event leading to this situation occurs upon wake up from idle. GPTimer non-posted synchronization mode is not impacted by this limitation. This limitation also impacts read from Watchdog timers WCRR registers. All the watchdog timers support only POSTED internal synchronization mode. There is no capability to change the internal synchronization scheme to NON-POSTED by software. The 32KSYNCNT_CR register is also impacted by this limitation, since the 32K sync timer is always in posted synchronization mode.	Software has to wait at least (2 timer interface clock cycles + 1 timer functional clock cycle) after L4 clock wakeup before reading TCRR, TCAR1 or TCAR2 registers for GPTimers in POSTED internal synchronization mode, and before reading WCRR register of the Watchdog timers . The same workaround must be applied before reading 32KSYNCNT_CR register of the 32K sync module.	1.1 Delay needed to read some GP timer, WD timer and sync timer registers after wakeup
Cortex A-9	TI	OMAP4460	Because of a glitchy structure inside the UART module, accessing the MDR1 register may create a dummy underrun condition and freeze the UART in IrDa transmission. In UART mode, this may corrupt the transferred data(received or transmitted).	To ensure this problem does not occur, the following software initialization sequence must be used each time MDR1 must be changed: 1. If needed, setup the UART by writing the required registers, except MDR1 2. Set appropriately the MDR1.MODE_SELECT bit field 3. Wait for 5 L4 clock cycles + 5 UART functional clock cycles 4. Clear TX and RX FIFO in FCR register to reset its counter logic 5. Read RESUME register to resume the halted operation Step 5 is for IrDA mode only and can be omitted in UART mode.	1.2 MDR1 access can freeze UART module
Cortex A-9	TI	OMAP4460	Minimum number of pixels for MIPI command mode from the video port should be greater than 1 (at least 2). Image with less than 2 pixels is not expected to be used in a real applicative use case.	If sending a single pixel is needed, the OCP L4 slave port can be used (through CPU or sDMA).	1.3 DSI: Minimum Of 2 Pixels Should Be Transferred Through DISPC Video Port
Cortex A-9	TI	OMAP4460	Transfer using tearing effect cannot be cancelled (writing TE_SIZE to 0). Writing TE_SIZE would have no effect and transfer would continue.	Always wait for tearing effect to complete before changing any configuration.	1.4 DSI: Cancel Tearing Effect Transfer
Cortex A-9	TI	OMAP4460	RX FIFO fullness can be incorrect just after a FIFO read. FIFO fullness should be read only once at the beginning of the transfer. Other accesses during a transfer are not guaranteed.	Use only programming model provided in Programming Model section in the TRM.	1.5 DSI: RX FIFO Fullness
Cortex A-9	TI	OMAP4460	This register must not be written twice when TxByteClkHS is stopped to avoid L4 OCP port deadlock.	User must check that the TxByteClkHS clock is activated before initiating any write access to DSI_TIMING2 register. To ensure the TxByteClkHS clock is active, the user must check: 1. PLL is locked (DSI_PLL_STATUS register; DSI_PLL_LOCK bit) 2. DSIPHY must be in ON power state (PWRCMDON). 3. Clock/Data lane positions are correctly set (DSI_COMPLEXIO_CFG1.xxx_POSITION).	1.6 DSI: Access Restriction On DSI_TIMING2 Register
Cortex A-9	TI	OMAP4460	Executing a FIFO flush does not properly clean the logic, thus resulting in unpredictable behavior of the module.	User must perform module software reset when a transfer is aborted.	1.7 DSI: Tx FIFO Flush Is Not Supported
Cortex A-9	TI	OMAP4460	In case of destination synchronized transfer on the write port (or source sync with SDMA.DMA4_CCRi[25] BUFFERING_DISABLE = 1), if a transaction error is reported at the last element of the transaction, the channel is not automatically disabled by DMA.	Whenever a transaction error is detected on a transaction on the write side of the channel i, software must disable the channel(i) by setting the DMA4_CCRi[7] ENABLE bit to 0.	1.8 sDMA Channel Is Not Disabled After A Transaction Error
Cortex A-9	TI	OMAP4460	The first packet in command mode is not sent due to inaccurate clock gating. Root cause description: In command mode when DDR_CLK_ALWAYS_ON and IF_EN are set to 1, DDR clock is not present immediately after the IF_EN bit is set to 1 but when the first HS packet from OCP is ready to be sent to PPI HS link. The DDR_CLK_PRE field is used between the start of the DDR clock and the assertion of the data request signal. After the time defined by the DDR_CLK_PRE field, the clock lane is always present until the IF_EN bit is set to 0. So, there is a delay between IF_EN set to 1 and assertion of the clock lane.	In case of command mode where DDR clock should be provided to peripheral before data, the workaround is to program DDR_CLK_PRE =! 0. The value of DDR_CLK_PRE must take into account the different timings: TCLK_PREPARE, TCLK_ZERO. Sequence to enable the DSI: 1. Set the ForceTxStopMode bit to 1 (DSI_TIMING1 register). This asserts the ForceTxStopMode. 2. Enable virtual channel in command mode / Enable DSI interface. 3. Poll the ForceTxStopMode bit to 0 (DSI_TIMING1 register) until deassertion of the ForceTxStopMode bit. The hardware resets this bit at the end of the counter value. 4. Send SOF(0x00000000) packet in command mode.	1.9 DSI SOF Packet Not Send
Cortex A-9	TI	OMAP4460	SIMCOP LDC module doesn't reach 100 MPix/s target in bilinear mode for YUV420 data.	Use LDC in YUV422 mode.	1.10 SIMCOP Lens Distortion Correction issue
Cortex A-9	TI	OMAP4460	The SOFTRESET bit of the SYSCONFIG register inside CBUFF (CBUFF_HL_SYSCONFIG[0] SOFTRESET) is set to 0x0 (reset done state) after reset only if CBUFF is out of IDLE. While CBUFF slave data port is in IDLE, the SOFTRESET bit is always set to 0x1 (status bit gives an ongoing reset, but reset is finished).	Ignore status of the the SOFTRESET bit. After a software reset, wait a few cycles before using the module.	1.11 ISS: SOFTRESET Bit Status Not Working For Circular Buffer
Cortex A-9	TI	OMAP4460	The SOFTRESET bit of the SYSCONFIG register inside BTE (BTE_HL_SYSCONFIG[0] SOFTRESET) is set to 0x0 (reset done state) after reset only if BTE is out of IDLE. While BTE slave data port is in IDLE, the SOFTRESET bit is always set to 0x1 (status bit gives an ongoing reset, but reset is finished).	Ignore the status of the SOFTRESET bit. After a software reset, wait a few cycles before using the module.	1.12 ISS: SOFTRESET Bit Status Not Working For Burst Translation Engine
Cortex A-9	TI	OMAP4460	Debug read operations should not impact the internal state of the module. That cannot be guaranteed because debug reads of some locations can impact DMA requests. Also, some read accesses may be stalled for a long time while ISP operation is ongoing.	To avoid read access from being stalled, the CPU must have the priority. This can be configured in the ISP5_MPSR register. Dummy accesses during frame processing lead to data corruption however response is given immediately. This register can be used to avoid stalling debug accesses. Dummy data is returned in that case but does not hurt functionality because debug accesses do not make sense while ISP5 is processing data.	1.13 ISS State Can Be Corrupted During Debug Mode
Cortex A-9	TI	OMAP4460	DSI engine is not always detecting the first VSYNC HSYNC signals received on the video port in video mode.	Because before first VSYNC rising edge, one HSYNC is transmitted and clock is transmitted during that HSYNC period, the workaround is to have the HSYNC period of DISPC longer than the timing described below: • Configuration with line buffers: 3 VP_PCLK + 6 VP_CLK + 6 DSI_CLK • Configuration without line buffers: 3 VP_PCLK + 2 VP_CLK There is no need to take care of some timings related to enabling the IF_EN, VC_EN, LCD output of the DSIPC.	1.14 DSI VSYNC HSYNC Detection In Video Mode
Cortex A-9	TI	OMAP4460	When two video ports are available at the input of the DSI protocol engine, the two streams are interleaved by the DSI protocol engine. Only one video mode is supported by the current implementation on VP1 only. VP2 cannot be in video mode even if VP1 is not in video mode.	No	1.15 Dual Video Mode
Cortex A-9	TI	OMAP4460	The buffer handshake feature in the DISPC avoids underflow of the DISPC DMA FIFO. The fullness of the DISPC DMA FIFO is checked before providing data to the pipeline when STALL signal is inactive. When the FIFO hand check feature is activated, the pixel transfer to the DSI module during STALL inactivity period can be stopped (no DISPC_PCLK pulse) and restarted when there is enough data in the FIFO. The DSI protocol engine is configured in command mode. On video port 1 in command mode, when DISPC_DIVISOR1.PCD = 2, DISPC_CONFIG1.BUFFERHANDCHECK = 1 and DSI_CTRL.VP_CLK_RATIO = 0, the FRAMEDONE IRQ might not be triggered and TE_SIZE counter might not be decremented to 0. This is caused by a deadlock between the DISPC and DSI modules during the transfer of the last pixel of a line On video port 2 in command mode, when DISPC_DIVISOR2.PCD = 2, DISPC_CONFIG2.BUFFERHANDCHECK = 1 and DSI_CTRL2.VP_CLK_RATIO = 0, the FRAMEDONE IRQ might not be triggered and TE_SIZE counter might not be decremented to 0. This is caused by a deadlock between the DISPC and DSI modules during the transfer of the last pixel of a line. The DSI protocol engine sends a STALL to the DISPC (stall mode); in parallel the DISPC stops the pixel clock to the DSI because it is waiting for its FIFO DMA to be refilled (buffer handcheck feature). When FIFO DMA is refilled, the DISPC being in stall mode does not provide back the pixel clock to the DSI to deassert the stall and it does not send the last pixel to the DSI.	DISPC_DIVISORi[7:0] PCD = 2 is not supported, where i = 1 to 3. DISPC should be set to DISPC_DIVISORi[7:0] PCD = 3 or above and DSI_CTRLi[4] VP_CLK_RATIO to 0x1.	1.16 Deadlock Between DISPC And DSI When PCD = 2, VP_CLK_RATIO = 0
Cortex A-9	TI	OMAP4460	When coming out of off mode, the memory controllers assume connected SDRAMs to be in self-refresh mode. The EMIF receives a DEVICE_OFFWKUP_CORERSTACTST signal from the PRCM defining if an EMIF cold reset was due to a global reset or to exiting off mode; • In case of a global cold reset, the full SDRAM init phase is performed. • In case of off mode exit, only the self-refresh exit sequence is performed and auto-refresh commands are immediately sent. If the memory was in deep power-down state during the chip off mode, the sequence performed by EMIF could result in an unexpected behavior on the memory side. Exit from DPD actually requires the same full init sequence as after a global cold reset.	Software workaround: • Before getting into off mode, force the value stored in the control module EMIF_SDRAM_REF_CTRL.REG_INITREF_DIS to 1. – This forces the value for the EMIF register to 1 when its content is restored when returning from off mode. • When returning from off mode, and before making any access to the memory in DPD state: 1. Put CORE PLL in MN bypass mode CM_CLKMODE_DPLL_CORE.DPLL_EN = 0x4. 2. Program the DLL override CM_DLL_CTRL.DLL_OVERRIDE = 1. 3. Force the configuration field EMIF_SDRAM_CONFIG.REG_SDRAM_TYPE register to 0x1 (reserved), then back to 0x4 (LPDDR2-S4) or 0x5 (LPDDR2-S2) according to memory configuration. This forces the controller back into its init state instead of self-refresh state. 4. Reconfigure EMIF_SDRAM_REF_CTRL.REG_INITREF_DIS to 0. 5. Perform normal init phase as from global cold reset.	1.17 Deep Power-Down Support During Off Mode
Cortex A-9	TI	OMAP4460	RTA (retention till access) feature is not supported and leads to device stability issues when enabled. The following modules are embedding memories with RTA support: • MPU subsystem (cache memories) • OCM RAM • SGX • Display subsystem • HS USB OTG • IVA-HD subsystem • Face detect • Imaging subsystem • DMM • DSP subsystem • AESS	PRM_LDO_SRAM_<Memory Voltage Domain>_SETUP[0] DISABLE_RTA_EXPORT default value is loaded by an eFuse value. The fuse value disables this RTA feature, so these bits must be kept at default value.	1.18 RTA Feature Is Not Supported
Cortex A-9	TI	OMAP4460	Due to design issue MMCHS_HCTL.HSPE bit does not work as intended. This means that the configuration must always be the normal speed mode configuration (MMCHS_HCTL.HSPE=0).	None	1.19 MMCHS_HCTL.HSPE Is Not Functional
Cortex A-9	TI	OMAP4460	When in YUV4:2:0 format in 1D burst, the DISPC DMA skips lines when fetching Chroma sampling.	If YUV4:2:0-1D burst is required: • Set DISPC_VIDp_ATTRIBUTES[22]DOUBLESTRIDE to 0x0 and DISPC_VIDp_ATTRIBUTES[13:12]ROTATION to 0x1 or 0x3	1.20 Wrong Access In 1D Burst For YUV4:2:0-NV12 Format
Cortex A-9	TI	OMAP4460	The DSI-PHY has an internal LDO. This LDO is used to convert 1.8V coming from VDDS_DSI input into 1.2V for appropriate DSI voltage level. An internal LDOPWRGOOD signal output by the DSI_PHY indicates the status of the LDO (LDO is up or is down). This signal should be connected to the DSI protocol engine for IRQ reporting (LDO_POWER_GOOD_IRQ). This signal is not connected to the DSI protocol engine and input of protocol engine is tied to 0x0.	There is no workaround to check HW status of DSI LDO. The LDO_POWER_GOOD_IRQ should be disabled by keeping or setting DSI_IRQENABLE.LDO_POWER_GOOD_IRQ_EN to 0x0.	1.21 Status of DSI LDO Is Not Reported to DSI Protocol Engine
Cortex A-9	TI	OMAP4460	When a break frame is sent in the middle of data transfers (DMA based),in pipelined flow or synchronized flow, one Tx data frame will be overwritten at the transmitter side by an all-zeros frame (break is received correctly). Table 1-1. Data Corruption Example Transmitted Data: Received Data: 0x77CFA0B0 0x77CFA0B0 0xDFFC7B49 0x00000000 <- break frame and data last 0x5BE7AD07 0x5BE7AD07 0x7F7F1BC8 0x7F7F1BC8 .... ....	No workaround identified.	1.22 HSI Break Frame Corrupt OnGoing Transfer
Cortex A-9	TI	OMAP4460	The counter configuration capabilities include start (begin counting), stop (halt counting), and load (set time-out period). It is not possible to disable the frame time-out and tailing bit error counters. Setting value 0 in HSR counters (HSR_COUNTERS_Pp[23:20]TB = 0x0 and HSR_COUNTERS_Pp[19:0]FT = 0x0) disables those counters, whereas errors keep being generated with this value. In transient setup phases where TX and RX data rates are still not aligned, false errors may be reported by HSR. Because HSR halts the reception upon an error (until the error is acknowledged) communication will be broken. In such circumstances, inability to disable error detection may be a critical problem.	To disable error reporting: • Set HSR_COUNTERS_Pp[19:0] FT counter to max value (0xFFFFF) • Set HSR_COUNTERS_Pp[23:20] TB error to min value (0x0)	1.23 HSI Error Counters Cannot Be Disabled
Cortex A-9	TI	OMAP4460	When transferring a data on McPDM uplink path, if the McPDM uplink path is reset by MCPDM_CTRL.SW_UP_RST, uplink FIFO is correctly reset but the dma pending signal is kept asserted. This can result in an invalid access by the host DMA to uplink FIFO. The same applies to DMIC if reset by DMIC_CTRL.SW_DMIC_RST.	Follow the programming model below to disable and enable the channels: • Disable the channels: – Set the MCPDM_CTRL.SW_xx_RST bit to 1. – Disable all channels. – Set the MCPDM_CTRL.SW_xx_RST bit to 0. • Enable the channels: – Set the MCPDM_CTRL.SW_xx_RST bit to 1 – Enable necessary channels. – Set the MCPDM_CTRL.SW_xx_RST bit to 0. Note: SW_xx_RST is either MCPDM_CTRL_SW_UP_RST, CPDM_CTRL_SW_DN_RST, or DMIC_CTRL.SW_DMIC_RST.	1.24 McPDM/DMIC Issue With Software Reset With SW_xx_RST
Cortex A-9	TI	OMAP4460	UART TX with a DMA THRESHOLD default configuration of 64 bytes would result in extra DMA Req assertion when FIFO tx_full is switched from high to low. This is because of the TX THRESHOLD added in ES2.0 compared to ES1.0.	Use TX_THRESHOLD+TRIGGER_LEVEL <= 63 (TX FIFO Size - 1).	1.25 UART: Extra Assertion of UARTi_DMA_TX Request
Cortex A-9	TI	OMAP4460	Software initiated read/write accesses to the PHY ULPI registers (that is, when using USB OTG ULPIReg registers) may be wrongly mixed up with USB OTG Tx traffic. Due to this corruption the USB OTG will detect a Vbus error or a Babble error (logged in IntrUSB register), and halts the communication. Hardware initiated accesses to the PHY ULPI registers are not impacted because they occur during connect, disconnect, suspend, and resume, when there is no USB traffic. Only software initiated accesses are impacted, and only when there is on-going USB Tx transfers.(including SOF in host mode) Software initiated accesses during connect, disconnect, suspend, and resume are not impacted. Host and peripheral modes are impacted.	If possible do not use software initiated reads/writes to access the PHY ULPI registers. Depending on the PHY, there may be a possibility to access these registers by I2C. If the USB OTG is host, another workaround consist in putting the bus in suspend mode with low-power mode disabled when willing to read/write an ULPI PHY register: • Disable PHY low-power mode (Power:EnableSuspendM=0) • Execute USB SUSPEND. • Do the ULPI register read/write • Execute USB RESUME • Restore Power:EnableSuspendM. If the USB OTG is peripheral, another workaround consists in using the 1-2us time frame after reception of SOF, before any transfer begins on the bus: • Enable the SOF interrupt • Program the ULPIReg registers except the ULPIRegControl:D0 bit • When the SOF interrupt fires, set the ULPIRegControl:D0 bit to make the access • Disable the SOF interrupt	1.26 USB OTG Software Initiated ULPI Accesses To PHY Registers Can Halt the Bus
Cortex A-9	TI	OMAP4460	The prefetch error event (PREFETCH_ERROR) is triggered when the gain table is read too slowly from SDRAM. When this event is pending the module should go into transparent mode, meaning LSC should copy input pixels to output pixels (output=input). Actually, when the prefetch error event occurs the LSC module outputs black pixels.	None	1.27 ISS-SIMCOP: ISS-LSC Not Transparent After Prefetch Error Event
Cortex A-9	TI	OMAP4460	When an RX wake-up mechanism is used for the UART module, the first character received can be lost.	This is a known behavior and is dependant on the speed of response of the PRCM module to a wakeup. The CTS wake-up mechanism should be preferred when it is possible.	1.28 UART: In an RX Wake-up Mechanism, the First Received Character Can be Lost
Cortex A-9	TI	OMAP4460	The issue occurs during concurrent accesses of CPU0 and CPU1 as described below. If one CPU fetches code from external RAM while the other CPU requires the access to the EMIF firewall (configuring its register REGUPDATE_CONTROL), then both CPUs hang. The issue occurs because when REGUPDATE_CONTROL.BUSY_REQ is activated, the interconnect blocks the accesses. Because the two CPUs of the MPUSS use the same bridge before the L3 interconnect, this bridge is saturated if one CPU is accessing external RAM.	The workaround is to make sure that the other CPU is not doing external accesses through EMIF when a CPU is updating the EMIF firewall. The issue does not occur with the other initiators because they do not share the bridge before the L3 interconnect.	1.29 Platform Hangs When CPU Tries To Configure The EMIF Firewall
Cortex A-9	TI	OMAP4460	If bus keeper mode is used (programmed through CONTROL_LPDDR2IO*_*.LPDDR2IO*_GR*_WD) after leaving open switch retention, it is necessary to reset the DDR PHY. Otherwise the LPDDR2 memory cannot be accessed.	If bus keeper mode is used, issue a PHY reset after leaving OSWR, set bit [10] to 1 at the following address (using read modify write to this register to keep other bits): • Assert PHY reset for EMIF1 @ x 4C00 0060 • Assert PHY reset for EMIF2 @ x 4D00 0060 Because this resets the command line, this reset must be done when memory is in self-refresh mode.	1.30 DDR PHY Must be Reset After Leaving OSWR
Cortex A-9	TI	OMAP4460	If data is stalled inside an asynchronous bridge because of back pressure, it may be accepted multiple times, thus creating pointer misalignment that corrupts next transfers on that data path until the next reset of the system (no recovery procedure once the issue is hit, the path remains consistently broken). The async bridge can be found on the path between MPU to L3 interconnect (to EMIF) and Cortex M3 to L3 interconnect (to EMIF). In the OMAP4460 and OMAP4470 devices, direct path from MPU to EMIF (through memory adapter in MPU-SS) is replacing MPU-to-DMM path, which was taking place in the OMAP4430. Hence, in an OMAP4460 or OMAP4470 device, this bug is not impacting the direct path from MPU to EMIF (through memory adapter in MPU-SS). This situation can happen only when the idle is initiated by a master request disconnection (which is trigged by software when executing WFI).	All the initiators connected through async bridge must ensure that data path is properly drained before issuing WFI. This condition is met if one strongly ordered access is performed to the target right before executing the WFI.	1.31 Async Bridge Corruption
Cortex A-9	TI	OMAP4460	When a key is released for a time shorter than the debounce time, in-between 2 key press (KP1 and KP2), the keyboard state machine will go to idle mode and will never detect the key release (after KP1, and also after KP2), and thus will never generate a new IRQ indicating the key release. From the operating system standpoint, only a key press as been detected, and the key will keep on being printed on the screen until another or the same key is pressed again. When the failing state has been reached, the KBD_STATEMACHINE register will show "idle state" and the KBD_FULLCODE register won't be empty, this is the signature of the bug.There is no impact on the power consumption of the system as the state machine goes to IDLE state.	First thing is to program the debounce time correctly: If X (us) is the maximum time of bounces when a key is pressed or released, and Y (us) is the minimum time of a key release that is expected to be detected, then the debounce time should be set to a value in-between X and Y. In case it is still possible to get shorter than debounce time key-release events, then the only solution is to implement a software workaround: Before printing a second character on the screen, the software must check if the keyboard has hit the failing condition (cf signature of the bug above) or if the key is still really pressed and then take the appropriate actions.	1.32 Keyboard Key Up Event Can Be Missed
Cortex A-9	TI	OMAP4460	Due to a design issue of power control signals of the L2 Cache, the content of the memory can be corrupted.	No SW workaround.	1.33 L2 Cache Corruption Issue
Cortex A-9	TI	OMAP4460	It is not possible to perform USB transactions with a FS device on port USB_B1/B2. EHCI is able to detect the device, reset it and find that it is a FS device. SW will then hand off the port to OHCI by setting PORTSC[5]:PO (PORT OWNER) bit. OHCI is able to detect the connection, but then cannot communicate with the device. When the PHY switches to FsLsSerialMode, the ULPI DIR signal will go to 1 forever. In HS mode, if DIR is 1, then the ULPI DATA switch to "input only" mode. This input only configuration is wrongly kept after switching to FsLsSerialMode, hence USB transactions cannot occur. Attaching a FS device directly to an OHCI port is working fine.	Only attach FS devices to OHCI ports, or use a HS hub to interface between EHCI ports and LS/FS/HS devices.	1.34 USB HOST - Impossible To Attach a FS Device To An EHCI Port. Handoff To OHCI Is Not Functional
Cortex A-9	TI	OMAP4460	When entering USB suspend mode, the EHCI will automatically ask the PHY to enter low power mode (PHY function control register bit suspendM is reset). The PHY will then cut the ULPI_CLK after a minimum of 5 clock cycles.(no maximum specified). On the other hand, the EHCI embeds a counter counting up to 18 before cutting the internal clock after suspend signal is asserted. Since the PHY cuts the clock prematurely, the counter is not reaching 18. However, the first suspend and resume will work correctly. At the second suspend sequence, since the counter has maintained the value (thanks to retention flops), the counter reaches 18 and cuts the clock internally. As a consequence, the internal state machine does not transition to the correct state causing the next resume to fail. Both host initiated resume and remote wakeup are impacted by this issue.	After setting the suspend bit, switch the internal clock supply from the external ULPI_CLK provided by the PHY to the internal 60 MHz clock. This will allow the internal counter to reach 18. Then after 1ms, switch back to the external ULPI_CLK. This switch can be done thanks to the CM_L3INIT_HSUSBHOST_CLKCTRL[25:24]:CLKSEL_UTMI_P1/2 bits. During the application of the WA, the CM_L3INIT_HSUSBHOST_CLKCTRL[9:8]OPTFCLKEN_UTMI_P1/2_CLK optional clocks need to be enabled.	1.35 USB HOST EHCI - Port Resume Fails On Second Resume Iteration
Cortex A-9	TI	OMAP4460	There is no H/W mechanism preventing violating below I2C Bus clear standard requirement. If the data line (SDA) is stuck LOW, the master should send 9 clock pulses. The device that held the bus LOW should release it sometime within those 9 clocks. If not, then use the HW reset or cycle power to clear the bus. Sys_Warmreset doesn't reset the I2C IP at Phoenix level, it does at IC level. Resetting the IP at Phoenix PMIC would avoid such situation, but this is partial answer as many other I2C slave devices could be addressed during Warm reset without any sensitivity to this sys_warmreset pin. No other reset source possible at Phoenix level to reset the I2C controller (only Cold Reset). So, once the situation is reached, IC is seeing bus busy status bit.	I2C SW handler could be programmed to detect such a locked situation. In this case, it will check the Bus Busy bit and issue the needed clock pulses.	1.36 System I2C hang due to miss of Bus Clear support
Cortex A-9	TI	OMAP4460	There are some fails while suspending then resuming on going HSI communication on both HST and HSR initiatives. If this is the HST initiative: 1. It is possible to suspend then resume communication by disabling then enabling active HST FIFOs through HST_MAPPINGf [0] ENABLE bit. Transmission stops as soon as TX FIFO is disabled (ENABLE bit equal to 0x0) and resumes as soon as TX FIFO is re-enabled (ENABLE bit equal to 0x1). 2. It is not possible to suspend then resume safely by setting HST mode to SLEEP. Writing HST_MODE_Pp[1:0] MODE_VAL = 0x0 (SLEEP) does not have any impact on transmission that continues. If it is the HSR initiative: 1. It is not possible to suspend then resume communication by disabling then enabling active HSR FIFOs through HSR_MAPPINGf [0] ENABLE bit. Disabling the RX FIFO does not stop the transmission (by dropping the READY line). The data keeps being sent by HST and HSR simply discards it. By the way, no RX mapping error is generated. Transmission did not actually stop and frame is lost by HSR. 2. It is not possible to suspend then resume safely by setting HSR mode to SLEEP. Writing HSR_MODE_Pp[1:0] MODE_VAL = 0x0 (SLEEP) stops any ongoing transfer unconditionally which may result in loss of frame(s) once the transfer is resumed.	If this is the HST initiative: It is not possible to configure MODE_VAL bit to SLEEP with active data transfers because it has no impact. The only way to suspend then resuming a HSI communication with HST is to disable then re-enables active TX FIFOs. If this is the HSR initiative: There is no way to suspend then resume the receiver without data loss.	1.37 HSI: Issues In Suspending and Resuming Communication (HSR and HST)
Cortex A-9	TI	OMAP4460	There is a bug in HSI IP;once the SW reset bit is set through the HSI_SYSCONFIG[1] SOFTRESET bit, the SW reset is not propagated well if there is an on-going reception. If the reception never ends (synchronization loss, interrupted transmission from transmitter...), then this is a deadlock, the SW reset is not propagated and there is no OCP access possible.	Use the HW reset from the PRCM instead of the local SW reset.	1.38 HSI: Issue with SW reset
Cortex A-9	TI	OMAP4460	The DMA4 channel generates an unexpected transaction on WR port under the following 2 scenarios : • Scenario 1 1. Software synchronization : Bit fields SYNCHRO_CONTROL and SYNCHRO_CONTROL_UPPER are set to 0 in register DMA4_CCRi Channel element number : Bit field CHANNEL_ELMNT_NBR is set to 0x9 in register DMA4_CENi Channel frame number : Bit field CHANNEL_FRAME_NBR is set to 0x1 in register DMA4_CFNi Element size : Bit field DATA_TYPE is set to 0x2 in register DMA4_CSDPi Destination addressing mode : Bit field DST_AMODE is set to 0x1 in register DMA4_CCRi Destination is packed : Bit field DST_PACKED is set to 0x1 in register DMA4_CSDPi Destination endianism : Bit field DST_ENDIAN is set to 0x0 in register DMA4_CSDPi Destination burst enable : Bit field DST_BURST_EN is set to 0x1 in register DMA4_CSDPi Destination start address : Register DMA4_CDSAi is set to 0xabcd0000 Disable graphics operation : Bit fields CONSTANT_FILL_ENABLE and TRANSPARENT_COPY_ENABLE are set to 0x0 in register DMA4_CCRi The channel has got an ERR response on the WR port before the end of block transfer. The channel has gone for clean abort and got disabled. The same channel has been configured with soft-sync and included in the channel chaining (This channel is not the head of the chain). When this channel gets enabled through the link, the channel is writing the data out as soon as it fetches the data from Read side. It is expected that the channel should go with burst transfer, but it is going for single transfers This results in a performance issue as DMA is executing single transfers instead of burst transfers. This performance issue is also observed while using the channel with destination synchronization and prefetch enabled. 2. Destination sync with Prefetch enabled : Bit field SEL_SRC_DST_SYNC is set to 0x0 ; Bit fields SYNCRO_CONTROL_UPPER and SYNCRO_CONTROL should not be set to 0x0 ; Bit field PREFETCH is set to 0x1 in register DMA4_CCRi The other settings remain same as in use case #a described above • Scenario 2 The channel has got an ERR response on the WR port before the end of block transfer. The channel has gone for clean abort and got disabled. The same channel has been configured with destination-sync with prefetch enabled and included in the channel chaining (This channel is not the head of the chain). When this channel gets enabled through the link, the read port will start its transaction. If the HWR request to this channel comes before the channel gets its first response, the channel will start a WR transaction with byte enable 0. Also, the internal data counters get updated and the corresponding data will never come out of DMA4. The Data FIFO locations are also not recovered. This results in a Data Integrity issue.	There is a software workaround to solve this issue 1. Work around to resolve both Data Integrity and Performance issue : 56 Bugs SWPZ017L – September 2011 – Revised September 2013 Copyright © 2011–2013, Texas Instruments Incorporated Public Version www.ti.com DMA4 generates unexpected transaction on WR port • Dummy enable-disable for an aborted Channel. i.e. On abort, configure the channel as soft sync with No of frames = 0 and enable the channel by writing 0x1 into the ENABLE bitfield of register DMA4_CCRi. Wait for the Address Misaligment Interrupt. The channel is now ready for reuse. • Ensure that clean drain happens for a channel that is or is to be used as part of a channel chain. i.e. ensure that the abort conditions never occur for this channel • If a channel gets aborted, do not reuse the channel in a chain • Don't use channel chaining 2. Work around to resolve the data integrity only. Disable prefetch in all channels that are part of a channel chain	1.39 DMA4 generates unexpected transaction on WR port
Cortex A-9	TI	OMAP4460	This Bug can occur only in a channel that is part of a channel chain. If channel chaining is not used, this bug is never seen. An exact corner case sequence of events must occur. The sequence is: • The channel is enabled and then aborted*. • This same channel is now configured as part of a channel chain (it should not be the head of the channel chain). • The channel is configured as "software synchronized" or "hardware synchronized at destination with prefetch enabled" • The channel gets enabled through linking. * Following is the subset of abort conditions for this scenario: • The channel is disabled in the middle of transaction and channnel is not a drain candidate. • The channel gets a transaction error on write port but not at the end-of-block transaction. • The channel gets a read transaction error and is not a drain candidate.	The software workaround is to configure DMA4 to be in no-standby or force-standby mode before clearing the PAUSE bit. The DMA4 can be reverted back to smart-standby mode after a certain period (after detecting DMA4_CSR[15:15] of corresponding channel to be 0 or ensuring DMA4_CCR[7:7] bit of corresponding channel to be 0. This ensures descriptor load completion or channel termination.)	1.40 DMA4 channel fails to continue with descriptor load when Pause bit is cleared
Cortex A-9	TI	OMAP4460	CPU random hang can happen during 1.2 and 1.5 GHz OPP changes. Hang are due to MPU clock glitch or shrink pulses created at DPLL MPU enable/disable with DCC (Duty Cycle Correction) used. DCC is required for DPLL lock frequency higher than 2Ghz. OPPs lower than 920 MHz use DPLL clock divided by 2, DCC is not used and so there is no issue at OPP change. 1.2 and 1.5GHz OPPs use the direct clock output from the DPLL and so this clock passes through a Duty Cycle Corrector. Random hang can happen at OPP change. Enable signal of DCC from the PRCM is not resynchronized with the output clock of the DCC and so glitches can occur at the output of the clock switch when enable signal toggles. This can create hang of the system.	The Software should lock the DPLL at 2 x the OPP frequency and disable the DCC for all OPPs: • Locking MPU DPLL at 2.4GHz for 1.2GHz unitsand at 3GHz for 1.5GHz units. (See the table below for DPLL_MPU recommended settings.) As DM never mentioned DCC used, these lock frequencies are already documented. • Disabling DCC: CM_CLKSEL_DPLL_MPU[22] DCC_EN=0. Table 1-2. DPLL_MPU Recommended Settings SysClk MPU OPPs MPU DPLL MPU (MHz) OPPs VDD_MPU DPLL M N M2 M3 MPU Actual (V) locked Freq Freq (MHz) (MHz) 38.4 NITRO+S 1.35 2995.2 39 0 1 Use M2 0 1497.6 B Output NITRO 1.35 2400 125 3 1 0 1200 26 NITRO+S 1.35 2998.7 173 2 1 Use M2 0 1499.3 B Output NITRO 1.35 2402.4 231 4 1 0 1201.2 19.2 NITRO+S 1.35 2995.2 78 0 1 Use M2 0 1497.6 B Output NITRO 1.35 2400 125 1 1 0 1200 16.8 NITRO+S 1.35 3001.6 268 2 1 Use M2 0 1500.8 B Output NITRO 1.35 2402.4 143 1 1 0 1201.2 12 NITRO+S 1.35 3000 125 0 1 Use M2 0 1500 B Output NITRO 1.35 2400 100 0 1 0 1200 SWPZ017L – September 2011 – Revised September 2013 Bugs 59 Copyright © 2011–2013, Texas Instruments Incorporated Public Version MPU clock glitches at OPP change www.ti.com Units are trimmed in production to support those frequencies, new trimming bits are added to give this information: CONTROL_STD_FUSE_OPP_DPLL_1 [19:18] = 00 for 2Ghz, 01 for 2.4GHz and 11 for 3GHz. For material trimmed at 2.0GHz only (CONTROL_STD_FUSE_OPP_DPLL_1[19:18] = 00), trimming override at a fix value is required to achieved performances at 2.4 and 3Ghz (write 0x29 in register CONTROL_DPLL_NWELL_TRIM_0). This trimming override is needed only for non production material. The new trimming bits CONTROL_STD_FUSE_OPP_DPLL_1 [19:18] will not give information of silicon performance type. To know the silicon performance type software sill need to read STD_FUSE_PROD_ID_1[17:16] SILICON_TYPE.	1.41 MPU clock glitches at OPP change
Cortex A-9	TI	OMAP4460	There is a silicon bug in HSI IP. The wakeup dependency from HSI towards DSP is by default enabled and the register bit controlling this dependency is read only. There is no option to disable this dependency. As a result when the MPU Wakeup is generated, a false DSP wakeup is also generated. When below scenario happens: 1. Modem interface (HSI is enabled) 2. The system is allowed to suspend 3. When CAWAKE signal has activity, it will wake-up MPU; it also wakes up DSP incorrectly. Consequences of this bug in previous scenario is 4. The DSP is not able to handle this wake up correctly 5. Next suspend, system can't enter in off-mode because DSP remains active	• While in the suspend path: 1. DSP is forced through SW to wake-up: - CM_DSP_CLKSTCTRL [1:0] CLKTRCTRL = 0x2 2. When CAWAKE signal has an activity, it will wake-up MPU and DSP; the DSP domain becomes active 3. Program DSP through SW to transition to low power state: change the HW_AUTO, sleep and wake up are based upon hardware conditions - CM_DSP_CLKSTCTRL [1:0] CLKTRCTRL = 0x3 • This will forcefully clear DSP wakeup-gen and will allow DSP to go idle. • No impact of this workaround on power/performance is seen after doing measurements	1.42 HSI: DSP Swakeup generated is the same than MPU Swakeup. System can't enter in off mode due to the DSP.
Cortex A-9	TI	OMAP4460	The next CBUFF ready window event (IRQ_CTXx_READY) is generated once CPU clears the CBUFF ready (IRQ_CTXx_READY)and after the CPU writes in the current ended window (setting the CBUFF_CTX_CTRL_i [10] DONE bit to 0x1).	The number of CBUFF windows to use in write mode for a given context is two windows.	1.43 CBUFF Ready Window Event in Write Mode
Cortex A-9	TI	OMAP4460	Ongoing transactions may be interrupted when a software reset is performed while there is still active traffic generated by the CSI-2 receiver. Interruption of ongoing transactions typically leads to a general OMAP hang that can only be recovered by a device reset.	Software must ensure that there is no ongoing traffic before performing a software reset. In particular, the CSI-2 receiver must be reset to resume normal operation after a CSI-2 FIFO overflow. There may be remaining data in the FIFO, and therefore ongoing traffic, when the software driver receives the overflow interrupt. To avoid creating a system hang, software must either: • Wait for several 1000s of L3 cycles before performing the software reset after an overflow or • Use the ISS level software reset	1.44 CSI-2 Receiver Executes Software Reset Unconditionally
Cortex A-9	TI	OMAP4460	The TLL bit-stuffing emulation feature (enabled by default after reset in the TLL_CHANNEL_CONF_i[11] ULPINOBITSTUFF bit) is broken. It must be disabled, that is, bit-stuffing must be disabled on all enabled TLL channels. However, disabling bit-stuffing on a TLL channel induces an asymmetry in the number of transmitted bits between the TLL channel and the other ports (ULPI or HSIC), which may result in an underrun or overrun errors. This could be the case while transferring data pattern where bit-stuffing is heavily used, like a white image (full of 11111...).	Disable TLL bit-stuffing on all enabled TLL channels: TLL_CHANNEL_CONF_i[11] ULPINOBITSTUFF = 1 and do not use at the same time one TLL port and one ULPI port or one HSIC port.	1.45 USB Host TLL Bit-stuffing Feature Is Broken
Cortex A-9	TI	OMAP4460	If unexpected VD, Start of frame signal, caused by noise comes before finishing the previous frame statistics, the H3A module hangs.	ISP full reset is necessary to exit from H3A hang state.	1.46 ISP H3A Hangs Due to Unstable Vertical Sync Signal
Cortex A-9	TI	OMAP4460	After the GPIO is configured in smart-idle (or smart-idle with wake-up) and the system goes into MPU inactive mode (idle), the GPIO does not generate any IRQ again if any of the register bits of both interrupt line raw status registers (GPIO_IRQSTATUS_RAW_0 or GPIO_IRQSTATUS_RAW_1) is set. In the case of a GPIO configured in smart-idle wake-up mode (GPIO_SYSCONFIG[4:3]=0x3), the wake-up associated to the GPIO IRQ event will not even occur.	Note: In the below paragraph, 'x' stands for 0 or 1 being the 1st interrupt to be handled, either MPU or DSP, 'y' refers to the other interrupt line. Upon an interrupt reported through GPIO_IRQSTATUS_x, do the following: • Read out GPIO_IRQSTATUS_x => status_value_x • Write status_value_x to GPIO_IRQSTATUS_x (clear the enabled status bits) • Read out GPIO_IRQSTATUS_SET_y=> enable_value_y • Write status_value_x and NOT enable_value_y to GPIO_IRQSTATUS_y By doing so, user clears the unused interrupt status bits for the other interrupt line. An extension to this workaround is to clear GPIO_IRQSTATUS_y (all the bits) when the corresponding interrupt line (most of the time the DSP, that is, 2nd interrupt line) is not used, at each time GPIO_IRQSTATUS_x is cleared. Note: Clearing GPIO_IRQSTATUS_0 (respectively 1) is done by writing 0xFFFFFFFF to this register. It will automatically clear GPIO_IRQSTATUS_RAW_0 (respectively 1) consequently.	1.47 GPIO IRQ Not Generated After MPU Idle if IRQSTATUS Bits Not Cleared
Cortex A-9	TI	OMAP4460	When DSI PLL is under locking, SYS_CLK can be observed on the hardware observability but once PLL is locked the hardware observability signal does not change and still show SYS_CLOCK. DSI PLL is not available on hardware observability.	No workaround is available.	1.48 DSI PLL Signal is Not available on Hardware Observability Pads
Cortex A-9	TI	OMAP4460	The equation for layer blending when upper layer is a premultiplied with a global alpha: LYR(result) = A(global) * LYR(upper) + (1 -“ (A(global) * A(pixel))) * LYR(lower) Where: • A(global) is alpha of upper layer • A(pixel) is pixel alpha of upper layer • (1 -“ (A(global) * A(pixel))) is the first complement of A(global * A(pixel)) • When A(global) = 0 P(result) should be P(lower). Calculation leads to 0xff * P(lower) which can have 1-bit error if P(lower) > (full range)/2 (0x80 for 8-bit) • When A(global) = 0xff P(result) should be P(upper). Calculation leads to 0xff * P(upper) + (1-A(pixel)) * P(lower) For example, 8-bit multiplication-with-rounding leading to 1-bit error in case Operand > (full range) / 2. 0x8c * 0xff = 0x8B74 final resulting after rounding is 0x8B instead of 0x8C.	No workaround is available.	1.49 Blending Calculation Error When Premultiply Alpha is Used
Cortex A-9	TI	OMAP4460	When the system enters off mode, the save-and-restore (SAR) process comes into play. During the save sequence, the USB host content must be saved (even if the module was not in use). The saved content is automatically restored upon the next wakeup from off mode. When the save of the USB context occurs, an extra pulse of UTMI_root clock coming from USB DPLL is entering the IP, and generates a minor corruption. This corrupted context is saved and restored later. Upon each save thereafter, the corrupted context is corrupted further. This is a cumulative process. At least three consecutive saves (with no wakeup of USB in-between) are needed for introducing a fatal corruption. This corruption will impact the next use of the USB module: it could be while resuming a suspended device, or it could be upon the enumeration of a new device. The exact failure is not predictable: disconnection or stalls have been observed. TLL and external PHY modes are impacted.	The workaround is to only perform the SAR-save of the USB registers if the USB bus has been resumed since the last wakeup from OFF mode. If the USB has been left untouched in-between the previous wakeup from OFF, and the next OFF mode entry, then do not perform the USB registers SAR-save. (However the regular SAR-save is still needed for PRCM and other registers. Just skip the USB part) By doing so, the SAR-restore process is always restoring valid data.	1.50 HS USB: Multiple OFF Mode Transitions Introduce Corruption
Cortex A-9	TI	OMAP4460	DISPC and RFBI are configured in smart-idle mode. After sending an image to the panel through the RFBI interface, the DISPC end-of-frame interrupt and RFBI end of transfer occur. After software sets the DSS in off state but no off state is not reached, DSS CM stays in idle transition, CM_DSS_DSS_CLKCTRL[17:16] IDLEST = 0x1 because RFBI is not acknowledging idle request.	After transfer of image completes, set the RFBI mode into bypass mode by setting the DISPC_CONTROL1[16] GPOUT1 and DISPC_CONTROL1[15] GPOUT0 bits to 0x1.	1.51 DSS Block in "Idle Transition" State when using RFBI I/F
Cortex A-9	TI	OMAP4460	A protocol violation between SmartReflex and voltage processor can happen when a global warm reset occurs during a transaction. Consequences are: • VP_xx_TRANXDONE_ST interrupt from the PRCM is no longer generated when a force update voltage from VP is performed. • SmartReflex does not request voltage change anymore. SmartReflex and voltage processor have a handshake protocol. SmartReflex indicates to voltage processor when voltage update is valid. Voltage processor acknowledges this request. Protocol violation appears when warm reset is asserted before acknowledge. This is because SmartReflex is warm reset-sensitive while voltage processor is cold reset-sensitive.	SmartReflex must be disabled before a software-controlled warm reset. For other warm resets, the issue cannot be avoided, but during reboot the following sequence can be performed to recover: • Initiate a Force Update and check TRANXDONE interrupt success (optional). If it is not successful then: • Initiate a software global cold reset.	1.52 Deadlock Between SmartReflex™ and Voltage Processor
Cortex A-9	TI	OMAP4460	The refresh rate is programmed in the EMIF_SDRAM_REF_CTRL[15:0] REG_REFRESH_RATE parameter taking into account frequency of the device. When a warm reset is applied on the system, the OMAP processor restarts with another frequency and so the frequency is not the same. Due to this frequency change, the refresh rate will be too low and could result in an unexpected behavior on the memory side.	The workaround is to force self-refresh when coming back from the warm reset with the following sequence: • Set EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x2 • Set EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM to 0x0 • Do a dummy read (loads automatically new value of sr_tim) This will reduce the risk of memory content corruption, but memory content can't be guaranteed after a warm reset. When OMAP is back to active mode with correct OPP configuration, EMIF registers need to be reprogram according to the OPP and respect workaround for i735 bug.	1.53 Refresh Rate Issue After Warm Reset
Cortex A-9	TI	OMAP4460	When the EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE bit field is set to 0x2, self-refresh mode is activated. In that case, EMIF puts the SDRAM into self-refresh mode if no access is performed during EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM number of DDR clock cycles. If during a small window the following three events occur: • The EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM counter expires • And frequency update is requested (CM_SHADOW_FREQ_CONFIG1[0] FREQ_UPDATE set to 1) • And OCP access is requested Then it causes unstable clock on the DDR interface.	To avoid the occurrence of the three events, the workaround is to disable the self-refresh when requesting a frequency change. Before requesting a frequency change the software must program EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x0. When the frequency change has been done, the software can reprogram EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x2.	1.54 System May Hang During EMIF Frequency Change
Cortex A-9	TI	OMAP4460	When the EMIF is going in IDLE state and the following three events occur: • Frequency update is requested (CM_SHADOW_FREQ_CONFIG1[0] FREQ_UPDATE set to 1). • And a warm reset occurs. • And a system access is requested. Then the EMIF will not properly reset internal FIFO. The EMIF may answer to the request when returning from reset not expected by the system; it creates protocol error or data corruption.	In case of software warm reset, software can check that no frequency change is ongoing before initiating the warm reset. In case of watchdog timer reset, there is no workaround to recover, a cold reset is needed.	1.55 DDR Access Hang After Warm Reset
Cortex A-9	TI	OMAP4460	Due to wrong timings, all register accesses transitioning through the L4 interconnect toward DSS are not reliable. DSS registers access done through the L4 interconnect are not supported	DSS register access should be addressed through the L3 interconnect.	1.56 DSS Configuration Registers Access Through the L4 Interconnect
Cortex A-9	TI	OMAP4460	LCD1 output supports gamma correction. The color look-up table (CLUT) is shared between the BITMAP to RGB conversion module on GFX pipeline and Gamma correction on the LCD1 output. LUT table can be loaded by SW through DISPC slave port (interconnect) or by DISPC master port using the DISPC DMA. However, LCD1 gamma correction LUT loading is not working properly and require to enable GFX pipeline for LUT loading. Depending on the load mode (DISPC_CONFIG1[2:1] LOADMODE) used, GFX pipeline can then be disabled after 1st frame.	There are two workaround treatments depends on the load mode for gamma correction LUT and frame data (see Table x-xx Workaround/Load mode settings ) Table 1-3. Workaround/Load mode settings Load Mode GFX Enable Condition Workaround ( DISPC_CONFIG1[2:1]LOADMODE) 0x0 (load LUT and data every frame) Always Enabled WA1 0x1 (load LUT for first frame and change loadmode to 2) Enable required for first frame only WA2 0x2 (load frame data only) Enable required for first frame only. WA2 0x3 (load LUT and data for first frame and change Enable required for first frame only. WA2 loadmode to 2) WA1 To use gamma correction on LCD1 output, software must: 1. Enable the GFX pipeline by setting DISPC_GFX_ATTRIBUTES[0] ENABLE to 0x1. 2. Set the GFX base address (DISPC_GFX_BA_i[31:0] BA) to an accessible frame buffer. 3. Set the GFX window to minimum size by configuring the DISPC_GFX_SIZE[27:16] SIZEY and DISPC_GFX_SIZE[11:0] SIZEX bits. 4. If the GFX pipeline is not to be displayed, set GFX LYR to bottom LYR in LCD1 overlay by setting appropriate DISPC_GFX_ATTRIBUTES[27:26] ZORDER bit field and make GFX fully transparent by setting the global alpha of the GFX to 0x00 in the DISPC_GLOBAL_ALPHA[7:0] GFXGLOBALALPHA bit field. WA2 To use gamma correction on LCD1 output, software must: 1. Enable the GFX pipeline by setting DISPC_GFX_ATTRIBUTES[0] ENABLE to 0x1. 2. Set the GFX base address (DISPC_GFX_BA_i[31:0] BA) to an accessible frame buffer. 3. Set the GFX window to minimum size by configuring the DISPC_GFX_SIZE[27:16] SIZEY and DISPC_GFX_SIZE[11:0] SIZEX bits. 4. If the GFX pipeline is not to be displayed, set GFX LYR to bottom LYR in LCD1 overlay by setting appropriate DISPC_GFX_ATTRIBUTES[27:26] ZORDER bit field and make GFX fully transparent by setting the global alpha of the GFX to 0x00 in the DISPC_GLOBAL_ALPHA[7:0] GFXGLOBALALPHA bit field. 5. When DISPC_IRQSTATUS[8]PALETTEGAMMALOADING_IRQ =0x1 then disable GFX pipeline	1.57 LCD1 Gamma Correction Is Not Working When GFX Pipe Is Disabled
Cortex A-9	TI	OMAP4460	LPDDR2 memories could be put in self-refresh mode for power savings. The number of cycles after which EMIF can start a self-refresh entry is software programmable (thanks to the power management timer for self-refresh: EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM register bit field). When exiting self-refresh mode, it is required that at least one refresh command is issued before entry into a subsequent self-refresh (as defined in the JEDEC LPDDR2 Specification) When this timer value is set to a value less than 0x6 (for VDD_CORE_L OPP100) or less than 0x5 (for VDD_CORE_L OPP50), the time between a self-refresh exit to the next immediate self-refresh entry does not allow the EMIF to perform a refresh command. As a consequence, data in LPDDR2 memory is not refreshed properly, and then data is corrupted in LPDDR2.	Using a value of EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM >= 6 for VDD_CORE_L OPP100 and a value of REG_SR_TIM >= 5 for VDD_CORE_L OPP50 avoid the occurrence of the issue.	1.58 Power Management Timer Value For Self-Refresh (SR_TIM)
Cortex A-9	TI	OMAP4460	Following a bug in the integration of I/Os cell for LPDDR2 clocks, a leakage increase can be observed on vddca_lpddr2 when OMAP is in open switch retention mode.	To prevent an increase in leakage, it is recommended to disable the pull logic for these I/Os except during off mode. So the default state of the I/Os (to program at boot) will have pull logic disable: CONTROL_LPDDR2IO1_2[18:17]LPDDR2IO1_GR10_WD = 00 CONTROL_LPDDR2IO2_2[18:17]LPDDR2IO2_GR10_WD = 00 When entering off mode, these I/Os must be configured with pulldown enable: CONTROL_LPDDR2IO1_2[18:17]LPDDR2IO1_GR10_WD = 10 CONTROL_LPDDR2IO2_2[18:17]LPDDR2IO2_GR10_WD = 10 When resuming from off mode, pull logic must be disabled.	1.59 Leakage Increase On LPDDR2 I/Os
Cortex A-9	TI	OMAP4460	If the sys_boot[5:0] pins are configured for booting from MMC1, then the boot on MMC1 may not happen (board dependency) and the ROM code jumps to the next device of the boot sequence. Indeed, depending on the voltage ramp, the ROM code may not wait long enough for SDMMC1_VDDS voltage to be stabilized at 3 V before checking the voltage level supplied to OMAP. In that case, the ROM code checks the SDMMC1_VDDS voltage too early, reads a bad level, and then jumps to 1.8-V configuration while the PMIC was configured to 3 V. The MMC1_PBIAS cell is in a bad state and prevents the sending of commands to the MMC1 bus. The ROM code switches to the next boot sequence.	No	1.60 MMC1 Booting May Be Bypassed Depending On VDD Ramp-up Delay
Cortex A-9	TI	OMAP4460	A bug has been identified in the interconnect agent handling the connect-disconnect protocol between an initiator and interconnect. When the disconnect protocol violation occurs, there is a dead lock and a system lockup is observed. The issue can occur in a corner case when the impacted module has started a transition to standby, for the L3 initiator on which it is attached, exactly at the time the initiator gets an event for exiting idle state. Such a situation can occur when the impacted initiator is generating short MStandby pulses (pulse durations less than one L4 clock cycle). DSS and ISS are the only initiators that are impacted.	L3_CLK1 must be kept in NO-IDLE when the DSS clock domain is ON. It can be switched back to HW_AUTO when the DSS clock domain is IDLE. L3_CLK2 must be kept in NO-IDLE when the ISS clock domain is ON. It can be switched back to HW_AUTO when the ISS clock domain is IDLE.	1.61 Disconnect Protocol Violation
Cortex A-9	TI	OMAP4460	ULPI RxCmds, from OMAP to USB device, convey the wrong ID bit after the save-and-restore sequence. When OMAP is in a low-power mode scenario (chip-OFF), in high-speed transceiverless link (TLL) connection, after the SAR phase, every RxCmd from the TLL to the peripheral conveys wrong ID field (for example, 0x0D instead of 0x4D), that is, the ID bit is 0 instead of 1. This is due to the TLL losing the value of ID during the SAR process. As long as the peripheral does not resample the ID (by toggling OTG_CTRL_i[0] IDPULLUP) after the restore, the ID bit keeps the wrong value 0 instead of 1. This results in sending the wrong RxCmd to the peripheral. Depending on the peripheral device design, it may consider or disregard the ID bit. The behavior and consequences depend on the device design.	Ensure that the OTG_CTRL_i [0] IDPULLUP bit is set to 1 before the SAR-save. By doing so, this bit is restored to 1 after every off mode. Then the ID bit is sampled and the Rxcmd is correct.	1.62 ULPI RxCmds Convey the Wrong ID Bit After Save-and-Restore Sequence
Cortex A-9	TI	OMAP4460	During DVFS transitions, the PRCM controller can hang if CORE DPLL dividers M2 and M5 are updated at once.	The recommended sequence is: • Update CM_SHADOW_FREQ_CONFIG2[7:3]DPLL_CORE_M5_DIV. • Set CM_SHADOW_FREQ_CONFIG2[0]GPMC_FREQ_UPDATE to 0x1. • Wait until CM_SHADOW_FREQ_CONFIG2[0]GPMC_FREQ_UPDATE becomes 0x0. • Update CM_SHADOW_FREQ_CONFIG1[15:11]DPLL_CORE_M2_DIV. • Set CM_SHADOW_FREQ_CONFIG1[0]FREQ_UPDATE to 0x1. • Wait until CM_SHADOW_FREQ_CONFIG1[0]FREQ_UPDATE becomes 0x0.	1.63 PRCM Hang at Frequency Update During DVFS
Cortex A-9	TI	OMAP4460	Due to a bad behavior of an internal signal, the Card Error interrupt bit MMCHS_STAT[28] CERR may not be set sometimes when an error occurred in the card response.	After responses of type R1/R1b for all cards and responses of type R5/R5b/R6 for SD and SDIO cards, software must read two registers: MMCHS_RSP10 and MMCHS_CSRE. When a MMCHS_CSRE[i] bit is set to 1, if the corresponding bit at the same position in the response MMCHS_RSP0[i] is set to 1, the host controller indicates a card error and software should proceed in the same way as if a CERR interrupt would have been detected in the MMCHS_STAT register.	1.64 Card Error Interrupt May Not Be Set Sometimes
Cortex A-9	TI	OMAP4460	When using AutoCMD12 mode in write transfer with ADMA and MMCHS_CMD[1] BCE is disabled, then the CMD12 command is not issued automatically after write transfer completion.	Instead of setting the MMCHS_CMD[2] ACEN bit to 0x1 to enable AutoCMD12 mode, software sends the CMD12 command at the end of write transfers (after the MMCHS_STAT [1] TC bit goes High).	1.65 In AutoCMD12 mode, the CMD12 Command Is Not Issued On Write Transfer Completion
Cortex A-9	TI	OMAP4460	Software override of EFUSE SRAM LDO output voltage value in retention mode is not functional and will have no effect. Retention voltage will be the one set by the EFUSE even if: CONTROL_LDOSRAM_xxx_VOLTAGE_CTRL[26] LDOSRAMxxx_ RETMODE_MUX _CTRL is set to 1 and CONTROL_LDOSRAM_xxx_VOLTAGE_CTRL[20:16] LDOSRAMxxx_ RETMODE_VSET_OUT contains a valid value.	None	1.66 SRAM LDO Output Voltage Value Software Override in RETENTION is Not Functional
Cortex A-9	TI	OMAP4460	Following a design issue on I/O muxing compiler, a glitch can occur on I/Os when switching them from the active mode to the off-mode override value. The glitch is present: • if the feature for pin state override during off mode is used CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y [25,9] OFFMODEENABLE = 1 • and the override value CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[27,11] OFFMODEOUTVALUE = 1 and the IO value when going to off mode was 1. There is no issue • if the override feature CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[25,9] OFFMODEENABLE = 0 is not used, • or if it is used to force a value which is different from the value before going to off mode. • or if it is used to force a 0 and the value before going to off mode was 0.	CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[25,9] OFFMODEENABLE = 1 should not be used on pad output pins driving glitch-sensitive signals if the same value is driven during active mode and off mode and is equal to 1. If CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[25,9] OFFMODEENABLE = 1, it is necessary to ensure that the CONTROL_(CORE/WKUP)_PAD0_X_PAD1_Y[27,11] OFFMODEOUTVALUE is equal to 0 or is different from the value of the I/Os when going to off mode.	1.67 I/O Glitch Issue When Entering Off Mode
Cortex A-9	TI	OMAP4460	This problem impacts the HS USB Host HSIC interface. TLL and ULPI interfaces are not impacted. For this issue to occur, the following conditions must exist: • A USB device is attached to an OMAP HSIC interface. • The USB bus is suspended. • The PRCM asserts idle_req, and the USB host answers idle_ack. • The PRCM hardware automatically stops the interface clocks (ICLK). • Software disables the module by setting the CM_L3INIT_HSUSBHOST_CLKCTRL[1:0]:MODULEMODE bit fields to 0x0. • The PRCM automatically stops the mandatory functional clocks (FLCK). • Software stops the optional FCLK. • The module is then idle. The clock domain can possibly enter idle, then the power domain also can enter a low-power mode, and even the full OMAP. • The device generates a remote wakeup. The USB Host detects the remote wakeup condition asynchronously and generates a USBHOST_SWAKEUP to the PRCM. The PRCM deasserts idle_req, and restarts ICLK and mandatory FCLK, but not the optional FCLK. However, in the case of HSIC, the optional FCLK (CM_L3INIT_HSUSBHOST_CLKCTRL[10/9/8].OPTFCLKEN_UTMI_P3/2/1_CLK) is needed to generate the interrupt indicating to the system that the USB HOST is the wake-up source. Consequently, OMAP is woken up but does not acknowledge who is the wake-up source.	Do not rely on the asynchronous wake-up feature of the USB host module, but rather on the daisy-chain for detecting a remote wakeup. Set the wakeup-enable feature of the HSIC pads and enable the daisy-chain to generate a wakeup and an interrupt to the PRCM. Upon wakeup and interrupt from the daisy chain, if the wakeupevent bit is set for the HSIC pads, then restart the USB Host module and the UTMI_Px clock and resume the device.	1.68 HS USB Host HSIC Remote Wakeup Is Not Functional
Cortex A-9	TI	OMAP4460	When I2C module is used in HS master receive mode, and when smart-idle wakeup mode is set: • If reconfiguration of I2C_BUF[13:8] RXTRSH value is done while I2C_CON[15] I2C_EN = 0x1, and with no clearing of the RX buffer pointer. • I2C module does not wakeup from idle mode due to wrong pointers of RX Buffer (as RXTRSH was reconfigured with no actual cleaning of RX FIFO pointers from a previous transfer). As a consequence, I2C FIFO draining interrupt is not generated in Idle/WakeUp scenario.	Before reconfiguring the RXTRSH (Threshold value for FIFO buffer in RX mode): • Disable I2C controller by setting the I2C_CON[15] I2C_EN bit to 0x0 (this puts the controller in reset, clears the FIFOs, and sets the status bits to their default value) • Once the I2C module reconfiguration is done, reactivate the I2C controller by setting the I2C_CON[15] I2C_EN bit to 0x1 (module enabled).	1.69 I2C FIFO Draining Interrupt Not Generated
Cortex A-9	TI	OMAP4460	General-purpose (GP) timers in posted mode (GPT_TSICR[2] POSTED bit set to 0x1) with GPTi_ICLK (timer interface clock) and GPTi_FCLK (timer functional clock) clock frequency not respecting the ICLK < 4*FCLK ratio, can periodically report a random time from read accesses to counter register GPT_TCRR.	If ICLK < 4*FCLK ratio is not respected, then software should make sure that the posted mode is inactive (the GPT_TSICR[2] POSTED bit is set to 0x0) before any read access to the GPT_TCRR register.	1.70 Read Accesses to GP Timer TCRR Can Report Random Value When In Posted Mode
Cortex A-9	TI	OMAP4460	In video mode, the command mode packets, provided through the DSI protocol engine OCP port, can be interleaving during the blanking periods vertical and/or horizontal blanking periods of the video stream sequence. When TX FIFO on the OCP slave port is empty and if the first packet written to TX FIFO is less than 13 words when 1 data lane is active or 17 words when 2 data lanes are active or 25 words when 3 or 4 data lanes are active, only this packet will be sent on the HS link during the next blanking period enabled for command packet transfer. This is the only sent packet, because this packet is the only completely written packet when the FSM has read the last location of this packet from TX FIFO. Even if more packets are written in TX FIFO before the interleaving starts, these packets will not be sent during that blanking period.	No workaround is available. The impact is minor because: • When interleaving is done on a vertical blanking period (VSA, VFP, VBP), as these blanking are expressed in a number of lines, the remaining packet(s) in TX FIFO are sent on HS link during the next line blanking interval within the same blanking period or during the next one. • When interleaving is done on a horizontal blanking period (HSA, HFP, HBP), the remaining data in TX FIFO is sent on the next blanking period.	2.1 Issue with Transfer Of Multiple Command Packets Coming From Interconnect
Cortex A-9	TI	OMAP4460	The DSI protocol engine is based on the MIPI DSI ver. 1.01 specification. However the video mode using sync pulses is implemented using the timing described in MIPI DSI ver. 1.00 and not ver. 1.01: • The DSI protocol engine sends only HE packets (when enabled) during VACT and not during VSA, VFP, and VBP. • The DSI protocol engine sends VE (noted as VSE in MIPI DSI ver. 1.01 specification) during VSA and not during VBP. Figure 2.1 represents actual implementation and Figure 2.2 represents MIPI DSI ver. 1.01 specification. Figure 2-1. MIPI DSI 1.00 (Implemented) - Video Mode Interface Timing: Nonburst Transmission With Sync Start And End. t * (VSA + VBP + VACT + VFP) L t t t t L t t L L L tL tL L L B L V BL H BL V BL H BL H BL H BL H BL H L V Active video area P S LP S LP E LP S LP S LP S LP S LP S L S M P VSA lines VBP lines VFP lines tHBP t t t t L HSA HACT HFP H H H H H H H H S B RGB HFP S B RGB HFP S E S E A P A P VACT lines SWPZ017L – September 2011 – Revised September 2013 Limitations 93 Copyright © 2011–2013, Texas Instruments Incorporated Public Version Nonburst Video Mode Using Sync Pulses: NO HE Packets Sent VSA, VFP, And VBP Blanking. www.ti.com Figure 2-2. MIPI DSI 1.01 ( Not Supported) - Video Mode Interface Timing: Nonburst Transmission With Sync Start And End. t * (VSA + VBP + VACT + VFP) L t t t t t t t t L L L L L L L L V H H H H H H H H V H H H H H H H H H H H H H H B L V BL BL BL BL BL BL BL L S S S S S S S S S S S S S S S Active video area S S S S S S S S S P S LP LP LP LP LP L LP LP S A E S A E S A E E A E S A E S A E S A E S A E P M S VSA lines VBP lines VFP lines tHBP t t t t L HSA HACT HFP H H H H H H H S HSA S B RGB HFP S B RGB HFP S E S E P A P VACT lines	NA	2.2 Nonburst Video Mode Using Sync Pulses: NO HE Packets Sent VSA, VFP, And VBP Blanking.
Cortex A-9	TI	OMAP4460	BITMAP1, BITMAP2, and BITMAP4 are not supported by the graphics pipeline.	No workaround is available.	2.3 BITMAP1-2-4 Formats Not Supported By The Graphics Pipeline
Cortex A-9	TI	OMAP4460	When Graphics pipeline input pixel is in BITMAP format, it cannot output pixel at the rate of one pixel per each clock cycle when LCD = 1 and PCD = 1. The limitation is not applicable if PCD is greater than or equal to 2.	No workaround is available.	2.4 Limitation On DISPC Dividers Settings When Using BITMAP Format
Cortex A-9	TI	OMAP4460	HDQ/1-Wire protocols use a return-to-1 mechanism and it requires an external pullup resistor on the line. There is a timing limitation on this return-to-1 mechanism that requires a constraint on the external pullup resistor(R) and the capacitive load(C) of the wire.	There is a constraint in the design for the maximum allowed rise time of the wire. After writing data to the wire, the HDQ/1-Wire module samples the logic value of the wire 1 FSM (finite state machine) clock cycle later. The FSM expects to read back 1 value from the wire. This constraint must be taken into account, when calculating the pullup resistor(R) according to the capacitive load(C) of the wire. The maximum RC (pullup resistor and capacitive load) value should be calculated as follow: R <1200ns/(10e-12 + C)	2.5 HDQ™/1-Wire® Communication Constraints
Cortex A-9	TI	OMAP4460	Depending on McPDM FIFO value, a floor Noise in audio band at ~-80dB_fullscale may appear with one of these two following configurations: • Case 1: AESS is used for the McPDM transfers, 6 downlink channels of McPDM are enabled and McPDM downlink FIFO threshold is set to 1. • Case 2: AESS is not used for the McPDM transfers, 4 downlink channels of McPDM are enabled and McPDM downlink FIFO threshold is set to 1 or 2.	Case 1 workaround: • Set McPDM downlink FIFO threshold to 2 (floor noise goes back to ~ -130dB_fullscale) Case 2 workaround: • Set McPDM downlink FIFO threshold to 4 (floor noise goes back to ~ -130dB_fullscale)	2.6 Presence of a Floor Noise on Audio Band When Multiple McPDM Downlink Enabled
Cortex A-9	TI	OMAP4460	Overlay optimization does not work when resize processing is enabled on any 'Enabled' layer. When any of the 'Enabled' layers has bit field DISPC_p_ATTRIBUTES.RESIZEENABLE as nonzero it will neither be optimized nor participate in optimization of layers below.	For optimization to occur for a particular layer, make RESIZEENABLE as 0x0. With multiple layers enabled, make RESIZEENABLE for all the layers as 0x0 for every layer to participate in overlay optimization of itself or for the layers below it.	2.7 Overlay Optimization Limitations
Cortex A-9	TI	OMAP4460	In memory-to-memory operation, it is possible for WB pipe to write out pixel data faster than the rate at which VID/GFX DMA is fetching the pixel data. Under such a condition, the WB pipe should slow down by itself (by inserting necessary stalls) and should not cause an underflow at the VID DMA. The required behavior is: when VID/GFX pipelines are connected to WB in memory-to-memory mode (connected either directly or through overlay), there should not be any buffer underflow and no underflow interrupt should be generated. However the DISPC module deviates from this behavior and generates sporadic underflow interrupt. But buffer underflow never happens; there is no corruption of the data written back to the memory. Only undesired interrupts are generated due to this defect.	Software should disable the VID/GFX pipeline underflow interrupt by writing 0x0 in DISPC_IRQENABLE[20-12-10-6] bit if it is connected to the WB pipeline in memory-to-memory mode. Software should not consider the underflow interrupt generated in DISPC_IRQSTATUS[20-12-10-6] bit when in memory-to-memory mode	2.8 VID /GFX Pipeline Underflow Interrupt Generated When In WB Memory-to-memory Operation
Cortex A-9	TI	OMAP4460	The MIPI HSI specification explicitly requires run-time configurability to be supported for these HSR Frame Burst, HSR Frame Time-out, and HSR Tailing Bit counters. Update of HSR counters with new values while data traffic is ongoing results in spurious errors and/or data loss/corruption: • HSR Frame Burst Counter update: Spurious FT/TB errors and/or data loss/corruption • HSR Frame Timeout Counter update : Spurious FT/TB errors and/or data loss/corruption (observed only in pipelined flow) • HSR Tailing Bit Counter: Spurious FT/TB errors and/or data loss/corruption (observed only in pipelined flow)	No workaround is identified.	2.9 HSI: Run-time Change Of HSR Counter Values Damages Communication
Cortex A-9	TI	OMAP4460	From the MIPI HSI spec; the transmitter shall be able to transmit a break transmission regardless of the state of the READY signal. • Break frame will not be sent if the READY line is low and Tx FIFO is not empty. Inserting a break frame, in this configuration, will also override a frame in Tx FIFO. Refer to "Break frame corrupt ongoing transfer" errata. • Break frame will be sent if TX FIFO is empty and READY line is low.	No workaround is identified.	2.10 HSI Does Not Send Break Frame In Some Scenario
Cortex A-9	TI	OMAP4460	The refresh rate is programmed in the EMIF_SDRAM_REF_CTRL.REG_REFRESH_RATE parameter. To ensure some bandwidth is still available to the system, a low threshold has been implemented in hardware; if the programmed value is lower than the threshold, the threshold value is programmed instead of the requested value. Assuming 1x is the refresh rate of the LPDDR at 85C, JEDEC requirement is to have 4x refresh rate between 85C and 105C. For die up to 1 Gb, Trefi is 15.6us or 7.8us, even with the threshold limitation OMAP will support a 4x refresh rate. For 2Gb and 4Gb die, Trefi = 3.9us, the threshold allows only a 3x refresh rate. For 8 Gbit the threshold will limit to a 2x refresh rate.	For 2 Gbit and 4 Gbit, between 85C and 95C the recommendation is to use this 3x refresh rate. Most of memory vendors have confirmed that this is acceptable. Customer must ensure the LPDDR2 junction temperature will never exceed 95C. This can be achieved by: • Full device level thermal simulations on the worst case thermal use case. TI can provide flotherm model to enable these types of simulations. • And/or instrumentation of the phone placing a thermocouple on the LPDDR2 top case and measuring the temperature thru a comprehensive set of use cases	2.11 EMIF: Refresh rate programmation issue
Cortex A-9	TI	OMAP4460	The refresh requirements for an LPDDR2 8-Gbit (single die) memory at high temperature (>85°C) conflicts with the current EMIF refresh policy and may result in a lock-up situation. This issue does not exist with 2-Gbit and 4-Gbit memories due to their lower t RFC(130 ns versus 210 ns).	There is no workaround.	2.12 EMIF: 8-Gbit (Single Die) Support
Cortex A-9	TI	OMAP4460	ECD3 fails to decode the bitstreams having the mismatch between CBP and CBF generated by non-TI encoder. The mismatch violates the H.264 CBP rule. But the mismatch can be correct in-practice / real-life /De-facto. It wrongly decodes the bitstream as error stream (instead of normal stream), but it never results in hang or crash. The decoded output have visual noticeable artifacts as many good slices are concealed. The issue occurs for H.264 MP/HP decoder decoding bitstream generated by non-TI encoder violating H.264 CBP rule. It does not occur for H.264 BP/MP/HP encoder as well as H.264 BP decoder.	No Workaround	2.13 ECD3 Fails To Decode Bitstreams Having Mismatch Between CBP and CBF
Cortex A-9	TI	OMAP4460	The overlay determine the blending effect by the following: If (Ae > 0x3fc) Result = Upper layer Elsif (Ae == 0x0) Result = Lower Layer Else Ae = Ap×(Upper layer) + (1-Ap)×(Lower layer) where Ae represents the effective Alpha, input of overlay. Ae is determined by two inputs parameters: Ap (pixel alpha) and Ag (global alpha). The Ap available at the input of overlay can come through two paths: 1. The scaler (in which case the highest and second highest values are 0x3ff and 0x3fb, respectively). 2. The parallel bypass path (in which case we can get pixel alpha values between 0x3fc and 0x3fe). The effective alpha value can only be in the range of 0x3fc – 0x3fe if the global alpha value is programmed as 0xff. As an inference from the above if Ae value (resulting as a multiplication of global alpha [Ag] and pixel alpha[Ap]) inside the TV overlay is between 0x3fc and 0x3fe, the blending logic treats this layer as opaque and blending does not occur.	None	2.14 TV Overlay Blending Limitation
Cortex A-9	TI	OMAP4460	The ISP pattern generator, which implements an internal data generation mechanism to test the external pins and can generate RAW data without the need for an external image sensor, is not functional.	None	2.15 ISP Pattern Generator Is Not Functional
Cortex A-9	TI	OMAP4460	Voltage drop can be observed when following conditions are met: • csix_dx/y_ pad pair(DXn, DYn on the figure below) is used in GPI mode (CONTROL_CAMERA_RX[20:19]/[17:16] CAMERARX_CSIx_CAMMODE=0x3) • One of the pair is connected to GND and another is pulled-up to High The signal level of the pad which is pulled-up is dropped due to the leakage of the component used in the off switch for the on-die termination between DXn and DYn. The leakage current (and the voltage drop) varies depending on PVT condition. Under the worst case condition, the leakage can be high enough to drop the signal level under VIH of the GPI buffer and causes functional failure. Figure 2-3. CSI PHY pad in GPI mode	1. Use different pad for GPI. 2. Use the pull-up resistor value smaller than or equal to 9k Ohm. It avoids the voltage drop and keeps the signal level above VIH. However this will be at the expense of increased current (up to 70uA in the worst case), as long as DXn and DYn are opposite in polarity. 108 Limitations SWPZ017L – September 2011 – Revised September 2013 Copyright © 2011–2013, Texas Instruments Incorporated Public Version www.ti.com Voltage Drop Observed On CSI PHY Pad In GPI mode	2.16 Voltage Drop Observed On CSI PHY Pad In GPI mode
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.1 LPDDR2 High Temperature Operating Limit Exceeded
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.2 SDMMC1 interface latch-up issue
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.3 Undesired McBSP slave mode behavior during reset without CLKR/CLKX
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.4 Use Smartreflex class 1.5 for Ice Cream Sandwich
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.5 Change In OMAP4xx Off Mode Sequence For a TPS62361B-Based Platform
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.6 High-Speed Image Capture Use Case
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.7 LPDDR2 Power-Down State is Not Efficient
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.8 MPU-EMIF Static Dependency Needed Around MPU WFI
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.9 SYSEN Usage for an OMAP44xx Platform based on TWL6030/TWL6032 and TPS62361B
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.10 Programming of CM_CLKSEL_DPLL_CORE[20]DPLL_CLKOUTHIF_CLKSEL
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.11 Power Delivery Network Verification
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.12 PRCM Voltage Controller Uses MPU Slave Address
Cortex A-9	TI	OMAP4460	DESCRIPTION	WORKAROUND	3.13 McPDM Downlink Data Corrupted With TWL604x
Cortex A-9	TI	OMAP4430	If a General Purpose Timer (GPTimer) is in posted mode (TSICR.POSTED=1), due to internal resynchronizations, values read in TCRR, TCAR1 and TCAR2 registers right after the timer interface clock (L4) goes from stopped to active may not return the expected values. The most common event leading to this situation occurs upon wake up from idle. GPTimer non-posted synchronization mode is not impacted by this limitation. This limitation also impacts read from Watchdog timers WCRR registers. All the watchdog timers support only POSTED internal synchronization mode. There is no capability to change the internal synchronization scheme to NON-POSTED by software. The 32KSYNCNT_CR register is also impacted by this limitation, since the 32K sync timer is always in posted synchronization mode.	Software has to wait at least (2 timer interface clock cycles + 1 timer functional clock cycle) after L4 clock wakeup before reading TCRR, TCAR1 or TCAR2 registers for GPTimers in POSTED internal synchronization mode, and before reading WCRR register of the Watchdog timers . The same workaround must be applied before reading 32KSYNCNT_CR register of the 32K sync module.	1.1 Delay needed to read some GP timer, WD timer and sync timer registers after wakeup
Cortex A-9	TI	OMAP4430	Because of a glitchy structure inside the UART module, accessing the MDR1 register may create a dummy underrun condition and freeze the UART in IrDa transmission. In UART mode, this may corrupt the transferred data(received or transmitted).	To ensure this problem does not occur, the following software initialization sequence must be used each time MDR1 must be changed: 1. If needed, setup the UART by writing the required registers, except MDR1 2. Set appropriately the MDR1.MODE_SELECT bit field 3. Wait for 5 L4 clock cycles + 5 UART functional clock cycles 4. Clear TX and RX FIFO in FCR register to reset its counter logic 5. Read RESUME register to resume the halted operation Step 5 is for IrDA mode only and can be omitted in UART mode.	1.2 MDR1 access can freeze UART module
Cortex A-9	TI	OMAP4430	Minimum number of pixels for MIPI command mode from the video port should be greater than 1 (at least 2). Image with less than 2 pixels is not expected to be used in a real applicative use case.	If sending a single pixel is needed, the OCP L4 slave port can be used (through CPU or sDMA).	1.3 DSI: Minimum Of 2 Pixels Should Be Transferred Through DISPC Video Port
Cortex A-9	TI	OMAP4430	Transfer using tearing effect cannot be cancelled (writing TE_SIZE to 0). Writing TE_SIZE would have no effect and transfer would continue.	Always wait for tearing effect to complete before changing any configuration.	1.4 DSI: Cancel Tearing Effect Transfer
Cortex A-9	TI	OMAP4430	RX FIFO fullness can be incorrect just after a FIFO read. FIFO fullness should be read only once at the beginning of the transfer. Other accesses during a transfer are not guaranteed.	Use only programming model provided in Programming Model section in the TRM.	1.5 DSI: RX FIFO Fullness
Cortex A-9	TI	OMAP4430	This register must not be written twice when TxByteClkHS is stopped to avoid L4 OCP port deadlock.	User must check that the TxByteClkHS clock is activated before initiating any write access to DSI_TIMING2 register. To ensure the TxByteClkHS clock is active, the user must check: 1. PLL is locked (DSI_PLL_STATUS register; DSI_PLL_LOCK bit) 2. DSIPHY must be in ON power state (PWRCMDON). 3. Clock/Data lane positions are correctly set (DSI_COMPLEXIO_CFG1.xxx_POSITION).	1.6 DSI: Access Restriction On DSI_TIMING2 Register
Cortex A-9	TI	OMAP4430	Executing a FIFO flush does not properly clean the logic, thus resulting in unpredictable behavior of the module.	User must perform module software reset when a transfer is aborted.	1.7 DSI: Tx FIFO Flush Is Not Supported
Cortex A-9	TI	OMAP4430	In case of destination synchronized transfer on the write port (or source sync with SDMA.DMA4_CCRi[25] BUFFERING_DISABLE = 1), if a transaction error is reported at the last element of the transaction, the channel is not automatically disabled by DMA.	Whenever a transaction error is detected on a transaction on the write side of the channel i, software must disable the channel(i) by setting the DMA4_CCRi[7] ENABLE bit to 0.	1.8 sDMA Channel Is Not Disabled After A Transaction Error
Cortex A-9	TI	OMAP4430	The first packet in command mode is not sent due to inaccurate clock gating. Root cause description: In command mode when DDR_CLK_ALWAYS_ON and IF_EN are set to 1, DDR clock is not present immediately after the IF_EN bit is set to 1 but when the first HS packet from OCP is ready to be sent to PPI HS link. The DDR_CLK_PRE field is used between the start of the DDR clock and the assertion of the data request signal. After the time defined by the DDR_CLK_PRE field, the clock lane is always present until the IF_EN bit is set to 0. So, there is a delay between IF_EN set to 1 and assertion of the clock lane.	In case of command mode where DDR clock should be provided to peripheral before data, the workaround is to program DDR_CLK_PRE =! 0. The value of DDR_CLK_PRE must take into account the different timings: TCLK_PREPARE, TCLK_ZERO. Sequence to enable the DSI: 1. Set the ForceTxStopMode bit to 1 (DSI_TIMING1 register). This asserts the ForceTxStopMode. 2. Enable virtual channel in command mode / Enable DSI interface. 3. Poll the ForceTxStopMode bit to 0 (DSI_TIMING1 register) until deassertion of the ForceTxStopMode bit. The hardware resets this bit at the end of the counter value. 4. Send SOF(0x00000000) packet in command mode.	1.9 DSI SOF Packet Not Send
Cortex A-9	TI	OMAP4430	SIMCOP LDC module doesn't reach 100 MPix/s target in bilinear mode for YUV420 data.	Use LDC in YUV422 mode.	1.10 SIMCOP Lens Distortion Correction issue
Cortex A-9	TI	OMAP4430	The SOFTRESET bit of the SYSCONFIG register inside CBUFF (CBUFF_HL_SYSCONFIG[0] SOFTRESET) is set to 0x0 (reset done state) after reset only if CBUFF is out of IDLE. While CBUFF slave data port is in IDLE, the SOFTRESET bit is always set to 0x1 (status bit gives an ongoing reset, but reset is finished).	Ignore status of the the SOFTRESET bit. After a software reset, wait a few cycles before using the module.	1.11 ISS: SOFTRESET Bit Status Not Working For Circular Buffer
Cortex A-9	TI	OMAP4430	The SOFTRESET bit of the SYSCONFIG register inside BTE (BTE_HL_SYSCONFIG[0] SOFTRESET) is set to 0x0 (reset done state) after reset only if BTE is out of IDLE. While BTE slave data port is in IDLE, the SOFTRESET bit is always set to 0x1 (status bit gives an ongoing reset, but reset is finished).	Ignore the status of the SOFTRESET bit. After a software reset, wait a few cycles before using the module.	1.12 ISS: SOFTRESET Bit Status Not Working For Burst Translation Engine
Cortex A-9	TI	OMAP4430	Debug read operations should not impact the internal state of the module. That cannot be guaranteed because debug reads of some locations can impact DMA requests. Also, some read accesses may be stalled for a long time while ISP operation is ongoing.	To avoid read access from being stalled, the CPU must have the priority. This can be configured in the ISP5_MPSR register. Dummy accesses during frame processing lead to data corruption however response is given immediately. This register can be used to avoid stalling debug accesses. Dummy data is returned in that case but does not hurt functionality because debug accesses do not make sense while ISP5 is processing data.	1.13 ISS State Can Be Corrupted During Debug Mode
Cortex A-9	TI	OMAP4430	DSI engine is not always detecting the first VSYNC HSYNC signals received on the video port in video mode.	Because before first VSYNC rising edge, one HSYNC is transmitted and clock is transmitted during that HSYNC period, the workaround is to have the HSYNC period of DISPC longer than the timing described below: • Configuration with line buffers: 3 VP_PCLK + 6 VP_CLK + 6 DSI_CLK • Configuration without line buffers: 3 VP_PCLK + 2 VP_CLK There is no need to take care of some timings related to enabling the IF_EN, VC_EN, LCD output of the DSIPC.	1.14 DSI VSYNC HSYNC Detection In Video Mode
Cortex A-9	TI	OMAP4430	When two video ports are available at the input of the DSI protocol engine, the two streams are interleaved by the DSI protocol engine. Only one video mode is supported by the current implementation on VP1 only. VP2 cannot be in video mode even if VP1 is not in video mode.	No	1.15 Dual Video Mode
Cortex A-9	TI	OMAP4430	The buffer handshake feature in the DISPC avoids underflow of the DISPC DMA FIFO. The fullness of the DISPC DMA FIFO is checked before providing data to the pipeline when STALL signal is inactive. When the FIFO hand check feature is activated, the pixel transfer to the DSI module during STALL inactivity period can be stopped (no DISPC_PCLK pulse) and restarted when there is enough data in the FIFO. The DSI protocol engine is configured in command mode. On video port 1 in command mode, when DISPC_DIVISOR1.PCD = 2, DISPC_CONFIG1.BUFFERHANDCHECK = 1 and DSI_CTRL.VP_CLK_RATIO = 0, the FRAMEDONE IRQ might not be triggered and TE_SIZE counter might not be decremented to 0. This is caused by a deadlock between the DISPC and DSI modules during the transfer of the last pixel of a line On video port 2 in command mode, when DISPC_DIVISOR2.PCD = 2, DISPC_CONFIG2.BUFFERHANDCHECK = 1 and DSI_CTRL2.VP_CLK_RATIO = 0, the FRAMEDONE IRQ might not be triggered and TE_SIZE counter might not be decremented to 0. This is caused by a deadlock between the DISPC and DSI modules during the transfer of the last pixel of a line. The DSI protocol engine sends a STALL to the DISPC (stall mode); in parallel the DISPC stops the pixel clock to the DSI because it is waiting for its FIFO DMA to be refilled (buffer handcheck feature). When FIFO DMA is refilled, the DISPC being in stall mode does not provide back the pixel clock to the DSI to deassert the stall and it does not send the last pixel to the DSI.	DISPC_DIVISORi[7:0] PCD = 2 is not supported, where i = 1 to 3. DISPC should be set to DISPC_DIVISORi[7:0] PCD = 3 or above and DSI_CTRLi[4] VP_CLK_RATIO to 0x1.	1.16 Deadlock Between DISPC And DSI When PCD = 2, VP_CLK_RATIO = 0
Cortex A-9	TI	OMAP4430	In SCCB mode if the XRDY/RRDY are not served during address phase, the module starts to hold the bus by keeping SCL low (FIFO empty or full). Then, after serving these interrupts, the module does not continue the current transfer and blocks in this state. This bug appears only in applications where the module is used in SCCB mode. The bug does not appear at all if interrupts are served before the address phase starts (quickly enough to avoid entering this context).	None.	1.17 I2C: In SCCB Mode, Under Specific Conditions, The Module Might Hold The Bus By Keeping SCL Low.
Cortex A-9	TI	OMAP4430	Expected behavior: Before starting a new transfer from another I2C device, 1 byte of data is written to TX FIFO. The module is addressed on a 10-bit address as a slave transmitter (one of his addresses) and I2C clock blocking is enabled. After a repeated start condition, SBLOCK is activated again for the second part of the address. Observed behavior: Given the addressing and SBLOCK conditions defined above, if the data put in FIFO has its MSB 0, the module makes a glitch on SDA bus on the eighth bit (SDA is set to 0 for a short period) which can be interpreted as an illegal start/stop condition.	The scenario described is a corner case. It may very seldom happen in applications. To avoid the situation, before a transfer is started on the I2C bus, all interrupts should have been cleared, or when I2C is a transmitter, no data should be placed in the FIFO, without receiving the request to do so from the slave.	1.18 I2C: Wrong Behavior When A Data With MSB 0 Is Put In The FIFO Before A Transfer With SBLOCK Is Started
Cortex A-9	TI	OMAP4430	Expected behavior: After a transfer on the I2C bus, where the module lost the arbitration during the address phase, a new transfer as a master is programmed in I2C_CON by setting the MST bit to 1, having the start bit STT in the I2C_CON register still unset. The STT bit can be set after a significant delay, to point the moment in which the transfer starts on the I2C bus. The module should only start the transfer on I2C after setting this STT start bit in I2C_CON. Observed behavior: The module starts the transfer on I2C before setting STT, immediately after setting the MST bit in the I2C_CON to 1.	The MST and STT bits inside I2C_CON should be set to 1 at the same moment (avoid setting the MST bit to 1 while STT = 0).	1.19 I2C: After An Arbitration Is Lost, The Module Starts Incorrectly The Next Transfer Incorrectly
Cortex A-9	TI	OMAP4430	When coming out of off mode, the memory controllers assume connected SDRAMs to be in self-refresh mode. The EMIF receives a DEVICE_OFFWKUP_CORERSTACTST signal from the PRCM defining if an EMIF cold reset was due to a global reset or to exiting off mode; • In case of a global cold reset, the full SDRAM init phase is performed. • In case of off mode exit, only the self-refresh exit sequence is performed and auto-refresh commands are immediately sent. If the memory was in deep power-down state during the chip off mode, the sequence performed by EMIF could result in an unexpected behavior on the memory side. Exit from DPD actually requires the same full init sequence as after a global cold reset.	Software workaround: • Before getting into off mode, force the value stored in the control module EMIF_SDRAM_REF_CTRL.REG_INITREF_DIS to 1. – This forces the value for the EMIF register to 1 when its content is restored when returning from off mode. • When returning from off mode, and before making any access to the memory in DPD state: 1. Put CORE PLL in MN bypass mode CM_CLKMODE_DPLL_CORE.DPLL_EN = 0x4. 2. Program the DLL override CM_DLL_CTRL.DLL_OVERRIDE = 1. 3. Force the configuration field EMIF_SDRAM_CONFIG.REG_SDRAM_TYPE register to 0x1 (reserved), then back to 0x4 (LPDDR2-S4) or 0x5 (LPDDR2-S2) according to memory configuration. This forces the controller back into its init state instead of self-refresh state. 4. Reconfigure EMIF_SDRAM_REF_CTRL.REG_INITREF_DIS to 0. 5. Perform normal init phase as from global cold reset.	1.20 Deep Power-Down Support During Off Mode
Cortex A-9	TI	OMAP4430	RTA (retention till access) feature is not supported and leads to device stability issues when enabled. The following modules are embedding memories with RTA support: • MPU subsystem (cache memories) • OCM RAM • SGX • Display subsystem • HS USB OTG • IVA-HD subsystem • Face detect • Imaging subsystem • DMM • DSP subsystem • AESS	PRM_LDO_SRAM_<Memory Voltage Domain>_SETUP[0] DISABLE_RTA_EXPORT default value is loaded by an eFuse value. Before ES2.1, this value enabled by default this RTA feature so these bits must be set to 0x1 as soon as the device is booted for correct operation. RTA should be disabled at boot time then consistently kept disabled. Starting with ES2.1 the fuse value disables this RTA feature, so these bits must be kept at default value.	1.21 RTA Feature Is Not Supported
Cortex A-9	TI	OMAP4430	If a wakeup from I/O daisy-chain is triggered in a short time window of the off mode transition, the device does not wake-up correctly and stays locked.	No	1.22 I/O Daisy Wakeup During Device Off Mode Transition Stalls the Device Power Transition
Cortex A-9	TI	OMAP4430	In OMAP4 off mode (VDD_CORE=0V, VDD_WKUP=0.83V) VDD_WKUP power consumption exceeds estimation budget by approximately 100 µA. This is an isolation cell issue, which creates a leakage path from VDD_WKUP to VDD_CORE.	No	1.23 Off Mode Power Consumption On VDD_WKUP
Cortex A-9	TI	OMAP4430	Hardware does not recycle the I/O wake-up clock upon a global warm reset. When a warm reset is done, wakeups of daisy I/Os are disabled, but without the wake-up clock running, this change is not latched. Hence there is a possibility of seeing unexpected I/O wake-up events after warm reset.	Software must set bit WUCLK_CTRL in PRCM register PRM_IO_PMCTRL and it must poll on bit WUCLK_STATUS to become 1. After this WUCLK_CTRL bit can be set back to 0 to enable/disable the wakeup feature for each pad.	1.24 Wkup Clk Recycling Needed After Warm Reset
Cortex A-9	TI	OMAP4430	DMM is assigned an address range of 2GB in the system address map. Internal registers (DMM_LISA_MAP_i) are used to program sections which define which part of the 2GB is actually mapped to external memories. A mapped access is a request to an address which hits at least one DMM section. An unmapped access is a request to an address which does not hit any DMM section; DMM replies with an OCP error response in that case. DMM can generate unmapped access at the end of a mapped section. A hang occurs if an unmapped access is issued after a mapped access.	Define LISA section to have response error when unmapped addresses. Define LISA section in such a way that all transactions reach the EMIF, which will return an error response.	1.25 DMM Hang Issue During Unmapped Accesses
Cortex A-9	TI	OMAP4430	Due to timing issue, the HSIC interface of the HS USB Host is not functional. The issue does not impact ULPI and TLL interfaces.	None	1.26 HS USB Host HSIC Not Functional
Cortex A-9	TI	OMAP4430	OMAP4430 will not boot in SYS_BOOT configurations involving USB or MMC1 due to negative glitches generated on I2C1 SCL and SDA lines after reset (nRESPWRON) deassertion. This can be interpreted by a START command of the I2C protocol and Phoenix power management IC does not respond correctly to second and subsequent requests. The lack of response to the first request blocks the boot of OMAP. Because I2C2/3/4 are impacted as well, side-effects on devices connected to those buses are possible. This issue is caused by two things: • Slew on the HHV internal signal of I/O which is too high. The HHV controls the state of I/O while power on reset is active. • After reset release, I2C internal pullup is not activated (corrected since ES2.2). Glitches duration is dependant on process, voltage, temperature conditions as well as the value of external pull-up resistors and can be higher than 50 ns with default OMAP pullup resistors.	For proper boot up of OMAP, customers must ensure that the size of glitches on I2C1 SCL/SDA are less than the 50 ns, because it will be filtered in Phoenix Power management IC. Board pullup resistors on SCL/SDA lines must be adjusted to respect this timing. They must be calculated in respect of system parameters (I2C1 bus loading, strength of pullup of devices connected to the I2C bus) The external pullup resistor value recommendation to fix the issue in most of the board configuration is: • ES2.1: 5KOhm for a 10-pF load, 1KOhm for a 50-pF load, 450Ohm for a 100-pF load, and 125Ohm for 400-pF load. • ES2.2: See table below. Table 1-1. External Pullup Resistor for ES2.2 I2C1 Glitch<50ns Glitch<100ns Glitch<150ns Glitch<200ns Glitch w/o external PU resistenace (ns) 10 pf None None None None 40 50 pf 870 4500 None None 107 100 pf 520 1300 2800 None 190 400 pf 200 525 870 1100 375 I2C2 10 pf Unacheivable 1000 1300 2000 220 50 pf Unacheivable 670 1000 1300 600 100 pf Unacheivable 520 670 1000 1100 400 pf Unacheivable 200 250 300 4800 I2C3 and I2C4 10 pf 1500 2000 2500 None 168 50 pf 670 1500 2000 2500 600 100 pf 400 670 1000 1500 1100 46 Bugs SWPZ009Q – October 2010 – Revised September 2013 Copyright © 2010–2013, Texas Instruments Incorporated Public Version www.ti.com I2C SCL and SDA Glitch At Reset Release Table 1-1. External Pullup Resistor for ES2.2 (continued) I2C1 400 pf 150 250 520 670 370 Unacheivable = Glitch can not be reduced to < 50 ns Redfont = The total resistance on the I2C line is < 420 ohms which is not allowed by the I2C spec.	1.27 I2C SCL and SDA Glitch At Reset Release
Cortex A-9	TI	OMAP4430	In OMAP4, for each switchable voltage domain, two registers are specified: • PRM_VOLTSETUP_<VD name>_OFF • PRM_VOLTSETUP_<VD name>_RET_SLEEP The first register specifies voltage ramp-up from OFF mode to ON mode, and ramp-down times from non-ON mode to OFF mode of the external regulator. The second register specifies voltage ramp-up from RET or SLEEP mode to ON mode, and ramp-down from ON mode to RET or SLEEP mode times of the external regulator. Times are specified in terms of system clock cycles through a prescaler (RAMP_* _PRESCAL) and count (RAMP_*_COUNT) values. In RTL, prescaler of SLEEP-RET transition is always decoded like for OFF transition making granularity on ramp-up/down times a little bigger. Because ramp-up/down times are of the order of tens of u-seconds, impact on PRCM functionality is minor. Prescaler is specified over 2 bits, its decoding is: OFF transition: • 0x0: Ramp-up/down counter is incremented every 64 system clock cycles • 0x1: Ramp-up/down counter is incremented every 256 system clock cycles • 0x2: Ramp-up/down counter is incremented every 512 system clock cycles • 0x3: Ramp-up/down counter is incremented every 2048 system clock cycles SLEEP-RET transitions: • 0x0: Ramp-down counter is incremented every 64 system clock cycles • 0x1: Ramp-down counter is incremented every 256 system clock cycles • 0x2: Ramp-down counter is incremented every 512 system clock cycles • 0x3: Ramp-down counter is incremented every 2048 system clock cycles	None	1.28 Retention/Sleep Voltage Transitions Ramp Time
Cortex A-9	TI	OMAP4430	When coming back from device off mode, the Cortex-A9 WUGEN enable registers are not restored by ROM code. The reset values are used instead. This leads to increased/unexpected CPU1 wakeups and can prevent MPU low-power transitions.	Device OFF mode cannot be used in GP device. The user can transition to the use of non-GP devices to avoid this issue and to use off mode in the system. The user can use a GP device but use an alternative power state (instead of off mode) which maintains the proper register settings.	1.29 Interrupt Enable Registers Not Restored
Cortex A-9	TI	OMAP4430	Due to design issue MMCHS_HCTL.HSPE bit does not work as intended. This means that the configuration must always be the normal speed mode configuration (MMCHS_HCTL.HSPE=0).	None	1.30 MMCHS_HCTL.HSPE Is Not Functional
Cortex A-9	TI	OMAP4430	During OMAP4430 platform power up, the power-on reset input signal for OMAP4430 is mistakenly driven by itself. It can cause some unexpected level on OMAP output pins which are supposed to stay in their default voltage value. Board can so fail to boot because: • It is impossible to ensure correct operation of the I/Os used to control external ICs involved in board power management (supply power path, battery charger circuits, etc). • Inrush current during power supply ramp can be higher than expected and can cause the battery voltage to drop down. Details: OMAP4430 SYS_NRESPWRON is the power-on reset input. TWL6030 PMIC drives this signal low until all voltages are ramped and the 32-kHz clock is running. OMAP SYS_NRESPWRON uses bidirectional I/O cell with its output driver disabled by default. Between VDDS and VDDS_1P2 I/O power rails ramp, OMAP SYS_NRESPWRON is driven high by the output buffer in its I/O cell. This creates a conflict with TWL6030 driving low and can create an intermediate voltage. Depending on TWL6030 and OMAP silicon, this voltage can be high enough to be interpreted as a '1' by OMAP input buffer. Internally, SYS_NRESPWRON is used to control reset of all OMAP I/Os. Therefore, OMAP CMOS I/Os are mistakenly controlled and are potentially driven at any interim voltage level. The consequence is high-power consumption on the VDDS power supply.	As a hardware workaround, some components must be placed on board to ensure the voltage at OMAP4430 SYS_NRESPWRON is kept below 0.5V while TWL6030 is driving low state. One example is shown in following schematic. SWPZ009Q – October 2010 – Revised September 2013 Bugs 51 Copyright © 2010–2013, Texas Instruments Incorporated Public Version NRESPWRON Pin Issue While Supplies are Ramping www.ti.com Figure 1-1. Buffer Implementation VIO_1V8 100kΩ 10kΩ OMAP4430 SYS_NRESPWRON RDSon<10Ω TWL6030 NRESPWRON	1.31 NRESPWRON Pin Issue While Supplies are Ramping
Cortex A-9	TI	OMAP4430	Some OMAP4430 I/Os can glitch at SYS_NRESPWRON reset release. This can affect platform behavior at boot. This issue is caused by the slew on the HHV internal signal which is too high. The HHV controls the state of I/O while power-on reset is active. Duration of the glitches depends on process, voltage, temperature conditions. In worst case conditions, glitch duration can be as high as: • For I2c1/2/3/4 see specific errata I622 • For other I/Os: Pins impacted are listed below as glitch size (worst case) versus external load. Table 1-2. IOs glitch size OMAP ball pad state after glitch @ 5 pf glitch @ 10 pf glitch @ 25 pf glitch @ 50 pf reset gpmc_ad0 I 95ns 128ns 124ns No glitch gpmc_ad1 I 95ns 128ns 124ns No glitch gpmc_ad10 I 95ns 128ns 124ns No glitch gpmc_ad11 I 95ns 128ns 124ns No glitch gpmc_ad2 I 95ns 128ns 124ns No glitch gpmc_ad3 I 95ns 128ns 124ns No glitch gpmc_ad4 I 95ns 128ns 124ns No glitch gpmc_ad5 I 95ns 128ns 124ns No glitch gpmc_ad6 I 95ns 128ns 124ns No glitch gpmc_ad7 I 95ns 128ns 124ns No glitch gpmc_ad8 I 95ns 128ns 124ns No glitch gpmc_ad9 I 95ns 128ns 124ns No glitch gpmc_ncs1 I 95ns 128ns 124ns No glitch gpmc_ncs2 I 95ns 128ns 124ns No glitch gpmc_ncs3 I 95ns 128ns 124ns No glitch gpmc_wait1 I 95ns 128ns 124ns No glitch dpm_emu0 I 40ns 20ns 5ns No glitch dpm_emu1 I 40ns 20ns 5ns No glitch usbb2_ulpitll_dat0 I 13ns No glitch No glitch No glitch usbb2_ulpitll_dat1 I 13ns No glitch No glitch No glitch usbb2_ulpitll_dat2 I 13ns No glitch No glitch No glitch usbb2_ulpitll_dat3 I 13ns No glitch No glitch No glitch usbb2_ulpitll_dat4 I 13ns No glitch No glitch No glitch usbb2_ulpitll_dat5 I 13ns No glitch No glitch No glitch usbb2_ulpitll_dat6 I 13ns No glitch No glitch No glitch usbb2_ulpitll_dat7 I 13ns No glitch No glitch No glitch usbb2_ulpitll_dir I 13ns No glitch No glitch No glitch usbb2_ulpitll_nxt I 13ns No glitch No glitch No glitch usbb2_ulpitll_stp I 13ns No glitch No glitch No glitch gpmc_ncs0 O 1ns 1ns 0.8ns No glitch gpmc_noe O 1ns 1ns 0.8ns No glitch SWPZ009Q – October 2010 – Revised September 2013 Bugs 53 Copyright © 2010–2013, Texas Instruments Incorporated Public Version I/O Glitch At Reset Release www.ti.com Table 1-2. IOs glitch size (continued) OMAP ball pad state after glitch @ 5 pf glitch @ 10 pf glitch @ 25 pf glitch @ 50 pf reset gpmc_nwe O 1ns 1ns 0.8ns No glitch	Customer must ensure that glitch on those pins cannot affect system behavior, or place appropriate pull on the board to minimize glitch to an acceptable value.	1.32 I/O Glitch At Reset Release
Cortex A-9	TI	OMAP4430	Due to highest MPU priority in the system (that is, ELLA port), SDRAM accesses may be significantly slowed down or completely stalled during heavy MPU accesses. Nonreal-time initiators are slowed down. Heavy MPU accesses are expected to be occasional and of short duration but long enough to cause real-time initiator failure.	None	1.33 SDRAM Access During Heavy MPU Accesses
Cortex A-9	TI	OMAP4430	When in YUV4:2:0 format in 1D burst, the DISPC DMA skips lines when fetching Chroma sampling.	If YUV4:2:0-1D burst is required: • For ES1.0: Set DISPC_VIDp_ATTRIBUTES[22]DOUBLESTRIDE to 0x0. • For ES2.x: Set DISPC_VIDp_ATTRIBUTES[22]DOUBLESTRIDE to 0x0 and DISPC_VIDp_ATTRIBUTES[13:12]ROTATION to 0x1 or 0x3	1.34 Wrong Access In 1D Burst For YUV4:2:0-NV12 Format
Cortex A-9	TI	OMAP4430	Within the restore sequence used during auto-restore process after off mode, EMIF_SDRAM_CONFIG is restored first. Because EMIF_SDRAM_CONFIG_2 is not yet restored, the register configuration setting is not done properly, therefore it is no longer possible to use memory on the second chip-select.	To avoid this issue, the EMIF_SDRAM_CONFIG_2 must be reset correctly before the restore sequence. This can be done by programming CONTROL_WKUP_PROT_EMIF*_SDRAM_CONFIG2_REG, which is retained during off mode and use to initialize EMIF_SDRAM_CONFIG_2 during the reset. Before going to off mode, bit 30 of the following two registers has to be set to 0: • CONTROL_WKUP_PROT_EMIF1_SDRAM_CONFIG2_REG (0x4A30 C114) • CONTROL_WKUP_PROT_EMIF2_SDRAM_CONFIG2_REG (0x4A30 C11C)	1.35 LPDDR2 Corruption After OFF Mode Transition When CS1 Is Used On EMIF
Cortex A-9	TI	OMAP4430	The HDQ_CTRL_STATUS.PRESENCEDETECT bit is reset only by a software or hardware reset of the whole HDQ/1-Wire module and nothing else. In particular, after a first presence was detected, any subsequent initialization pulses will: • Generate a time-out interrupt and the PRESENCEDETECT bit will be set to '1' if the slave responded (this is the expected behavior). • Never generate a time-out interrupt if the slave did not respond. This is rather unexpected.	Do a software reset of the HDQ/1-Wire module prior to generating any initialization pulse (1-Wire mode). Software reset (from TRM section HDQ/1-Wire Module Global Initialization): • Initiate software reset. Set HDQ_SYSCONFIG[bit1] (SOFTRESET=0x1) • Disable power-down mode. Set HDQ_CTRL_STATUS[bit5] (CLOCKENABLE=0x1). • Wait until reset complete. Wait until HDQ_SYSSTATUS[bit0] is set (RESETDONE=0x1).	1.36 Time-out Interrupt May Never Come When Device Is Not Detected (1-Wire Mode)
Cortex A-9	TI	OMAP4430	For any pad of OMAP, • when the system is ON, the pullup/down configuration depends on the following: – CONTROL_PADCONF:PULLTYPESELECT – CONTROL_PADCONF:PULLUDENABLE. • When the system goes to off mode, and when CONTROL_PADCONF:OFFMODEENABLE is set, the pullup/down capability depends on the following: – CONTROL_PADCONF:OFFMODEPULLTYPESELECT – CONTROL_PADCONF: OFFMODEPULLUDENABLE. So the pullup/down ON configuration is normally overwritten with the OFF configuration when OFFMODEENABLE bit is set and when the system enters off mode. The OFFMODEENABLE bit can be set long before the system enters off mode. In the specific case of all usbb*_hsic pads, the pullup/down OFF configuration will be wrongly taken into account as soon as OFFMODEENABLE bit is set, without waiting for the full system to enter off mode. This issue impacts only the following pads : • usbb1_hsic_data - ball AF14 • usbb1_hsic_strobe - ball AE14 • usbb2_hsic_data - ball AF13 • usbb1_hsic_strobe - ball AE13	There is no workaround. Just take care that the pullup/down configuration will switch to the OFF configuration as soon as OFFMODEENABLE is set. It is also advised to set the same pullup/down configuration in on and off mode, to avoid any glitches or transitions on the signal when the OFFMODEENABLE is set or reset.	1.37 Usbb*_hsic Pads Pullup/Down Control Not Working As Expected
Cortex A-9	TI	OMAP4430	This bug impacts the TLL module when used in conjunction with the EHCI part of the USB host module. Upon resume or remote wakeup from a bus suspended state, the device will switch from full speed to high speed before the host does.This will incorrectly generate a disconnect IRQ on the host side (USBSTS[2]:PCD=1), and the hardware will disable the port.(PORTSC_i[2]:PED=0).The peripheral will then go back to suspend because there is no more activity on the bus. PHY mode (non-TLL) is not impacted. OHCI is not impacted.	The workaround consists of stalling the device for some time so that the host can switch to HS before the device. Because of the conception of this workaround, the workaround for i464 also needs to be applied on top of it. (even if i464 itself is not applicable) As a consequence, the programming guide to follow when performing the suspend resume sequence will be: If using WA1 from i464: 1. Read FRINDEX register. 2. Keep polling FRINDEX register to make sure that the register value has incremented from the value read in Step (1). 3. Set the PORTSC_i[7].SUS bit. 4. Wait for the required suspend time. 5. When software is ready to issue resume, Read FRINDEX register. 6. Keep polling FRINDEX register to make sure that the register value has incremented from the value read in Step (5). 7. Set PORTSC_i[6].FPR bit 8. Wait for at least 20ms (as specified by the USB 2.0 Spec). 9. Read FRINDEX register. 10. Keep polling FRINDEX register to make sure that the register value has incremented from the value read in Step (9). 11. Clear PORTSC_i[6].FPR bit. 12. Gate the TLL ULPI clock and thereby the device controller by PRCM control: the whole TLL is frozen, including the ULPI clock - Clear the appropriate OPTFCLKEN_USB_CHx_CLK bit in the CM_L3INIT_HSUSBTLL_CLKCTRL register 13. Wait 3 us for the host to go to HS. 14. Restart the TLL ULPI clock and the device controller by PRCM control, to unfreeze the entire TLL, including the ULPI clock - Set back the appropriate OPTFCLKEN_USB_CHx_CLK bit in the CM_L3INIT_HSUSBTLL_CLKCTRL register 15. Set the USBCMD[0].RS bit to 1. If using WA2 from i464: 1. Set the PORTSC_i[7].SUS bit. 2. Wait for the required suspend time. 60 Bugs SWPZ009Q – October 2010 – Revised September 2013 Copyright © 2010–2013, Texas Instruments Incorporated Public Version www.ti.com USB HOST EHCI In TLL Mode Will See The Port Being Disabled Upon Resume Or Remote Wakeup. 3. When software is ready to issue resume, set PORTSC_i[6].FPR bit. 4. Wait for at least 20ms (as specified by the USB 2.0 Spec). 5. Clear the USBCMD[0].RS bit to 0. 6. Wait until USBSTS[12].HCH is set to 1 by HW 7. Clear PORTSC_i[6].FPR bit. 8. Gate the TLL ULPI clock and thereby the device controller by PRCM control: the whole TLL is frozen, including the ULPI clock - Clear the appropriate OPTFCLKEN_USB_CHx_CLK bit in the CM_L3INIT_HSUSBTLL_CLKCTRL register 9. Wait 3 us for the host to go to HS. 10. Restart the TLL ULPI clock and the device controller by PRCM control, to unfreeze the entire TLL, including the ULPI clock - Set back the appropriate OPTFCLKEN_USB_CHx_CLK bit in the CM_L3INIT_HSUSBTLL_CLKCTRL register 11. Wait for the resume to finish : wait PORTSC_i[6].FPR=0 12. Set the USBCMD[0].RS bit to 1. The programming guide to follow at the end of the resume sequence is: 1. The host ends the resume sequence by clearing PORTSC.FPR bit. 2. The software waits for the TLL to report the LineState change from K to SE0 on ULPI. PORTSC.LS will switch from 0x1(K) to 0x0(SE0). 3. Gate the TLL ULPI clock and thereby the device controller by PRCM control: the whole TLL is frozen, including the ULPI clock - Clear the appropriate OPTFCLKEN_USB_CHx_CLK bit in the CM_L3INIT_HSUSBTLL_CLKCTRL register 4. Wait 3 us for the host to go to HS. 5. Restart the TLL ULPI clock and the device controller by PRCM control, to unfreeze the entire TLL, including the ULPI clock - Set back the appropriate OPTFCLKEN_USB_CHx_CLK bit in the CM_L3INIT_HSUSBTLL_CLKCTRL register 6. The USB device switches to HS.	1.38 USB HOST EHCI In TLL Mode Will See The Port Being Disabled Upon Resume Or Remote Wakeup.
Cortex A-9	TI	OMAP4430	The DSI-PHY has an internal LDO. This LDO is used to convert 1.8V coming from VDDS_DSI input into 1.2V for appropriate DSI voltage level. An internal LDOPWRGOOD signal output by the DSI_PHY indicates the status of the LDO (LDO is up or is down). This signal should be connected to the DSI protocol engine for IRQ reporting (LDO_POWER_GOOD_IRQ). This signal is not connected to the DSI protocol engine and input of protocol engine is tied to 0x0.	There is no workaround to check HW status of DSI LDO. The LDO_POWER_GOOD_IRQ should be disabled by keeping or setting DSI_IRQENABLE.LDO_POWER_GOOD_IRQ_EN to 0x0.	1.39 Status of DSI LDO Is Not Reported to DSI Protocol Engine
Cortex A-9	TI	OMAP4430	When a break frame is sent in the middle of data transfers (DMA based),in pipelined flow or synchronized flow, one Tx data frame will be overwritten at the transmitter side by an all-zeros frame (break is received correctly). Table 1-3. Data Corruption Example Transmitted Data: Received Data: 0x77CFA0B0 0x77CFA0B0 0xDFFC7B49 0x00000000 <- break frame and data last 0x5BE7AD07 0x5BE7AD07 0x7F7F1BC8 0x7F7F1BC8 .... ....	No workaround identified.	1.40 HSI Break Frame Corrupt OnGoing Transfer
Cortex A-9	TI	OMAP4430	The counter configuration capabilities include start (begin counting), stop (halt counting), and load (set time-out period). It is not possible to disable the frame time-out and tailing bit error counters. Setting value 0 in HSR counters (HSR_COUNTERS_Pp[23:20]TB = 0x0 and HSR_COUNTERS_Pp[19:0]FT = 0x0) disables those counters, whereas errors keep being generated with this value. In transient setup phases where TX and RX data rates are still not aligned, false errors may be reported by HSR. Because HSR halts the reception upon an error (until the error is acknowledged) communication will be broken. In such circumstances, inability to disable error detection may be a critical problem.	To disable error reporting: • Set HSR_COUNTERS_Pp[19:0] FT counter to max value (0xFFFFF) • Set HSR_COUNTERS_Pp[23:20] TB error to min value (0x0)	1.41 HSI Error Counters Cannot Be Disabled
Cortex A-9	TI	OMAP4430	When transferring a data on McPDM uplink path, if the McPDM uplink path is reset by MCPDM_CTRL.SW_UP_RST, uplink FIFO is correctly reset but the dma pending signal is kept asserted. This can result in an invalid access by the host DMA to uplink FIFO. The same applies to DMIC if reset by DMIC_CTRL.SW_DMIC_RST.	Follow the programming model below to disable and enable the channels: • Disable the channels: – Set the MCPDM_CTRL.SW_xx_RST bit to 1. – Disable all channels. – Set the MCPDM_CTRL.SW_xx_RST bit to 0. • Enable the channels: – Set the MCPDM_CTRL.SW_xx_RST bit to 1 – Enable necessary channels. – Set the MCPDM_CTRL.SW_xx_RST bit to 0. Note: SW_xx_RST is either MCPDM_CTRL_SW_UP_RST, CPDM_CTRL_SW_DN_RST, or DMIC_CTRL.SW_DMIC_RST.	1.42 McPDM/DMIC Issue With Software Reset With SW_xx_RST
Cortex A-9	TI	OMAP4430	The CM1 and CM2 OCP interface can hang if warm reset occurs while accessing to CM1 CM2 registers. Data abort will be generated.	None	1.43 CM1 And CM2 OCP Interface Hangs
Cortex A-9	TI	OMAP4430	UART TX with a DMA THRESHOLD default configuration of 64 bytes would result in extra DMA Req assertion when FIFO tx_full is switched from high to low. This is because of the TX THRESHOLD added in ES2.0 compared to ES1.0.	Use TX_THRESHOLD+TRIGGER_LEVEL <= 63 (TX FIFO Size - 1).	1.44 UART: Extra Assertion of UARTi_DMA_TX Request
Cortex A-9	TI	OMAP4430	Software initiated read/write accesses to the PHY ULPI registers (that is, when using USB OTG ULPIReg registers) may be wrongly mixed up with USB OTG Tx traffic. Due to this corruption the USB OTG will detect a Vbus error or a Babble error (logged in IntrUSB register), and halts the communication. Hardware initiated accesses to the PHY ULPI registers are not impacted because they occur during connect, disconnect, suspend, and resume, when there is no USB traffic. Only software initiated accesses are impacted, and only when there is on-going USB Tx transfers.(including SOF in host mode) Software initiated accesses during connect, disconnect, suspend, and resume are not impacted. Host and peripheral modes are impacted.	If possible do not use software initiated reads/writes to access the PHY ULPI registers. Depending on the PHY, there may be a possibility to access these registers by I2C. If the USB OTG is host, another workaround consist in putting the bus in suspend mode with low- power mode disabled when willing to read/write an ULPI PHY register: • Disable PHY low-power mode (Power:EnableSuspendM=0) • Execute USB SUSPEND. • Do the ULPI register read/write • Execute USB RESUME • Restore Power:EnableSuspendM. If the USB OTG is peripheral, another workaround consists in using the 1-2us time frame after reception of SOF, before any transfer begins on the bus: • Enable the SOF interrupt • Program the ULPIReg registers except the ULPIRegControl:D0 bit • When the SOF interrupt fires, set the ULPIRegControl:D0 bit to make the access • Disable the SOF interrupt	1.45 USB OTG Software Initiated ULPI Accesses To PHY Registers Can Halt the Bus
Cortex A-9	TI	OMAP4430	The prefetch error event (PREFETCH_ERROR) is triggered when the gain table is read too slowly from SDRAM. When this event is pending the module should go into transparent mode, meaning LSC should copy input pixels to output pixels (output=input). Actually, when the prefetch error event occurs the LSC module outputs black pixels.	None	1.46 ISS-SIMCOP: ISS-LSC Not Transparent After Prefetch Error Event
Cortex A-9	TI	OMAP4430	When configuring Phoenix for USB or MMC boot, values are hard-coded in Phoenix registers, overwriting previous values. Custom values are lost. Impacted registers are: • VmmcCfgVoltage • PhoenixSeqReg • VbusCfgVoltage • Misc2	Re-write custom values after boot.	1.47 Phoenix Registers Value Are Lost
Cortex A-9	TI	OMAP4430	In the SYSBOOT table, MMC1 is considered as a permanent device only when there is no other permanent device in the list (NOR, NAND, OneNAND), else it is a non-permanent device (booting on MMC1 is bypassed after warm reset). This impacted SYSBOOT configurations 10110, 10111 and 11001. But the way it is implemented in the ROM Code is that MMC1 is always a permanent device. After warm reset, if MMC1 is on the device list selected by SYSBOOT pins, the ROM Code will try to boot on it even if it is marked as non-permanent device.	A SW Booting configuration can be used so that MMC1 is bypassed after the next warm resets.	1.48 MMC1 Is Wrongly Marked As Permanent Device
Cortex A-9	TI	OMAP4430	Bit 7 from Tracing Vector 1 (GP header (non-XIP) found) is wrongly set for XIP Memory Booting. This may be misleading when debugging while using the trace information (at 0x4030D040).	None.	1.49 Bit 7 from Tracing Vector 1 Is Wrongly Set For XIP Memory Booting
Cortex A-9	TI	OMAP4430	When booting with alternate muxing (Mux5) on MMC2 port (e.g. SYSBOOT=111100), wrong pads are configured by ROM code. It has no direct impact on the ROM Code functionality because the relevant pads are properly configured. However, a few pads are changed into an unexpected/unnecessary configuration. Namely, the pads sys_32k and sys_nrespwon are enabled with an internal pull up.	Possible SW workaround: if ever it represents a system issue, the pads may be reverted back to their reset value in the initial software.	1.50 Incorrect Pad Muxing in MMC2 Boot Mode
Cortex A-9	TI	OMAP4430	When an RX wake-up mechanism is used for the UART module, the first character received can be lost.	This is a known behavior and is dependant on the speed of response of the PRCM module to a wakeup. The CTS wake-up mechanism should be preferred when it is possible.	1.51 UART: In an RX Wake-up Mechanism, the First Received Character Can be Lost
Cortex A-9	TI	OMAP4430	The issue occurs during concurrent accesses of CPU0 and CPU1 as described below. If one CPU fetches code from external RAM while the other CPU requires the access to the EMIF firewall (configuring its register REGUPDATE_CONTROL), then both CPUs hang. The issue occurs because when REGUPDATE_CONTROL.BUSY_REQ is activated, the interconnect blocks the accesses. Because the two CPUs of the MPUSS use the same bridge before the L3 interconnect, this bridge is saturated if one CPU is accessing external RAM.	The workaround is to make sure that the other CPU is not doing external accesses through EMIF when a CPU is updating the EMIF firewall. The issue does not occur with the other initiators because they do not share the bridge before the L3 interconnect.	1.52 Platform Hangs When CPU Tries To Configure The EMIF Firewall
Cortex A-9	TI	OMAP4430	Control module provides observability feature on sdma_req64 and sdma_req65. But due to a design issue the behavior of these signals during hardware observability is not correct. There is no impact on the functionality of these DMA requests.	None	1.53 Observability on sdma_req64 and 65 Does Not Have Expected Behavior
Cortex A-9	TI	OMAP4430	If bus keeper mode is used (programmed through CONTROL_LPDDR2IO*_*.LPDDR2IO*_GR*_WD) after leaving open switch retention, it is necessary to reset the DDR PHY. Otherwise the LPDDR2 memory cannot be accessed.	If bus keeper mode is used, issue a PHY reset after leaving OSWR, set bit [10] to 1 at the following address (using read modify write to this register to keep other bits): • Assert PHY reset for EMIF1 @ x 4C00 0060 • Assert PHY reset for EMIF2 @ x 4D00 0060 Because this resets the command line, this reset must be done when memory is in self-refresh mode.	1.54 DDR PHY Must be Reset After Leaving OSWR
Cortex A-9	TI	OMAP4430	There is a timing hold violation on an internal logic on the clock USB TLL path resulting in a systematic connection failure on the TLL link under following conditions: • Using TLL in HS-mode • Using OPP100 TLL failure is sensitive to: • Core voltage: vdd_core increase • I/O voltage: vdds_1p8V decrease • I/O drive strength decrease • Clock trace length increase • OMAP process (strong silicon) • Temperature (-40C).	With the following workaround, there is no more problem with the USB TLL. The two following items must be applied: 1. Use a voltage for VDD_CORE that is inside the range for OPP100 suitable for production: 1.094 - 1.127 - 1.172 V Moreover, use the Vnom for vdds_1p8V as 1.8-V minimum 2. Set the I/O drive strength to 1. Depending which USB host subsystem is used, • Port B1 used: Set CONTROL.CONTROL_SMART2IO_PADCONF_2[11] USBB1_DR0_DS = 0x1 • Port B2 used: Set CONTROL.CONTROL_SMART2IO_PADCONF_2[12] USBB2_DR0_DS = 0x1	1.55 USB TLL Hold Timing Violation
Cortex A-9	TI	OMAP4430	If data is stalled inside an asynchronous bridge because of back pressure, it may be accepted multiple times, thus creating pointer misalignment that corrupts next transfers on that data path until the next reset of the system (no recovery procedure once the issue is hit, the path remains consistently broken). This situation can happen only when the idle is initiated by a master request disconnection (which is trigged by software when executing WFI).	All the initiators connected through async bridge must ensure that data path is properly drained before issuing WFI. This condition is met if one strongly ordered access is performed to the target right before executing the WFI.	1.56 Async Bridge Corruption
Cortex A-9	TI	OMAP4430	When a key is released for a time shorter than the debounce time, in-between 2 key press (KP1 and KP2), the keyboard state machine will go to idle mode and will never detect the key release (after KP1, and also after KP2), and thus will never generate a new IRQ indicating the key release. From the operating system standpoint, only a key press as been detected, and the key will keep on being printed on the screen until another or the same key is pressed again. When the failing state has been reached, the KBD_STATEMACHINE register will show "idle state" and the KBD_FULLCODE register won't be empty, this is the signature of the bug.There is no impact on the power consumption of the system as the state machine goes to IDLE state.	First thing is to program the debounce time correctly: If X (us) is the maximum time of bounces when a key is pressed or released, and Y (us) is the minimum time of a key release that is expected to be detected, then the debounce time should be set to a value in-between X and Y. In case it is still possible to get shorter than debounce time key-release events, then the only solution is to implement a software workaround: Before printing a second character on the screen, the software must check if the keyboard has hit the failing condition (cf signature of the bug above) or if the key is still really pressed and then take the appropriate actions.	1.57 Keyboard Key Up Event Can Be Missed
Cortex A-9	TI	OMAP4430	It is not possible to perform USB transactions with a FS device on port USB_B1/B2. EHCI is able to detect the device, reset it and find that it is a FS device. SW will then hand off the port to OHCI by setting PORTSC[5]:PO (PORT OWNER) bit. OHCI is able to detect the connection, but then cannot communicate with the device. When the PHY switches to FsLsSerialMode, the ULPI DIR signal will go to 1 forever. In HS mode, if DIR is 1, then the ULPI DATA switch to "input only" mode. This input only configuration is wrongly kept after switching to FsLsSerialMode, hence USB transactions cannot occur. Attaching a FS device directly to an OHCI port is working fine.	Only attach FS devices to OHCI ports, or use a HS hub to interface between EHCI ports and LS/FS/HS devices.	1.58 USB HOST - Impossible To Attach a FS Device To An EHCI Port. Handoff To OHCI Is Not Functional
Cortex A-9	TI	OMAP4430	When entering USB suspend mode, the EHCI will automatically ask the PHY to enter low power mode (PHY function control register bit suspendM is reset). The PHY will then cut the ULPI_CLK after a minimum of 5 clock cycles.(no maximum specified). On the other hand, the EHCI embeds a counter counting up to 18 before cutting the internal clock after suspend signal is asserted. Since the PHY cuts the clock prematurely, the counter is not reaching 18. However, the first suspend and resume will work correctly. At the second suspend sequence, since the counter has maintained the value (thanks to retention flops), the counter reaches 18 and cuts the clock internally. As a consequence, the internal state machine does not transition to the correct state causing the next resume to fail. Both host initiated resume and remote wakeup are impacted by this issue.	After setting the suspend bit, switch the internal clock supply from the external ULPI_CLK provided by the PHY to the internal 60 MHz clock. This will allow the internal counter to reach 18. Then after 1ms, switch back to the external ULPI_CLK. This switch can be done thanks to the CM_L3INIT_HSUSBHOST_CLKCTRL[25:24]:CLKSEL_UTMI_P1/2 bits. During the application of the WA, the CM_L3INIT_HSUSBHOST_CLKCTRL[9:8]OPTFCLKEN_UTMI_P1/2_CLK optional clocks need to be enabled.	1.59 USB HOST EHCI - Port Resume Fails On Second Resume Iteration
Cortex A-9	TI	OMAP4430	There is no H/W mechanism preventing violating below I2C Bus clear standard requirement. If the data line (SDA) is stuck LOW, the master should send 9 clock pulses. The device that held the bus LOW should release it sometime within those 9 clocks. If not, then use the HW reset or cycle power to clear the bus. Sys_Warmreset doesn't reset the I2C IP at Phoenix level, it does at IC level. Resetting the IP at Phoenix PMIC would avoid such situation, but this is partial answer as many other I2C slave devices could be addressed during Warm reset without any sensitivity to this sys_warmreset pin. No other reset source possible at Phoenix level to reset the I2C controller (only Cold Reset). So, once the situation is reached, IC is seeing bus busy status bit.	I2C SW handler could be programmed to detect such a locked situation. In this case, it will check the Bus Busy bit and issue the needed clock pulses.	1.60 System I2C hang due to miss of Bus Clear support
Cortex A-9	TI	OMAP4430	There are some fails while suspending then resuming on going HSI communication on both HST and HSR initiatives. If this is the HST initiative: 1. It is possible to suspend then resume communication by disabling then enabling active HST FIFOs through HST_MAPPINGf [0] ENABLE bit. Transmission stops as soon as TX FIFO is disabled (ENABLE bit equal to 0x0) and resumes as soon as TX FIFO is re-enabled (ENABLE bit equal to 0x1). 2. It is not possible to suspend then resume safely by setting HST mode to SLEEP. Writing HST_MODE_Pp[1:0] MODE_VAL = 0x0 (SLEEP) does not have any impact on transmission that continues. If it is the HSR initiative: 1. It is not possible to suspend then resume communication by disabling then enabling active HSR FIFOs through HSR_MAPPINGf [0] ENABLE bit. Disabling the RX FIFO does not stop the transmission (by dropping the READY line). The data keeps being sent by HST and HSR simply discards it. By the way, no RX mapping error is generated. Transmission did not actually stop and frame is lost by HSR. 2. It is not possible to suspend then resume safely by setting HSR mode to SLEEP. Writing HSR_MODE_Pp[1:0] MODE_VAL = 0x0 (SLEEP) stops any ongoing transfer unconditionally which may result in loss of frame(s) once the transfer is resumed.	If this is the HST initiative: It is not possible to configure MODE_VAL bit to SLEEP with active data transfers because it has no impact. The only way to suspend then resuming a HSI communication with HST is to disable then re-enables active TX FIFOs. If this is the HSR initiative: There is no way to suspend then resume the receiver without data loss.	1.61 HSI: Issues In Suspending and Resuming Communication (HSR and HST)
Cortex A-9	TI	OMAP4430	There is a bug in HSI IP;once the SW reset bit is set through the HSI_SYSCONFIG[1] SOFTRESET bit, the SW reset is not propagated well if there is an on-going reception. If the reception never ends (synchronization loss, interrupted transmission from transmitter...), then this is a deadlock, the SW reset is not propagated and there is no OCP access possible.	Use the HW reset from the PRCM instead of the local SW reset.	1.62 HSI: Issue with SW reset
Cortex A-9	TI	OMAP4430	The DMA4 channel generates an unexpected transaction on WR port under the following 2 scenarios : • Scenario 1 1. Software synchronization : Bit fields SYNCHRO_CONTROL and SYNCHRO_CONTROL_UPPER are set to 0 in register DMA4_CCRi Channel element number : Bit field CHANNEL_ELMNT_NBR is set to 0x9 in register DMA4_CENi Channel frame number : Bit field CHANNEL_FRAME_NBR is set to 0x1 in register DMA4_CFNi Element size : Bit field DATA_TYPE is set to 0x2 in register DMA4_CSDPi Destination addressing mode : Bit field DST_AMODE is set to 0x1 in register DMA4_CCRi Destination is packed : Bit field DST_PACKED is set to 0x1 in register DMA4_CSDPi Destination endianism : Bit field DST_ENDIAN is set to 0x0 in register DMA4_CSDPi Destination burst enable : Bit field DST_BURST_EN is set to 0x1 in register DMA4_CSDPi Destination start address : Register DMA4_CDSAi is set to 0xabcd0000 Disable graphics operation : Bit fields CONSTANT_FILL_ENABLE and TRANSPARENT_COPY_ENABLE are set to 0x0 in register DMA4_CCRi The channel has got an ERR response on the WR port before the end of block transfer. The channel has gone for clean abort and got disabled. The same channel has been configured with soft-sync and included in the channel chaining (This channel is not the head of the chain). When this channel gets enabled through the link, the channel is writing the data out as soon as it fetches the data from Read side. It is expected that the channel should go with burst transfer, but it is going for single transfers This results in a performance issue as DMA is executing single transfers instead of burst transfers. This performance issue is also observed while using the channel with destination synchronization and prefetch enabled. 2. Destination sync with Prefetch enabled : Bit field SEL_SRC_DST_SYNC is set to 0x0 ; Bit fields SYNCRO_CONTROL_UPPER and SYNCRO_CONTROL should not be set to 0x0 ; Bit field PREFETCH is set to 0x1 in register DMA4_CCRi The other settings remain same as in use case #a described above • Scenario 2 The channel has got an ERR response on the WR port before the end of block transfer. The channel has gone for clean abort and got disabled. The same channel has been configured with destination-sync with prefetch enabled and included in the channel chaining (This channel is not the head of the chain). When this channel gets enabled through the link, the read port will start its transaction. If the HWR request to this channel comes before the channel gets its first response, the channel will start a WR transaction with byte enable 0. Also, the internal data counters get updated and the corresponding data will never come out of DMA4. The Data FIFO locations are also not recovered. This results in a Data Integrity issue.	There is a software workaround to solve this issue 1. Work around to resolve both Data Integrity and Performance issue : 86 Bugs SWPZ009Q – October 2010 – Revised September 2013 Copyright © 2010–2013, Texas Instruments Incorporated Public Version www.ti.com DMA4 generates unexpected transaction on WR port • Dummy enable-disable for an aborted Channel. i.e. On abort, configure the channel as soft sync with No of frames = 0 and enable the channel by writing 0x1 into the ENABLE bitfield of register DMA4_CCRi. Wait for the Address Misaligment Interrupt. The channel is now ready for reuse. • Ensure that clean drain happens for a channel that is or is to be used as part of a channel chain. i.e. ensure that the abort conditions never occur for this channel • If a channel gets aborted, do not reuse the channel in a chain • Don't use channel chaining 2. Work around to resolve the data integrity only. Disable prefetch in all channels that are part of a channel chain	1.63 DMA4 generates unexpected transaction on WR port
Cortex A-9	TI	OMAP4430	This Bug can occur only in a channel that is part of a channel chain. If channel chaining is not used, this bug is never seen. An exact corner case sequence of events must occur. The sequence is: • The channel is enabled and then aborted*. • This same channel is now configured as part of a channel chain (it should not be the head of the channel chain). • The channel is configured as "software synchronized" or "hardware synchronized at destination with prefetch enabled" • The channel gets enabled through linking. * Following is the subset of abort conditions for this scenario: • The channel is disabled in the middle of transaction and channnel is not a drain candidate. • The channel gets a transaction error on write port but not at the end-of-block transaction. • The channel gets a read transaction error and is not a drain candidate.	The software workaround is to configure DMA4 to be in no-standby or force-standby mode before clearing the PAUSE bit. The DMA4 can be reverted back to smart-standby mode after a certain period (after detecting DMA4_CSR[15:15] of corresponding channel to be 0 or ensuring DMA4_CCR[7:7] bit of corresponding channel to be 0. This ensures descriptor load completion or channel termination.)	1.64 DMA4 channel fails to continue with descriptor load when Pause bit is cleared
Cortex A-9	TI	OMAP4430	There is a silicon bug in HSI IP. The wakeup dependency from HSI towards DSP is by default enabled and the register bit controlling this dependency is read only. There is no option to disable this dependency. As a result when the MPU Wakeup is generated, a false DSP wakeup is also generated. When below scenario happens: 1. Modem interface (HSI is enabled) 2. The system is allowed to suspend 3. When CAWAKE signal has activity, it will wake-up MPU; it also wakes up DSP incorrectly. Consequences of this bug in previous scenario is 4. The DSP is not able to handle this wake up correctly 5. Next suspend, system can't enter in off-mode because DSP remains active	• While in the suspend path: 1. DSP is forced through SW to wake-up: - CM_DSP_CLKSTCTRL [1:0] CLKTRCTRL = 0x2 2. When CAWAKE signal has an activity, it will wake-up MPU and DSP; the DSP domain becomes active 3. Program DSP through SW to transition to low power state: change the HW_AUTO, sleep and wake up are based upon hardware conditions - CM_DSP_CLKSTCTRL [1:0] CLKTRCTRL = 0x3 • This will forcefully clear DSP wakeup-gen and will allow DSP to go idle. • No impact of this workaround on power/performance is seen after doing measurements	1.65 HSI: DSP Swakeup generated is the same than MPU Swakeup. System can't enter in off mode due to the DSP.
Cortex A-9	TI	OMAP4430	The next CBUFF ready window event (IRQ_CTXx_READY) is generated once CPU clears the CBUFF ready (IRQ_CTXx_READY)and after the CPU writes in the current ended window (setting the CBUFF_CTX_CTRL_i [10] DONE bit to 0x1).	The number of CBUFF windows to use in write mode for a given context is two windows.	1.66 CBUFF Ready Window Event in Write Mode
Cortex A-9	TI	OMAP4430	Ongoing transactions may be interrupted when a software reset is performed while there is still active traffic generated by the CSI-2 receiver. Interruption of ongoing transactions typically leads to a general OMAP hang that can only be recovered by a device reset.	Software must ensure that there is no ongoing traffic before performing a software reset. In particular, the CSI-2 receiver must be reset to resume normal operation after a CSI-2 FIFO overflow. There may be remaining data in the FIFO, and therefore ongoing traffic, when the software driver receives the overflow interrupt. To avoid creating a system hang, software must either: • Wait for several 1000s of L3 cycles before performing the software reset after an overflow or • Use the ISS level software reset	1.67 CSI-2 Receiver Executes Software Reset Unconditionally
Cortex A-9	TI	OMAP4430	The TLL bit-stuffing emulation feature (enabled by default after reset in the TLL_CHANNEL_CONF_i[11] ULPINOBITSTUFF bit) is broken. It must be disabled, that is, bit-stuffing must be disabled on all enabled TLL channels. However, disabling bit-stuffing on a TLL channel induces an asymmetry in the number of transmitted bits between the TLL channel and the other ports (ULPI or HSIC), which may result in an underrun or overrun errors. This could be the case while transferring data pattern where bit-stuffing is heavily used, like a white image (full of 11111...).	Disable TLL bit-stuffing on all enabled TLL channels: TLL_CHANNEL_CONF_i[11] ULPINOBITSTUFF = 1 and do not use at the same time one TLL port and one ULPI port or one HSIC port.	1.68 USB Host TLL Bit-stuffing Feature Is Broken
Cortex A-9	TI	OMAP4430	If unexpected VD, Start of frame signal, caused by noise comes before finishing the previous frame statistics, the H3A module hangs.	ISP full reset is necessary to exit from H3A hang state.	1.69 ISP H3A Hangs Due to Unstable Vertical Sync Signal
Cortex A-9	TI	OMAP4430	After the GPIO is configured in smart-idle (or smart-idle with wake-up) and the system goes into MPU inactive mode (idle), the GPIO does not generate any IRQ again if any of the register bits of both interrupt line raw status registers (GPIO_IRQSTATUS_RAW_0 or GPIO_IRQSTATUS_RAW_1) is set. In the case of a GPIO configured in smart-idle wake-up mode (GPIO_SYSCONFIG[4:3]=0x3), the wake-up associated to the GPIO IRQ event will not even occur.	Note: In the below paragraph, 'x' stands for 0 or 1 being the 1st interrupt to be handled, either MPU or DSP, 'y' refers to the other interrupt line. Upon an interrupt reported through GPIO_IRQSTATUS_x, do the following: • Read out GPIO_IRQSTATUS_x => status_value_x • Write status_value_x to GPIO_IRQSTATUS_x (clear the enabled status bits) • Read out GPIO_IRQSTATUS_SET_y=> enable_value_y • Write status_value_x and NOT enable_value_y to GPIO_IRQSTATUS_y By doing so, user clears the unused interrupt status bits for the other interrupt line. An extension to this workaround is to clear GPIO_IRQSTATUS_y (all the bits) when the corresponding interrupt line (most of the time the DSP, that is, 2nd interrupt line) is not used, at each time GPIO_IRQSTATUS_x is cleared. Note: Clearing GPIO_IRQSTATUS_0 (respectively 1) is done by writing 0xFFFFFFFF to this register. It will automatically clear GPIO_IRQSTATUS_RAW_0 (respectively 1) consequently.	1.70 GPIO IRQ Not Generated After MPU Idle if IRQSTATUS Bits Not Cleared
Cortex A-9	TI	OMAP4430	When DSI PLL is under locking, SYS_CLK can be observed on the hardware observability but once PLL is locked the hardware observability signal does not change and still show SYS_CLOCK. DSI PLL is not available on hardware observability.	No workaround is available.	1.71 DSI PLL Signal is Not available on Hardware Observability Pads
Cortex A-9	TI	OMAP4430	The equation for layer blending when upper layer is a premultiplied with a global alpha: LYR(result) = A(global) * LYR(upper) + (1 -“ (A(global) * A(pixel))) * LYR(lower) Where: • A(global) is alpha of upper layer • A(pixel) is pixel alpha of upper layer • (1 -“ (A(global) * A(pixel))) is the first complement of A(global * A(pixel)) • When A(global) = 0 P(result) should be P(lower). Calculation leads to 0xff * P(lower) which can have 1-bit error if P(lower) > (full range)/2 (0x80 for 8-bit) • When A(global) = 0xff P(result) should be P(upper). Calculation leads to 0xff * P(upper) + (1-A(pixel)) * P(lower) For example, 8-bit multiplication-with-rounding leading to 1-bit error in case Operand > (full range) / 2. 0x8c * 0xff = 0x8B74 final resulting after rounding is 0x8B instead of 0x8C.	No workaround is available.	1.72 Blending Calculation Error When Premultiply Alpha is Used
Cortex A-9	TI	OMAP4430	When the system enters off mode, the save-and-restore (SAR) process comes into play. During the save sequence, the USB host content must be saved (even if the module was not in use). The saved content is automatically restored upon the next wakeup from off mode. When the save of the USB context occurs, an extra pulse of UTMI_root clock coming from USB DPLL is entering the IP, and generates a minor corruption. This corrupted context is saved and restored later. Upon each save thereafter, the corrupted context is corrupted further. This is a cumulative process. At least three consecutive saves (with no wakeup of USB in-between) are needed for introducing a fatal corruption. This corruption will impact the next use of the USB module: it could be while resuming a suspended device, or it could be upon the enumeration of a new device. The exact failure is not predictable: disconnection or stalls have been observed. TLL and external PHY modes are impacted.	The workaround is to only perform the SAR-save of the USB registers if the USB bus has been resumed since the last wakeup from OFF mode. If the USB has been left untouched in-between the previous wakeup from OFF, and the next OFF mode entry, then do not perform the USB registers SAR-save. (However the regular SAR-save is still needed for PRCM and other registers. Just skip the USB part) By doing so, the SAR-restore process is always restoring valid data.	1.73 HS USB: Multiple OFF Mode Transitions Introduce Corruption
Cortex A-9	TI	OMAP4430	OMAP is unable to generate the SLIMbus presence rate on flow-controlled SLIMbus channels (that is, using "pushed" protocol for TX or "pulled" protocol for RX). For example: when a 44.1â€“KSPS stream must be mapped on a 48KSPS channel reserved on SLIMbus. Flow control should ensure that only 44.1/48 ~= 92 percent of the SLIMbus bandwidth do contain data. However, SLIMbus transmits (or requests) data as often as allowed by the local data source (or sink), either the AESS or the SDMA (at 48k).	No workaround is available.	1.74 Presence Rate Generation Not Supported
Cortex A-9	TI	OMAP4430	During a reconfiguration message sequence, the controller accumulates parameter changes to be applied at the following reconfiguration boundary. Writing 0x1 to the SLIMBUS_FL_CONTROL[7] CLEAR_RECONFIGURATION bit should revert some registers fields to their current value; that is, the value currently used for SLIMbus operations. The value previously written in is discarded. This setting has immediate effect on the configuration registers. The following registers do not revert to their original configuration: • SLIMBUS_FR_CLOCK_SOURCE [6:4] CLKSEL bit • SLIMBUS_FR_CLOCK_SOURCE [3:0] CLKDIV bit • SLIMBUS_DCT_CONFIG1_j[31]/SLIMBUS_DCR_CONFIG1_j[31] ENABLE bit • SLIMBUS_DCT_CONFIG1_j[15]/SLIMBUS_DCR_CONFIG1_j[15] CL bit • SLIMBUS_DCT_CONFIG1_j[3:0]/SLIMBUS_DCR_CONFIG1_j[3:0] TP bit field • SLIMBUS_DCT_CONFIG2_j[11:0]/SLIMBUS_DCR_CONFIG2_j[11:0] SD bit field	The workaround is software. It consists of keeping a copy of the values of the nonrestore registers in memory and restoring them by software (rewriting the module registers) in case the reconfiguration clear situation is encountered.	1.75 Clear Reconfiguration Feature Does Not Revert to Previous Settings on All Registers
Cortex A-9	TI	OMAP4430	DISPC and RFBI are configured in smart-idle mode. After sending an image to the panel through the RFBI interface, the DISPC end-of-frame interrupt and RFBI end of transfer occur. After software sets the DSS in off state but no off state is not reached, DSS CM stays in idle transition, CM_DSS_DSS_CLKCTRL[17:16] IDLEST = 0x1 because RFBI is not acknowledging idle request.	After transfer of image completes, set the RFBI mode into bypass mode by setting the DISPC_CONTROL1[16] GPOUT1 and DISPC_CONTROL1[15] GPOUT0 bits to 0x1.	1.76 DSS Block in "Idle Transition" State when using RFBI I/F
Cortex A-9	TI	OMAP4430	The issue occurs when all of the following conditions are met: • DPLL_ABE input clock is set at 32 kHz (register CM_ABE_PLL_REF_CLKSEL = 0x1) • PLL is in one of the following modes: – Low-power stop mode – Fast-relock stop mode – Low-power idle bypass mode – Fast-relock idle bypass mode If a warm reset is applied on the system, the system hangs during the boot. This issue is not seen if either of the following conditions is true: • Sys_clk is used as input for DPLL_ABE. • PLL is in LOCKED state before the warm reset is applied. • PLL is in MN bypass state before the warm reset is applied.	Need to reprogram the M and N values of DPLL_ABE (that is, register CM_CLKSEL_DPLL_ABE) at the beginning of Linux® boot: • Reprogram must be done when CM_CLKMODE_DPLL_ABE[2:0]DPLL_EN is 0x7. • Reprogramming will not work if CM_CLKMODE_DPLL_ABE[2:0]DPLL_EN is 0x4 and PLL is in stop/idle-bypass state. • Reprogramming will also work if CM_CLKMODE_DPLL_ABE[2:0]DPLL_EN is 0x4 and PLL is already in MN bypass state.	1.77 System Boot Hangs When Warm Reset is Applied
Cortex A-9	TI	OMAP4430	A protocol violation between SmartReflex and voltage processor can happen when a global warm reset occurs during a transaction. Consequences are: • VP_xx_TRANXDONE_ST interrupt from the PRCM is no longer generated when a force update voltage from VP is performed. • SmartReflex does not request voltage change anymore. SmartReflex and voltage processor have a handshake protocol. SmartReflex indicates to voltage processor when voltage update is valid. Voltage processor acknowledges this request. Protocol violation appears when warm reset is asserted before acknowledge. This is because SmartReflex is warm reset-sensitive while voltage processor is cold reset-sensitive.	SmartReflex must be disabled before a software-controlled warm reset. For other warm resets, the issue cannot be avoided, but during reboot the following sequence can be performed to recover: • Initiate a Force Update and check TRANXDONE interrupt success (optional). If it is not successful then: • Initiate a software global cold reset.	1.78 Deadlock Between SmartReflex™ and Voltage Processor
Cortex A-9	TI	OMAP4430	The refresh rate is programmed in the EMIF_SDRAM_REF_CTRL[15:0] REG_REFRESH_RATE parameter taking into account frequency of the device. When a warm reset is applied on the system, the OMAP processor restarts with another frequency and so the frequency is not the same. Due to this frequency change, the refresh rate will be too low and could result in an unexpected behavior on the memory side.	The workaround is to force self-refresh when coming back from the warm reset with the following sequence: • Set EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x2 • Set EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM to 0x0 • Do a dummy read (loads automatically new value of sr_tim) This will reduce the risk of memory content corruption, but memory content can't be guaranteed after a warm reset. When OMAP is back to active mode with correct OPP configuration, EMIF registers need to be re- program according to the OPP and respect workaround for i735 bug.	1.79 Refresh Rate Issue After Warm Reset
Cortex A-9	TI	OMAP4430	When the EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE bit field is set to 0x2, self-refresh mode is activated. In that case, EMIF puts the SDRAM into self-refresh mode if no access is performed during EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM number of DDR clock cycles. If during a small window the following three events occur: • The EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM counter expires • And frequency update is requested (CM_SHADOW_FREQ_CONFIG1[0] FREQ_UPDATE set to 1) • And OCP access is requested Then it causes unstable clock on the DDR interface.	To avoid the occurrence of the three events, the workaround is to disable the self-refresh when requesting a frequency change. Before requesting a frequency change the software must program EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x0. When the frequency change has been done, the software can reprogram EMIF_PWR_MGMT_CTRL[10:8] REG_LP_MODE to 0x2.	1.80 System May Hang During EMIF Frequency Change
Cortex A-9	TI	OMAP4430	When the EMIF is going in IDLE state and the following three events occur: • Frequency update is requested (CM_SHADOW_FREQ_CONFIG1[0] FREQ_UPDATE set to 1). • And a warm reset occurs. • And a system access is requested. Then the EMIF will not properly reset internal FIFO. The EMIF may answer to the request when returning from reset not expected by the system; it creates protocol error or data corruption.	In case of software warm reset, software can check that no frequency change is ongoing before initiating the warm reset. In case of watchdog timer reset, there is no workaround to recover, a cold reset is needed.	1.81 DDR Access Hang After Warm Reset
Cortex A-9	TI	OMAP4430	Due to wrong timings, all register accesses transitioning through the L4 interconnect toward DSS are not reliable. DSS registers access done through the L4 interconnect are not supported	DSS register access should be addressed through the L3 interconnect.	1.82 DSS Configuration Registers Access Through the L4 Interconnect
Cortex A-9	TI	OMAP4430	LCD1 output supports gamma correction. The color look-up table (CLUT) is shared between the BITMAP to RGB conversion module on GFX pipeline and Gamma correction on the LCD1 output. LUT table can be loaded by SW through DISPC slave port (interconnect) or by DISPC master port using the DISPC DMA. However, LCD1 gamma correction LUT loading is not working properly and require to enable GFX pipeline for LUT loading. Depending on the load mode (DISPC_CONFIG1[2:1] LOADMODE) used, GFX pipeline can then be disabled after 1st frame.	There are two workaround treatments depends on the load mode for gamma correction LUT and frame data (see Table x-xx Workaround/Load mode settings ) Table 1-4. Workaround/Load mode settings Load Mode GFX Enable Condition Workaround ( DISPC_CONFIG1[2:1]LOADMODE) 0x0 (load LUT and data every frame) Always Enabled WA1 0x1 (load LUT for first frame and change loadmode to 2) Enable required for first frame only WA2 0x2 (load frame data only) Enable required for first frame only. WA2 0x3 (load LUT and data for first frame and change Enable required for first frame only. WA2 loadmode to 2) WA1 To use gamma correction on LCD1 output, software must: 1. Enable the GFX pipeline by setting DISPC_GFX_ATTRIBUTES[0] ENABLE to 0x1. 2. Set the GFX base address (DISPC_GFX_BA_i[31:0] BA) to an accessible frame buffer. 3. Set the GFX window to minimum size by configuring the DISPC_GFX_SIZE[27:16] SIZEY and DISPC_GFX_SIZE[11:0] SIZEX bits. 4. If the GFX pipeline is not to be displayed, set GFX LYR to bottom LYR in LCD1 overlay by setting appropriate DISPC_GFX_ATTRIBUTES[27:26] ZORDER bit field and make GFX fully transparent by setting the global alpha of the GFX to 0x00 in the DISPC_GLOBAL_ALPHA[7:0] GFXGLOBALALPHA bit field. WA2 To use gamma correction on LCD1 output, software must: 1. Enable the GFX pipeline by setting DISPC_GFX_ATTRIBUTES[0] ENABLE to 0x1. 2. Set the GFX base address (DISPC_GFX_BA_i[31:0] BA) to an accessible frame buffer. 3. Set the GFX window to minimum size by configuring the DISPC_GFX_SIZE[27:16] SIZEY and DISPC_GFX_SIZE[11:0] SIZEX bits. 4. If the GFX pipeline is not to be displayed, set GFX LYR to bottom LYR in LCD1 overlay by setting appropriate DISPC_GFX_ATTRIBUTES[27:26] ZORDER bit field and make GFX fully transparent by setting the global alpha of the GFX to 0x00 in the DISPC_GLOBAL_ALPHA[7:0] GFXGLOBALALPHA bit field. 5. When DISPC_IRQSTATUS[8]PALETTEGAMMALOADING_IRQ =0x1 then disable GFX pipeline	1.83 LCD1 Gamma Correction Is Not Working When GFX Pipe Is Disabled
Cortex A-9	TI	OMAP4430	LPDDR2 memories could be put in self-refresh mode for power savings. The number of cycles after which EMIF can start a self-refresh entry is software programmable (thanks to the power management timer for self-refresh: EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM register bit field). When exiting self-refresh mode, it is required that at least one refresh command is issued before entry into a subsequent self-refresh (as defined in the JEDEC LPDDR2 Specification) When this timer value is set to a value less than 0x6 (for VDD_CORE_L OPP100) or less than 0x5 (for VDD_CORE_L OPP50), the time between a self-refresh exit to the next immediate self-refresh entry does not allow the EMIF to perform a refresh command. As a consequence, data in LPDDR2 memory is not refreshed properly, and then data is corrupted in LPDDR2.	Using a value of EMIF_PWR_MGMT_CTRL[7:4] REG_SR_TIM >= 6 for VDD_CORE_L OPP100 and a value of REG_SR_TIM >= 5 for VDD_CORE_L OPP50 avoid the occurrence of the issue.	1.84 Power Management Timer Value For Self-Refresh (SR_TIM)
Cortex A-9	TI	OMAP4430	Following a bug in the integration of I/Os cell for LPDDR2 clocks, a leakage increase can be observed on vddca_lpddr2 when OMAP is in open switch retention mode.	To prevent an increase in leakage, it is recommended to disable the pull logic for these I/Os except during off mode. So the default state of the I/Os (to program at boot) will have pull logic disable: CONTROL_LPDDR2IO1_2[18:17]LPDDR2IO1_GR10_WD = 00 CONTROL_LPDDR2IO2_2[18:17]LPDDR2IO2_GR10_WD = 00 When entering off mode, these I/Os must be configured with pulldown enable: CONTROL_LPDDR2IO1_2[18:17]LPDDR2IO1_GR10_WD = 10 CONTROL_LPDDR2IO2_2[18:17]LPDDR2IO2_GR10_WD = 10 When resuming from off mode, pull logic must be disabled.	1.85 Leakage Increase On LPDDR2 I/Os
Cortex A-9	TI	OMAP4430	If the sys_boot[5:0] pins are configured for booting from MMC1, then the boot on MMC1 may not happen (board dependency) and the ROM code jumps to the next device of the boot sequence. Indeed, depending on the voltage ramp, the ROM code may not wait long enough for SDMMC1_VDDS voltage to be stabilized at 3 V before checking the voltage level supplied to OMAP. In that case, the ROM code checks the SDMMC1_VDDS voltage too early, reads a bad level, and then jumps to 1.8-V configuration while the PMIC was configured to 3 V. The MMC1_PBIAS cell is in a bad state and prevents the sending of commands to the MMC1 bus. The ROM code switches to the next boot sequence.	No	1.86 MMC1 Booting May Be Bypassed Depending On VDD Ramp-up Delay
Cortex A-9	TI	OMAP4430	A bug has been identified in the interconnect agent handling the connect-disconnect protocol between an initiator and interconnect. When the disconnect protocol violation occurs, there is a dead lock and a system lockup is observed. The issue can occur in a corner case when the impacted module has started a transition to standby, for the L3 initiator on which it is attached, exactly at the time the initiator gets an event for exiting idle state. Such a situation can occur when the impacted initiator is generating short MStandby pulses (pulse durations less than one L4 clock cycle). DSS and ISS are the only initiators that are impacted.	L3_CLK1 must be kept in NO-IDLE when the DSS clock domain is ON. It can be switched back to HW_AUTO when the DSS clock domain is IDLE. L3_CLK2 must be kept in NO-IDLE when the ISS clock domain is ON. It can be switched back to HW_AUTO when the ISS clock domain is IDLE.	1.87 Disconnect Protocol Violation
Cortex A-9	TI	OMAP4430	ULPI RxCmds, from OMAP to USB device, convey the wrong ID bit after the save-and-restore sequence. When OMAP is in a low-power mode scenario (chip-OFF), in high-speed transceiverless link (TLL) connection, after the SAR phase, every RxCmd from the TLL to the peripheral conveys wrong ID field (for example, 0x0D instead of 0x4D), that is, the ID bit is 0 instead of 1. This is due to the TLL losing the value of ID during the SAR process. As long as the peripheral does not resample the ID (by toggling OTG_CTRL_i[0] IDPULLUP) after the restore, the ID bit keeps the wrong value 0 instead of 1. This results in sending the wrong RxCmd to the peripheral. Depending on the peripheral device design, it may consider or disregard the ID bit. The behavior and consequences depend on the device design.	Ensure that the OTG_CTRL_i [0] IDPULLUP bit is set to 1 before the SAR-save. By doing so, this bit is restored to 1 after every off mode. Then the ID bit is sampled and the Rxcmd is correct.	1.88 ULPI RxCmds Convey the Wrong ID Bit After Save-and-Restore Sequence
Cortex A-9	TI	OMAP4430	During DVFS transitions, the PRCM controller can hang if CORE DPLL dividers M2 and M5 are updated at once.	The recommended sequence is: • Update CM_SHADOW_FREQ_CONFIG2[7:3]DPLL_CORE_M5_DIV. • Set CM_SHADOW_FREQ_CONFIG2[0]GPMC_FREQ_UPDATE to 0x1. • Wait until CM_SHADOW_FREQ_CONFIG2[0]GPMC_FREQ_UPDATE becomes 0x0. • Update CM_SHADOW_FREQ_CONFIG1[15:11]DPLL_CORE_M2_DIV. • Set CM_SHADOW_FREQ_CONFIG1[0]FREQ_UPDATE to 0x1. • Wait until CM_SHADOW_FREQ_CONFIG1[0]FREQ_UPDATE becomes 0x0.	1.89 PRCM Hang at Frequency Update During DVFS
Cortex A-9	TI	OMAP4430	Due to a bad behavior of an internal signal, the Card Error interrupt bit MMCHS_STAT[28] CERR may not be set sometimes when an error occurred in the card response.	After responses of type R1/R1b for all cards and responses of type R5/R5b/R6 for SD and SDIO cards, software must read two registers: MMCHS_RSP10 and MMCHS_CSRE. When a MMCHS_CSRE[i] bit is set to 1, if the corresponding bit at the same position in the response MMCHS_RSP0[i] is set to 1, the host controller indicates a card error and software should proceed in the same way as if a CERR interrupt would have been detected in the MMCHS_STAT register.	1.90 Card Error Interrupt May Not Be Set Sometimes
Cortex A-9	TI	OMAP4430	Software override of EFUSE SRAM LDO output voltage value in retention mode is not functional and will have no effect. Retention voltage will be the one set by the EFUSE even if: CONTROL_LDOSRAM_xxx_VOLTAGE_CTRL[26] LDOSRAMxxx_ RETMODE_MUX _CTRL is set to 1 and CONTROL_LDOSRAM_xxx_VOLTAGE_CTRL[20:16] LDOSRAMxxx_ RETMODE_VSET_OUT contains a valid value.	None	1.91 SRAM LDO Output Voltage Value Software Override in RETENTION is Not Functional
Cortex A-9	TI	OMAP4430	This problem impacts the HS USB Host HSIC interface. TLL and ULPI interfaces are not impacted. For this issue to occur, the following conditions must exist: • A USB device is attached to an OMAP HSIC interface. • The USB bus is suspended. • The PRCM asserts idle_req, and the USB host answers idle_ack. • The PRCM hardware automatically stops the interface clocks (ICLK). • Software disables the module by setting the CM_L3INIT_HSUSBHOST_CLKCTRL[1:0]:MODULEMODE bit fields to 0x0. • The PRCM automatically stops the mandatory functional clocks (FLCK). • Software stops the optional FCLK. • The module is then idle. The clock domain can possibly enter idle, then the power domain also can enter a low-power mode, and even the full OMAP. • The device generates a remote wakeup. The USB Host detects the remote wakeup condition asynchronously and generates a USBHOST_SWAKEUP to the PRCM. The PRCM deasserts idle_req, and restarts ICLK and mandatory FCLK, but not the optional FCLK. However, in the case of HSIC, the optional FCLK (CM_L3INIT_HSUSBHOST_CLKCTRL[10/9/8].OPTFCLKEN_UTMI_P3/2/1_CLK) is needed to generate the interrupt indicating to the system that the USB HOST is the wake-up source. Consequently, OMAP is woken up but does not acknowledge who is the wake-up source.	Do not rely on the asynchronous wake-up feature of the USB host module, but rather on the daisy-chain for detecting a remote wakeup. Set the wakeup-enable feature of the HSIC pads and enable the daisy-chain to generate a wakeup and an interrupt to the PRCM. Upon wakeup and interrupt from the daisy chain, if the wakeupevent bit is set for the HSIC pads, then restart the USB Host module and the UTMI_Px clock and resume the device.	1.92 HS USB Host HSIC Remote Wakeup Is Not Functional
Cortex A-9	TI	OMAP4430	When I2C module is used in HS master receive mode, and when smart-idle wakeup mode is set: • If reconfiguration of I2C_BUF[13:8] RXTRSH value is done while I2C_CON[15] I2C_EN = 0x1, and with no clearing of the RX buffer pointer. • I2C module does not wakeup from idle mode due to wrong pointers of RX Buffer (as RXTRSH was reconfigured with no actual cleaning of RX FIFO pointers from a previous transfer). As a consequence, I2C FIFO draining interrupt is not generated in Idle/WakeUp scenario.	Before reconfiguring the RXTRSH (Threshold value for FIFO buffer in RX mode): • Disable I2C controller by setting the I2C_CON[15] I2C_EN bit to 0x0 (this puts the controller in reset, clears the FIFOs, and sets the status bits to their default value) • Once the I2C module reconfiguration is done, reactivate the I2C controller by setting the I2C_CON[15] I2C_EN bit to 0x1 (module enabled).	1.93 I2C FIFO Draining Interrupt Not Generated
Cortex A-9	TI	OMAP4430	General-purpose (GP) timers in posted mode (GPT_TSICR[2] POSTED bit set to 0x1) with GPTi_ICLK (timer interface clock) and GPTi_FCLK (timer functional clock) clock frequency not respecting the ICLK < 4*FCLK ratio, can periodically report a random time from read accesses to counter register GPT_TCRR.	If ICLK < 4*FCLK ratio is not respected, then software should make sure that the posted mode is inactive (the GPT_TSICR[2] POSTED bit is set to 0x0) before any read access to the GPT_TCRR register.	1.94 Read Accesses to GP Timer TCRR Can Report Random Value When In Posted Mode
Cortex A-9	TI	OMAP4430	In video mode, the command mode packets, provided through the DSI protocol engine OCP port, can be interleaving during the blanking periods vertical and/or horizontal blanking periods of the video stream sequence. When TX FIFO on the OCP slave port is empty and if the first packet written to TX FIFO is less than 13 words when 1 data lane is active or 17 words when 2 data lanes are active or 25 words when 3 or 4 data lanes are active, only this packet will be sent on the HS link during the next blanking period enabled for command packet transfer. This is the only sent packet, because this packet is the only completely written packet when the FSM has read the last location of this packet from TX FIFO. Even if more packets are written in TX FIFO before the interleaving starts, these packets will not be sent during that blanking period.	No workaround is available. The impact is minor because: • When interleaving is done on a vertical blanking period (VSA, VFP, VBP), as these blanking are expressed in a number of lines, the remaining packet(s) in TX FIFO are sent on HS link during the next line blanking interval within the same blanking period or during the next one. • When interleaving is done on a horizontal blanking period (HSA, HFP, HBP), the remaining data in TX FIFO is sent on the next blanking period.	2.1 Issue with Transfer Of Multiple Command Packets Coming From Interconnect
Cortex A-9	TI	OMAP4430	The DSI protocol engine is based on the MIPI DSI ver. 1.01 specification. However the video mode using sync pulses is implemented using the timing described in MIPI DSI ver. 1.00 and not ver. 1.01: • The DSI protocol engine sends only HE packets (when enabled) during VACT and not during VSA, VFP, and VBP. • The DSI protocol engine sends VE (noted as VSE in MIPI DSI ver. 1.01 specification) during VSA and not during VBP. Figure 2.1 represents actual implementation and Figure 2.2 represents MIPI DSI ver. 1.01 specification. Figure 2-1. MIPI DSI 1.00 (Implemented) - Video Mode Interface Timing: Nonburst Transmission With Sync Start And End. t * (VSA + VBP + VACT + VFP) L t t t t t t t L L L L L tL L L B L V BL H BL V BL H BL H BL H BL H BL H L V Active video area P S LP S LP E LP S LP S LP S LP S LP S L S M P VSA lines VBP lines VFP lines tHBP t t t t L HSA HACT HFP H H H H H H H H S B RGB HFP S B RGB HFP S E S E A P A P VACT lines 122 Limitations SWPZ009Q – October 2010 – Revised September 2013 Copyright © 2010–2013, Texas Instruments Incorporated Public Version www.ti.com Nonburst Video Mode Using Sync Pulses: NO HE Packets Sent VSA, VFP, And VBP Blanking. Figure 2-2. MIPI DSI 1.01 ( Not Supported) - Video Mode Interface Timing: Nonburst Transmission With Sync Start And End. t * (VSA + VBP + VACT + VFP) L t t t t t t t t L L L L L L L L V H H H H H H H H V H H H H H H H H H H H H H H B L V BL BL BL BL BL BL BL L S S S S S S S S S S S S S S S Active video area S S S S S S S S S P S LP LP LP LP LP L LP LP S A E S A E S A E E A E S A E S A E S A E S A E P M S VSA lines VBP lines VFP lines tHBP t t t t L HSA HACT HFP H H H H H H H S HSA S B RGB HFP S B RGB HFP S E S E P A P VACT lines	NA	2.2 Nonburst Video Mode Using Sync Pulses: NO HE Packets Sent VSA, VFP, And VBP Blanking.
Cortex A-9	TI	OMAP4430	CORE, MPU, IVA, ABE, and PER DPLLs are incorrectly controlled when switching to idle bypass power states. The ADPLL-M instances are forced to run in low-power mode when entering in idle bypass power state. To avoid a deadlock in the DPLLCtrl state-machine, fast relock mode must not be used.	For CORE, MPU, IVA, ABE, and PER DPLLs, the following registers programming must not be used: • DPLL_EN = 6 • AUTO_DPLL_MODE = 2 or 6 For CORE DPLL, the following registers programming must not be used: • CM_SHADOW_FREQ_CONFIG1.DPLL_CORE_DPLL_EN = 6 • CM_SHADOW_FREQ_CONFIG1_RESTORE.DPLL_CORE_DPLL_EN = 6	2.3 DPLL Fast Relock Idle Bypass Mode Not Supported
Cortex A-9	TI	OMAP4430	BITMAP1, BITMAP2, and BITMAP4 are not supported by the graphics pipeline.	No workaround is available.	2.4 BITMAP1-2-4 Formats Not Supported By The Graphics Pipeline
Cortex A-9	TI	OMAP4430	When Graphics pipeline input pixel is in BITMAP format, it cannot output pixel at the rate of one pixel per each clock cycle when LCD = 1 and PCD = 1. The limitation is not applicable if PCD is greater than or equal to 2.	No workaround is available.	2.5 Limitation On DISPC Dividers Settings When Using BITMAP Format
Cortex A-9	TI	OMAP4430	LPDDR2 memory accesses are not stable following two design issues on DQS: • Improper control of the pullup/down resistors on DQS • Excessive skew during the enable of the DQS	To have stable access the EMIF must work at 200 MHz on the LPDDR2 interface. This means that PHY_ROOT_CLK from DPLL_CORE must be programmed at 400 MHz. Chip powerup and reset sequence begins: • EMIF sends precharge command followed by MRW reset to memory. • MPU completes EMIF configuration. The following sequence is needed to set correctly pullup/down resistors on DQS: 1. Program the wd0/wd1 bits for the I/O as 1/1 (bus keeper mode). This ensures that the differential pads of DQS I/O cell are held at their last driven value. • CONTROL_LPDDR2IO1_1.LPDDR2IO1_GR6_WD = 0x11 • CONTROL_LPDDR2IO1_1.LPDDR2IO1_GR7_WD = 0x11 • CONTROL_LPDDR2IO1_1.LPDDR2IO1_GR8_WD = 0x11 • CONTROL_LPDDR2IO1_2.LPDDR2IO1_GR9_WD = 0x11 • CONTROL_LPDDR2IO2_1.LPDDR2IO2_GR6_WD = 0x11 • CONTROL_LPDDR2IO2_1.LPDDR2IO2_GR7_WD = 0x11 • CONTROL_LPDDR2IO2_1.LPDDR2IO2_GR8_WD = 0x11 • CONTROL_LPDDR2IO2_2.LPDDR2IO2_GR9_WD = 0x11 2. Initialize the DQS inputs to a known value by a dummy read. • MR1 read for lpddr2 (dummy read for each channel) as an example 3. Issue a PHY reset to initialize FIFO pointers. Write 1 to bit 10 at the following address(using read modify write to this register to keep other bits): • Assert PHY reset for EMIF1 @ x 4C00 0060 • Assert PHY reset for EMIF2 @ x 4D00 0060 Note: Step 3 "issue PHY reset" must be done after leaving Open Switch Retention state.	2.6 LPDDR2 Instability
Cortex A-9	TI	OMAP4430	HDQ/1-Wire protocols use a return-to-1 mechanism and it requires an external pullup resistor on the line. There is a timing limitation on this return-to-1 mechanism that requires a constraint on the external pullup resistor(R) and the capacitive load(C) of the wire.	There is a constraint in the design for the maximum allowed rise time of the wire. After writing data to the wire, the HDQ/1-Wire module samples the logic value of the wire 1 FSM (finite state machine) clock cycle later. The FSM expects to read back 1 value from the wire. This constraint must be taken into account, when calculating the pullup resistor(R) according to the capacitive load(C) of the wire. The maximum RC (pullup resistor and capacitive load) value should be calculated as follow: R <1200ns/(10e-12 + C)	2.7 HDQ™/1-Wire® Communication Constraints
Cortex A-9	TI	OMAP4430	The Cortex-A9 MPUSS (CPU0 and CPU1) mstandby, mwait, and mwkup signals which are available through hardware observability do not show correct value when MPU is in OFF mode or in retention-OSWR. This is due to the fact that this logic is part of PD_MPU and therefore will be shutdown during these power modes.	CPU0 and CPU1 states are still available during off mode and retention-OSWR through PROFILING_EVENT2PRM bus which has hardware observability feature.	2.8 Dual Cortex-A9 Observability Signals Not Available
Cortex A-9	TI	OMAP4430	Hardware observability is lost when wakeup from off mode is happening. In off mode sequence, the CORE power domain is resetting so its control enable bit HWOBS_CONTROL.HWOBS_MACRO_ENABLE would get the reset value, thus disabling hardware observability.	None	2.9 HW Observability Lost After Wakeup From Off Mode
Cortex A-9	TI	OMAP4430	Depending on McPDM FIFO value, a floor Noise in audio band at ~-80dB_fullscale may appear with one of these two following configurations: • Case 1: AESS is used for the McPDM transfers, 6 downlink channels of McPDM are enabled and McPDM downlink FIFO threshold is set to 1. • Case 2: AESS is not used for the McPDM transfers, 4 downlink channels of McPDM are enabled and McPDM downlink FIFO threshold is set to 1 or 2.	Case 1 workaround: • Set McPDM downlink FIFO threshold to 2 (floor noise goes back to ~ -130dB_fullscale) Case 2 workaround: • Set McPDM downlink FIFO threshold to 4 (floor noise goes back to ~ -130dB_fullscale)	2.10 Presence of a Floor Noise on Audio Band When Multiple McPDM Downlink Enabled
Cortex A-9	TI	OMAP4430	Due to the use of only a 14-bit bus by MMCHS instead of 15 bits used by ADMA2, then one bit is not used by MMCHS. So, for descriptor length 0, 65535, 65534, and 65533 (16384 accesses of 32 bits in 15-bit bus), then only 8192*32 bits accesses will be transferred instead of 16384*32 bits. For accesses lower than or equal to 65532bytes, there is no impact.	To avoid transferring less number of data than desired, the descriptor length should always be less than or equal to 65532 bytes.	2.11 MMCHS: ADMA2 Descriptor Length Upper Than 65532 Bytes Is Not Supported
Cortex A-9	TI	OMAP4430	In Off mode, power consumption for nominal device is measured at 690µA on VDDS_1P8 and 730 µA VDDS_1P8_FREF.	When clock slicer is used, use WA of putting alternate system clock source in bypass. There is no WA when OMAP oscillator is used.	2.12 OFF Mode Over Power Consumption On VDDS_1P8 and VDDS_1P8_FREF
Cortex A-9	TI	OMAP4430	Overlay optimization does not work when resize processing is enabled on any 'Enabled' layer. When any of the 'Enabled' layers has bit field DISPC_p_ATTRIBUTES.RESIZEENABLE as nonzero it will neither be optimized nor participate in optimization of layers below.	For optimization to occur for a particular layer, make RESIZEENABLE as 0x0. With multiple layers enabled, make RESIZEENABLE for all the layers as 0x0 for every layer to participate in overlay optimization of itself or for the layers below it.	2.13 Overlay Optimization Limitations
Cortex A-9	TI	OMAP4430	In memory-to-memory operation, it is possible for WB pipe to write out pixel data faster than the rate at which VID/GFX DMA is fetching the pixel data. Under such a condition, the WB pipe should slow down by itself (by inserting necessary stalls) and should not cause an underflow at the VID DMA. The required behavior is: when VID/GFX pipelines are connected to WB in memory-to-memory mode (connected either directly or through overlay), there should not be any buffer underflow and no underflow interrupt should be generated. However the DISPC module deviates from this behavior and generates sporadic underflow interrupt. But buffer underflow never happens; there is no corruption of the data written back to the memory. Only undesired interrupts are generated due to this defect.	Software should disable the VID/GFX pipeline underflow interrupt by writing 0x0 in DISPC_IRQENABLE[20-12-10-6] bit if it is connected to the WB pipeline in memory-to-memory mode. Software should not consider the underflow interrupt generated in DISPC_IRQSTATUS[20-12-10-6] bit when in memory-to-memory mode	2.14 VID /GFX Pipeline Underflow Interrupt Generated When In WB Memory-to-memory Operation
Cortex A-9	TI	OMAP4430	If the HDQ/1-Wire module is used with interrupts disabled (HDQ_STATUS_CTRL. INTERRUPTMASK=0), all operations triggered by setting the GO bit to 1 (initialization pulse, write operation, read operation) will be repeated indefinitely until software sets the GO bit back to 0. Consequently, the HDQ/1-Wire module is not suitable for use with interrupts disabled (unless maybe in some very specific situations and with extra care).	There is no software workaround for this limitation. The HDQ/1-Wire module must be used with interrupts enabled.	2.15 HDQ/1-Wire Module Is Not Suitable For Use With Interrupts Disabled
Cortex A-9	TI	OMAP4430	The MIPI HSI specification explicitly requires run-time configurability to be supported for these HSR Frame Burst, HSR Frame Time-out, and HSR Tailing Bit counters. Update of HSR counters with new values while data traffic is ongoing results in spurious errors and/or data loss/corruption: • HSR Frame Burst Counter update: Spurious FT/TB errors and/or data loss/corruption • HSR Frame Timeout Counter update : Spurious FT/TB errors and/or data loss/corruption (observed only in pipelined flow) • HSR Tailing Bit Counter: Spurious FT/TB errors and/or data loss/corruption (observed only in pipelined flow)	No workaround is identified.	2.16 HSI: Run-time Change Of HSR Counter Values Damages Communication
Cortex A-9	TI	OMAP4430	From the MIPI HSI spec; the transmitter shall be able to transmit a break transmission regardless of the state of the READY signal. • Break frame will not be sent if the READY line is low and Tx FIFO is not empty. Inserting a break frame, in this configuration, will also override a frame in Tx FIFO. Refer to "Break frame corrupt ongoing transfer" errata. • Break frame will be sent if TX FIFO is empty and READY line is low.	No workaround is identified.	2.17 HSI Does Not Send Break Frame In Some Scenario
Cortex A-9	TI	OMAP4430	The ROM Code normally keeps looping indefinitely on trying to boot on the list of boot devices until one of them succeeds. However, when the USB cable is not attached, a bug in the ROM Code USB driver leads to the interrupt table filling up quickly. After 2 or 3 loops in the SYSBOOT table (that defines which list of devices should be looped through), the USB boot will not be tried anymore. It is not possible to keep trying to boot with USB until the cable is attached.	To perform USB boot, the USB cable must be attached to the OMAP device before reset.	2.18 USB Boot When Cable Not Attached
Cortex A-9	TI	OMAP4430	Started with ES2.x, EMIF accesses are done using bursts of eight words which cannot be interrupted. So if the initiator requires only four words at a time, the access is not efficient. A list of use cases potentially impacted by this limitation follows: • DSS and ISS (BTE) behavior in rotated view • SDMA, SGX or MPU line fill/writeback in 0-degree/90-degree	There is no workaround to avoid this lost of efficiency. The 4 word accesses have to be avoiding in the application.	2.19 Efficiency Lost on EMIF Accesses
Cortex A-9	TI	OMAP4430	The refresh rate is programmed in the EMIF_SDRAM_REF_CTRL.REG_REFRESH_RATE parameter. To ensure some bandwidth is still available to the system, a low threshold has been implemented in hardware; if the programmed value is lower than the threshold, the threshold value is programmed instead of the requested value. Assuming 1x is the refresh rate of the LPDDR at 85C, JEDEC requirement is to have 4x refresh rate between 85C and 105C. For die up to 1 Gb, Trefi is 15.6us or 7.8us, even with the threshold limitation OMAP will support a 4x refresh rate. For 2Gb and 4Gb die, Trefi = 3.9us, the threshold allows only a 3x refresh rate. For 8 Gbit the threshold will limit to a 2x refresh rate.	For 2 Gbit and 4 Gbit, between 85C and 95C the recommendation is to use this 3x refresh rate. Most of memory vendors have confirmed that this is acceptable. Customer must ensure the LPDDR2 junction temperature will never exceed 95C. This can be achieved by: • Full device level thermal simulations on the worst case thermal use case. TI can provide flotherm model to enable these types of simulations. • And/or instrumentation of the phone placing a thermocouple on the LPDDR2 top case and measuring the temperature thru a comprehensive set of use cases	2.20 EMIF: Refresh rate programmation issue
Cortex A-9	TI	OMAP4430	ECD3 fails to decode the bitstreams having the mismatch between CBP and CBF generated by non-TI encoder. The mismatch violates the H.264 CBP rule. But the mismatch can be correct in-practice / real-life /De-facto. It wrongly decodes the bitstream as error stream (instead of normal stream), but it never results in hang or crash. The decoded output have visual noticeable artifacts as many good slices are concealed. The issue occurs for H.264 MP/HP decoder decoding bitstream generated by non-TI encoder violating H.264 CBP rule. It does not occur for H.264 BP/MP/HP encoder as well as H.264 BP decoder.	No Workaround	2.21 ECD3 Fails To Decode Bitstreams Having Mismatch Between CBP and CBF
Cortex A-9	TI	OMAP4430	The overlay determine the blending effect by the following: If (Ae > 0x3fc) Result = Upper layer Elsif (Ae == 0x0) Result = Lower Layer Else Ae = Ap×(Upper layer) + (1-Ap)×(Lower layer) where Ae represents the effective Alpha, input of overlay. Ae is determined by two inputs parameters: Ap (pixel alpha) and Ag (global alpha). The Ap available at the input of overlay can come through two paths: 1. The scaler (in which case the highest and second highest values are 0x3ff and 0x3fb, respectively). 2. The parallel bypass path (in which case we can get pixel alpha values between 0x3fc and 0x3fe). The effective alpha value can only be in the range of 0x3fc – 0x3fe if the global alpha value is programmed as 0xff. As an inference from the above if Ae value (resulting as a multiplication of global alpha [Ag] and pixel alpha[Ap]) inside the TV overlay is between 0x3fc and 0x3fe, the blending logic treats this layer as opaque and blending does not occur.	None	2.22 TV Overlay Blending Limitation
Cortex A-9	TI	OMAP4430	The ISP pattern generator, which implements an internal data generation mechanism to test the external pins and can generate RAW data without the need for an external image sensor, is not functional.	None	2.23 ISP Pattern Generator Is Not Functional
Cortex A-9	TI	OMAP4430	Voltage drop can be observed when following conditions are met: • csix_dx/y_ pad pair(DXn, DYn on the figure below) is used in GPI mode (CONTROL_CAMERA_RX[20:19]/[17:16] CAMERARX_CSIx_CAMMODE=0x3) • One of the pair is connected to GND and another is pulled-up to High The signal level of the pad which is pulled-up is dropped due to the leakage of the component used in the off switch for the on-die termination between DXn and DYn. The leakage current (and the voltage drop) varies depending on PVT condition. Under the worst case condition, the leakage can be high enough to drop the signal level under VIH of the GPI buffer and causes functional failure. Figure 2-3. CSI PHY pad in GPI mode	1. Use different pad for GPI. 2. Use the pull-up resistor value smaller than or equal to 9k Ohm. It avoids the voltage drop and keeps the signal level above VIH. However this will be at the expense of increased current (up to 70uA in the worst case), as long as DXn and DYn are opposite in polarity. SWPZ009Q – October 2010 – Revised September 2013 Limitations 145 Copyright © 2010–2013, Texas Instruments Incorporated Public Version Voltage Drop Observed On CSI PHY Pad In GPI mode www.ti.com	2.24 Voltage Drop Observed On CSI PHY Pad In GPI mode
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.1 I/O Incorrectly Trimmed
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.2 LPDDR2 High Temperature Operating Limit Exceeded
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.3 SDMMC1 interface latch-up issue
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.4 Undesired McBSP slave mode behavior during reset without CLKR/CLKX
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.5 Use Smartreflex class 1.5 for Ice Cream Sandwich
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.6 MPU EMIF Static Dependency Needed
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.7 Change In OMAP4xx Off Mode Sequence For a TPS62361B-Based Platform
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.8 High-Speed Image Capture Use Case
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.9 LPDDR2 Power-Down State is Not Efficient
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.10 SYSEN Usage for an OMAP44xx Platform based on TWL6030/TWL6032 and TPS62361B
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.11 Programming of CM_CLKSEL_DPLL_CORE[20]DPLL_CLKOUTHIF_CLKSEL
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.12 Power Delivery Network Verification
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.13 PRCM Voltage Controller Uses MPU Slave Address
Cortex A-9	TI	OMAP4430	DESCRIPTION	WORKAROUND	3.14 McPDM Downlink Data Corrupted With TWL604x