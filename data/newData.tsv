title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	instruction fetch may cause machine check if page size and memory type was changed without invalidation										
problem	this erratum may cause a machine-check error (ia32_mci_status.mcacod=0150h) on the fetch of an instruction that crosses a 4- kbyte address boundary. it applies only if (1) the 4-kbyte linear region on which the instruction begins is originally translated using a 4-kbyte page with the wb memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-mbyte, 4-mbyte, or 1-gbyte) with the uc memory type; and (3) the instruction fetch occurs after the paging-structure modification but before software invalidates any tlb entries for the linear region.										
implication	due to this erratum an unexpected machine check with error code 0150h may occur, possibly resulting in a shutdown. intel has not observed this erratum with any commercially available software.										
workaround	software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. it can instead use the following algorithm: first clear the p flag in the relevant paging-structure entry (e.g., pde); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the p flag and establish the new page size and memory type.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device- not-available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr										
											
title	smram state-save area above the 4gb boundary may cause unpredictable system behavior										
problem	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	ensure that the smram state-save area is located entirely below the 4gb address boundary.										
											
title	x87 fpu exception (#mf) may be signaled earlier than expected										
problem	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executing when an enhanced intel speedstep® technology transitions, an intel® turbo boost technology transitions, or a thermal monitor events occurs, the #mf may be taken before pending interrupts are serviced.										
implication	software may observe #mf being signaled before pending interrupts are serviced.										
workaround	none identified.										
											
title	incorrect from_ip value for an rtm abort in btm or bts may be observed										
problem	during rtm (restricted transactional memory) operation when branch tracing is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.										
implication	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.										
workaround	none identified.										
											
title	dr6 register may contain an incorrect value when a mov to ss or pop ss instruction is followed by an xbegin instruction										
problem	if xbegin is executed immediately after an execution of mov to ss or pop ss, a transactional abort occurs and the logical processor restarts execution from the fallback instruction address. if execution of the instruction at that address causes a debug exception, bits [3:0] of the dr6 register may contain an incorrect value.										
implication	when the instruction at the fallback instruction address causes a debug exception, dr6 may report a breakpoint that was not triggered by that instruction, or it may fail to report a breakpoint that was triggered by the instruction.										
workaround	avoid following a mov ss or pop ss instruction immediately with an xbegin instruction.										
											
title	opcode bytes f3 0f bc may execute as tzcnt even when tzcnt not enumerated by cpuid										
problem	if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 then opcode bytes f3 0f bc should be interpreted as tzcnt otherwise they will be interpreted as rep bsf. due to this erratum, opcode bytes f3 0f bc may execute as tzcnt even if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 0.										
implication	software that expects rep prefix before a bsf instruction to be ignored may not operate correctly since there are cases in which bsf and tzcnt differ with regard to the flags that are set and how the destination operand is established.										
workaround	software should use the opcode bytes f3 0f bc only if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 and only if the functionality of tzcnt (and not bsf) is desired.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	the smsw instruction may execute within an enclave										
problem	the smsw instruction is illegal within an sgx (software guard extensions) enclave, and an attempt to execute it within an enclave should result in a #ud (invalid-opcode exception). due to this erratum, the instruction executes normally within an enclave and does not cause a #ud.										
implication	the smsw instruction provides access to cr0 bits 15:0 and will provide that information inside an enclave. these bits include ne, et, ts, em, mp and pe.										
workaround	none identified. if smsw execution inside an enclave is unacceptable, system software should not enable sgx.										
											
title	wrmsr to ia32_bios_updt_trig concurrent with an smx senter/sexit may result in a system hang										
problem	performing wrmsr to ia32_bios_updt_trig (msr 79h) on a logical processor while another logical processor is executing an smx (safer mode extensions) senter/sexit operation (getsec[senter] or getsec[sexit] instruction) may cause the processor to hang.										
implication	when this erratum occurs, the system will hang. intel has not observed this erratum with any commercially available system.										
workaround	none identified.										
											
title	intel® pt tip.pgd may not have target ip payload										
problem	when intel pt (intel processor trace) is enabled and a direct unconditional branch clears ia32_rtit_status.filteren (msr 571h, bit 0), due to this erratum, the resulting tip.pgd (target ip packet, packet generation disable) may not have an ip payload with the target ip.										
implication	it may not be possible to tell which instruction in the flow caused the tip.pgd using only the information in trace packets when this erratum occurs.										
workaround	the intel pt trace decoder can compare direct unconditional branch targets in the source with the filteren address range(s) to determine which branch cleared filteren.										
											
title	operand-size override prefix causes 64-bit operand form of movbe instruction to cause a #ud										
problem	execution of a 64 bit operand movbe instruction with an operand-size override instruction prefix (66h) may incorrectly cause an invalid-opcode exception (#ud).										
implication	a movbe instruction with both rex.w=1 and a 66h prefix will unexpectedly cause an #ud (invalid-opcode exception). intel has not observed this erratum with any commercially available software.										
workaround	do not use a 66h instruction prefix with a 64-bit operand movbe instruction.										
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid-opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not-available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	wrmsr may not clear the sticky count overflow bit in the ia32_mci_status msrs’ corrected error count field										
problem	the sticky count overflow bit is the most significant bit (bit 52) of the corrected error count field (bits[52:38]) in ia32_mci_status msrs. once set, the sticky count overflow bit may not be cleared by a wrmsr instruction. when this occurs, that bit can only be cleared by power-on reset.										
implication	software that uses the corrected error count field and expects to be able to clear the sticky count overflow bit may misinterpret the number of corrected errors when the sticky count overflow bit is set. this erratum does not affect threshold-based cmci (corrected machine check error interrupt) signaling.										
workaround	none identified.										
											
title	pebs eventing ip field may be incorrect after not-taken branch										
problem	when a pebs (precise-event-based-sampling) record is logged immediately after a not-taken conditional branch (jcc instruction), the eventing ip field should contain the address of the first byte of the jcc instruction. due to this erratum, it may instead contain the address of the instruction preceding the jcc instruction.										
implication	performance monitoring software using pebs may incorrectly attribute pebs events that occur on a jcc to the preceding instruction.										
workaround	none identified.										
											
title	debug exceptions may be lost or misreported following wrmsr to ia32_bios_updt_trig										
problem	if the wrmsr instruction writes to the ia32_bios_updt_trig msr (79h) immediately after an execution of mov ss or pop ss that generated a debug exception, the processor may fail to deliver the debug exception or, if it does, the dr6 register contents may not correctly reflect the causes of the debug exception.										
implication	debugging software may fail to operate properly if a debug exception is lost or does not report complete information.										
workaround	software should avoid using wrmsr instruction immediately after executing mov ss or pop ss										
											
title	complex interactions with internal graphics may impact processor responsiveness										
problem	under complex conditions associated with the use of internal graphics, the processor may exceed the max_lat csr values (pci configuration space, offset 03fh, bits[7:0]).										
implication	when this erratum occurs, the processor responsiveness is affected. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	intel® processor trace psb+ packets may contain unexpected packets										
problem	some intel processor trace packets should be issued only between tip.pge (target ip packet.packet generation enable) and tip.pgd (target ip packet.packet generation disable) packets. due to this erratum, when a tip.pge packet is generated it may be preceded by a psb+ (packet stream boundary) that incorrectly includes fup (flow update packet) and mode.exec packets.										
implication	due to this erratum, fup and mode.exec may be generated unexpectedly.										
workaround	decoders should ignore fup and mode.exec packets that are not between tip.pge and tip.pgd packets.										
											
title	placing an intel® pt topa in non-wb memory or writing it within a transactional region may lead to system instability										
problem	if an intel pt (intel® processor trace) topa (table of physical addresses) is not placed in wb (writeback) memory or is written by software executing within an intel® tsx (intel® transactional synchronization extension) transactional region, the system may become unstable.										
implication	unusual treatment of the topa may lead to system instability.										
workaround	none identified. intel pt topa should reside in wb memory and should not be written within a transactional region.										
											
title	vm entry that clears traceen may generate a fup										
problem	if vm entry clears intel® pt (intel processor trace) ia32_rtit_ctl.traceen (msr 570h, bit 0) while packeten is 1 then a fup (flow update packet) will precede the tip.pgd (target ip packet, packet generation disable). vm entry can clear traceen if the vm-entry msr-load area includes an entry for the ia32_rtit_ctl msr.										
implication	when this erratum occurs, an unexpected fup may be generated that creates the appearance of an asynchronous event taking place immediately before or during the vm entry.										
workaround	the intel pt trace decoder may opt to ignore any fup whose ip matches that of a vm entry instruction.										
											
title	performance monitor event for outstanding offcore requests and snoop requests may be incorrect										
problem	the performance monitor event offcore_requests_outstanding (event 60h, any umask value) should count the number of offcore outstanding transactions each cycle. due to this erratum, the counts may be higher or lower than expected.										
implication	the performance monitor event offcore_requests_outstanding may reflect an incorrect count.										
workaround	none identified.										
											
title	enclu[egetkey] ignores keyrequest.miscmask										
problem	the intel® sgx (software guard extensions) enclu[egetkey] instruction ignores the miscmask field in keyrequest structure when computing a provisioning key, a provisioning seal key, or a seal key.										
implication	enclu[egetkey] will return the same key in response to two requests that differ only in the value of keyrequest.miscmask. intel has not observed this erratum with any commercially available software.										
workaround	when executing the enclu[egetkey] instruction, software should ensure the bits set in keyrequest.miscmask are a subset of the bits set in the current secs’s miscselect field.										
											
title	popcnt instruction may take longer to execute than expected										
problem	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.										
implication	software using the popcnt instruction may experience lower performance than expected.										
workaround	none identified										
											
title	enclu[ereport] may cause a #gp when targetinfo.miscselect is non- zero										
problem	the intel® sgx (software guard extensions) enclu[ereport] instruction may cause a #gp (general protection fault) if any bit is set in targetinfo structure’s miscselect field.										
implication	this erratum may cause unexpected general-protection exceptions inside enclaves.										
workaround	when executing the enclu[ereport] instruction, software should ensure the bits set in targetinfo.miscselect are a subset of the bits set in the current secs’s miscselect field.										
											
title	a vmx transition attempting to load a non-existent msr may result in a shutdown										
problem	a vmx transition may result in a shutdown (without generating a machine-check event) if a non-existent msr is included in the associated msr-load area. when such a shutdown occurs, a machine check error will be logged with ia32_mci_status.mcacod (bits [15:0]) of 406h, but the processor does not issue the special shutdown cycle. a hardware reset must be used to restart the processor.										
implication	due to this erratum, the hypervisor may experience an unexpected shutdown.										
workaround	software should not configure vmx transitions to load non-existent msrs.										
											
title	transitions out of 64-bit mode may lead to an incorrect fdp and fip										
problem	a transition from 64-bit mode to compatibility or legacy modes may result in cause a subsequent x87 fpu state save to zeroing bits [63:32] of the fdp (x87 fpu data pointer offset) and the fip (x87 fpu instruction pointer offset).										
implication	leaving 64-bit mode may result in incorrect fdp and fip values when x87 fpu state is saved.										
workaround	none identified. 64-bit software should save x87 fpu state before leaving 64-bit mode if it needs to access the fdp and/or fip values.										
											
title	intel® pt fup may be dropped after ovf										
problem	some intel pt (intel processor trace) ovf (overflow) packets may not be followed by a fup (flow update packet) or tip.pge (target ip packet, packet generation enable).										
implication	when this erratum occurs, an unexpected packet sequence is generated.										
workaround	when it encounters an ovf without a following fup or tip.pge, the intel pt trace decoder should scan for the next tip, tip.pge, or psb+ to resume operation.										
											
title	encls[ecreate] causes #gp if enclave base address is not canonical										
problem	the encls[ecreate] instruction uses an secs (sgx enclave control structure) referenced by the srcpage pointer in the pageinfo structure, which is referenced by the rbx register. due to this erratum, the instruction causes a #gp (general- protection fault) if the secs attributes indicate that the enclave should operate in 64- bit mode and the enclave base linear address in the secs is not canonical.										
implication	system software will incur a general-protection fault if it mistakenly programs the secs with a non-canonical address. intel has not observed this erratum with any commercially available software.										
workaround	system software should always specify a canonical address as the base address of the 64-bit mode enclave.										
											
title	processor graphics iommu unit may report spurious faults										
problem	the iommu unit for processor graphics pre-fetches context (or extended-context) entries to improve performance. due to the erratum, the iommu unit may report spurious dma remapping faults if prefetching encounters a context (or extended- context) entry which is not marked present.										
implication	software may observe spurious dma remapping faults when the present bit for the context (or extended-context) entry corresponding to the processor graphics device (bus: 0; device: 2; function: 0) is cleared. these faults may be reported when the processor graphics device is quiescent.										
workaround	none identified. instead of marking a context not present, software should mark the context (or extended-context) entry present while using the page table to indicate all the memory pages referenced by the context entry is not present.										
											
title	processor ddr vref signals may briefly exceed jedec spec when entering s3 state										
problem	voltage glitch of up to 200mv on the vref signal lasting for about 1ms may be observed when entering system s3 state. this violates the jedec ddr specifications.										
implication	intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store or an mmx instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (i.e., following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	encls[einit] instruction may unexpectedly #gp										
problem	when using intel® sgx (software guard extensions), the encls[einit] instruction will incorrectly cause a #gp (general protection fault) if the miscselect field of the sigstruct structure is not zero.										
implication	this erratum may cause an unexpected #gp, but only if software has set bits in the miscselect field in sigstruct structure that do not correspond to extended features that can be written to the misc region of the ssa (state save area). intel has not observed this erratum with any commercially available software.										
workaround	when executing the encls[einit] instruction, software should only set bits in the miscselect field in the sigstruct structure that are enumerated as 1 by cpuid.(eax=12h,ecx=0):ebx (the bit vector of extended features that can be written to the misc region of the ssa).										
											
title	intel® pt ovf packet may be lost if immediately preceding a tracestop										
problem	if an intel pt (intel® processor trace) internal buffer overflow occurs immediately before software executes a taken branch or event that enters an intel pt tracestop region, the ovf (overflow) packet may be lost.										
implication	the trace decoder will not see the ovf packet, nor any subsequent packets (e.g., tracestop) that were lost due to overflow.										
workaround	none identified.										
											
title	wrmsr to ia32_bios_updt_trig may be counted as multiple instructions										
problem	when software loads a microcode update by writing to msr ia32_bios_updt_trig (79h) on multiple logical processors in parallel, a logical processor may, due to this erratum, count the wrmsr instruction as multiple instruction-retired events.										
implication	performance monitoring with the instruction-retired event may over count by up to four extra events per instance of wrmsr which targets the ia32_bios_updt_trig register .										
workaround	none identified.										
											
title	branch instructions may initialize mpx bound registers incorrectly										
problem	depending on the current intel® mpx (memory protection extensions) configuration, execution of certain branch instructions (near call, near ret, near jmp, and jcc instructions) without a bnd prefix (f2h) initialize the mpx bound registers. due to this erratum, execution of such a branch instruction on a user-mode page may not use the mpx configuration register appropriate to the current privilege level (bndcfgu for cpl 3 or bndcfgs otherwise) for determining whether to initialize the bound registers; it may thus initialize the bound registers when it should not, or fail to initialize them when it should.										
implication	after a branch instruction on a user-mode page has executed, a #br (bound-range) exception may occur when it should not have or a #br may not occur when one should have.										
workaround	if supervisor software is not expected to execute instructions on user-mode pages, software can avoid this erratum by setting cr4.smep[bit 20] to enable supervisor- mode execution prevention (smep). if smep is not available or if supervisor software is expected to execute instructions on user-mode pages, no workaround is identified.										
											
title	writing a non-canonical value to an lbr msr does not signal a #gp when intel® pt is enabled										
problem	if intel pt (intel processor trace) is enabled, wrmsr will not cause a general- protection exception (#gp) on an attempt to write a non-canonical value to any of the following msrs:  • msr_lastbranch_{0-31}_from_ip(680h–69fh) • msr_lastbranch__{0-31}_to_ip(6c0h–6dfh) • msr_lastbranch_from_ip(1dbh) • msr_lastbranch_to_ip(1dch)  • msr_lastint_from_ip(1ddh)  • msr_lastint_to_ip(1deh)insteadthesamebehaviorwilloccurasifacanonical value had been written. specifically, the wrmsr will be dropped and the msr value will not be changed.										
implication	due to this erratum, an expected #gp may not be signaled.										
workaround	none identified.										
											
title	processor may run intel® avx code much slower than expected										
problem	after a c6 state exit, the execution rate of avx instructions may be reduced.										
implication	applications using avx instructions may run slower than expected.										
workaround	it is possible for the bios to contain a workaround										
											
title	intel® pt buffer overflow may result in incorrect packets										
problem	under complex micro-architectural conditions, an intel pt (processor trace) ovf (overflow) packet may be issued after the first byte of a multi-byte cyc (cycle count) packet, instead of any remaining bytes of the cyc.										
implication	when this erratum occurs, the splicing of the cyc and ovf packets may prevent the intel pt decoder from recognizing the overflow. the intel pt decoder may then encounter subsequent packets that are not consistent with expected behavior.										
workaround	none identified. the decoder may be able to recognize that this erratum has occurred when a two-byte cyc packet is followed by a single byte cyc, where the latter 2 bytes are 0xf302, and where the cyc packets are followed by a fup (flow update packet) and a psb+ (packet stream boundary+). it should then treat the two cyc packets as indicating an overflow.										
											
title	last level cache performance monitoring events may be inaccurate										
problem	the performance monitoring events longest_lat_cache.reference (event 2eh; umask 4fh) and longest_lat_cache.miss (event 2eh; umask 41h) count requests that reference or miss in the last level cache. however, due to this erratum, the count may be incorrect.										
implication	longest_lat_cache events may be incorrect.										
workaround	none identified. software may use the following offcore_requests model-specific sub events that provide related performance monitoring data:  demand_data_rd, demand_code_rd, demand_rfo, all_data_rd, l3_miss_demand_data_rd, all_requests.										
											
title	#gp occurs rather than #db on code page split inside an intel® sgx enclave										
problem	when executing within an intel® sgx (software guard extensions) enclave, a #gp (general-protection exception) may be delivered instead of a #db (debug exception) when an instruction breakpoint is detected. this occurs when the instruction to be executed spans two pages, the second of which has an entry in the epcm (enclave page cache map) that is not valid.										
implication	debugging software may not be invoked when an instruction breakpoint is detected.										
workaround	software should ensure that all pages containing enclave instructions have valid epcm entries.										
											
title	execution of vaesenclast instruction may produce a #nm exception instead of a #ud exception										
problem	execution of vaesenclast with vex.l= 1 should signal a #ud (invalid opcode) exception, however, due to the erratum, a #nm (device not available) exception may be signaled.										
implication	as a result of this erratum, an operating system may restore avx and other state unnecessarily.										
workaround	none identified.										
											
title	intel® sgx enclave accesses to the apic-access page may cause apic- access vm exits										
problem	in vmx non-root operation, intel sgx (software guard extensions) enclave accesses to the apic-access page may cause apic-access vm exits instead of page faults.										
implication	a vmm (virtual-machine monitor) may receive a vm exit due to an access that should have caused a page fault, which would be handled by the guest os (operating system).										
workaround	a vmm avoids this erratum if it does not map any part of the epc (enclave page cache) to the guest’s apic-access address; an operating system avoids this erratum if it does not attempt indirect enclave accesses to the apic.										
											
title	cr3 filtering does not compare bits [11:5] of cr3 and ia32_rtit_cr3_match in pae paging mode										
problem	in pae paging mode, the cr3[11:5] are used to locate the page-directory-pointer table. due to this erratum, those bits of cr3 are not compared to ia32_rtit_cr3_match (msr 572h) when ia32_rtit_ctl.cr3filter (msr 570h, bit 7) is set.										
implication	if multiple page-directory-pointer tables are co-located within a 4kb region, cr3 filtering will not be able to distinguish between them so additional processes may be traced.										
workaround	none identified.										
											
title	x87 fdp value may be saved incorrectly										
problem	execution of the fsave, fnsave, fstenv, or fnstenv instructions in real-address mode or virtual-8086 mode may save an incorrect value for the x87 fdp (fpu data pointer). this erratum does not apply if the last non-control x87 instruction had an unmasked exception.										
implication	software operating in real-address mode or virtual-8086 mode that depends on the fdp value for non-control x87 instructions without unmasked exceptions may not operate properly.										
workaround	none identified. software should use the fdp value saved by the listed instructions only when the most recent non-control x87 instruction incurred an unmasked exception.										
											
title	peci frequency limited to 1 mhz										
problem	the peci (platform environmental control interface) 3.1 specification’s operating frequency range is 0.2 mhz to 2 mhz. due to this erratum, peci may be unreliable when operated above 1 mhz.										
implication	platforms attempting to run peci above 1 mhz may not behave as expected.										
workaround	none identified. platforms should limit peci operating frequency to 1 mhz.										
											
title	processor graphics iommu unit may not mask dma remapping faults										
problem	intel® virtualization technology for directed i/o specification specifies setting the fpd (fault processing disable) field in the context (or extended-context) entry of iommu to mask recording of qualified dma remapping faults for dma requests processed through that context entry. due to this erratum, the iommu unit for processor graphics device may record dma remapping faults from processor graphics device (bus: 0; device: 2; function: 0) even when the fpd field is set to 1.										
implication	software may continue to observe dma remapping faults recorded in the iommu fault recording register even after setting the fpd field.										
workaround	none identified. software may mask the fault reporting event by setting the im (interrupt mask) field in the iommu fault event control register (offset 038h in gfxvtbar).										
											
title	intel® pt cycthresh value of 13 is not supported										
problem	intel pt (intel® processor trace) cyc (cycle count) threshold is configured through cycthresh field in bits [22:19] of ia32_rtit_ctl msr (570h). a value of 13 is advertised as supported by cpuid (leaf 14h, sub-lead 1h). due to this erratum, if cycthresh is set to 13 then the cyc threshold will be 0 cycles instead of 4096 (213- 1) cycles.										
implication	cyc packets may be issued in higher rate than expected if threshold value of 13 is used.										
workaround	none identified. software should not use value of 13 for cyc threshold.										
											
title	enabling vmx-preemption timer blocks hdc operation										
problem	hdc (hardware duty cycling) will not put the physical package into the forced idle state while any logical processor is in vmx non-root operation and the “activate vmx- preemption timer” vm-execution control is 1.										
implication	hdc will not provide the desired power reduction when the vmx-preemption timer is active in vmx non-root operation.										
workaround	none identified.										
											
title	integrated audio codec may not be detected										
problem	integrated audio codec may lose power when lpsp (low-power single pipe) mode is enabled for an edp* (embedded displayport) or dp/hdmi ports. platforms with intel® sst (intel® smart sound technology) enabled are not affected.										
implication	the audio bus driver may attempt to do enumeration of codecs when edp or dp/hdmi port enters lpsp mode, due to this erratum, the integrated audio codec will not be detected and audio maybe be lost.										
workaround	intel® graphics driver 15.40.11.4312 or later will prevent the integrated audio codec from losing power when lpsp mode is enabled.										
											
title	display flickering may be observed with specific edp panels										
problem	the processor may incorrectly configure transmitter buffer characteristics if the associated edp panel requests vesa equalization preset 3, 5, 6, or 8.										
implication	display flickering or display loss maybe observed.										
workaround	intel® graphics driver version 15.40.12.4326 or later contains a workaround for this erratum.										
											
title	incorrect branch predicted bit in bts/btm branch records										
problem	bts (branch trace store) and btm (branch trace message) send branch records to the debug store management area and system bus respectively. the branch predicted bit (bit 4 of eighth byte in bts/btm records) should report whether the most recent branch was predicted correctly. due to this erratum, the branch predicted bit may be incorrect.										
implication	bts and btm cannot be used to determine the accuracy of branch prediction.										
workaround	none identified.										
											
title	machine_clears.memory_ordering performance monitoring event may undercount										
problem	the performance monitoring event machine_clears.memory_ordering (event c3h; umask 02h) counts the number of machine clears caused by memory ordering conflicts. however due to this erratum, this event may undercount for vgather*/vpgather* instructions of four or more elements.										
implication	machine_clears.memory_ordering performance monitoring event may undercount.										
workaround	none identified.										
											
title	ctr_frz may not freeze some counters										
problem	ia32_perf_global_status.ctr_frz (msr 38eh, bit 59) is set when either (1) ia32_debugctl.freeze_perfmon_on_pmi (msr 1d9h, bit 12) is set and a pmi is triggered, or (2) software sets bit 59 of ia32_perf_global_status_set (msr 391h). when set, ctr_frz should stop all core performance monitoring counters from counting. however, due to this erratum, ia32_pmc4-7 (msr c5-c8h) may not stop counting. ia32_pmc4-7 are only available when a processor core is not shared by two logical processors.										
implication	general performance monitoring counters 4-7 may not freeze when ia32_perf_global_status.ctr_frz is set.										
workaround	none identified.										
											
title	instructions and branches retired performance monitoring events may overcount										
problem	the performance monitoring events inst_retired (event c0h; any umask value) and br_inst_retired (event c4h; any umask value) count instructions retired and branches retired, respectively. however, due to this erratum, these events may overcount in certain conditions when:  - executing vmaskmov* instructions with at least one masked vector element  - executing rep movs or rep stos with fast strings enabled (ia32_misc_enables msr (1a0h), bit 0 set)  - an mpx #br exception occurred on bndldx/bndstx instructions and the br_inst_retired (event c4h; umask is 00h or 04h) is used.										
implication	inst_retired and br_inst_retired performance monitoring events may overcount.										
workaround	none identified.										
											
title	some offcore_response performance monitoring events may overcount										
problem	the performance monitoring events offcore_response (events b7h and bbh) should count off-core responses matching the request-response configuration specified in msr_offcore_rsp_0 and msr_offcore_rsp_1 (1a6h and 1a7h, respectively) for core-originated requests. however, due to this erratum, dmnd_rfo (bit 1), dmnd_ifetch (bit 2) and other (bit 15) request types may overcount.										
implication	some offcore_response events may overcount.										
workaround	none identified. software may use the following model-specific events that provide related performance monitoring data: offcore_requests (all sub-events), l2_trans.l2_wb and l2_rqsts.pf_miss.										
											
title	instructions fetch #gp after rsm during inter® pt may push incorrect rflags value on stack										
problem	if intel pt (processor trace) is enabled, a #gp (general protection fault) caused by the instruction fetch immediately following execution of an rsm instruction may push an incorrect value for rflags onto the stack.										
implication	software that relies on rflags value pushed on the stack under the conditions described may not work properly.										
workaround	none identified.										
											
title	access to sgx epc page in blocked state is not reported as an sgx- induced page fault										
problem	if a page fault results from attempting to access a page in the sgx (intel® software guard extensions) epc (enclave page cache) that is in the blocked state, the processor does not set bit 15 of the error code and thus fails to indicate that the page fault was sgx-induced.										
implication	due to this erratum, software may not recognize these page faults as being sgx- induced.										
workaround	before using the eblock instruction to marking a page as blocked, software should use paging to mark the page not present.										
											
title	mtf vm exit on xbegin instruction may save state incorrectly										
problem	execution of an xbegin instruction while the monitor trap flag vm-execution control is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save as instruction pointer the address of the xbegin instruction instead of the fallback instruction address specified by the xbegin instruction. in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.										
implication	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.										
workaround	none identified										
											
title	intel® turbo boost technology may be incorrectly reported as supported on intel® coretm i3 u/h/s, select intel® mobile pentium®, intel® mobile celeron®, intel® pentium® and intel® celeron® processors										
problem	these processors may incorrectly report support for intel® turbo boost technology via cpuid.06h.eax bit 1.										
implication	the cpuid instruction may report turbo boost technology as supported even though the processor does not permit operation above the base frequency.										
workaround	none identified.										
											
title	performance monitoring counters may undercount when using cpl filtering										
problem	performance monitoring counters configured to count only os or only usr events by setting exactly one of bits 16 or 17 in ia32_perfevtselx msrs (186h-18dh) may not count for a brief period during the transition to a new cpl.										
implication	a measurement of ring transitions (using the edge-detect bit 18 in ia32_perfevtselx) may undercount, such as cpl_cycles.ring0_trans (event 5ch, umask 01h). additionally, the sum of an os-only event and a usr-only event may not exactly equal an event counting both os and usr. intel has not observed any other software-visible impact										
workaround	none identified.										
											
title	executing a 256 bit avx instruction may cause unpredictable behavior										
problem	under complex micro-architectural conditions, executing a 256 avx bit instruction may result in unpredictable system behavior.										
implication	when this erratum occurs, the system may behave unpredictably.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	system may hang during display power cycles										
problem	when the display is turned on after being shutoff to save power or when the display is exiting psr (panel self refresh) mode, the system may hang.										
implication	when this erratum occurs the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain non-canonical ia32_bndcfgs values will not cause vm-entry failures										
problem	if the vm-entry controls load ia32_bndcfgs field (bit 16) is 1, vm-entry should fail when the value of the guest ia32_bndcfgs field in the vmcs is not canonical (that is, when bits 63:47 are not identical). due to this erratum, vm-entry does not fail if bits 63:48 are identical but differ from bit 47. in this case, vm-entry loads the ia32_bndcfgs msr with a value in which bits 63:48 are identical to the value of bit 47 in the vmcs field.										
implication	if the value of the guest ia32_bndcfgs field in the vmcs is not canonical, vm-entry may load the ia32_bndcfgs msr with a value different from that of the vmcs field.										
workaround	none identified.										
											
title	pebs eventingip field may be incorrect under certain conditions										
problem	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.										
implication	when this erratum occurs, performance monitoring software may not attribute the pebs events to the correct instruction.										
workaround	none identified.										
											
title	hwp’s guaranteed_performance updated only on configurable tdp changes										
problem	according to hwp (hardware p-states) specification, the guaranteed_performance field (bits[15:8]) in the ia32_hwp_capabilities msr (771h) should be updated as a result of changes in the configuration of tdp, rapl (running average power limit), and other platform tuning options that may have dynamic effects on the actual guaranteed performance support level. due to this erratum, the processor will update the guaranteed_performance field only as a result of configurable tdp dynamic changes.										
implication	software may read a stale value of the guaranteed _performance field.										
workaround	none identified.										
											
title	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts										
problem	after a fault due to a failed pebs (processor event based sampling) or bts (branch trace store) address translation, the rf (resume flag) may be incorrectly set in the eflags image that is saved.										
implication	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.										
workaround	software should always prevent faults on pebs or bts.										
											
title	intel® pt topa pmi does not freeze performance monitoring counters										
problem	due to this erratum, if ia32_debugctl.freeze_perfmon_on_pmi (msr 1d9h, bit 12) is set to 1 when intel pt (processor trace) triggers a topa (table of physical addresses) pmi (perfmon interrupt), performance monitoring counters are not frozen as expected.										
implication	performance monitoring counters will continue to count for events that occur during pmi handler execution.										
workaround	pmi handler software can programmatically stop performance monitoring counters upon entry.										
											
title	hwp’s maximum_performance value is reset to 0xff										
problem	according to hwp (hardware p-states) specification, the reset value of the maximum_performance field (bits [15:8]) in ia32_hwp_request msr (774h) should be set to the value of ia32_hwp_capabilities msr (771h) highest_performance field (bits[7:0]) after reset. due to this erratum, the reset value of maximum_performance is always set to 0xff.										
implication	software may see an unexpected value in maximum performance field. hardware clipping will prevent invalid performance states.										
workaround	none identified.										
											
title	hwp’s guaranteed_performance and relevant status/interrupt may be updated more than once per second										
problem	according to hwp (hardware p-states) specification, the guaranteed_performance field (bits[15:8]) in the ia32_hwp_capabilities msr (771h) and the guaranteed_performance_change (bit 0) bit in ia32_hwp_status msr (777h) should not be changed more than once per second nor should the thermal interrupt associated with the change to these fields be signaled more than once per second. due to this erratum, the processor may change these fields and generate the associated interrupt more than once per second										
implication	hwp interrupt rate due to guaranteed_performance field change can be higher than specified										
workaround	clearing the guaranteed_performance_change status bit no more than once per second will ensure that interrupts are not generated at too fast a rate										
											
title	some memory performance monitoring events may produce incorrect results when filtering on either os or usr modes										
problem	the memory at-retirement performance monitoring events (listed below) may produce incorrect results when a performance counter is configured in os-only or usr-only modes (bits 17 or 16 in ia32_perfevtselx msr). counters with both os and usr bits set are not affected by this erratum.  the list of affected memory at-retirement events is as follows: mem_inst_retired.stlb_miss_loads event d0h, umask 11h mem_inst_retired.stlb_miss_stores event d0h, umask 12h mem_inst_retired.lock_loads event d0h, umask 21h mem_inst_retired.split_loads event d0h, umask 41h mem_inst_retired.split_stores event d0h, umask 42h mem_load_retired.l2_hit event d1h, umask 02h mem_load_retired.l3_hit event d1h, umask 04h mem_load_retired.l4_hit event d1h, umask 80h mem_load_retired.l1_miss event d1h, umask 08h mem_load_retired.l2_miss event d1h, umask 10h mem_load_retired.l3_miss event d1h, umask 20h mem_load_retired.fb_hit event d1h, umask 40h										
implication	the listed performance monitoring events may produce incorrect results including pebs records generated at an incorrect point										
workaround	none identified										
											
title	hwp may generate thermal interrupt while not enabled										
problem	due to this erratum, the conditions for hwp (hardware p-states) to generate a thermal interrupt on a logical processor may generate thermal interrupts on both logical processors of that core.										
implication	if two logical processors of a core have different configurations of hwp (e.g. only enabled on one), an unexpected thermal interrupt may occur on one logical processor due to the hwp settings of the other logical processor.										
workaround	software should configure hwp consistently on all logical processors of a core.										
											
title	camera device does not issue an msi when intx is enabled										
problem	when both msi (message signaled interrupts) and legacy intx are enabled by the camera device, intx is asserted rather than issuing the msi, in violation of the pci local bus specification.										
implication	due to this erratum, camera device interrupts can be lost leading to device failure.										
workaround	the camera device must disable legacy intx by setting bit 10 of pcicmd (bus 0; device 5; function 0; offset 04h) before msi is enabled										
											
title	an x87 store instruction which pends #pe may lead to unexpected behavior when ept a/d is enabled.										
problem	an x87 store instruction which causes a #pe (precision exception) to be pended and updates an ept (extended page tables) a/d bit may lead to unexpected behavior.										
implication	the vmm may experience unexpected x87 fault or a machine check exception with the value of 0x150 in ia32_mc0_status.mcacod (bits [15:0] in msr 401h)										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	use of vmaskmov to store when using ept may fail										
problem	use of vmaskmov instructions to store data that splits over two pages, when the instruction resides on the first page may cause a hang if ept (extended page tables) is in use, and the store to the second page requires setting the a/d bits in the ept entry.										
implication	due to this erratum, the cpu may hang on the execution of vmaskmov										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci may not be functional after package c10 resume										
problem	when resuming from package c10, peci may fail to function properly.										
implication	when this erratum occurs, the peci does not respond to any command.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	attempts to retrain a pcie* link may be ignored										
problem	a pcie link should retrain when retrain link (bit 5) in the link control register (bus 0; device 1; functions 0,1,2; offset 0xb0) is set. due to this erratum, if the link is in the l1 state, it may ignore the retrain request										
implication	the pcie link may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* expansion rom base address register may be incorrect										
problem	after pcie 8.0 gt/s link equalization on a root port (bus 0; device 1; function 0, 1, 2) has completed, the expansion rom base address register (offset 38h) may be incorrect.										
implication	software that uses this bar may behave unexpectedly. intel has not observed this erratum with any commercially available software.										
workaround	none identified										
											
title	pcie* port does not support dll link activity reporting										
problem	the pcie base specification requires dll (data link layer) link activity reporting when 8 gt/s link speed is supported. due to this erratum, link activity reporting is not supported										
implication	due to this erratum, pcie port does not support dll link activity reporting when 8 gt/s is supported.										
workaround	none identified										
											
title	bndldx and bndstx may not signal #gp on non-canonical bound directory access										
problem	bndldx and bndstx instructions access the bound’s directory and table to load or store bounds. these accesses should signal #gp (general protection exception) when the address is not canonical (i.e. bits 48 to 63 are not the sign extension of bit 47). due to this erratum, #gp may not be generated by the processor when a non- canonical address is used by bndldx or bndstx for their bound directory memory access.										
implication	intel has not observed this erratum with any commercially available software.										
workaround	software should use canonical addresses for bound directory accesses.										
											
title	ring_perf_limit_reasons may be incorrect										
problem	under certain conditions, ring_perf_limit_reasons (msr 6b1h) may incorrectly assert the other status bit (bit 8) as well as the other log bit (bit 24).										
implication	when this erratum occurs, software using this register will incorrectly report clipping because of the other reason.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor may exceed vcccore iccmax during multi-core turbo										
problem	due to this erratum, the maximum ring frequency limit is incorrectly configured to be 100mhz higher than intended.										
implication	vcccore iccmax may be temporarily exceeded when all the cores are executing at a turbo frequency.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring load latency events may be inaccurate for gather instructions										
problem	the performance monitoring events mem_trans_retired.load_latency_* (event cdh; umask 01h; any latency) count load instructions whose latency exceed a predefined threshold, where the loads are randomly selected using the load latency facility (an extension of pebs). however due to this erratum, these events may count incorrectly for vgather*/vpgather* instructions.										
implication	the load latency performance monitoring events may be inaccurate for gather instructions.										
workaround	none identified										
											
title	edram corrected error events may not be properly logged after a warm reset										
problem	after a warm reset, an edram corrected error may not be logged correctly until the associated machine check register is initialized. this erratum may affect ia32_mc8_status or ia32_mc10_status.										
implication	the edram corrected error information may be lost when this erratum occurs.										
workaround	data from the affected machine check registers should be read and the registers initialized as soon as practical after a warm reset.										
											
title	unpredictable system behavior may occur when system agent enhanced intel® speedstep® is enabled										
problem	under complex system conditions, sa-gv (system agent enhanced intel® speedstep®) may result in unpredictable system behavior.										
implication	when this erratum occurs, the system may behave unpredictably.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor may hang under complex scenarios										
problem	under a complex micro-architectural conditions, the processor may hang with an internal timeout error (mcacod 0400h) logged into ia32_mci_status.										
implication	this erratum may result in a processor hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	some bits in msr_misc_pwr_mgmt may be updated on writing illegal values to this msr										
problem	attempts to write illegal values to msr_misc_pwr_mgmt (msr 0x1aa) result in #gp (general protection fault) and should not change the msr value. due to this erratum, some bits in the msr may be updated on writing an illegal value.										
implication	certain fields may be updated with allowed values when writing illegal values to msr_misc_pwr_mgmt. such writes will always result in #gp as expected.										
workaround	none identified. software should not attempt to write illegal values to this msr.										
											
title	violations of intel® software guard extensions (intel® sgx) access-control requirements produce #gp instead of #pf										
problem	intel® software guard extensions (intel® sgx) define new access-control requirements on memory accesses. a violation of any of these requirements causes a page fault (#pf) that sets bit 15 (sgx) in the page-fault error code. due to this erratum, these violations instead cause general-protection exceptions (#gp).										
implication	software resuming from system sleep states s3 or s4 and relying on receiving a page fault from the above enclave accesses may not operate properly.										
workaround	software can monitor #gp faults to detect that an enclave has been destroyed and needs to be rebuilt after resuming from s3 or s4										
											
title	ia32_rtit_cr3_match msr bits[11:5] are treated as reserved										
problem	due to this erratum, bits[11:5] in ia32_rtit_cr3_match (msr 572h) are reserved; an msr write that attempts to set that field to a non-zero value will result in a #gp fault.										
implication	the inability to write the identified bit field does not affect the functioning of intel® pt (intel® processor trace) operation because, as described in erratum skl061, the bit field that is the subject of this erratum is not used during intel pt cr3 filtering.										
workaround	ensure that bits 11:5 of the value written to ia32_rtit_cr3_match are zero, including cases where the selected page-directory-pointer-table base address has non-zero bits in this range.										
											
title	apic timer interrupt may not be generated at the correct time in tsc- deadline mode										
problem	after writing to the ia32_tsc_adjust msr (3bh), any subsequent write to the ia32_tsc_deadline msr (6e0h) may incorrectly process the desired deadline. when this erratum occurs, the resulting timer interrupt may be generated at the incorrect time.										
implication	when the local apic (advanced programmable interrupt controller) timer is configured for tsc-deadline mode, a timer interrupt may be generated much earlier than expected or much later than expected. intel has not observed this erratum with most commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the intel pt cr3 filter is not re-evaluated on vm entry										
problem	on a vmresume or vmlaunch with both traceen[0] and cr3filter[7] in ia32_rtit_ctl (msr 0570h) set to 1 both before the vm entry and after, the new value of cr3 is not compared with ia32_rtit_cr3_match (msr 0572h).										
implication	the intel pt (processor trace) cr3 filtering mechanism may continue to generate packets despite a mismatching cr3 value, or may fail to generate packets despite a matching cr3, as a result of an incorrect value of ia32_rtit_status.contexten[1] (msr 0571h) that results from the failure to re-evaluate the cr3 match on vm entry.										
workaround	none identified.										
											
title	display slowness may be observed under certain display commands scenario										
problem	back to back access to the vga register ports (i/o addresses 0x3c2, 0x3ce, 0x3cf) will experience higher than expected latency.										
implication	due to this erratum, the processor may redraw the slowly when in vga mode.										
workaround	none identified.										
											
title	short loops which use ah/bh/ch/dh registers may cause unpredictable system behavior										
problem	under complex micro-architectural conditions, short loops of less than 64 instructions that use ah, bh, ch or dh registers as well as their corresponding wider register (e.g. rax, eax or ax for ah) may cause unpredictable system behavior. this can only happen when both logical processors on the same physical processor are active.										
implication	due to this erratum, the system may experience unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	cpuid tlb associativity information is inaccurate										
problem	cpuid leaf 2 (eax=02h) tlb information inaccurately reports that the shared 2nd- level tlb is 6-way set associative (value c3h), although it is 12-way set associative. other information reported by cpuid leaf 2 is accurate.										
implication	software that uses cpuid shared 2nd-level tlb associativity information for value c3h may operate incorrectly. intel has not observed this erratum to impact the operation of any commercially available software										
workaround	none identified. software should ignore the shared 2nd-level tlb associativity information reported by cpuid for the affected processors.										
											
title	processor graphics may render incorrectly or may hang following warm reset with package c8 disabled										
problem	processor graphics may not properly restore internal configuration after warm reset when package c8 is disabled.										
implication	due to this erratum processor graphics may render incorrectly or hang on warm reset.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	using different vendors for 2400 mhz ddr4 udimms may cause correctable errors or a system hang										
problem	when using 2400 mhz ddr4 udimms from different vendors within the same channel, a higher rate of correctable errors may occur or the system may hang.										
implication	due to this erratum, reported correctable error counts may increase or the system may hang.										
workaround	none identified. use a single vendor for 2400 mhz udimms										
											
title	two dimms per channel 2133mhz ddr4 sodimm daisy-chain systems with different vendors may hang										
problem	when, on a single memory channel with 2133 mhz ddr4 sodimms, mixing different vendors or mixing single rank and dual rank dimms, may lead to a higher rate of correctable error to system hangs.										
implication	due to this erratum, reported correctable error counts may increase or system may hang.										
workaround	use a single vendor for and do not mix single rank and dual rank 2133 mhz ddr4 sodimm.										
											
title	unpredictable system behavior may occur in ddr4 multi-rank system										
problem	due to incorrect configuration of ddr4 odt by bios, it is possible for a multi-rank system to violate section 4.27 of the ddr4 jedec spec revision jesed79-4a.										
implication	due to this erratum, complex microarchitectural conditions may result in unpredictable system behavior.										
workaround	a bios workaround has been identified.										
											
title	processor graphics may render incorrectly when edram is enabled										
problem	during high display bandwidth scenarios with edram is enabled, the display engine may generate display artifacts.										
implication	due to this erratum, the display engine may generate display artifacts.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum. additionally, an updated intel® graphics driver may be needed for this workaround.										
											
title	processor may hang on complex sequence of conditions										
problem	a complex set of architectural and micro-architectural conditions may lead to a processor hang with an internal timeout error (mcacod 0400h) logged into ia32_mci_status. when both logical processors in a core are active, this erratum will not occur unless there is no store on one of the logical processors for more than 10 seconds.										
implication	this erratum may result in a processor hang. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	potential partial trace data loss in intel® trace hub odla when storing to memory										
problem	when intel® trace hub’s odla (on-die logic analyzer) is configured to trace to memory, under complex microarchitectural conditions, the trace may lose a timestamp.										
implication	some odla trace data may be lost. this erratum does not affect other trace data sources. typically, lost trace data will be displayed as “overflow.” subsequent timestamps will allow the trace decoder to resume tracing. intel has not observed this erratum in commercially available software.										
workaround	none identified. for a particular workload, changing the memory buffer size or disabling deep compression may eliminate the microarchitectural condition that causes the erratum.										
											
title	the soc may not detect a battery charger or may fail to connect to a usb host										
problem	during power-on, when the soc is used in device mode instead of host mode, the usb d+ line may have a 2 µsec glitch to 3.3 v.										
implication	due to this erratum, the platform may not detect a battery charger (and hence not charge the battery) or the soc may not successfully connect to an attached usb host.										
workaround	power the soc on before connecting to its usb port. alternatively, manually disconnecting and re-connecting the usb cable restores operation after the erratum has occurred.										
											
title	rgb666 pixel format display panel may not operate as expected										
problem	due to this erratum, the rgb666 format support on the soc has restrictions on the horizontal resolution. for single link mipi* dsi (display serial interface), the horizontal resolution must be evenly divisible by 4. for dual link mipi dsi, one-half the horizontal resolution plus the overlapping pixels must be evenly divisible by 4.										
implication	due to this erratum, the rgb666 panel may not operate as expected.										
workaround	for dual link panels with overlap, choose the overlap so that one-half the horizontal resolution plus the overlapping pixels is evenly divisible by 4. for single link panels the horizontal resolution must be evenly divisible by 4										
											
title	lpddr3 tinit0 jedec* duration may be longer than specification requirement										
problem	jedec standard jesd209-3 requires a maximum power ramp duration tinit0 of 20ms. due to this erratum, the soc may not comply with the tinit0 specification.										
implication	intel has not observed this erratum to impact the functionality or performance of any commercially available lpddr3 parts. intel has obtained waivers from vendors who provide commonly used lpddr3 dram parts										
workaround	none identified.										
											
title	hdmi and dvi displays may flicker or blank out when using certain pixel frequencies										
problem	due to this erratum, hdmi (high-definition multimedia interface) and dvi (digital visual interface) ports may send data out at an incorrect rate, that is different than the one requested when using certain pixel frequencies.										
implication	when this erratum occurs, panels may flicker or blank out. the impacted pixel frequencies are: 218.25mhz, 218.70mhz, 220.50mhz, 221.20mhz, 229.50mhz, 233.793mhz and 234.00mhz.										
workaround	select a video mode that does not use an affected pixel frequency. statusfor the steppings affected, see the summary table of changes.										
											
title	popcnt instruction may take longer to execute than expected										
problem	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.										
implication	software using the popcnt instruction may experience lower performance than expected.										
workaround	none identified.										
											
title	lpss uart not fully compatible with 16550 uart										
problem	stick parity bit, lcr[5], (line control register, hsuart0_bar0, offset 0ch; bit [5] for hsuart0 and hsuart1_bar0, offset 0ch; bit [5] for hsuart1) does not follow the 16550 specified behavior, instead the parity bit is always logic 0.										
implication	lpss (low power sub-system) uarts are not fully 16550 compatible and may cause an error when connected to a uart device that requires the stick parity feature.										
workaround	do not use stick parity mode of uart.										
											
title	lalala										
problem	after processing a usb wake event, the usb xhci controller may not reenter d3 state.										
implication	when this erratum occurs, the affected usb xhci controller may not recognize subsequent usb wake events. when this erratum occurs, pme status bit [15] of register power management control/status (pm_cs) (bus 0; device 20; function 20; offset 74h) remains at 1.										
workaround	the software driver should set pmctrl[28] (bus 0; device 14; function 0; offset 80a4h) after the xhci controller enters d0 state following an exit from d3 state.										
											
title	soc pcie* gen 2 refclk jitter does not meet pcie* specification with ssc enabled										
problem	soc pcie* refclk does not meet pcie* jitter specification when ssc is enabled.										
implication	this issue only impacts pcie* interface when it is running at gen 2 speed when ssc is enabled. no impact to pcie* gen 1 operation. intel has not observed any functional failures due to this erratum.										
workaround	there are no known issues with enabling ssc on pcie interface that operates at gen 1 speed. however, if ssc is enabled while pcie* interface is running at gen 2 speed, system refclk will experience jitter would not meet pcie specifications.										
											
title	sd card / sdio controller preset_value does not change transfer frequency										
problem	the preset_value (cmd12_err_stat_host_ctrl_2 csr at bus 0; device 18; function 0; offset 3ch, bit 31) does not change the sd card/ sdio bus transfer frequency as required by the sd host controller standard specification version 3.0.										
implication	drivers that attempt to utilize preset_value may not obtain the maximum transfer rate of an attached uhs sd card or sdio bus.										
workaround	software should set the uhs_mode field (bits [1816] of the cmd12_err_stat_host_ctrl_2 csr) before setting the preset_value bit to reach the maximum transfer rate.										
											
title	ia32_debugctl.freeze_perfmon_on_pmi is incorrectly cleared by smi										
problem	freeze_perfmon_on_pmi (bit 12) in the ia32_debugctl msr (1d9h) is erroneously cleared during delivery of an smi (system-management interrupt).										
implication	as a result of this erratum the performance monitoring counters will continue to count after a pmi occurs in smm (system-management mode).										
workaround	none identified.										
											
title	redirection of rsm to probe mode may not generate an lbr record										
problem	a redirection of the rsm instruction to probe mode may not generate the lbr (last branch record) record that would have been generated by a non-redirected rsm instruction.										
implication	the lbr stack may be missing a record when redirection of rsm to probe mode is used. The LBR stack will still properly describe the code flow of non-SMM code.										
workaround	none identified.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor or system bus master writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction prior to execution of the new code is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the intel architecture software developer's manual volume 3: system programming guide including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	in order to avoid this erratum programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3 system programming guide section handling self- and cross-modifying code.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	a page fault may not be generated when the ps bit is set to “1” in a pml4e or pdpte										
problem	on processors supporting intel® 64 architecture the ps bit (page size bit 7) is reserved in pml4es and pdptes. if the translation of the linear address of a memory access encounters a pml4e or a pdpte with ps set to 1 a page fault should occur. due to this erratum, ps of such an entry is ignored and no page fault will occur due to its being set.										
implication	software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.										
workaround	software should not set bit 7 in any pml4e or pdpte that has present bit (bit 0) set to “1”.										
											
title	some performance counter overflows may not be logged in ia32_perf_global_status when freeze_perfmon_on_pmi is enabled										
problem	when enabled, freeze_perfmon_on_pmi bit 12 in ia32_debugctl msr (1d9h) freezes pmcs (performance monitoring counters) on a pmi (performance monitoring interrupt) request by clearing the ia32_perf_global_ctrl msr (38fh). due to this erratum, when freeze_perfmon_on_pmi is enabled and two or more pmcs overflow within a small window of time and pmi is requested, then subsequent pmc overflows may not be logged in ia32_perf_global_status msr (38eh).										
implication	on a pmi, subsequent pmc overflows may not be logged in ia32_perf_global_status msr.										
workaround	re-enabling the pmcs in ia32_perf_global_ctrl will log the overflows that were not previously logged in ia32_perf_global_status.										
											
title	cs limit violations may not be detected after vm entry										
problem	the processor may fail to detect a cs limit violation on fetching the first instruction after vm entry if the first byte of that instruction is outside the cs limit but the last byte of the instruction is inside the limit.										
implication	the processor may erroneously execute an instruction that should have caused a general protection exception.										
workaround	when a vmm emulates a branch instruction it should inject a general protection exception if the instruction’s target eip is beyond the cs limit.										
											
title	pebs record eventingip field may be incorrect after cs.base change										
problem	due to this erratum a pebs (precise event base sampling) record generated after an operation which changes cs.base may contain an incorrect address in the eventingip field.										
implication	software attempting to identify the instruction which caused the pebs event may identify the incorrect instruction when non-zero cs.base is supported and cs.base is changed. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of movntdqa that loads from wc (write combining) memory may appear to pass an earlier locked instruction to a different cache line.										
implication	software that expects a lock to fence subsequent movntdqa instructions may not operate properly. if the software does not rely on locked instructions to fence the subsequent execution of movntdqa then this erratum does not apply.										
workaround	software that requires a locked instruction to fence subsequent executions of movntdqa should insert an lfence instruction before the first execution of movntdqa following the locked instruction. if there is already a fencing or serializing instruction between the locked instruction and the movntdqa, then an additional lfence is not necessary.										
											
title	performance monitor instructions retired event may not count consistently										
problem	performance monitor instructions retired (event c0h; umask 00h) and the instruction retired fixed counter (ia32_fixed_ctr0 msr (309h)) are used to track the number of instructions retired. due to this erratum, certain situations may cause the counter(s) to increment when no instruction has retired or to not increment when specific instructions have retired.										
implication	a performance counter counting instructions retired may over or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title											
problem	when freeze_lbrs_on_pmi flag (bit 11) in ia32_debugctl msr (1d9h) is set, the lbr (last branch record) stack is frozen on a hardware pmi (performance monitoring interrupt) request. when freeze_perfmon_on_pmi flag (bit 12) in ia32_debugctl msr is set, a pmi request clears each of the enable fields of the ia32_perf_global_ctrl msr (38fh) to disable counters. due to this erratum, when freeze_lbrs_on_pmi and/or freeze_perfmon_on_pmi is set in ia32_debugctl msr and the local apic is disabled or the pmi lvt is masked, the lbr stack and/or performance counters freeze on pmi may not function correctly.										
implication	performance monitoring software may not function properly if the lbr stack and performance counters freeze on pmi do not operate as expected. intel has not observed this erratum to impact any commercially available system.										
workaround	none identified.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable MSR. Intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	lpddr3 tinit0 duration may be longer than specification requirement										
problem	jedec standard jesd209-3 requires a maximum power ramp duration tinit0 of 20ms. due to this erratum, the soc may not comply with the tinit0 specification.										
implication	intel has not observed this erratum to impact the functionality or performance of any commercially available lpddr3 parts. intel has obtained waivers from vendors who provide commonly used lpddr3 dram parts.										
workaround	none identified.										
											
title	xhci usb2.0 split-transactions error counter reset issue										
problem	the xhci controller may not reset its split transaction error counter if a high-speed usb hub propagates a mal-formed bit from a low-speed or full-speed usb device exhibiting non-usb specification compliant signal quality.										
implication	the implication is device dependent. full speed and low speed devices behind the hub may be re-enumerated and may cause a device to not function as expected										
workaround	software driver can be modified to workaround this erratum. statusfor the steppings affected, see the summary table of changes.										
											
title	soc may not meet pcie* clock jitter specification										
problem	the soc’s pcie refclk signals may not meet pcie jitter specifications when operating at 5.0 gt/s with ssc (spread spectrum clocking) enabled.										
implication	the platform may not meet refclk jitter specification. intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	sata host controller does not pass certain compliance tests										
problem	the soc sata host controller oob (out of band) host responses, oob transmit gap, and oob transmit burst length do not pass serial ata interoperability program revision 1.4.3, unified test document version 1.01 tests oob-03[a/b], oob-05, and oob-06[a/b].										
implication	intel has obtained a waiver for these tests. intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	rtit trace may contain fup.far packet with incorrect address										
problem	the fup.far (flow update packet for far transfer) generated by rtit (real time instruction trace) on a far transfer instruction should contain the linear address of the first byte of the next sequential instruction after the far transfer instruction. due to this erratum, far transfer instructions with more than 3 prefixes may incorrectly include an address between the first byte of the far transfer instruction and the last byte of the far transfer instruction.										
implication	the rtit trace decoder may incorrectly decode the trace due to an incorrect address in the fup packet.										
workaround	the rtit trace decoder can identify a fup.far in the middle of a far transfer instruction and treat that fup.far as if it was coming from the first byte of the following sequential instruction.										
											
title	rtit fup.buffovf packet may be incorrectly followed by a tip packet										
problem	when rtit (real time instruction trace) suffers an internal buffer overflow, packet generation stops temporarily, after which a fup.buffovf (flow update packet for buffer overflow) is sent to indicate the lip that follows the instruction upon which tracing resumes. in some cases, however, this packet will be immediately followed by a fup.tip (flow update packet for target ip) which was generated by a branch instruction that executed during the overflow. the ip payload of this fup.tip will be the lip of the instruction upon which tracing resumes.										
implication	the spurious fup.tip packet may cause the rtit trace decoder to fail.										
workaround	the rtit trace decoder should ignore any fup.tip packet that immediately follows a fup.buffovf whose ip matches the ip payload of the fup.buffovf.										
											
title	rtit cyc packet payload values may be off by 1 cycle										
problem	when rtit (real time instruction trace) is enabled with rtit_ctl.cyc_acc msr (768h) bit 1 set to 1, all cyc (cycle count) packets have a payload value that is one less than the number of cycles that have actually passed. note that for cyc packets with a payload value of 0, the correct value may be 0 or 1.										
implication	the trace decoder will produce inaccurate performance data when using cyc packets to track software performance.										
workaround	as a partial workaround, the trace decoder should add 1 to the payload value of any cyc packet with a non-zero payload.										
											
title	first mtc packet after rtit enable may be incorrect										
problem	when rtit (real time instruction trace) is enabled, indicated by triggeren in bit 2 of the rtit_status msr (769h) transitioning from 0 to 1, the first mtc (mini time counter) packet may be sent at the wrong time.										
implication	the rtit trace decoder will make incorrect assumptions about the tsc value based on an asynchronous mtc packet.										
workaround	the rtit trace decoder should ignore the first mtc that follows trace enabling. statusfor the steppings affected, see the summary table of changes.										
											
title	usb device mode may not be functional when connected to usb1.x										
problem	device mode may not be functional when connected to usb 1.x host or hub.										
implication	due to this erratum, the soc in device mode may be unable to connect to usb 1.x host or hub.										
workaround	none identified..										
											
title	multiple drivers that access the gpio registers concurrently may result in unpredictable system behavior										
problem	the pcu (platform control unit) in soc may not be able to process concurrent accesses to the gpio registers. due to this sighting, read instructions may return 0xffffffff and write instructions may be dropped.										
implication	multiple drivers concurrently accessing gpio registers may result in unpredictable system behavior.										
workaround	it is possible for the display driver to contain a workaround for this erratum. statusfor the steppings affected, see the summary table of changes.										
											
title	power rail leakage at power on										
problem	at power on, leakage from the v1p05a power rail to the v1p8a power rail may result in raising the v1p8a rail to about 400mv prior to that rail being powered.										
implication	intel has not observed this erratum to impact the operation of any commercially available platform.										
workaround	none identified.										
											
title	pcie* refclk drivers remain enabled in sx states										
problem	in sx states, the pcie refclk (clk_diff_n [0:3]) signals stay at 1.05v level instead of shutting off completely.										
implication	intel has observed a worst case leakage of about 6mw per clock pair during sx states for each connected pcie device. intel has not observed any functional failures as a result of this erratum.										
workaround	none identified.										
											
title	sd card / sdio controller preset_value does not change transfer frequency										
problem	the preset_value (cmd12_err_stat_host_ctrl_2 csr at bus 0; device 18; function 0; mmio offset 3ch, bit 31) does not change the sd card/ sdio bus transfer frequency as required by the sd host controller standard specification version 3.0.										
implication	drivers that attempt to utilize preset_value may not obtain the maximum transfer rate of an attached uhs sd card or sdio bus.										
workaround	software should set the uhs_mode field (bits [1816] of the cmd12_err_stat_host_ctrl_2 csr) before setting the preset_value bit to reach the maximum transfer rate.										
											
title	incorrect detection of usb lfps may lead to usb 3.0 link errors										
problem	the usb 3.0 host controller may incorrectly detect lfps (low frequency periodic signal) on certain soc parts.										
implication	when this erratum occurs, the usb 3.0 host controller may not enumerate the link or may encounter unrecoverable errors during operation.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	usb high speed links may disconnect when subject to eft events										
problem	when subjected to eft (electric fast transient) events, the xhci host controller usb When subjected to EFT (Electric Fast Transient) events, the xHCI host controller USB										
implication	when this erratum occurs, the usb high speed device may be falsely disconnected.										
workaround	none identified.										
											
title	xhci usb controller may not resume after s3 exit problem										
problem											
implication											
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	lpc serr generation can not be independently disabled										
problem	lpc serr# events are incorrectly propagated to trigger the nmi interrupt when the see field of the pcie_reg_command register (bus 0; device 31; function 0; offset 4h) is cleared. this erratum only affects systems with attached lpc devices that signal serr# events.										
implication	serr for lpc cannot be disabled using pcie_reg_command see bit. serr# is used on the lpc bus to carry the legacy isa iochk# parity error indication.										
workaround	none identified. software can clear nsc (nmi status and control) msr (bus 0; device 31; function 0; offset 61h) sne field to disable serr for both nmi and lpc.										
											
title	some rtit packets following psb may be sent out of order or dropped										
problem	when a complex micro-architectural condition occurs concurrently with the generation of a rtit (real-time instruction trace) psb (packet stream boundary) packet, the packets that immediately follow the psb could precede or overwrite some older packets. this erratum applies to no more than 21 packets immediately following the psb.										
implication	the rtit packet output immediately following a psb may not accurately reflect software behavior, and may result in an rtit decoder error.										
workaround	none identified.										
											
title	system may hang when ddr dynamic self-refresh is enabled										
problem	the system may hang when ddr dynamic self-refresh is enabled.										
implication	when this erratum occurs, the system hangs. a cold reset is required to recover the system.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	usb3 phy may become unreliable on certain soc parts										
problem	when the system enters s0i3 sleep state, the contents of usb3 phy configuration registers may change sometimes.										
implication	due to this erratum, the usb3 device connected to the port may not be detected or the port may downgrade to usb2 speed.										
workaround	it is possible for bios to contain a workaround for this erratum. statusfor the steppings affected, see the summary table of changes.										
											
title	system may experience inability to boot or may cease operation										
problem	under certain conditions where activity is high for several years the lpc, rtc and sd card may stop functioning in the outer years of use.										
implication	lpc and rtc circuitry that stops functioning may cause operation to cease or inability to boot. sd card that stops functioning may cause sd cards to be unrecognized. intel has only observed this behavior in simulation. designs that implement the lpc interface at the 1.8v signal voltage are not affected by the lpc part of this erratum.										
workaround	firmware code changes for lpc and rtc circuitry and mitigations for sd card circuitry have been identified and may be implemented for this erratum.										
											
title	xhci host controller reset may lead to system hang										
problem	an access to xhci configuration space within 1ms of setting the xhci hcrst (host controller reset) bit of the usb command register (xhcibar, offset 80h, bit [1]) or a second setting of the hcrst bit within 120ms may cause the xhci host controller to fail to respond.										
implication	due to this erratum, the system may hang.										
workaround	software must not access xhci configuration space within 1ms or set hcrst bit within 120ms of setting the hcrst bit.										
											
title	processor may not wake from c6 or deeper sleep state										
problem	the processor may not wake after a sleep state entered with mwait target c-state of c6 and sub c-state of 2 or a target c-state deeper than c6 is requested.										
implication	when this erratum occurs, the system may hang.										
workaround	it is possible for the firmware to contain a workaround for this erratum. statusfor the steppings affected, see the summary table of changes.										
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms.  however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s.  subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title	monitor or clflush on the local xapic's address space results in hang										
problem	if the target linear address range for a monitor or clflush is mapped to the local xapic's address space, the processor will hang.										
implication	when this erratum occurs, the processor will hang. the local xapic's address space must be uncached. the monitor instruction only functions correctly if the specified linear address range is of the type write-back. clflush flushes data from the cache. intel has not observed this erratum with any commercially available software.										
workaround	do not execute monitor or clflush instructions on the local xapic address space.										
											
title	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang										
problem	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).										
implication	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.										
workaround	none identified.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	freeze_while_smm does not prevent event from pending  pebs during smm										
problem	in general, a pebs record should be generated on the first count of the event after the counter	has	overflowed.	however,	ia32_debugctl_msr.freeze_while_smm (msr 1d9h,  bit [14])  prevents performance  counters from counting  during  smm (system management mode). due to this erratum, if 1.a performance counter overflowed before an smi 2.a pebs record has not yet been generated because another count of the event has not occurred 3.the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.						
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.										
workaround	none identified.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	changing the memory type for an in-use page translation may lead to memory-ordering violations										
problem	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.										
implication	memory ordering may be violated. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure pages are not being actively used before requesting their memory type be changed.										
											
title	performance monitor precise instruction retired event may present wrong indications										
problem	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).										
implication	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.										
workaround	the sampling driver should avoid using sav<100.										
											
title	cr0										
problem	if cr0.cd=1, the mtrrs and pat should be ignored and the uc memory type should be used for all memory accesses. due to this erratum, a logical processor in vmx operation will operate as if cr0.cd=0 even if that bit is set to 1.										
implication	algorithms that rely on cache disabling may not function properly in vmx operation.										
workaround	algorithms that rely on cache disabling should not be executed in vmx root operation.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	processor may fail to acknowledge a tlp request										
problem	when a pcie root port’s receiver is in receiver l0s power state and the port initiates a recovery event, it will issue training sets to the link partner. the link partner will respond by initiating an l0s exit sequence. prior to transmitting its own training sets, the link partner may transmit a tlp (transaction layer packet) request. due to this erratum, the root port may not acknowledge the tlp request.										
implication	after completing the recovery event, the pcie link partner will replay the tlp request. the link partner may set a correctable error status bit, which has no functional effect.										
workaround	none identified.										
											
title	interrupt from local apic timer may not be detectable while being  delivered										
problem	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.										
implication	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.										
workaround	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.										
											
title	pcie* root-port initiated compliance state transmitter equalization settings may be incorrect										
problem	if the processor is directed to enter pcie polling.compliance at 5.0 gt/s or 8.0 gt/s transfer rates, it should use the link control 2 compliance preset/de-emphasis field (bits [15:12]) to determine the correct de-emphasis level. due to this erratum, when the processor is directed to enter polling.compliance from 2.5 gt/s transfer rate, it retains 2.5 gt/s de-emphasis values.										
implication	the processor may operate in polling.compliance mode with an incorrect transmitter de-emphasis level.										
workaround	none identified.										
											
title	pcie* controller may incorrectly log errors on transition to rxl0s										
problem	due to this erratum, if a link partner transitions to rxl0s state within 20 ns of entering l0 state, the pcie controller may incorrectly log an error in “correctable error status.receiver error status” field (bus 0, device 2, function 0, 1, 2 and device 6, function 0, offset 1d0h, bit 0).										
implication	correctable receiver errors may be incorrectly logged.	intel has not observed any functional impact due to this erratum with any commercially available add-in cards.									
workaround	none identified.										
											
title	unused pcie* lanes may report correctable errors										
problem	due to this erratum, during pcie* link down configuration, unused lanes may report a correctable error detected in bus 0, device 1, function 0-2, and device 6, function 0, offset 158h, bit 0.										
implication	correctable errors may be reported by a pcie controller for unused lanes.										
workaround	none identified.										
											
title	pcie root port may not initiate link speed change										
problem	the pcie base specification requires the upstream component to maintain the pcie link at the target link speed or the highest speed supported by both components on the link, whichever is lower. pcie root port will not initiate the link speed change without being triggered by the software when the root port maximum link speed is configured to be 5.0 gt/s. system bios will trigger the link speed change under normal boot scenarios. however, bios is not involved in some scenarios such as link disable/re- enable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. this erratum does not affect the ability of the downstream component to initiate a link speed change. all known 5.0gb/s-capable pcie downstream components have been observed to initiate the link speed change without relying on the root port to do so.										
implication	due to this erratum, the pcie root port may not initiate a link speed change during some hardware scenarios causing the pcie link to operate at a lower than expected speed. intel has not observed this erratum with any commercially available platform.										
workaround	none identified.										
											
title											
problem											
implication											
workaround	none identified.										
											
title	dr6 ss is followed by a store or an mmx instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction  boundary  following  the  next  instruction  is  reached.  after  the  debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (i.e., following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	vex 										
problem	the vex.l bit should be ignored for the vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions, however due to this erratum the vex.l bit is not ignored and will cause a #ud.										
implication	unexpected #uds will be seen when the vex.l bit is set to 1 with vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions.										
workaround	software should ensure that the vex.l bit is set to 0 for all scalar instructions.										
											
title	pcie* atomic transactions from two or more pcie controllers may cause starvation										
problem	on a processor pcie controller configuration in which two or more controllers receive concurrent atomic transactions, a pcie controller may experience starvation which eventually can lead to a completion timeout.										
implication	atomic transactions from two or more pcie controllers may lead to a completion timeout. atomic transactions from only one controller will not be affected by this erratum. intel has not observed this erratum with any commercially available device.										
workaround	none identified.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in  the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	pcie* controller may initiate speed change while in dl_init state causing certain pcie devices to fail to train										
problem	the pcie controller supports hardware autonomous speed change capabilities. due to this erratum, the pcie controller may initiate speed change while in the dl_init state which may prevent link training for certain pcie devices.										
implication	certain pcie devices may fail to complete dl_init causing the pcie link to fail to train.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	spurious vt-d interrupts may occur when the pfo bit is set										
problem	when the pfo (primary fault overflow) field (bit [0] in the vt-d fsts [fault status] register) is set to 1, further faults should not generate an interrupt. due to this erratum, further interrupts may still occur.										
implication	unexpected invalidation queue error interrupts may occur. intel has not observed this erratum with any commercially available software.										
workaround	software should be written to handle spurious vt-d fault interrupts.										
											
title	processor may livelock during on demand clock modulation										
problem	the processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the ia32_clock_modulation msr (19ah) and the clock modulation duty cycle is set to 12.5% (02h in bits 3:0 of the same msr), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access uc memory.										
implication	program execution may stall on both threads of the core subject to this erratum.										
workaround	this erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the ia32_clock_modulation msr is 18.75% or higher.										
											
title											
problem											
implication	ia32_mc2_status.over may not accurately indicate multiple occurrences of uncorrectable internal parity errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	performance monitor events other_assists other_assists.sse_to_avx may over count										
problem	the performance monitor events other_assists.avx_to_sse (event c1h; umask 08h) and other_assists.sse_to_avx (event c1h; umask 10h) incorrectly increment and over count when an hle (hardware lock elision) abort occurs.										
implication	the performance monirtor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count.										
workaround	none identified.										
											
title	performance monitor event dsb2mite_switches count										
problem	the performance monitor event dsb2mite_switches.count (event abh; umask 01h) should count the number of dsb (decode stream buffer) to mite (macro instruction translation engine) switches. due to this erratum, the dsb2mite_switches.count event will count speculative switches and cause the count to be higher than expected.										
implication	the performance monitor event dsb2mite_switches.count may report count higher than expected.										
workaround	none identified. 										
											
title	timed mwait may use deadline of a previous execution										
problem	a timed mwait instruction specifies a tsc deadline for execution resumption. if a wake event causes execution to resume before the deadline is reached, a subsequent timed mwait instruction may incorrectly use the deadline of the previous timed mwait when that previous deadline is earlier than the new one.										
implication	a timed mwait may end earlier than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding										
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9 any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9 write all vmcs fields may omit one field.										
workaround	none identified.										
											
title	incorrect from_ip value for an rtm abort in btm or bts may be observed										
problem	during rtm (restricted transactional memory) operation when branch tracing is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.										
implication	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.										
workaround	none identified.										
											
title	locked load performance monitoring events may under count										
problem	the  performance  monitoring  events  mem_trans_retired.load_latency  (event cdh;  umask  01h),  mem_load_retired.l2_hit  (event  d1h;  umask  02h),  and mem_uops_retired.locked (event doh; umask 20h) should count the number of locked  loads.  due  to  this  erratum,  these  events  may  under  count  for  locked transactions that hit the l2 cache.										
implication	the above event count will under count on locked loads hitting the l2 cache.										
workaround	none identified.										
											
title	transactional abort may produce an incorrect branch record										
problem	if an intel® tsx transactional abort event occurs during a string instruction, the from- ip in the lbr (last branch record) is not correctly reported.										
implication	due to this erratum, an incorrect from-ip on the lbr stack may be observed.										
workaround	none identified.										
											
title	smram state-save area above the 4gb boundary may cause unpredictable system behavior										
problem	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	ensure that the smram state-save area is located entirely below the 4gb address boundary.										
											
title	pmi may be signaled more than once for performance monitor counter overflow										
problem	due to this erratum, pmi (performance monitoring interrupt) may be repeatedly issued until the counter overflow bit is cleared in the overflowing counter.										
implication	multiple pmis may be received when a performance monitor counter overflows.										
workaround	none identified. if the pmi is programmed to generate an nmi, software may delay the eoi (end-of- interrupt) register write for the interrupt until after the overflow indications have been cleared.										
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not-available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	intel® turbo boost technology may be incorrectly reported as										
problem	mobile intel® pentium® processors and mobile intel® celeron® processors celeron processors may incorrectly report support for intel turbo boost technology via cpuid.06h.eax bit 1.										
implication	the cpuid instruction may report turbo boost technology as supported even though the processor does not permit operation above the maximum non-turbo frequency.										
workaround	none identified.										
											
title	the sample/preload jtag command does not sample the display transmit signals										
problem	the display transmit signals are not correctly sampled by the sample/preload jtag command, violating the boundary scan specification (ieee 1149.1). 										
implication	the sample/preload command cannot be used to sample display transmit signals.										
workaround	none identified.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	for the steppings affected, see the summary table of changes. chap counter values may be cleared after package c7 or deeper c-state										
problem	the chap (chipset hardware architecture performance) counters which do not have a "start" opcode present in the cmd register will not be preserved across a package c7 or deeper c-state.										
implication	chap counter data is not saved/restored after package c7 or deeper c-state causing counts to be lost; actions based on those counts may not occur as expected.										
workaround	none identified.										
											
title	opcode bytes f3 0f bc may execute as tzcnt even when tzcnt not enumerated by cpuid										
problem	if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 then opcode bytes f3 0f bc should be interpreted as tzcnt otherwise they will be interpreted as rep bsf. due to this erratum, opcode bytes f3 0f bc may execute as tzcnt even if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 0.										
implication	software that expects rep prefix before a bsf instruction to be ignored may not operate correctly since there are cases in which bsf and tzcnt differ with regard to the flags that are set and how the destination operand is established.										
workaround	software should use the opcode bytes f3 0f bc only if cpuid.(eax=07h, ecx=0)										
											
title	back to back updates of the vt-d root table pointer may lead to an unexpected dma remapping fault										
problem	a vt-d (intel® virtualization technology for directed i/o) root table pointer update that completes followed by a second root table pointer update that also completes, without performing a global invalidation of either the context-cache or the iotlb between the two updates, may lead to an unexpected dma remapping fault. july 2017 5th generation intel® core and m- processor families, mobile intel® pentium® and celeron® processor families 27										
implication	back to back root table pointer updates may cause an unexpected dma remapping fault. intel has not observed this erratum with any commercially available software.										
workaround	software must not perform a second root table pointer update before doing a global invalidation of either the context-cache or the iotlb.										
											
title	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation										
problem	if ept (extended page tables) is enabled, a mov to cr3 or vmfunc may be followed by an unexpected page fault or the use of an incorrect page translation.										
implication	guest software may crash or experience unpredictable behavior as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peer io device writes to the gmadr may lead to a system hang										
problem	the system may hang when a peer io device uses the peer aperture to directly write into the gmadr (graphics memory address range).										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	spurious corrected errors may be reported										
problem	due this erratum, spurious corrected errors may be logged in the ia32_mc0_status register with the valid field (bit 63) set, the uncorrected error field (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.										
implication	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.										
workaround	none identified.										
											
title	intel® pt packet generation may stop sooner than expected										
problem	setting the stop bit (bit 4) in a table of physical addresses entry directs the processor to stop intel pt (processor trace) packet generation when the associated output region is filled. the processor indicates this has occurred by setting the stopped bit (bit 5) of ia32_rtit_status msr (571h). due to this erratum, packet generation may stop earlier than expected.										
implication	when this erratum occurs, the outputoffset field [62 ia32_rtit_output_mask_ptrs msr (561h) holds a value that is less than the size of the output region which triggered the stop condition; intel pt analysis software should not attempt to decode packet data bytes beyond the outputoffset.										
workaround	none identified.										
											
title	pebs eventing ip field may be incorrect after not-taken branch 										
problem	when a pebs (precise-event-based-sampling) record is logged immediately after a not-taken conditional branch (jcc instruction), the eventing ip field should contain the address of the first byte of the jcc instruction. due to this erratum, it may instead contain the address of the instruction preceding the jcc instruction.										
implication	performance monitoring software using pebs may incorrectly attribute pebs events that occur on a jcc to the preceding instruction.										
workaround	none identified.										
											
title	reading the memory destination of an instruction that begins an hle transaction may return the original value										
problem	an hle (hardware lock elision) transactional region begins with an instruction with the xacquire prefix. due to this erratum, reads from within the transactional region of the memory destination of that instruction may return the value that was in memory before the transactional region began.										
implication	due to this erratum, unpredictable system behavior may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package c7 entry may cause display artifact										
problem	due to this erratum, package c7 entry may exceed published latencies.										
implication	when this erratum occurs, it is possible that isochronous requirements may not be met. intel has not observed this erratum to affect isochronous elements other than display.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® tsx instructions not available										
problem	intel tsx (transactional synchronization extensions) instructions are not supported and not reported by cpuid.										
implication	the intel tsx feature is not available.										
workaround	none identified.										
											
title	spurious corrected errors may be reported										
problem	due this erratum, spurious corrected errors may be logged in the mc0_status register with the valid (bit 63) set, the uncorrected error (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.										
implication	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring event instr_retired redundant pebs records for an overflow										
problem	due to this erratum, the performance monitoring feature pdir (precise distribution of instructions retired) for instr_retired.all (event c0h; umask 01h) will generate redundant pebs (precise event based sample) records for a counter overflow. this can occur if the lower 6 bits of the performance monitoring counter are not initialized or reset to 0, in the pebs counter reset field of the ds buffer management area.										
implication	the performance monitor feature pdir, may generate redundant pebs records for an overflow.										
workaround	initialize or reset the counters such that lower 6 bits are 0.										
											
title	concurrent core and graphics operation at turbo ratios may lead to system hang										
problem	workloads that attempt concurrent operation of cores and graphics in their respective turbo ranges, under certain conditions may result in a system hang.										
implication	concurrent core and graphics operation may hang the system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the system may hang on first package c6 or deeper c-state										
problem	under certain conditions following a cold boot, exiting the first package c6 or deeper c- state may hang the system.										
implication	due to this erratum, the system may hang exiting a package c6 or deeper c-state.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	svm doorbells are not correctly preserved across package c-states										
problem	svm (shared virtual memory) doorbell registers are incorrectly preserved across package c-states (c7 and deeper).										
implication	due to this erratum, software that uses svm may experience unreliable behavior from the graphics device.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	using the fivr spread spectrum control mailbox may not produce the requested range										
problem	values programmed into the fivr ssc (fully integrated voltage regulator spread spectrum control) mailbox may not result in the expected spread spectrum range.										
implication	the actual fivr spread spectrum range may not be the same as the programmed values affecting the usefulness of fivr ssc mailbox as a means to reduce emi (electromagnetic interference).										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	intel® processor trace (intel® pt) mode  are not generated as expected										
problem	the  intel®  pt  mode.exec  (mode  packet  –  execution  mode  leaf),  pip  (paging information packet), and cbr (core:bus ratio) packets are generated at the following psb+ (packet stream boundary) event rather than at the time of the originating event as expected.										
implication	the decoder may not be able to properly disassemble portions of the binary or interpret portions of the trace because many packets may be generated between the mode.exec, pip, and cbr events and the following psb+ event.										
workaround	the processor inserts these packets as status packets in the psb+ block. the decoder may have to skip forward to the next psb+ block in the trace to obtain the proper updated information to continue decoding.										
											
title	performance monitor instructions retired event may not count consistently										
problem	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.										
implication	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	general-purpose performance counters may be inaccurate with any thread										
problem	the ia32_pmcx msr (c1h - c8h) general-purpose performance counters may report inaccurate counts when the associated event selection ia32_perfevtselx msr’s (186h - 18dh) anythread field (bit 21) is set and either the os field (bit 17) or usr field (bit 16) is set (but not both set).										
implication	due to this erratum, ia32_pmcx counters may be inaccurate.										
workaround	none identified										
											
title	glitches on internal voltage planes during package c9/c10 exit may cause a system hang										
problem	internally generated processor voltage planes may exhibit unexpected voltage glitches during a package c9/c10 exit.										
implication	when this erratum occurs, the system may hang. intel has not observed this erratum with any commercially available system.										
workaround	it is possible for bios to contain a workaround for this erratum										
											
title											
problem											
implication											
workaround	if software enables intel® pt in system-management mode, it should disable intel® pt before executing rsm.										
											
title	intel® processor trace pip may be unexpectedly generated										
problem	when intel® processor trace (intel® pt) is enabled, psb+ (packet stream boundary) packets may include a pip (paging information packet) even though the os field (bit 2) of ia32_rtit_ctl msr (570h) is 0.										
implication	when this erratum occurs, user-mode tracing (indicated by ia32_rtit_ctl.os = 0) may include cr3 address information. this may be an undesirable leakage of kernel information.										
workaround	it is possible for bios to contain a workaround for this erratum										
											
title	a #ve may not invalidate cached translation information										
problem	an ept (extended page table) violation that causes a #ve (virtualization exception) may not invalidate the guest-physical mappings that were used to translate the guest-physical address that caused the ept violation.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	frequent entries into package c8, c9, or c10 may cause a hang 										
problem	it is possible for the processor to signal a machine check exception when deep packages c-states, c8, c9, or c10, are entered too frequently, typically less than 200us apart. the processor will not be able to process the machine check and will hang.										
implication	due to this erratum, the processor may signal a machine check exception (ia32_mci_status.mccod = 0x0400) and the processor will hang.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	some performance monitor events may overcount during tlb misses										
problem	the following performance monitor events may significantly overcount when multiple tlb misses happen nearly concurrently: 1.itlb_misses (event 85h, umask 01h, 02h, 04h, 08h, 10h) 2.dtlb_load_misses (event 08h, umask 01h, 02h, 04h, 08h, 10h) 3.dtlb_store_misses (event 49h, umask 01h, 02h, 04h, 08h, 10h) 4.page_walker_loads (event bch, all umasks)										
implication	when this erratum occurs, counts accumulated for the listed events may significantly exceed the correct counts.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® processor trace psb+ packets may contain unexpected packets										
problem	some intel processor trace packets should be issued only between tip.pge (target ip packet.packet generation enable) and tip.pgd (target ip packet.packet generation disable) packets. due to this erratum, when a tip.pge packet is generated it may be preceded by a psb+ (packet stream boundary) that incorrectly includes fup (flow update packet) and mode.exec packets.										
implication	due to this erratum, fup and mode.exec may be generated unexpectedly.										
workaround	decoders should ignore fup and mode.exec packets that are not between tip.pge and tip.pgd packets.										
											
title	writing non-zero value to ia32_rtit_cr3_match [63:48] will cause #gp										
problem	bits [63 reserved and therefore writing non-zero values to them will cause a #gp										
implication	due  to  this  erratum,  a  #gp  fault  will  occur  if  a  non-zero  value  is  written  to ia32_rtit_cr3_match[63:48].										
workaround	software should avoid writing non-zero values to bits [63 ia32_rtit_cr3_match msr.										
											
title	core c6 may cause interrupts to be serviced out of order										
problem	if the apic isr (in-service register) indicates in-progress interrupt(s) at core c6 entry, a lower priority interrupt pending in the irr (interrupt request register) may be executed after core c6 exit, delaying completion of the higher priority interrupt’s service routine.										
implication	an interrupt may be processed out of its intended priority order immediately after core c6 exit.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	the display may not resume correctly after package c8-c10 exit										
problem	display configuration is not properly restored after a package c8-c10 exit.										
implication	the display engine may not function correctly after package c8-c10 exit leading to an incorrect display.										
workaround	it is possible for bios to contain a workaround for this erratum										
											
title	lpddr3 memory training may cause platform boot failure										
problem	due to this erratum, lpddr3 memory sub-systems may not successfully complete training.										
implication	when this erratum occurs, the platform may fail to boot successfully										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	aggressive ramp down of voltage may result in unpredictable behavior										
problem	aggressive ramp down of vcc voltage may result in insufficient voltage to meet power demand.										
implication	due to this erratum, unpredictable system behavior or hangs may be observed.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitor event for outstanding offcore requests and snoop requests may be incorrect										
problem	the performance monitor event offcore_requests_outstanding (event 60h, any umask value) should count the number of offcore outstanding transactions each cycle. due to this erratum, the counts may be higher or lower than expected.										
implication	the performance monitor event offcore_requests_outstanding may reflect an incorrect count.										
workaround	none identified.										
											
title	dr6 register may contain an incorrect value when a mov to ss or  pop ss instruction is followed by an xbegin instruction										
problem	if xbegin is executed immediately after an execution of mov to ss or pop ss, a transactional abort occurs and the logical processor restarts execution from the fallback instruction address. if execution of the instruction at that address causes a debug exception, bits [3:0] of the dr6 register may contain an incorrect value.										
implication	when the instruction at the fallback instruction address causes a debug exception, dr6 may report a breakpoint that was not triggered by that instruction, or it may fail to report a breakpoint that was triggered by the instruction.										
workaround	avoid  following  a  mov  ss  or  pop  ss  instruction  immediately  with  an  xbegin instruction.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated after a uc error is logged										
problem	when a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to update the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated after a uc error is logged.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	processor may incorrectly enter into package-c states c8, c9, or c10										
problem	the processor may not fully honor all ltr (latency tolerance register) values when selecting the package c-state level.										
implication	due to this erratum, the exit latency of an incorrect package c-state may lead to media artifacts such as audio glitching. intel has not observed this erratum with any commercially available software										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain llc frequency changes may result in unpredictable system behavior										
problem	a large frequency or voltage change for the llc (last level cache) and associated logic can lead to unpredictable system behavior										
implication	due to this erratum, unpredictable system behavior may be observed.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	operand-size override prefix causes 64-bit operand form of movbe instruction to cause a #ud										
problem	execution of a 64 bit operand movbe instruction with an operand-size override instruction prefix (66h) may incorrectly cause an invalid-opcode exception (#ud).										
implication	a movbe instruction with both rex.w=1 and a 66h prefix will unexpectedly cause an invalid-opcode exception (#ud). intel has not observed this erratum with any commercially available software.										
workaround	do not use a 66h instruction prefix with a 64-bit operand movbe instruction.										
											
title	processor operation at turbo frequencies above 3 the processor to hang										
problem	the processor may not run reliably when operating at turbo frequencies above 3.2 ghz.										
implication	due to this erratum, the processor may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ddr-1600 with a reference clock of 100 mhz may cause s3 entry failure										
problem	due to this erratum, platform state s3 entry with a ddr-1600 memory subsystem may cause the ddr reference clock, when configured at 100 mhz, to briefly switch to 133 mhz resulting in unpredictable system behavior.										
implication	when this erratum occurs, the system may experience unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	popcnt instruction may take longer to execute than expected										
problem	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.										
implication	software using the popcnt instruction may experience lower performance than expected.										
workaround	none identified.										
											
title	system may hang or video may be distorted after graphics rc6 exit										
problem	in a specific scenario, when the processor graphics exits rc6 and a processor core exits c6 at the same time, the system may become unresponsive or the video may become distorted.										
implication	the system may hang or video may be distorted.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain edp* displays may not function as expected 										
problem	when the processor attempts to receive data on the edp aux bus, the impedance seen by the display’s aux bus drivers will be significantly below the vesa* edp* (embedded displayport*) specification’s requirement for the vaux(rx) (edp auxiliary channel) input impedance.										
implication	certain edp displays may not operate as expected.										
workaround	none identified.										
											
title	instruction fetch power saving feature may cause unexpected instruction execution										
problem	under a complex set of micro-architectural conditions, an instruction fetch dynamic power savings feature may cause the processor to execute unexpected instructions.										
implication	when this erratum occurs, instances of unexpected #gp (general protection fault) or #pf (page fault) have been observed. unexpected faults may lead to an application or operating system crash.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	c8 or deeper sleep state exit may result in an incorrect hdcp key										
problem	the hdcp (high-bandwidth digital content protection) key may be incorrect after a package c8 or deeper sleep state exit.										
implication	when this erratum occurs, drm (digital rights management) video playback may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia core ratio change coincident with outstanding read to the de may cause a system hang										
problem	an outstanding read from an ia core to the de (display engine) that is coincident with an ia core ratio change may result in a system hang.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ddr1600 clocking marginality may lead to unpredictable system behavior										
problem	the memory controller’s ddr clock, when operating at ddr1600 frequencies and at elevated temperatures, may not operate within tolerance and may lead to unpredictable system behavior.										
implication	due to this erratum, unpredictable system behavior may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package c9/c10 exit may cause a system hang										
problem	certain processors may not reliably exit package c9/c10 states.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	pl3 power limit control mechanism may not release frequency restrictions										
problem	the  pl3  mechanism  imposes  peak  frequency  constraints  on  all  domains  (core, graphics, and ring) when a current spike that might cause accelerated battery aging is detected. due to this erratum, these constraints may not be released when the current spike has ended.										
implication	the processor clock frequencies may be unnecessarily limited.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	frequency difference between ia core(s) and ring domains may cause unpredictable system behavior										
problem	operating one or more of the ia (intel® architecture) cores at a frequency significantly higher than the ring operating frequency may cause unpredictable system behavior. intel has observed this erratum to occur when the software explicitly requests the ring and ia core(s) to operate at different frequencies or when ia core(s) are transitioning in and out of c-states with the ia core(s) operating at frequencies much higher than the ring frequency. exposure to this erratum may be increased when the ia cores run at or close to p0 p-state frequency.										
implication	due to this erratum, system may hang or experience unpredictable system behavior.										
workaround	it is possible for bios to contain processor a workaround for this erratum.										
											
title	i/o subsystem clock gating may cause a system hang										
problem	certain complex internal conditions and timing relationships during clock gating of the i/o subsystem may cause a system hang and may lead to a timeout machine check with an ia32_mci_status.mcacod of 0400h.										
implication	due to this erratum, the processor may hang and may report a machine check.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® trusted execution technology uses incorrect tpm 2  index handles										
problem	intel® txt (trusted execution technology) uses tpm (trusted platform module) 2.0 draft specification handles (indices) aux 01800003, ps 01800001, and po 01400003. those handles conflict with the released tcg (trusted computing group) “registry of reserved tpm 2.0 handles and localities”, version 1.0, revision 1.										
implication	txt tpm 2.0 handles may conflict with platform manufacturer or owner usage of tpm nv space. intel has not identified any functional impact due to this erratum.										
workaround	none identified.										
											
title	transitions through package c7 or deeper may result in a system hang										
problem	under certain conditions, entry into a package c7 or deeper c-state may result in a system hang on the subsequent c-state exit										
implication	due to this erratum, the processor may experience a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	page_walker_loads performance monitoring event may count incorrectly										
problem	due to this erratum, the page_walker_loads (event bch) performance monitoring event may overcount or may undercount										
implication	these performance monitoring events may not produce reliable results										
workaround	none identified.										
											
title	the system may hang when exiting from deep package c-states										
problem	when exiting from package c7-c10, the system may hang.										
implication	the system may hang when exiting from package c-states										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain local memory read/load retired perfmon events may undercount										
problem	due to this erratum, the local memory read/load retired perfmon events listed below may undercount.										
implication	the affected events may undercount, resulting in inaccurate memory profiles. intel has observed under counts by as much as 20%.										
workaround	none identified.										
											
title	the system may hang when executing a complex sequence of locked instructions										
problem	under certain internal timing conditions while executing a complex sequence of locked instructions, the system may hang										
implication	the system may hang while executing a complex sequence of locked instructions and cause an internal timeout error machine check (ia32_mci_status.mcacod=0400h).										
workaround	it is possible for the bios to contain a workaround for this problem.										
											
title	certain settings of vm-execution controls may result in incorrect linear-address translations										
problem	if vm exit occurs from a guest with primary processor-based vm-execution control “activate  secondary  controls”  set  to  0  and  the  secondary  processor-based  vm- execution control “enable vpid” set to 1, then after a later vm entry with vpid fully enabled (“activate secondary controls” and “enable vpid” set to 1), the processor may use stale linear address translations.										
implication	the processor may incorrectly translate linear addresses.  intel has not observed this erratum with any commercially available software.										
workaround	software should not enter a guest with “enable vpid” set to 1 when “activate secondary controls” is set to 0.										
											
title	an iret instruction that results in a task switch does not serialize  the processor										
problem	an iret instruction that results in a task switch by returning from a nested task does not serialize the processor (contrary to the software developer’s manual vol. 3 section titled "serializing instructions").										
implication	software which depends on the serialization property of iret during task switching may not behave as expected. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	none identified. software can execute an mfence instruction immediately prior to the iret instruction if serialization is needed.										
											
title	attempting concurrent enabling of intel® pt with lbr, bts, or btm results in a #gp										
problem	if lbr (last branch records), bts (branch trace store), or btm (branch trace messages) are enabled in the ia32_debugctl msr (1d9h), an attempt to enable intel pt (intel® processor trace) in ia32_rtit _ctl msr (570h) results in a #gp (general protection exception). (note that the btm enable bit in ia32_debugctl msr is named “tr”.) correspondingly, if intel pt was previously enabled when an attempt is made to enable lbr, bts, or btm, a #gp will occur.										
implication	an unexpected #gp may occur when concurrently enabling any one of lbr, bts, or btm with intel pt.										
workaround	none identified										
											
title	processor may hang when package c-states are enabled										
problem	when package c6 or deeper c-states are enabled, certain micro-architectural conditions during a c-state exit may cause the processor to hang.										
implication	due to this erratum, a system hang may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	setting traceen while clearing branchen in ia32_rtit_ctl causes a #gp										
problem	a wrmsr to ia32_rtit_ctl (msr 0570h) that sets traceen (bit 0) and clears branchen (bit 13) will cause a #gp (general protection exception)										
implication	intel® processor trace cannot be enabled without enabling control flow trace packets.										
workaround	none identified.										
											
title	processor graphics iommu unit may not mask dma remapping faults										
problem	intel® virtualization technology for directed i/o specification specifies setting the fpd (fault processing disable) field in the context (or extended-context) entry of iommu to mask recording of qualified dma remapping faults for dma requests processed through that context entry. due to this erratum, the iommu unit for processor graphics device may record dma remapping faults from processor graphics device (bus: 0; device: 2; function: 0) even when the fpd field is set to 1.										
implication	software may continue to observe dma remapping faults recorded in the iommu fault recording register even after setting the fpd field.										
workaround	none identified. software may mask the fault reporting event by setting the im (interrupt mask) field in the iommu fault event control register (offset 038h in gfxvtbar).										
											
title	processor graphics iommu unit may report spurious faults										
problem	the iommu unit for processor graphics pre-fetches context (or extended-context) entries to improve performance. due to the erratum, the iommu unit may report spurious dma remapping faults if prefetching encounters a context (or extended-context) entry which is not marked present.										
implication	software may observe spurious dma remapping faults when the present bit for the context (or extended-context) entry corresponding to the processor graphics device (bus										
workaround	none identified. instead of marking a context not present, software should mark the context (or extended-context) entry present while using the page table to indicate all the memory pages referenced by the context entry is not present.										
											
title	peci frequency limited to 1 mhz										
problem	the processor should ensure internal graphics configuration is restored during a package c7 or deeper exit event. due to this erratum, some internal graphics configurations may not be correctly restored.										
implication	when this erratum occurs, a graphics driver restart may lead to system instability. such a restart may occur when upgrading the graphics driver.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	reads or writes to lbrs with intel® pt enabled will result in a #gp										
problem	on processors where the use of intel pt (intel® processor trace) and lbrs (last branch records) are mutually exclusive, reads of the lbr msrs should return 0s and writes to them should be ignored. due to this erratum, reads and writes to the lbr msrs while ia32_rtit_ctl msr (570h) traceen bit 0 is 1 will result in a #gp.										
implication	when this erratum occurs, a #gp will occur. lbrs are not available when intel pt is enabled.										
workaround	none identified.										
											
title	graphics configuration may not be correctly restored after a package c7 exit 										
problem	the processor should ensure internal graphics configuration is restored during a package c7 or deeper exit event. due to this erratum, some internal graphics configurations may not be correctly restored.										
implication	when this erratum occurs, a graphics driver restart may lead to system instability. such a restart may occur when upgrading the graphics driver.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	mtf vm exit on xbegin instruction may save state incorrectly										
problem	execution of an xbegin instruction while the “monitor trap flag” vm-execution control is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save the address of the xbegin instruction as the instruction pointer (instead of the fallback instruction address specified by the xbegin instruction). in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.										
implication	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	back-to-back page walks due to instruction fetches may cause a system hang										
problem	multiple code fetches in quick succession that generate page walks may result in a system hang causing an internal timer error (an mcacod value of 0400h) logged into ia32_mci_status bits [15:0].										
implication	due to this erratum, the processor may hang and report a machine check.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pebs record may be generated after being disabled										
problem	a performance monitoring counter may generate a pebs (precise event based sampling) record after disabling pebs or the performance monitoring counter by clearing the corresponding enable bit in ia32_pebs_enable msr (3f1h) or ia32_perf_global_ctrl msr (38fh).										
implication	a pebs record generated after a vmx transition will store into memory according to the post-transition ds (debug store) configuration. these stores may be unexpected if pebs is not enabled following the transition.										
workaround	it is possible for the bios to contain a workaround for this erratum. a software workaround is possible through disallowing pebs during vmx non-root operation and disabling pebs prior to vm entry.										
											
title	some offcore_response performance monitoring events related to rfo request types may count incorrectly										
problem	the performance monitoring events offcore_response (events b7h and bbh) should count uncore responses matching the request-response configuration specified in msr_offcore_rsp_0 (1a6h) and msr_offcore_rsp_1 (1a7h) for core-originated requests. however, due to this erratum, response type no_supp bit [17] may be reported instead of local bit [26] for request types dmnd_rfo bit [1] and pf_rfo bit [5].										
implication	the specified performance monitoring events may count incorrectly.										
workaround	none identified.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	data breakpoint coincident with a machine check exception may be lost										
problem	if a data breakpoint occurs coincident with a machine check exception, then the data breakpoint may be lost.										
implication	due to this erratum, a valid data breakpoint may be lost.										
workaround	none identified.										
											
title	internal parity errors may incorrectly report overflow in the ia32_mc0_status msr										
problem	due to this erratum, an uncorrectable internal parity error with an ia32_mc0_status.mcacod (bits [15										
implication	ia32_mc0_status.over may not accurately indicate multiple occurrences of errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	an intel® hyper-threading technology enabled processor may exhibit internal parity errors or unpredictable system behavior										
problem											
implication											
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring counters may undercount when using cpl filtering										
problem	performance monitoring counters configured to count only os or only usr events by setting exactly one of bits 16 or 17 in ia32_perfevtselx msrs (186h-18dh) may not count for a brief period during the transition to a new cpl.										
implication	due to this erratum, performance monitoring counters may report counts lower than expected.										
workaround	none identified.										
											
title	pebs eventingip field may be incorrect under certain conditions										
problem	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.										
implication	a measurement of ring transitions (using the edge-detect bit 18 in ia32_perfevtselx) may  undercount,  such  as  cpl_cycles.ring0_trans  (event  5ch,  umask  01h). additionally, the sum of an os-only event and a usr-only event may not exactly equal an event counting both os and usr. intel has not observed any other software-visible impact.										
workaround	none identified.										
											
title	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts										
problem	after a fault due to a failed pebs (processor event based sampling) or bts (branch trace store) address translation, the rf (resume flag) may be incorrectly set in the eflags image that is saved.										
implication	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.										
workaround	software should always prevent faults on pebs or bts.										
											
title	some memory performance monitoring events may produce incorrect results when filtering on either os or usr modes										
problem	the memory at-retirement performance monitoring events (listed below) may produce incorrect results when a performance counter is configured in os-only or usr-only modes (bits 17 or 16 in ia32_perfevtselx msr). counters with both os and usr bits set are not affected by this erratum. the list of affected memory at-retirement events for bdw is as follows: mem_uops_retired.stlb_miss_loads event d0h, umask 11h mem_uops_retired.stlb_miss_stores event d0h, umask 12h mem_uops_retired.lock_loads event d0h, umask 21h  mem_uops_retired.split_loads event d0h, umask 41h mem_uops_retired.split_stores event d0h, umask 42h mem_load_uops_retired.l2_hit event d1h, umask 02h mem_load_uops_retired.l3_hit event d1h, umask 04h mem_load_uops_retired.l1_miss event d1h, umask 08h mem_load_uops_retired.l2_miss event d1h, umask 10h mem_load_uops_retired.l3_miss event d1h, umask 20h mem_load_uops_retired.hit_lfb event d1h, umask 40h mem_load_l3_hit_retired.xsnp_miss event d2h, umask 01h mem_load_l3_hit_retired.xsnp_hit event d2h, umask 02h mem_load_l3_hit_retired.xsnp_hitm event d2h, umask 04h mem_load_l3_hit_retired.xsnp_none event d2h, umask 08h mem_load_uops_l3_miss_retired.local_dram event d3h, umask 01h										
implication	the listed performance monitoring events may produce incorrect results including pebs records generated at an incorrect point.										
workaround	none identified.										
											
title	some dram and l3 cache performance monitoring events may undercount										
problem	due to this erratum, the supplier may be misattributed to unknown, and the following events may undercount: mem_load_uops_retired.l3_hit (event d1h umask 04h) mem_load_uops_retired.l3_miss (event d1h umask 20h) mem_load_uops_l3_hit_retired.xsnp_miss (event d2h umask 01h) mem_load_uops_l3_hit_retired.xsnp_hit (event d2h umask 02h) mem_load_uops_l3_hit_retired.xsnp_hitm (event d2h umask 04h) mem_load_uops_l3_hit_retired.xsnp_none (event d2h umask 08h) mem_load_uops_l3_miss_retired.local_dram (event d3h umask 01h) mem_trans_retired.load_latency (event cdh umask 01h)										
implication	the affected events may undercount, resulting in inaccurate memory profiles.for the affected events that are precise, pebs records may be generated at incorrect points. intel has observed incorrect counts by as much as 20%										
workaround	none identified										
											
title	an x87 store instruction which pends #pe while ept is enabled may  lead to an unexpected machine check and/or incorrect x87 state information										
problem	the execution of an x87 store instruction which causes a #pe (precision exception) to be pended and also causes a vm-exit due to an ept violation or misconfiguration may lead the vmm logging a machine check exception with a cache hierarchy error (ia32_mci_status.mcacod  =  0150h  and  ia32_mci_status.mscod  =  000fh). additionally, fsw.pe and fsw.es (bits 5 and 7 of the fpu status word) may be incorrectly set to 1, and the x87 last instruction opcode (fop) may be incorrect.										
implication	when this erratum occurs, the vmm may receive an expected machine check exception and software attempting to handle the #pe may not behave as expected.										
workaround	none identified										
											
title	general-purpose performance monitoring counters 4-7 do not count with usr mode only filtering										
problem	the ia32_pmc4-7 msr (c5h-c8h) general-purpose performance monitoring counters will not count when the associated cpl filter selection in ia32_perfevtselx msr's (18ah-18dh) usr field (bit 16) is set while os field (bit 17) is not set.										
implication	software depending upon ia32_pmc4-7 to count only usr events will not operate as expected. counting os only events or os and usr events together is unaffected by this erratum.										
workaround	none identified										
											
title	writing msr_lastbranch_x_from_ip may #gp when intel® tsx is not supported										
problem	due to this erratum, on processors that do not support intel tsx (intel® transactional synchronization extensions) (cpuid.07h.ebx bits 4 and 11 are both zero), writes to msr_lastbranch_x_from_ip (msr 680h to 68fh) may #gp unless bits[62:61] are equal to bit[47].										
implication	the value read from msr_lastbranch_x_from_ip is unaffected by this erratum; bits [62:61] contain in_tsx and tsx_abort information respectively. software restoring these msrs from saved values are subject to this erratum.										
workaround	before writing msr _lastbranch_x_from_ip, ensure the value being written has bit[47] replicated in bits[62										
											
title	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception										
problem	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.										
implication	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software or system.										
workaround	as recommended in the ia32 intel® architecture software developer’s manual, the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang										
problem	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).										
implication	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.										
workaround	none identified.										
											
title	changing the memory type for an in-use page translation may lead to memory-ordering violations										
problem	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.										
implication	memory ordering may be violated. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure pages are not being actively used before requesting their memory type be changed.										
											
title	code segment limit/canonical faults on rsm may be serviced before higher priority interrupts/exceptions and may push the wrong address onto the stack										
problem	normally, when the processor encounters a segment limit or canonical fault due to code execution, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. due to this erratum, if rsm (resume from system management mode) returns to execution flow that results in a code segment limit or canonical fault, the #gp fault may be serviced before a higher priority interrupt or exception (for example, nmi (non-maskable interrupt), debug break(#db), machine check (#mc), and so forth). if the rsm attempts to return to a non-canonical address, the address pushed onto the stack for this #gp fault may not match the non-canonical address that caused the fault.										
implication	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	debug exception flags dr6 breakpoints										
problem	when a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (dr7.g0-g3 and dr7.l0-l3), the dr6.b0-b3 flags may be incorrect.										
implication	the  debug  exception  dr6.b0-b3  flags  may  be  incorrect  for  the  load  if  the corresponding breakpoint enable flag in dr7 is disabled.										
workaround	none identified.										
											
title	dr6 may contain incorrect information when the first instruction after a mov ss,r/m or pop ss is a store										
problem	normally, each instruction clears the changes in dr6 (debug status register) caused by the previous instruction. however, the instruction following a mov ss,r/m (mov to the stack segment selector) or pop ss (pop stack segment selector) instruction will not clear the changes in dr6 because data breakpoints are not taken immediately after a mov ss,r/m or pop ss instruction. due to this erratum, any dr6 changes caused by a mov ss,r/m or pop ss instruction may be cleared if the following instruction is a store.										
implication	when this erratum occurs, incorrect information may exist in dr6. this erratum will not be observed under normal usage of the mov ss,r/m or pop ss instructions (that is, following them with an instruction that writes [e/r]sp). when debugging or when developing debuggers, this behavior should be noted.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	fault on enter instruction may result in unexpected values on stack frame										
problem	the enter instruction is used to create a procedure stack frame. due to this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (that is, residual stack data as a result of processing the fault).										
implication	data in the created stack frame may be altered following a fault on the enter instruction. please refer to “procedure calls for block-structured languages” in ia-32 intel®  architecture  software  developer’s  manual,  vol.  1,  basic  architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3.  faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	faulting mmx instruction may incorrectly update x87 fpu tag word										
problem	under a specific set of conditions, mmx stores (movd, movq, movntq, maskmovq) which cause memory access faults (#gp, #ss, #pf, or #ac), may incorrectly update the x87 fpu tag word register. this erratum will occur when the following additional conditions are also met. the mmx store instruction must be the first mmx instruction to operate on x87 fpu state (that is, the x87 fp tag word is not already set to 0x0000). for movd, movq, movntq stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to maskmovq).										
implication	if the erratum conditions are met, the x87 fpu tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.										
workaround	none identified.										
											
title	freeze_while_smm does not prevent event from pending pebs during smm										
problem	in general, a pebs record should be generated on the first count of the event after the counter has overflowed.  however, ia32_debugctl_msr.freeze_while_smm (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if: a performance counter overflowed before an smi a pebs record has not yet been generated because another count of the event has not occurred the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.										
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.										
workaround	none identified.										
											
title	general protection fault (#gp) for instructions greater than 15 bytes may be preempted										
problem	when the processor encounters an instruction that is greater than 15 bytes in length, a #gp is signaled when the instruction is decoded. under some circumstances, the #gp fault may be preempted by another lower priority fault (for example, page fault (#pf)). however, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #gp fault will occur.										
implication	software may observe a lower-priority fault occurring before or in lieu of a #gp fault. instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.										
workaround	none identified.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	io_smi indication in smram state save area may be set incorrectly										
problem	the io_smi bit in smram’s location 7fa4h is set to “1” by the cpu to indicate a system management interrupt (smi) occurred as the result of executing an instruction that reads from an i/o port. due to this erratum, the io_smi bit may be incorrectly set by: • a non-i/o instruction • smi is pending while a lower priority event interrupts • a rep i/o read • a i/o read that redirects to mwait										
implication	smm handlers may get false io_smi indication.										
workaround	the smm handler has to evaluate the saved context to determine if the smi was triggered by an instruction that read from an i/o port. the smm handler must not restart an i/o instruction if the platform has not been configured to generate a synchronous smi for the recorded i/o port address.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	mov to/from debug registers causes debug exception										
problem	when in v86 mode, if a mov instruction is executed to/from a debug registers, a general-protection exception (#gp) should be generated. however, in the case when the general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.										
implication	with debug-register protection enabled (that is, the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception will be generated instead of the expected general-protection fault.										
workaround	in general, operating systems do not set the gd bit when they are in v86 mode. the gd bit is generally set and used by debuggers. the debug exception handler should check that the exception did not occur in v86 mode before continuing. if the exception did occur in v86 mode, the exception may be directed to the general-protection exception handler.										
											
title	pebs record not updated when in probe mode										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflows of the counter can result in storage of a pebs record in the pebs buffer. due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new pebs record may not be added to the pebs buffer.										
implication	due to this erratum, the pebs buffer may not be updated by overflows that occur during probe mode.										
workaround	none identified.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53 uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53 will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	single step interrupts with floating point exception pending may be mishandled										
problem	in certain circumstances, when a floating point exception (#mf) is pending during single-step execution, processing of the single-step debug exception (#db) may be mishandled.										
implication	when this erratum occurs, #db will be incorrectly handled as follows • #db is signaled before the pending higher priority #mf (interrupt 16) • #db is generated twice on the same instruction										
workaround	none identified.										
											
title	storage of pebs record delayed following execution of mov ss or sti										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflow of the counter results in storage of a pebs record in the pebs buffer. the information in the pebs record represents the state of the next instruction to be executed following the counter overflow. due to this erratum, if the counter overflow occurs after execution of either mov ss or sti, storage of the pebs record is delayed by one instruction.										
implication	when this erratum occurs, software may observe storage of the pebs record being delayed by one instruction following execution of mov ss or sti. the state information in the pebs record will also reflect the one instruction delay.										
workaround	none identified.										
											
title	vm exits due to “nmi-window exiting” may be delayed by one instruction										
problem	if vm entry is executed with the “nmi-window exiting” vm-execution control set to 1, a vm exit with exit reason “nmi window” should occur before execution of any instruction if there is no virtual-nmi blocking, no blocking of events by mov ss, and no blocking of events by sti. if vm entry is made with no virtual-nmi blocking but with blocking of events by either mov ss or sti, such a vm exit should occur after execution of one instruction in vmx non-root operation. due to this erratum, the vm exit may be delayed by one additional instruction.										
implication	vmm software using “nmi-window exiting” for nmi virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual nmi, which is virtually asynchronous. the erratum may affect vmms relying on deterministic delivery of the affected vm exits.										
workaround	none identified.										
											
title	valuesforlbr/bts/btmwillbeincorrectafteranexitfromsmm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect. note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.										
workaround	none identified.										
											
title	vphminposuw instruction in vex format does not signal #ud (invalid opcode exception) when vex										
problem	processor does not signal #ud fault when executing the reserved instruction vphminposuw with vex.vvvv!=1111. the vphminposuw instruction is described in greater detail in the intel® advanced vector extensions programming reference.										
implication	executing vphminposuw with vex.vvvv != 1111 results in same behavior as vex.vvvv= 1111.										
workaround	sw should not use vphminposuw with vex.vvvv != 1111 in order to ensure future compatibility.										
											
title	vmread/vmwrite instruction may not fail when accessing an unsupported field in vmcs										
problem	the intel® 64 and ia-32 architectures software developer’s manual, volume 2b states that execution of vmread or vmwrite should fail if the value of the instruction’s register source operand corresponds to an unsupported field in the vmcs (virtual machine control structure). the correct operation is that the logical processor will set the zf (zero flag), write 0ch into the vm-instruction error field and for vmread leave the instruction’s destination operand unmodified. due to this erratum, the instruction may instead clear the zf, leave the vm-instruction error field unmodified and for vmread modify the contents of its destination operand.										
implication	accessing an unsupported field in vmcs will fail to properly report an error. in addition, vmread from an unsupported vmcs field may unexpectedly change its destination operand. intel has not observed this erratum with any commercially available software.										
workaround	software should avoid accessing unsupported fields in a vmcs.										
											
title	unexpected #ud on vzeroall/vzeroupper										
problem	execution of the vzeroall or vzeroupper instructions in 64-bit mode with vex.w set to 1 may erroneously cause a #ud (invalid-opcode exception).										
implication	the affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.										
workaround	compilers should encode vex.w = 0 for the vzeroall and vzeroupper instructions.										
											
title	execution of opcode 9bh with the vex opcode extension may produce a #nm exception										
problem	attempt to use opcode 9bh with a vex opcode extension should produce a #ud (invalid-opcode) exception. due to this erratum, if cr0.mp and cr0.ts are both 1, the processor may produce a #nm (device-not-available) exception if one of the following conditions exists 66h, f2h, f3h or rex as a preceding prefix; an illegal map specified in the vex.mmmmm field;										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should not use opcode 9bh with the vex opcode extension.										
											
title	an unexpected page fault or ept violation may occur after another logical processor creates a valid translation for a page										
problem	an unexpected page fault (#pf) or ept violation may occur for a page under the following conditions the paging structures initially specify no valid translation for the page. software on one logical processor modifies the paging structures so that there is a valid translation for the page (for example, by setting to 1 the present bit in one of the paging-structure entries used to translate the page). software on another logical processor observes this modification (for example, by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). shortly thereafter, software on that other logical processor performs a store to a linear address on the page. in this case, the store may cause a page fault or ept violation that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). intel has not observed this erratum with any commercially available software.										
implication	an unexpected page fault may be reported. there are no other side effects due to this erratum.										
workaround	system software can be constructed to tolerate these unexpected page faults. see section “propagation of paging-structure changes to multiple processors” of volume 3a of ia-32 intel® architecture software developer’s manual, for recommendations for software treatment of asynchronous paging-structure updates.										
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not-available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	unexpected #ud on vpextrd/vpinsrd										
problem	execution of the vpextrd or vpinsrd instructions outside of 64-bit mode with vex.w set to 1 may erroneously cause a #ud (invalid-opcode exception).										
implication	the affected instructions may produce unexpected invalid-opcode exceptions outside 64-bit mode.										
workaround	software should encode vex.w = 0 for executions of the vpextrd and vpinsrd instructions outside 64-bit mode.										
											
title	lbr, btm or bts records may have incorrect branch from information after an enhanced intel® speedstep technology/t-state/s-state/c1e transition or adaptive thermal throttling										
problem	the “from” address associated with the lbr (last branch record), btm (branch trace message) or bts (branch trace store) may be incorrect for the first branch after a transition of: • enhanced intel speedstep® technology • t-state (thermal monitor states) • s1-state (acpi package sleep state) • c1e (enhanced c1 low power state) • adaptive thermal throttling										
implication	when the lbrs, btm or bts are enabled, some records may have incorrect branch “from” addresses for the first branch after a transition of enhanced intel speedstep® technology, t-states, s-states, c1e, or adaptive thermal throttling.										
workaround	none identified.										
											
title	a write to the ia32_fixed_ctr1 msr may result in incorrect value in certain conditions										
problem	under specific internal conditions, if software tries to write the ia32_fixed_ctr1 msr (30ah) a value that has all bits [31:1] set while the counter was just about to overflow when the write is attempted (that is, its value was 0xffff ffff ffff), then due to this erratum the new value in the msr may be corrupted.										
implication	due to this erratum, ia32_fixed_ctr1 msr may be written with a corrupted value.										
workaround	software may avoid this erratum by writing zeros to the ia32_fixed_ctr1 msr, before the desired write operation.										
											
title	l1 data cache errors may be logged with level set to 1 instead of 0										
problem	when an l1 data cache error is logged in ia32_mci_status[15 error code field, with a cache error type of the format 0000 0001 rrrr ttll, the ll field may be incorrectly encoded as 01b instead of 00b.										
implication	an error in the l1 data cache may report the same ll value as the l2 cache. software should not assume that an ll value of 01b is the l2 cache.										
workaround	none identified.										
											
title	warm reset may leave the system in an invalid poisoning state and could cause the feature to be disabled										
problem	due to this erratum, the pcie poison forwarding enable and intel® quickpath interconnect (intel® qpi) poison enable bits are cleared by warm reset, but other bits related to the poisoning feature remain set. after the warm reset the system may be in an invalid state in regards to the poisoning bits. this invalid state may cause the feature to be disabled.										
implication	this invalid state may prevent the propagation of the poisoning indication, effectively disabling the feature.										
workaround	if poisoning is disabled, program the following bits to 0 after reset. if poisoning is enabled, program the following bits to 1 after reset the ia32_mcg_contain.poison_enable bit (msr 178h, bit 0). it should be noted that each thread must perform this action. the ia32_mcg_contain.poison_enable (msr 178h, bit 0). the poisfen bit (iiomiscctrl; cpubus(0); device 5; function 0; offset 1c0h; bit 37). the dmask bit (uncedmask; cpubus(0); device 0, 1, 2, 3; functions 0, 1, 2, 3; offset 218h; bit 12).										
											
title	vm entries that return from smm using vmlaunch may not update the launch state of the vmcs										
problem	successful vm entries using the vmlaunch instruction should set the launch state of the vmcs to “launched”. due to this erratum, such a vm entry may not update the launch state of the current vmcs if the vm entry is returning from smm.										
implication	subsequent vm entries using the vmresume instruction with this vmcs will fail. rflags.zf is set to 1 and the value 5 (indicating vmresume with non-launched vmcs) is stored in the vm-instruction error field. this erratum applies only if dual monitor treatment of smi and smm is active.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	interrupt from local apic timer may not be detectable while being delivered										
problem	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.										
implication	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.										
workaround	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.										
											
title	ia32_mci_addr overwritten in the case of multiple recoverable instruction fetch errors										
problem	the instruction fetch machine check error (mcacod 0x150) is a srar (software recoverable action required) error. the address of the location with the error is provided in the corresponding ia32_mci_addr msr. when multiple instruction fetch errors are logged as part of a single machine check event, as indicated by setting of the overflow (bit 62) in the ia32_mci_status msr, then recovery is not possible. due to this erratum, when multiple instruction fetch errors are logged in the same bank, the ia32_mci_misc msr contains all of the correct information including the proper setting for overflow (bit 62); however, the ia32_mci_addr msr is overwritten with a value that corresponds to neither the first or second error.										
implication	when debugging failures associated with the instruction fetch machine check error and the overflow bit is set, the value in ia32_mci_addr will not be valid.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the processor does not detect intel® quickpath interconnect (intel® qpi) rsvd_chk field violations										
problem	according to the intel qpi specification, if a target agent receives a packet with a non- zero  rsvd_chk  field,  it  should  flag  it  as  an  “intel  qpi  link  layer  detected unsupported/undefined” packet. due to this erratum, the processor does not check the rsvd_chk field nor report the expected error.										
implication	the processor will not flag the “intel qpi link layer detected unsupported/undefined” packet error in the case that the rsvd_chk field is non-zero.										
workaround	none identified.										
											
title	the intel qpi link status register linkinitstatus field incorrectly reports “internal stall link initialization” for certain stall conditions										
problem	the intel qpi link control register (cpubus(1), devices 8, 9; function 0; offset 0x44) bits 17 and 16 allow for the control of the link layer initialization by forcing the link to stall  the  initialization  process  until  cleared.  the  intel  qpi  link  status  register (cpubus(1), device 8, 9; function 0; offset 0x48) bits 27:24 report the link initialization status (linkinitstatus). the linkinitstatus incorrectly reports “internal stall link initialization” (0001b) for non-intel qpi link control register, bit[17,16] stall conditions. the intel qpi specification does not intend for internal stall conditions to report that status, but rather report the normal “waiting for physical layer ready” (0000b).										
implication	there is no known problem with this behavior since there is no usage model that relies on polling of the linkinitstatus state in the “waiting for physical layer ready” versus “internal stall link initialization” state, and it only advertises the “internal stall link initialization” state for a brief period of time during link layer initialization.										
workaround	none identified.										
											
title	intel qpi tx ac common mode fails specification										
problem	the intel qpi interface specification requires tx ac common mode (accm) to be between -50 mv to 50 mv at 8.0 gt/s. testing across process, voltage, and temperature showed that the accm exceeded the upper end of the specification on several lanes.										
implication	those performing an electrical characterization of the intel qpi interface may notice a violation of the upper end of the accm specification by no more than 5 mv.										
workaround	none identified.										
											
title	prochot_n assertion during warm reset may disable a processor via the frb mechanism										
problem	frb (fault resilient booting) is defined as the ability to boot even when one or more processors in the system fail, as long as there is one processor functional. if a warm reset is asserted during the boot flow before the intel qpi interface is enumerated and while a processor is hot and drives prochot_n, the processor that is driving prochot_n will mistakenly observe prochot_n as a signal to transition itself into frb mode.										
implication	it is possible that a processor may be incorrectly isolated via the frb mechanism if the same processor asserts prochot_n during a warm reset.										
workaround	case 1 case 1.1: legacy processor gets disabled: the system will not boot. the bmc can detect this case by observing that legacy socket is occupied, but the processor times out on peci ping() command. since bmc knows it did not disable legacy socket, it can assume this is an error case. case 1.2: non-legacy processor gets disabled: if system boots with one or more fewer sockets, bmc will observe a discrepancy between socket occupied pins and response to peci ping() command. if bmc did not disable the affected socket, it can conclude they were accidentally disabled due to this issue. the bmc can respond to either case by issuing a cold reset to the platform. case 2: systems without a bmc case 2.1: legacy socket gets disabled: this will prevent booting. the pch (platform control hub) tco logic can be strapped to reset the platform if the cpu does not fetch code after reset. case 2.2: non-legacy socket gets disabled: bios cannot read socket occupied pin from other socket. therefore, bios cannot tell the difference between a tri-stated socket and unpopulated socket. enable autoack in the intel® qpi interface enumeration which will ensure that a warm reset asserted before the intel® quick path interconnect enumeration will be converted into a power-cycle reset.										
											
title	the pcie* link at 8 operation while training										
problem	the pcie bus uses high speed serial links that must go through a training process to allow both transmitter and receiver to make adjustments in behavior to optimize the signaling between the transmitter and receiver. when a pcie compliant device must train or retrain the link, training sequences are used. the device must allow enough time for the training to complete before transitioning to normal operation. in the case of pcie equalization at 8.0 gt/s the processor is not allowing enough time to optimize signaling before attempting normal operation.										
implication	due to this erratum, unexpected system behavior may be observed.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	qpils reports the vna/vn0 credits available for the processor rx rather than tx										
problem	the qpils register (cpubus(1); devices 8,9; function 0; offset 0x48), according to the intel® quick path interconnect specification at revisions 1.1 and later, should report the vna/vn0 credits available for the processor tx (transmit port). due to this erratum, the qpils register reports the vna/vn0 credits available for the processor rx (receive port).										
implication	this is a violation of the specification but no functional failures have been observed due to this erratum.										
workaround	none identified.										
											
title	the router value exchanged during intel qpi link layer initialization is set to zero										
problem	during the intel qpi link layer initialization, parameters are exchanged by hardware. the parameters that are received are stored by the receiver. the information is used to setup link operation. one of those parameters that is exchanged is the router value. the router value should be one but it is zero in the processor.										
implication	given that the processor is designed to only go into 2 socket platforms and that the bios is not using this value, there is no known negative impact from the router value being 0.										
workaround	none identified.										
											
title	a first level data cache parity error may result in unexpected behavior										
problem	when a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accesses the processor may exhibit unexpected behavior.										
implication	due to this erratum unpredictable system behavior may occur. intel has not observed this erratum with any commercially available system.										
workaround	none identified.										
											
title	the processor incorrectly indicates that 16-bit rolling crc is supported										
problem	the intel qpi specification defines two methods of computing crc rolling crc. the processor implements only 8-bit crc. the “crc mode supported” bit in the qpilcp registers (devices 8, 9; function 0; offset 40h, bit 11) is set incorrectly indicating that both 8-bit crc and 16-bit rolling crc are supported.										
implication	the “crc mode supported” bit of qpilcp must be disregarded; there should be no attempt to use 16-bit rolling crc mode.										
workaround	the “crc mode” bits in the qpilcl (devices 8, 9; function 0; offset 44h, bits[15 should be left at their reset value of 00b to ensure 8-bit crc is selected.										
											
title	peci write requests that require a retry will always time out										
problem	peci 3.0 introduces a ‘host identification’ field as a way for the peci host device to identify itself to the peci client. this is intended for use in future peci systems that may support more than one peci originator. since peci 3.0 systems do not support the use of multiple originators, peci 3.0 host devices should zero out the unused host id field. peci 3.0 also introduces a ‘retry’ bit as a way for the peci host to indicate to the client that the current request is a ‘retry’ of a previous read or write operation. unless the peci 3.0 host device zeroes out the byte containing the ‘host id & retry bit’ information, peci write requests that require a retry will never complete successfully.										
implication	peci write requests that require a retry may never complete successfully. instead, they will return a timeout completion code of 81h for a period ranging from 1 ms to 30 ms if the ‘retry’ bit is asserted.										
workaround	peci 3.0 host devices should zero out the byte that contains the host id and retry bit information for all peci requests at all times including retries.										
											
title	the vswing of the pcie* transmitter exceeds the specification										
problem	the pcie specification defines a limit for the vswing (voltage swing) of the differential lines that make up a lane to be 1200 mv peak-to-peak when operating at 2.5 gt/s and 5 gt/s. intel has found that the processor’s pcie transmitter may exceed this specification. peak-to-peak swings on a limited number of samples have been observed up to 1450 mv.										
implication	for those taking direct measurements of the pcie transmit traffic coming from the processor may detect that the vswing exceeds the pcie specification. intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	intel qpi interface calibration may log spurious bus and interconnect error machine checks										
problem	the intel qpi interface physical layer performs calibration across all 20 of the lanes and reports the success or failure of the calibration process. due to this erratum, the processor may detect spurious errors during the calibration of the intel qpi interface. the bus and interconnect errors are reported with the ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_1xx0_0000_1111 (where x is zero or one).										
implication	the processor may log spurious bus and interconnect error machine checks reports during intel qpi calibration.										
workaround	is possible for the bios to contain a workaround for this erratum. a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	when a link is degraded on a port due to pcie* signaling issues correctable receiver errors may be reported on the neighboring port										
problem	pci express* interface incorporates a recovery mechanism when certain link degradation occurs by retraining the link without impacting the pending transactions. when a link is degraded on a specific port due to pcie signaling issues, it is possible that correctable receiver errors are reported on the neighboring (logically adjacent) port. the correctable receiver errors are indicated by the pcie aer correctable error bit (xpglberrsts cpubus(0); device 0-3; function 0-3; offset 230h; bit 2).										
implication	software that logs errors on the pcie interface must be aware that errors detected on a specific port could be due to either an error on that specific port or on a neighboring port.										
workaround	none identified.										
											
title	a cmci is only generated when the memory controller’s correctable error count threshold is exceeded										
problem	a cmci (corrected machine check error interrupt) should be generated when the number of corrected errors for a bank reaches the corrected error threshold programmed into the ia32 _mci_ctl2 bits [14										
implication	the cmci will not be generated when expected but rather will be generated on the next corrected error for the bank.										
workaround	it is possible for bios to contain a workaround for this issue. it should be noted that with this workaround if the threshold is programmed to a value of 0, a read of the value will return 1 and the threshold will be 1. all other valid threshold values for the bank will be read back correctly and function as expected.										
											
title	pcie* rx dc common mode impedance is not meeting the specification										
problem	when the pcie rx termination is not powered, the dc common mode impedance has the following requirement: ≥10 kΩ over 0-200 mv range with respect to ground and ≥20 kΩ for voltages ≥200 mv with respect to ground. the processor’s pcie rx do not meet this requirement at 85 degrees c or greater. in a limited number of samples intel has measured an impedance as low as 9.85 kΩ at 50 mv.										
implication	intel  has  not  observed  any  functional  impact  due  to  this  violation  with  any commercially available system.										
workaround	none identified.										
											
title	a modification to the multiple message enable field does not affect the aer interrupt message number field										
problem	the (advanced error interrupt) message number field (rperrsts devices 0-3; functions 0-3; offset 178h; bits[31 field (msimsgctl device 3; function 0; offset 62h; bits[6:4]). however, writing the multiple message enable in the root port does not update the advanced error interrupt message number field.										
implication	due to this erratum, software can allocate only one msi (message signaled interrupt) to the root port.										
workaround	none identified.										
											
title	unexpected pcie* set_slot_power_limit message on writes to lnkcon										
problem	the processor sends the pcie set_slot_power_limit message on writes to the slot capabilities (sltcap devices 0-3; functions 0-3; offset a4h) register. due to this erratum, the processor also sends pcie the set_slot_power_limit message on writes to the lnkcon (cpubus(0); devices 0-3; functions 0-3; offset a0h) register.										
implication	for those monitoring the pcie traffic going across the link, the unexpected pcie set_slot_power_limit message will be detected whenever a write to the lnkcon register occurs. intel has not observed any functional failures due to this erratum on any commercially available system.										
workaround	none identified.										
											
title	enabling intel qpi l0s state may prevent entry into l1										
problem	enabling intel qpi l0s state in a dual processor system with both processor sockets populated may not allow the intel qpi link between the processors to enter the l1 state.										
implication	entry into the package c3 state and lower power package c-states cannot occur if the intel qpi link cannot enter the l1 state. system power consumption may increase.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	locked accesses spanning cachelines that include pci space may lead to a system hang										
problem	a locked memory access which splits across a cacheline boundary that suffers a master abort on a pci bus may lead to a system hang.										
implication	aborted split lock accesses may cause pci devices to become inoperable until a platform reset. intel has not observed this erratum with commercially available software.										
workaround	none identified.										
											
title	intel qpi training sensitivities related to clock detection										
problem	the processor is demonstrating link training sensitivities related to clock detection and will indicate the error with an ia32_mci_status.mscod (bits[21:16]) of 10011 and with an ia32_mci_status.mcacod (bits[15:0]) of 0000_1000_0000_1111.										
implication	due to this erratum, the intel qpi interface may train intermittently and flag a machine check error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* rx common mode return loss is not meeting the specification										
problem	the pcie specification requires that the rx common mode return loss in the range of 0.05 to 2.5 ghz must be limited to -6 db. the processor’s pcie rx do not meet this requirement. the pcie rx common mode return at 500 mhz has been found to be between -3.5 and -4 db on a limited number of samples.										
implication	intel  has  not  observed  any  functional  failures  due  to  this  erratum  with  any commercially available pcie devices.										
workaround	none identified.										
											
title	the most significant bit of the cec cannot be cleared once set										
problem	the most significant bit of the cec (corrected error count ia32_mci_status (i=12- 19), bit 52) cannot be cleared once it has been set.										
implication	in the case that software attempts to clear the cec and the count exceeds 3fffh, software will read incorrect cec values on subsequent accesses and additional cmcis (corrected machine check error interrupts) will not be generated.										
workaround	none identified. software can avoid this erratum by setting corrected error threshold to a value less than 3fffh, enable cmci and clearing the error count before it exceeds 3fffh.										
											
title	an unexpected page fault or ept violation may occur after another logical processor creates a valid translation for a page										
problem	an unexpected page fault (#pf) or ept violation may occur for a page under the following conditions: the paging structures initially specify no valid translation for the page. software on one logical processor modifies the paging structures so that there is a valid translation for the page (for example, by setting to 1 the present bit in one of the paging-structure entries used to translate the page). software on another logical processor observes this modification (for example, by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). shortly thereafter, software on that other logical processor performs a store to a linear address on the page. in this case, the store may cause a page fault or ept violation that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). intel has not observed this erratum with any commercially available software.										
implication	an unexpected page fault may be reported. there are no other side effects due to this erratum.										
workaround	system software can be constructed to tolerate these unexpected page faults. see section “propagation of paging-structure changes to multiple processors” of volume 3a of ia-32 intel® architecture software developer’s manual, for recommendations for software treatment of asynchronous paging-structure updates.										
											
title	pcie* adaptive equalization may not train to the optimal settings										
problem	in the case of the pcie equalization procedure for 8 gt/s, the downstream port’s (for example, the processor’s) txeq (transmitter equalization settings) can be fine tuned for each lane during a process called adaptive equalization phase 3. due to this erratum, the processor may not direct the end-agent to the optimal txeq settings.										
implication	the pcie link may not be as robust as possible potentially leading to a higher bit error rate than expected.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	a core may not complete transactions to the caching agent when c- states are enabled leading to an internal timer error										
problem	when multiple cores have outstanding transactions targeted to a single caching agent and one of the cores enters a core c-state before completing the transaction with the targeted caching agent an internal timer machine check error may occur (ia32_mci_status.mcacod of 0000_0100_0000_0000).										
implication	due to this erratum, the processor may experience an internal timer error.										
workaround	none identified.										
											
title	tsc is not affected by warm reset										
problem	the tsc (time stamp counter msr 10h) should be cleared on reset. due to this erratum the tsc is not affected by warm reset.										
implication	the tsc is not cleared by a warm reset. the tsc is cleared by power-on reset as expected. intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	warm resets may be converted to power-on resets when recovering from an ierr										
problem	when a warm reset is attempted and an ierr (internal error) happens as indicated by the ia32_mci_status.mcacod of 0000_0100_0000_0000, a power-on reset occurs instead.										
implication	the values in the machine check bank will be lost as a result of the power-on reset. this prevents a os, bios or the bmc (baseboard management controller) from logging the content of the error registers or taking any post-reset actions that are dependent on the machine check information.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	using dma xor with dca may cause a machine check										
problem	if both dca (direct cache access) and dma xor operations are active at the same time, then invalid prefetch hints may be generated. these prefetch transactions may not complete and could result in a timeout machine check, which will cause caterr# to become asserted.										
implication	invalid prefetch hints may not complete resulting in a machine check.										
workaround	if using dma xor operations, disable dca by clearing chanctrl. completion_write _dca_enable (offset 80h; bit 9) in the region described by cb_bar (device: 10; function 0-7; 0ffset 80h).										
											
title	mixed dma xor and legacy operations in the same channel may cause data to be observed out of order										
problem	for mixed channel dma (xor and legacy operations active on the same channel) completion writes from legacy operations may pass completion writes from xor operations resulting in out of order descriptor updates/completions.										
implication	dma descriptor progress may appear out of order with incorrect data.										
workaround	in the dma driver each dma xor descriptor must be followed by an additional legacy descriptor. the legacy descriptor must have a non-zero transfer length and the “null transfer” bit and “completion interrupt” in the descriptor control field set to '1'. the transfer will not actually occur, but a completion interrupt will be generated that indicates that the xor operation has completed. this causes all completion interrupts to be of the legacy type.										
											
title	unexpected dma xor halt and errors when using descriptors with p or q operations disabled										
problem	if a galois field generate/validate base descriptor has either the p operations disable or q operation disable bit set and the corresponding disabled p parity address or q parity address field of the descriptor does not contain a valid/aligned address, the dma channel may halt unexpectedly with destination address errors. the destination address errors will be logged in chanerr_int. dma transfer destination address error (device 4; function 0-7; offset 180h; bit 1).										
implication	the dma may only partially process a dma xor descriptor when a disabled p or q parity address field of the descriptor does not contain a valid/aligned address, resulting in incomplete data, an unexpected dma channel halt and destination address errors.										
workaround	at all times, software must place a valid/aligned address in both the p parity address field and the q parity address field of a dma xor with galois field generate/validate base descriptor even if the p operations disable or q operations disable descriptor fields are set to disable either p or q operations for the descriptor.										
											
title	dma xor channel may hang on source read completion data parity error for >8k descriptors										
problem	if a parity error occurs of source read completion data while inside the dma for >8k descriptor  transfer  lengths,  the  dma  channel  will  hang  until  the  next  platform reset.this behavior only applies if the data arrived at the dma unit error free (from dram and intel qpi) but then had a parity error in the completion data fifo inside the dma.										
implication	the effected dma channel will hang until the next platform reset.										
workaround	none identified.										
											
title	dma cb_bar decode may be incorrect after dma flr										
problem	pcie* flr (function level reset) of the dma function, may result in an incorrect cb_bar (device 4; function 0-7; offset 10h) decode when a memory read of the cb_bar occurs around the same time as the flr.										
implication	a flr may cause a pcie memory read to decode to channel 0 instead of the intended channel resulting in incorrect read data returned.										
workaround	software must quiesce the dma function before issuing flr including ensure clients are no longer referencing the driver. ensure all outstanding descriptors have completed via the normal completion writeback notifications by reading chancmp, chansts, and dmacount. issue flr and ensure no new dma transactions are started until flr has completed. chancmp (offset 98h) and chansts (offset 88h), and dmacount (offset 86h) are offsets relative to cb_bar on the processor's internal io bus (as defined in the iiobusno register).										
											
title	xor dma restricted to ≤ 8 kb transfers when multiple channels are in use										
problem	incorrect data transfers can occur if more than one dma channel is in operation and >8 kb xor dma transfer sizes are being used. xor dma transfer size is set by software in the block size field of the xor with galios field generate/validate base descriptor.										
implication	xor dma operation is restricted to ≤ 8 kb transfer sizes when multiple dma channels are in use. legacy dma operations may still use up to the maximum 1 mb transfer length.										
workaround	software may either use a single dma channel for both legacy and xor operation types both up to the maximum 1mb transfer size. use multiple dma channels where xor operation types are ≤ 8 kb transfer size and legacy operation types are up to 1 mb transfer size.										
											
title	unable to restart dma after poisoned error during an xor operation										
problem	if the chanerr field read data error (offset a8h; bit 8) is set due to a poisoned completion error during a dma xor operation, the dma stays in the halted state and the read data error bit does not clear										
implication	the xor operations on the dma can not be restarted after a read data error due to a poisoned xor operation.										
workaround	at least one xor descriptor with no read data errors has to be processed for a new chain of xor descriptors to work correctly with the corresponding chanerrmsk (offset ach; bit 8) bit set. upon detection of a read data error, software must clear the chanerr and chanerr_int (device 4; function 0-7; offset 180h) registers and disable  the  corresponding  error  mask  bit  by  setting  chanerrmsk.  then  new descriptors can be added to the chain and the dma started by writing the dmacount (offset 86h). once the dma channel is in the running state, software can clear the chanerrmsk.  chanerr,  chanerrmsk,  and  dmacount  are  offsets  relative  to cb_bar (device 4; function 0-7; 0ffset 10h) on the processors internal io bus (as defined in the iiobusno register).										
											
title	dma restart hang when first descriptor is a legacy type following channel halt due to an extended descriptor error										
problem	when using multiple dma channels, all dma channels may hang if a dma channel restart is attempted with a legacy descriptor as the first descriptor following an error/ halt on an extended descriptor on channel 0 or 1.										
implication	following an extended descriptor error on channel 0 or 1, the channel must be not be restarted with a first descriptor of legacy type including null. does not apply for single channel operation.										
workaround	software must guarantee that the first descriptor processed on restart is an xor gf multiply generation (base type) before using legacy descriptors with interrupts and completions.										
											
title	jsp cbdma errata bf508s: operation with dma xor interrupts/ completions enabled restricted to channel 0 and 1										
problem	if dma xor interrupts and completions are enabled on channel 0 or 1 concurrent with operation on channels 2-7, incorrect data transfers can occur on dma channels 2-7. dma xor interrupts and completions are enabled by setting bits 0 and 3 of descriptor control field of a dma xor with galios field generate/validate base descriptor.										
implication	if dma xor interrupts and completions are enabled, only one interrupt/completion type may be used on any single channel and only channels 0 and 1 may be used.										
workaround	software must either only use only legacy interrupts and completions on all channels. use only dma channels 0 and 1 where: — only dma xor interrupts/completions are enabled on channel 0 and is only used for dma xor operations. — only legacy interrupts/completions are enabled on channel 1 and is only used for dma legacy operations.										
											
title	suspending/resetting an active dma xor channel may cause an incorrect data transfer on other active channels										
problem	suspending an active dma xor channel by setting chancmd.suspend dma bit (offset 84; bit 2) while xor type dma channels are active may cause incorrect data transfer on the other active legacy channels. this erratum may also occur while resetting an active dma xor channel chancmd.reset dma bit (offset 84; bit 5). chancmd is in the region described by cb_bar(device 4; function 0-7; offset 10h) on the processor's internal io bus (as defined in the iiobusno register).										
implication	an incorrect data transfer may occur on the active legacy dma channels.										
workaround	software must suspend all legacy dma channels before suspending an active dma xor channel (channel 0 or 1).										
											
title	dword-aligned dma xor descriptors with fencing and multi- channel operation may cause a channel hang										
problem	dma xor descriptors with dword aligned sources and fencing enabled may result in a xor channel hang until the next platform reset. xor dma fencing is set by software in descriptor control.fence (xor base descriptor, bit 4)										
implication	an xor dma descriptor with non cacheline aligned sources may hang until the next platform reset.										
workaround	do  not  enable  fencing  on  xor  descriptors.  fencing  can  be  enabled  on  legacy descriptors. it is recommended that a null legacy descriptor must be paired with each xor descriptor. software can use fencing of the legacy null descriptor to track full completion of its associated xor descriptor.										
											
title	intel qpi link layer does not drop unsupported or undefined packets										
problem	the intel qpi should detect an unsupported or undefined packet, drop the offending packet, and log a correctable error with an ia32_mci_status.mcacod of 0000_1100_0000_1111. when the intel qpi detects an unsupported or undefined packet it does not drop the offending packet but it does log the error.										
implication	due to this erratum, intel qpi does not drop unsupported packets. intel has not observed any functional failure on commercially available systems due to this erratum.										
workaround	none identified										
											
title	the equalization phase successful bits are not compliant to the pcie* specification										
problem	pcie specification states that if the phase 1 of transmitter equalization completes successfully as indicated by the lnksts2.equalization phase 1 successful (devices 0- 3; functions 0-3; bit[2]) bit being set to one and if the phase 2 and 3 link training phases are bypassed, the lnksts2.equalization phase 3 successful (devices 0-3; functions 0-3; bit[4]) and lnksts2.equalization phase 2 successful (bit[3]) bits should be set to one. due to this erratum, the processor will only set the equalization phase 2 or 3 successful bits if the phases are completed successfully.										
implication	due to this erratum, equalization phase 2 and 3 successful bits may not be set. intel has not observed any functional failure with commercially available pcie devices.										
workaround	none identified.										
											
title	executing the getsec instruction while throttling may result in a processor hang										
problem	if the processor throttles, due to either high temperature thermal conditions or due to an explicit operating system throttling request (tt1), while executing getsec[senter] or getsec[sexit] instructions, then under certain circumstances, the processor may hang. intel has not been observed this erratum with any commercially available software.										
implication	possible hang during execution of getsec instruction.										
workaround	none identified.										
											
title	incorrect address computed for last byte of fxsave/fxrstor or xsave/xrstor image leads to partial memory update										
problem	a partial memory state save of the fxsave or xsave image or a partial memory state restore of the fxrstor or xrstor image may occur if a memory address exceeds the 64 kb limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4 gb limit while the processor is operating in 32-bit mode.										
implication	fxsave/fxrstor or xsave/xrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.										
workaround	software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	lbr may contain incorrect information when using freeze_lbrs_on_pmi										
problem	when freeze_lbrs_on_pmi is enabled (bit 11 of ia32_debugctl msr (1d9h) is set), and a taken branch retires at the same time that a pmi (performance monitor interrupt) occurs, then under certain internal conditions the record at the top of the lbr stack may contain an incorrect “from” address.										
implication	when the lbrs are enabled with freeze_lrbs_on_pmi, the “from” address at the top of the lbr stack may be incorrect.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring may overcount some events during debugging										
problem	if the debug-control register (dr7) is configured so that some but not all of the breakpoints in the debug-address registers (dr0-dr3) are enabled and one or more of the following performance-monitoring counters are locally enabled (via ia32_cr_permon_evntsel_cntr{3:0}): br_inst_retired br_misp_retired fp_assist fp_assist inst_retired machine_clears mem_load_uops_llc_hit_retired mem_load_uops_misc_retired.llc_miss mem_load_uops_retiredmem_trans_retiredmem_uops_retired other_assists rob_misc_events.lbr_inserts uops_retired any of the globally enabled (via ia32_cr_emon_perf_global_ctrl) counters may overcount certain events when a disabled breakpoint condition is met.										
implication	performance-monitor counters may indicate a number greater than the number of events that occurred.										
workaround	software can disable all breakpoints by clearing dr7. alternatively, software can ensure that, for a breakpoint disabled in dr7, the corresponding debug-address register contains an address that prevents the breakpoint condition from being met (for example, a non-canonical address).										
											
title	hdrlog registers do not report the header for pcie* port 1 packets with detected errors										
problem	the hdrlog registers contain the header information of the first pcie packet detected that contains errors. because of this erratum, the port 1 (iou2) hdrlog registers (cpubus(0), device 1, function 0; offsets 164h, 168h, 16ch, 170h) do not reflect the header of a packet with a detected error.										
implication	the hdrlog registers cannot be used to debug the receipt of packets with detected errors on port 1.										
workaround	none identified.										
											
title	peci temperature data values returned during reset may be non- zero										
problem	the processor peci power-up time line presented in the intel® xeon® processor e5- 1600/e5-2600/e5-4600 product families datasheet - volume one or intel® xeon® e5-2400 product family datasheet- volume two defines the value returned by the peci gettemp() command as 0x0000 - the maximum value - during the 'data not ready' (dnr) phase (starting approximately 100 µs after pwrgood assertion and lasting until approximately 500 µs after reset de-assertion). due to this erratum, the gettemp() command returns a small negative number during the dnr phase.										
implication	the temperature reported during the peci dnr phase may be below the maximum and therefore may not have the intended effect of causing platform fans to operate at full speed until the actual processor temperature becomes available.										
workaround	processor thermal management solutions utilizing peci should operate platform fans at full speed during the peci dnr phase.										
											
title	tsod related smbus transactions may not complete when package c-states are enabled										
problem	the processor may not complete smbus (system management bus) transactions targeting the tsod (temperature sensor on dimm) when package c-states are enabled. due to this erratum, if the processor transitions into a package c-state while an smbus transaction with the tsod is in process, the processor will suspend receipt of the transaction. the transaction completes while the processor is in a package c-state. upon exiting package c-state, the processor will attempt to resume the smbus transaction, detect a protocol violation, and log an error.										
implication	when package c-states are enabled, the smbus communication error rate between the processor and the tsod may be higher than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	dram rapl dynamic range is too narrow on the low side										
problem	the lower limit for the dram rapl (running average power limit) dynamic range is specified to be about 120% of dram minimum power. due to this erratum, the lower limit is enforced at about 170% of dram minimum power. dram minimum power can be found in the minimal dram power field (dram_power_info csr at cpubus(1), device 10, function 2, offset 90h; bits[30:16]).										
implication	dram rapl cannot regulate dram power consumption to as low a level as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	mcacod 0119h reported in ia32_mc3_status is ambiguous										
problem	the machine check error code (mcacod) in the ia32_mc3_status (msr 040dh) register is intended to report the type of error that has been discovered. the 0119h mcacod is correctly logged for mlc (mid-level cache) generic read errors and, due to this erratum, also logged for errors detected as a result of monitor instructions.										
implication	it may not be possible to distinguish the precise operation associated with an mlc machine check error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the processor incorrectly transitions from polling polling.compliance after receiving two ts1 ordered sets with the compliance bit set										
problem	the processor pcie* interface incorrectly transitions from the polling.active link state to the polling.compliance link state after receiving two ts1 ordered sets with the compliance bit set instead of the eight ts1 ordered sets required by the specification.										
implication	it is possible that the pcie link may enter polling.compliance link state unexpectedly. exposure to this erratum requires bit errors on the compliance receive bit (byte 5, bit										
workaround	none identified.										
											
title	patrol scrubbing may not resume properly after package c3 and package c6 states										
problem	patrol scrubbing is disabled at entry into package c3 and package c6 states. due to this erratum, the memory subsystem may not get fully scrubbed in the expected 24-hour timeframe.										
implication	memory may not be scrubbed as expected when patrol scrubbing is enabled while package c3 and/or package c6 states are enabled. as a consequence, single bit memory errors may not be proactively corrected and could increase the likelihood of uncorrectable memory errors.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	platform idle power may be higher than expected										
problem	the processor may not place the associated dram subsystem in the lowest allowed power state during package c3 and package c6 states. this may cause the platform idle power to be higher than expected.										
implication	platform average power and idle power may be higher than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci transactions during an s-state transition may result in a platform cold reset										
problem	due to this erratum, a peci transaction during an s-state transition may result in an unexpected platform cold reset rather than an s-state transition.										
implication	use of peci transactions during an s-state transition can result in a platform reset that terminates transitioning to the desired s-state.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	complex platform conditions during a transition to s4 or s5 state may result in an internal timeout error										
problem	due to this erratum, the bios sequencing associated with s4 (sometimes known as “hibernate”) and s5 (also known as “soft off”), when undertaken with certain complex platform conditions, can result in an internal timeout error as indicated by ia32_mci_status.mcacod  of  0000_0100_0000_0000  and  ierr  assertion.  this internal timeout error stops the platform s-state sequencing before platform power down occurs. certain platforms may have logic that, upon detection of the failure to reach power down, initiates a cold reset sequence.										
implication	s4 state or s5 state may not be reliably entered; the platform may not reach the very low power condition.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writes to sdoorbell or b2bdoorbell in conjunction with inbound access to ntb mmio space may hang system										
problem	a posted write targeting the sdoorbell (offset 64h) or b2bdoorbell (offset 140h) mmio registers in the region define by base address register pb01base (bus 0; device 3; function 0: offset 10h) or sb01base (bus m; device 0; function 0; offset 10h) may hang the system. this system hang may occur if the ntb (non-transparent bridge) is processing a transaction from the secondary side of the ntb that is targeting the ntb shared mmio registers or targeting the secondary side configuration registers when the write arrives.										
implication	the system may hang if the processor writes to the local sdoorbell or b2bdoorbell register at the same time that the ntb is processing an inbound transaction.										
workaround	in ntb/ntb (back-to-back) mode, do not use the b2bdoorbell to send interrupts from the local to remote host. instead, configure one of the following local register pairs to point to the remote sb01base region pb23base (device: 3; function: 0; offset: 18h) and pbar2xlat (offset 10h) from pb01base or sb01base regions; pb45base (device: 3; function: 0; offset: 20h) and pbar4xlat (offset 18h) from pb01base, or sb01base regions; the local host may then write directly to the pdoorbell (offset 60h) from the pb23base/pb45base region defined above. in ntb/rp (bridge to root port) mode, the sdoorbell register cannot be used by the processor on the primary side of the ntb to interrupt the processor on the secondary side. instead, dedicate a bar and xlat pair, either pb23base/pbar2xlat or pb45base/pbar4xlat, to generate an interrupt directed directly into the msi/msix (message signaled interrupt) interrupt range on the remote processor. the device driver or client on the remote host must point the appropriate pbarnxlat register to its msi/msix interrupt range. the processor on the primary side can then write the msi/msix interrupt to the dedicated bar which will be translated by the ntb to the msi/msix region of the secondary side’s processor.										
											
title	programming pdir and an additional precise perfmon event may cause unexpected pmi or pebs events										
problem	pdir (precise distribution for instructions retired) mechanism is activated by programming inst_retired.all (event c0h, umask value 00h) on counter 1. when pdir is activated in pebs (precise event based sampling) mode with an additional precise perfmon event, an incorrect pmi or pebs event may occur.										
implication	due to this erratum, when another pebs event is programmed along with pdir, an incorrect pmi or pebs event may occur.										
workaround	software should not program another pebs event in conjunction with the pdir mechanism.										
											
title	a peci rdiamsr command near ierr assertion may cause the peci interface to become unresponsive										
problem	when a peci rdiamsr command is issued to the processor near the time that the processor is experiencing an internal timeout error, as indicated by ia32_mci_status.mcacod of 0000_0100_0000_0000 and ierr assertion, the peci interface may issue an 81h (timeout) response. after a timeout response, the processor will ignore future peci commands until it is reset.										
implication	due to this erratum, peci commands typically used to debug a processor that is not behaving normally - rdpkgconfig and rdpciconfig - may not be available after an internal timeout error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	long latency transactions may cause i/o devices on the same link to time out										
problem	certain long latency transactions - for example, master aborts on inbound traffic, locked transactions, peer-to-peer transactions, or vendor defined messages - conveyed over the pcie* and dmi2 interfaces can block the progress of subsequent transactions for extended periods.  in certain cases, these delays may lead to i/o device timeout that can result in device error reports and/or device off-lining.										
implication	due to this erratum, devices that generate pcie or dmi2 traffic characterized by long latencies can interfere with other traffic types on the same link. this may result in reduced i/o performance and device timeout errors. usb traffic can be particularly sensitive to these delays.										
workaround	avoid the contributing conditions. this can be accomplished by separating traffic types to be conveyed on different links and/or reducing or eliminating long latency transactions.										
											
title	the coherent interface error codes “c2”, “c3”, “da” and “db” are incorrectly flagged										
problem	the coherent interface error status registers (irpp0errst and irpp1errst at cpubus(0), device 5, function 2, offsets 230h and 2b0h respectively) indicate that an error has been detected by the coherent interface. bit 3 indicates that a write cache un-correctable ecc (c2) error has occurred. bit 4 indicates that a csr access crossing 32-bit boundary (c3) error has occurred. bit 13 indicates that a protocol queue/table overflow or underflow (da) error has occurred. bit 14 indicates that a protocol parity error (db) error has occurred. due to this erratum, the processor may incorrectly log the “c2”, “c3”, “da” and “db” error flags.										
implication	the “c2”, “c3”, “da” and “db” error flags are indeterminate.										
workaround	mask off the “c2”, “c3”, “da” and “db” error flags (bit 3, bit 4, bit 13 and bit 14) of the irpp0errctl and irpp1errctl registers at cpubus(0), device 5, function 2, offsets 234h and 2b4h respectively.										
											
title	if multiple poison events are detected within two core clocks, the overflow flag may not be set										
problem	if multiple poison events are detected within two core clocks, the error is logged with an ia32_mci_status.mcacod of 0000_0001_0011_0100 but the ia32_mci_status.over (bit [60]) may not be set.										
implication	due to this erratum, only one poison event may be reported by a logical processor when more than one poison event was encountered.										
workaround	none identified.										
											
title	pci express* capability structure not fully implemented										
problem	according to the pcie* base specification, “the pci express capability structure is required for all pci express device functions.” due to this erratum, some pci express capabilities fields were not implemented (“device capability,” “device status” and “device control”) for cpubus[0], device 5, function 2, reads to these fields will return zero.										
implication	software that depends on the pci express capability structure fields device capability, device status and/or device control will not operate properly.										
workaround	none identified.										
											
title	software reads from lmmioh_limit register may be incorrect										
problem	the mmioh is a memory-mapped i/o region relocatable above 4 gb. due to this erratum, software reads of the lmmioh_limit register (local mmio high base, device										
implication	software depending on lmmioh_limit register reads may not behave as expected. intel has not identified any commercially available software that is affected by the erratum.										
workaround	none identified.										
											
title	patrol scrub is incompatible with rank sparing on more than one channel										
problem	the imc (integrated memory controller) permits independent sparing of one rank on each memory channel. due to this erratum, patrol scrub operation is impaired when more than one ranking sparing event occurs.										
implication	if more than one channel has undergone a rank sparing event, patrol scrub may scrub ranks that should have been taken out of service and may skip scrubbing ranks that are in service. in the former case, excessive errors will be reported while in the latter case, memory is incompletely scrubbed.										
workaround	patrol scrub should not be enabled when more than one channel has suffered a rank sparing event. this can be accomplished during the bios initialization phase by either not enabling the patrol scrub feature not enabling the rank sparing feature. alternatively, during run time one of the following can be implemented • patrol scrub can be disabled when the second rank sparing event occurs • disallowing any rank sparing event after the first one please refer to the latest version of the bios specification update and release notes.										
											
title	multi-socket intel® txt platform may enter a sequence of warm resets										
problem	due to this erratum, a platform warm reset issued while a processor is attempting an authenticated boot on a multi-socket intel® trusted execution technology (intel® txt) platform may initiate a series of repeating warm resets.										
implication	a warm reset attempt during an authenticated boot on a multi-socket intel txt platform may lead to platform unavailability.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ntb may incorrectly set msi or msi-x interrupt pending bits										
problem	the ntb (non-transparent bridge) may incorrectly set msi (message signaled interrupt) pending bits in msipending (bar pb01base,sb01base; offset 74h) while operating in msi-x mode or set msi-x pending bits in pmsixpba (bar pb01base, sb01base; offset 03000h) while operating in msi mode.										
implication	due to this erratum, ntb incorrectly sets msi or msi-x pending bits. the correct pending bits are also set and it is safe to ignore the incorrectly set bits.										
workaround	none identified.										
											
title	dword aligned xor dma sources may prevent further dma xor progress										
problem	xor dma channels may stop further progress in the presence of locks/pholds if the source pointed to by a dma xor descriptor is not cacheline aligned.										
implication	non-cacheline aligned dma xor sources may hang both channels 0 and 1. a reset is required in order to recover from the hang. legacy dma descriptors on any channel have no source alignment restrictions.										
workaround	software must either ensure xor dma descriptors only point to cache-line aligned sources (best performance) or a legacy dma copy must be used prior to non-cacheline aligned dma operations to guarantee that the source mis-alignment is on dword15 of the cacheline. the required source that must be misaligned to dword15, depends on the following desired subsequent dma xor operations: — dma xor validate (raid5/ p-only): the p-source must be mis-aligned to dword15 (last dword). — dma xor validate (raid6/p+q): the q-source must be mis-aligned to dword15 (last dword). — dma xor generate or update: the last source (which will be different based on numblk) must be misaligned to dword15 (last dword).										
											
title	using i/o peer-to-peer write traffic across an ntb may lead to a hang										
problem	if two systems are connected via an ntb (non-transparent bridge), either the internal ntb or an external ntb, and both systems attempt to send i/o peer-to-peer write traffic across the ntb either to memory or an i/o device on the remote system, it is possible for both systems to deadlock.										
implication	due to this erratum, using i/o peer-to-peer write traffic across an ntb may lead to a hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	ntb does not set pme_to_ack after a pme_turn_off request										
problem	the ntb (non-transparent bridge) does not set pme_to_ack in miscctrlsts (device 3; function 0: offset 188h; bit [48]) after a pme_turn_off request.										
implication	due to this erratum, the ntb will not acknowledge a pme_turn_off request.										
workaround	acpi or other software must have a time-out to proceed with the power management event and should not wait indefinitely for the ntb to acknowledge the pme_turn_off request.										
											
title	pcmpestri, pcmpestrm, vpcmpestri and vpcmpestrm always operate with 32-bit length registers										
problem	in 64-bit mode, using rex.w=1 with pcmpestri and pcmpestrm or vex.w=1 with vpcmpestri and vpcmpestrm should support a 64-bit length operation with rax/ rdx. due to this erratum, the length registers are incorrectly interpreted as 32-bit values.										
implication	due to this erratum, using rex.w=1 with pcmpestri and pcmpestrm as well as vex.w=1 with vpcmpestri and vpcmpestrm do not result in promotion to 64-bit length registers.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci commands differing only in length field may be interpreted as command retries										
problem	due to this erratum, the processor interprets any peci read or write command that accesses the processor, a downstream pci device, or package configuration space and differs from the preceding request only in the length field as a retry request. that is, a retry will be inferred by the processor even if the read length and write length fields don't match between two consecutive requests, regardless of the state of the host retry bit on the succeeding request.										
implication	back-to-back peci commands that are identical with the exception of the length field may yield incorrect results if processor retry completion codes are ignored by the peci host.										
workaround	peci hosts should retry timed-out commands until they complete successfully by reissuing a peci command sequence identical to the originally timed-out command.										
											
title	performance monitor precise instruction retired event may present wrong indications										
problem	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).										
implication	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.										
workaround	the sampling driver should avoid using sav<100.										
											
title	vm exits from real-address mode due to machine check exceptions may incorrectly save rflags.rf as 1										
problem	if a machine check is encountered while fetching an instruction, and if the resulting machine check exception causes a vm exit, the vm exit should save an rflags value in the guest-state area of the vmcs with the rf value that existed at the time of the machine check. due to this erratum, such vm exits that occur in real-address mode may save rflags.rf as 1 even if it had been 0.										
implication	the processor may fail to report an instruction breakpoint following a return to real- address mode via vm entry.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the integrated memory controller does not enforce cke high for txsdll dclks after self-refresh										
problem	the jedec standard ddr3 sdram specification (no. 79-3e) requires that the cke signal  be  held  high  for  txsdll  dclks  after  exiting  self-refresh  before  issuing commands that require a locked dll (delay-locked loop). due to this erratum, the integrated memory controller may not meet this requirement with 512 mb, 1 gb, and 2gb devices in single rank per channel configurations.										
implication	violating txsdll may result in dimm clocking issues and may lead to unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	the default value of the i/o base address field does not comply with the pci-to-pci bridge architecture specification										
problem	the pci-to-pci bridge architecture specification defines the default value of the i/o base address field (iobas cpubus(0); device 0-3; function 0-3; offset 1ch; bits [3:2]) to 0. due to this erratum, the processor's default value is 3.										
implication	it is possible that system software will generate an error due to this erratum.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	a sustained series of pcie* posted upstream writes can lead to deadlock										
problem	due to this erratum, a sustained series of pcie posted upstream writes to the same cache line, with no other access of that same cache line, may cause a deadlock.										
implication	under a complex set of conditions, a sustained series of pcie posted upstream writes targeting the same cache line can lead to deadlock. intel has not been observed this erratum with any commercially available system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	extraneous characters are included in the processor brand string										
problem	the processor brand string is provided by the cpuid instruction for leaf values eax=80000002h, 80000003h, and 80000004h. each execution of the three cpuid leaf value returns 16 ascii bytes of the processor brand string in the eax, ebx, ecx, and edx registers. due to this erratum, an extra zero character (“0”, 30h ascii code) and space character (“ “, 20h ascii code) are inserted after the processor number in the brand string output. in the following example brand string, the extraneous characters are underlined										
implication	an extraneous “0” and “space” character are included in the processor brand string.										
workaround	the extraneous characters may be ignored or removed by software.										
											
title	imc controlled dynamic dram refresh rate can lead to unpredictable system behavior										
problem	drams require a 2x refresh rate when operating above 85°c. due to this erratum, the imc (integrated memory controller) logic intended to double the refresh rate when dram  temperature  exceeds  85°c  can  cause  dram  access  failures,  leading  to unpredictable system behavior.										
implication	the imc is not able to dynamically adjust the dram refresh rate based on dram temperature. if drams may be operated above 85°c then bios must configure the imc for a doubled refresh rate.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	incorrect error address status may get logged										
problem	when a correctable machine check event with a valid address precedes an uncorrectable machine check event without a valid address, the ia32_mci_status over flag (bit 62) should be set and addrv flag (bit 58) should be cleared. due to this erratum, both flags may be set.										
implication	the machine check report logged may incorrectly indicate valid address information when the over flag is set.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the machine check threshold-based error status indication may be incorrect										
problem	a corrected cache hierarchy data or tag error is reported in ia32_mci_status.mcacod (bits [15										
implication	the threshold-based error status indication is unreliable.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_mci_status registers may contain undefined data after reset										
problem	due to this erratum, if the reset_n signal is asserted while the processor is in a package c state the ia32_mci_status registers may contain undefined data after the processor completes the reset. in particular, the ia32_mci_status.val (bit[63]) may be set incorrectly indicating a valid machine check has been logged.										
implication	invalid errors may be reported in the ia32_mci_status registers.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	refresh cycles for high capacity dimms are not staggered										
problem	certain high capacity dimms, typically quad rank rdimms and lr-dimms, may exceed instantaneous and short-term power limits if refresh cycles are not correctly staggered. due to this erratum, the integrated memory controller is unable to stagger refresh cycles.										
implication	some dimms may exceed power limits during refresh operations leading to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a stream of snoops can lead to a system hang or machine check										
problem	due to this erratum, a stream of snoop requests to a single cache slice may cause the processor in that slice to livelock, resulting in a system hang or internal timer error machine check indicated by ia32_mci_status.mcacod (bits 15:0, 0000 0100 0000 0000).										
implication	a system hang or machine check may occur. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_mci_status exceptions										
problem	due to this erratum, ia32_mci_status.en may not be set as expected after the mlc (mid-level cache) has logged a fatal error with a mcacod value of 000x_0001_xxxx_xx10 (where x stands for zero or one) and signaled an mce (machine check error) as a result of encountering poisoned data.										
implication	the value of ia32_mci_status.en may be inconsistent with signaling an mce while logging a fatal error, however a machine check exception is still signaled.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	llc cache correctable errors are not counted and logged										
problem	llc cache correctable errors are logged in the corrected_error_count field bits [53 of the ia32_mc[19:12]_status msr. due to this erratum, llc cache corrections are not counted and logged.										
implication	software using the corrected error count may not function correctly. a cmci (corrected machine check error interrupt) may not be generated when the error threshold programmed in ia32_cr_mc[19:12]_ctl2.error_threshold (bits [14:0]) would otherwise be expected to be met.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the processor incorrectly transitions from the pcie* recovery.rcvrlock ltssm state to the configuration.linkwidth.start ltssm state										
problem	when a pcie link is operating at 2.5 gt/s and the processor's ltssm (link training and status state machine) is in recovery.rcvrlock state, the processor expects to receive ts1 ordered sets within 24 ms. if it does not receive the ts1s in the allotted time, the ltssm should transition to the detect state. due to this erratum, if the processor does not receive ts1s within 24 ms, it will transition to configuration.linkwidth.start. in that state, if it receives no ts1s, it will transition to detect. if it receives ts1s, it will configure the link appropriately and return to l0.										
implication	the  state  transition  sequence  from  the  recovery.rcvrlock  ltssm  state  to  the configuration.linkwidth.start ltssm state is in violation of the pcie specification. intel has not observed any functional failures due to this erratum with any commercially available pcie devices.										
workaround	none identified.										
											
title	writes to b2bspad[15:0] registers may transfer corrupt data between ntb connected systems										
problem	writes to the ntb (non-transparent bridge) b2bspad[15 sb01base; offsets 100h - 13fh) may result in corrupted data transfer between systems.										
implication	using b2bspad[15 pb23base (device 3; function 0; offset 18h) and pbar2xlat (offset 10h) from pb01base or sb01base regions; pb45base (device 3; function 0; offset 20h) and pbar4xlat(offset 18h) from pb01base, or sb01base regions;										
workaround	it is possible for the bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	ntb operating in ntb/rp mode with msi/msi-x interrupts may cause system hang										
problem	the ntb (non-transparent bridge) operating in ntb/rp (ntb to root port mode) using message signaled interrupts (msi or msi-x) in the presence of locks may result in a system hang.										
implication	due to this erratum, system may hang under the condition described above.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	xsaveopt may fail to save some state after transitions into or out of stm										
problem	the xsaveopt instruction may optimize performance by not saving state that has not been modified since the last execution of xrstor. this optimization should occur only if the executions of xsaveopt and xrstor are either both or neither in smm (system- management mode). due to this erratum, this optimization may be performed by the first execution of xsaveopt after a transition into or out of the stm (smm-transfer monitor) if the most recent execution of xrstor occurred before that transition. for transitions into the stm, the erratum applies only to transitions using the vmcall instruction. this erratum can occur only if the two executions are at the same privilege level, use the same linear address, and are either both or neither in vmx non-root operation. the erratum does not apply if software in smm never uses xrstor or xsaveopt.										
implication	this erratum may lead to unpredictable system behavior.										
workaround	stm software should execute the xrstor instruction with the value 0 in edx										
											
title	rank sparing may cause an extended system stall										
problem	the integrated memory controller sequencing during a rank sparing copy operation blocks all writes to the memory region associated with the rank being taken out of service. due to this erratum, this block can result in a system stall that persists until the sparing copy operation completes.										
implication	the system can stall at unpredictable times which may be observed as one time instance of system unavailability.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	system hang may occur when memory sparing is enabled										
problem	due to this erratum, enabling memory sparing can result in an internal timer error as indicated by the ia32_mci_status.mcacod of 0000_0100_0000_0000.										
implication	enabling memory sparing may result in a system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling opportunistic self-refresh and pkg c2 state can severely degrade pcie* bandwidth										
problem	due to this erratum, enabling opportunistic self-refresh can lead to the memory controller over-aggressively transitioning dram to self-refresh mode when the processor is in pkg c2 state.										
implication	the pcie interface peak bandwidth can be degraded by as much as 90%.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	mirrored memory writes may lead to system failures										
problem	in mirrored memory mode, each channel manages its memory write bandwidth resources. due to this erratum, if a channel in mirrored memory mode is heavily utilized, it is possible for issued writes to exceed available bandwidth resulting in write failures.										
implication	a system hang or unpredictable system behavior may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	end agent pcie packet errors may result in a system hang										
problem	pcie agents are required by the pcie base specification to identify and report packet errors. due to this erratum, certain invalid completion types from the end agent are not correctly handled by the processor.										
implication	if a pcie end agent issues certain invalid completion types, the system may hang.										
workaround	none identified.										
											
title	retraining cannot be initiated by downstream devices in ntb/ntb or ntb/rp configurations										
problem	the pcie base specification requires that a downstream device can initiate link retraining. due to this erratum, link retraining cannot be initiated by the downstream device in a ntb/ntb (non-transparent bridge) or a ntb/rp (root port) configuration.										
implication	the retrain_link field (lnkcon device 3; function 0; offset 1a0h; bit [5]) does not function as expected in the identified configurations; software referencing the downstream device is not able to retrain the link.										
workaround	the link speed and training must be managed by the upstream host in ntb/ntb or ntb/rp configurations.										
											
title	pcie port in ntb mode flags upstream slot power limit message as ur										
problem	when the processor is in ntb (non-transparent bridge) mode, it should ignore upstream slot power limit messages from the root port it is connected to. due to this erratum, the processor generates ur (unsupported request) on these slot power limit messages when in ntb mode.										
implication	due to this erratum, some messages will be improperly flagged with ur.										
workaround	upstream slot power limit message should be disabled in the identified configurations.										
											
title	spurious smis may occur due to memhot# assertion										
problem	the imc (integrated memory controller) can be programmed to generate an smi (system management interrupt) on an internal memhot# event assertion through the mhot_smi_en field (mh_maincntl bus										
implication	due to this erratum, excessive smi generation may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie link bandwidth notification capability is incorrect										
problem	a value of 1 in the link_bandwidth_notification_capability field (lkncap bit 21) for a pcie device indicates support for the link bandwidth notification status and interrupt mechanisms. due to this erratum, this field for ports 2c, 2d, 3c and 3d (lkncap bus 0; device 2,3; function 2,3; offset 09ch; bit 21) always reads as 0 when it should read as 1.										
implication	software that reads this field for the listed ports will incorrectly conclude that the link bandwidth notification status and interrupt mechanisms are not available.										
workaround	software should ignore the value of the link_bandwidth_notification_capability field for ports 2c, 2d, 3c, and 3d.										
											
title	uncorrectable intel qpi errors may cause the system to power down										
problem	due to this erratum, under a complex set of conditions, intel qpi uncorrectable errors may cause a deadlock between the processor and pch (platform controller hub). the deadlock will cause a processor internal timeout error as indicated by ia32_mci_status.mcacod of 0000_0100_0000_0000, caterr# assertion and a shutdown transaction being sent to the pch. depending on the platform implementation, this will result in reset being asserted to the pch. this deadlock persists, causing the pch to timeout on the reset request. reacting to the reset request timeout, the pch powers down the system.										
implication	the system will be powered down and the ia32_mci_status register contents will be lost. the system may need to be manually powered back on. intel has not observed this erratum in the absence of injected uncorrectable intel qpi errors.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum. this is a partial workaround that causes the system to power cycle, eliminating the need for manual power on. the ia32_mci_status register contents are still lost.										
											
title	four outstanding pcie configuration retries may cause deadlock										
problem	pcie configuration retries are allowed for older generation pci/pci-x bridges that take a long time to respond to configuration cycles after a reset. due to this erratum, a fifth configuration  cycle  following  the  fourth  pcie  configuration  retry  may  not  make progress, resulting in a deadlock.										
implication	a deadlock could occur. intel has not observed this erratum with any commercially available system.										
workaround	when configuring devices on pci/pci-x buses, bios should wait for configuration cycles to complete before issuing subsequent configuration cycles.										
											
title	a peci rdpciconfiglocal command referencing a non-existent device may return an unexpected value										
problem	configuration reads to non-existent pci configuration registers should return 0ffff_ffffh. due to this erratum, when the peci rdpciconfiglocal command references a non-existent pci configuration register, the value 0000_0000h may be returned instead of the expected 0ffff_ffffh.										
implication	a peci rdpciconfiglocal command referencing a non-existent device may observe a return value of 0000_0000h. software expecting a return value of 0ffff_ffffh to identify non-existent devices may not work as expected.										
workaround	software that performs enumeration via the peci "rdpciconfiglocal" command should interpret 0ffff_ffffh and 0000_0000h values for the vendor identification and device identification register as indicating a non-existent device.										
											
title	when in dmi mode, port 0's device_port_type field is incorrect										
problem	when in dmi mode, the device_port_type field (pxpcap bus 0; device 0; function 0; offset 92h; bits [7:4]) should read as 9h (dmi mode) but incorrectly reads as 4h (pcie* mode).										
implication	software may incorrectly conclude that this port is operating in pcie mode when it is actually being used in the dmi mode.										
workaround	none identified.										
											
title	pcie tph attributes may result in unpredictable system behavior										
problem	tph (transactions processing hints) are optional aids to optimize internal processing of pcie transactions. due to this erratum, certain transactions with tph attributes may be misdirected, resulting in unpredictable system behavior.										
implication	use of the tph feature may affect system stability.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	continuous intel qpi retraining feature indication is incorrect										
problem	the processor is capable of continuous intel qpi retraining. due to this erratum, the field reporting support for this feature “continuous retraining” (qpireut_ph_cpr bus 1; device 8,9; function 3; offset 128h; bit 18) indicates this feature is not supported although it is enabled and cannot be disabled.										
implication	due to this erratum, it is not possible to disable the continuous intel qpi retraining feature.										
workaround	none identified.										
											
title	correctable memory errors may result in unpredictable system behavior										
problem	under certain conditions, the processor may not detect or correct a correctable memory error.										
implication	when this erratum occurs, it may result in unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel® quickdata technology dma lock quiescent flow causes dma state machine to hang										
problem	the lock quiescent flow is a means for an agent to gain sole ownership of another agent's resources by preventing other devices from sending transactions. due to this erratum, during the lock quiescent flow, the intel quickdata technology dma read and write queues are throttled simultaneously. this prevents subsequent read completions from draining into the write queue, hanging the dma lock state machine.										
implication	the dma lock state machine may hang during a lock quiescent flow.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	malformed tlp power management messages may be dropped										
problem	the pcie base specification requires power management messages to use the default traffic class designator, tc0, and receivers to check for violations of this rule. due to this erratum, a tlp using a non-default traffic class designator will be dropped, rather than handled as a malformed tlp.										
implication	an advanced error reporting err_fatal notification will not be logged for malformed tlp power management messages.										
workaround	none identified										
											
title	core frequencies at or below the dram ddr frequency may result in unpredictable system behavior										
problem	the intel speedstep® technology can dynamically adjust the core operating frequency to as low as 1200 mhz. due to this erratum, under complex conditions and when the cores are operating at or below the dram ddr frequency, unpredictable system behavior may result.										
implication	systems using intel speedstep technology with ddr3-1333 or ddr3-1600 memory devices are subject to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	quad rank dimms may not be properly refreshed during ibt_off mode										
problem	the integrated memory controller incorporates a power savings mode known as ibt_off (input buffer termination disabled). due to this erratum, quad rank dimms may not be properly refreshed during ibt_off mode.										
implication	use of ibt_off mode with quad rank dimms may result in unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel® quickdata technology dma non-page-aligned next source/ destination addresses may result in unpredictable system behavior										
problem	non-page aligned intel® quickdata technology dma next source/destination addresses may cause memory read-write collisions.										
implication	due to this erratum, using non-page aligned next source/destination addresses may result in unpredictable system behavior.										
workaround	next source/destination addresses must be page aligned. the intel-provided intel quickdata technology dma driver abides by this alignment rule.										
											
title	spurious crc errors may be detected on intel qpi links										
problem	the processor autonomously manages intel qpi (quickpath interconnect) link power state transitions based on link idle intervals. due to this erratum, crc errors may be detected  during  intel  qpi  link  power  state  transitions  and  may  be  logged  in qpireut_err_ced (bus 1; device 8,9; function 3; offset 120h).										
implication	spurious intel qpi link crc errors may be reported.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	peci temperature lower limit may be as high as 7°c										
problem	peci reports temperatures as an offset from the prochot threshold (a negative value when the temperature is below the prochot threshold, zero when at or above that threshold).  if  the  temperature  is  below  0°c,  peci  responds  with  an  “invalid temperature” encoding (8002h). due to this erratum, peci may indicate an invalid temperature when the actual temperature is as high as 7°c.										
implication	an invalid temperature report from peci indicates the actual temperature is 7°c or lower. platform facilities depending peci to provide accurate temperature readings between 0°c and 7°c may not function correctly.										
workaround	none identified.										
											
title	the dram power meter may not be accurate										
problem	the dram power meter uses vr (voltage regulator) current readings in combination with weighted activity counters to provide a running estimate of dram subsystem power. due to this erratum, the dram power meter may not be sufficiently accurate for system power management purposes.										
implication	the dram power meter cannot be relied upon to provide accurate dram subsystem power measurements. reduced or variable system performance may be a side effect.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	a machine check exception due to instruction fetch may be delivered before an instruction breakpoint										
problem	debug exceptions due to instruction breakpoints take priority over exceptions resulting from fetching an instruction. due to this erratum, a machine check exception resulting from the fetch of an instruction may take priority over an instruction breakpoint if the instruction crosses a 32-byte boundary and the second part of the instruction is in a 32-byte poisoned instruction fetch block.										
implication	instruction breakpoints may not operate as expected in the presence of a poisoned instruction fetch block.										
workaround	none identified.										
											
title	enhanced intel speedstep® technology may cause a system hang										
problem	enhanced intel speedstep® technology dynamically changes core operating frequencies. due to this erratum, under complex conditions, core frequency changes may result in a system hang.										
implication	enhanced intel speedstep technology may cause a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	prochot may be incorrectly asserted at reset										
problem	the prochot signal is used to indicate elevated processor temperatures during normal operation and is used for frb (fault resilient boot) actions during the reset sequence. due to this erratum, the elevated temperature indication usage of prochot can persist into reset and subsequently can cause improper frb actions.										
implication	elevated die temperatures at reset time may impair platform operation.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package c3-state and package c6-state residency is too low										
problem	the intel qpi link must transition to its l1 power state for the processor to enter package c3-state or package c6-state. due to this erratum, the intel qpi link does not transition to l1 as intended, restricting the processor from reaching package c3-state or package c6-state.										
implication	the increased idle state power consumption caused by reduced package c3-state and package c6-state residency may exceed the processor idle power specification for multi-socket platforms.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	dram pbm overflow may result in a system hang not return an error flag.										
problem	the dram pbm (power budget meter) manages dram power consumption. due to this erratum, under complex platform conditions, the dram pbm may throttle the memory subsystem to such a great extent that a system hang results.										
implication	the dram pbm may cause platform instability.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	combining rol transactions with non-rol transactions or marker skipping operations may result in a system hang										
problem	when intel® quick data technology dma rol (raid on load) transactions and non- rol transactions are simultaneously active, and the non-rol address offsets are not cacheline boundary aligned, the non-rol transaction's last partial cacheline data write may be lost leading to a system hang. in addition, when intel quickdata dma rol transactions are active, marker skipping operations may lead to a system hang.										
implication	when this erratum occurs, the processor may live lock resulting in a system hang.										
workaround	none identified. when rol transactions and non-rol transactions are simultaneously active, all non-rol address offsets must be aligned on cacheline boundaries. further, marker  skipping  operations  may  not  be  used  on  any  dma  channel  when  rol transactions are active.										
											
title	error indication in pcie lane error status incorrectly set when operating at 8 gt/s										
problem	the lane error status field in bits[15 258h; and device 2,3; function 0,1,2,3; offset 258h) is used to monitor errors on the pcie lanes. due to this erratum, the lnerrsts bits associated with the lanes operating at 8 gt/s port are spuriously set.										
implication	lnerrsts cannot be used to reliably monitor errors on the pcie lanes operating at 8 gt/s.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie* link may not train to full width										
problem	during pcie link training, the receiver looks at symbols in the ts1 and ts2 ordered sets as indicators of lane polarity inversion. if polarity inversion is detected, the receiver must invert those lane(s). due to this erratum, the receiver may incorrectly set polarity inversion.										
implication	pcie links may not train to full width.										
workaround	none identified. perform a secondary bus reset on the link up to three times to achieve full width.										
											
title	patrol scrubbing doesn't skip ranks disabled after ddr training										
problem	if a rank is detected as failed after completing ddr training then bios will mark it as disabled. disabled ranks are omitted from the os memory map. due to this erratum, a rank disabled after ddr training completes is not skipped by the patrol scrubber. patrol scrubbing of the disabled ranks may result in superfluous correctable and uncorrectable memory error reports.										
implication	disabling ranks after ddr training may result in the over-reporting of memory errors.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	simultaneously enabling patrol scrubbing, package c-states, and rank sparing may cause the patrol scrubber to hang										
problem	patrol scrubbing is a ras facility that scans all physical memory (including any spare ranks) to find errors and attempts to fix single bit errors. patrol scrubbing is suspended when the processor enters a deep package c-state then resumed when that package c- state is exited. due to this erratum, under complex conditions, resuming patrol scrubbing from a package c-state after a rank sparing event may cause the patrol scrubber to hang.										
implication	enabling package c-states, rank sparing, and patrol scrubbing simultaneously can lead to a patrol scrubber hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	patrol scrubbing will report uncorrectable memory errors found on a spare rank										
problem	due to this erratum, patrol scrubbing signals an uncorrectable machine check event when it encounters an uncorrectable error while scrubbing a spare rank. the error logged in ia32_mc{8-11}_status (msr 421h, 425h, 429h, 42dh) will have the pcc field (bit 57) set to '1' and the addrv field (bit 58) set to '0' (that is, there is no address information associated with the error report).										
implication	an uncorrectable machine check event may occur for physical memory that is not in use at the time of the event.										
workaround	none identified.										
											
title	directory mode and memory mirroring are incompatible with demand scrubbing or mirror scrubbing										
problem	directory mode is a performance feature used on four socket and scalable platforms to reduce average snoop latency. mirror scrubbing attempts to erase uncorrectable errors found in one mirror channel by overwriting them with the correct data from the other channel. due to this erratum, enabling memory mirroring and directory mode with demand  scrubbing  and/or  mirror  scrubbing  can  result  in  unpredictable  system behavior. patrol scrubbing with memory mirroring enabled and directory mode enabled is not affected by this erratum.										
implication	enabling memory mirroring and directory mode with demand scrubbing and/or mirror scrubbing can lead to unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	spurious power limit interrupt may occur at package c-state exit										
problem	the processor monitors power consumption and uses that information to limit core operating frequency. due to this erratum, power consumption may be improperly calculated by the processor during package c-states. as a result, the processor may incorrectly signal a power limit interrupt.										
implication	in response to a power limit interrupt, the os may choose to operate the processor at its minimum frequency for several milliseconds after the package c-state exit.										
workaround	none identified. the os can mask these interrupts by setting the power limit interrupt enable field (bit 24) in the ia32_therm_interrupt msr (19bh) to 0.										
											
title	intel vt-d translation fault may be dropped										
problem	due to this erratum, under complex conditions, an intel vt-d translation request that results in a dma remapping fault (more commonly called “translation fault”) may be lost.										
implication	an intel vt-d translation fault might not be properly reported.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum										
											
title	the accumulated energy status read service may report a power spike early in boot										
problem	the peci rdpkgconfig() command with an index value of 03h is the accumulated energy status read service. during platform boot, the accumulated energy status read service returns an accumulated energy value of 0. later in the boot flow, due to this erratum, the accumulated energy status read service returns a value that is large. energy values calculated with the first non-zero sample have been observed to be as high as 10kj over a limited number of parts.										
implication	software may interpret values returned by the accumulated energy status read service during boot time as indicating a large power spike. this could lead to unexpected or undesired platform power management actions.										
workaround	once  the  first  non-zero  value  is  detected,  the  difference  between  subsequent sequential values is a reliable measure of energy consumed between the sample points.										
											
title	certain uncorrectable errors may cause loss of peci functionality										
problem	a peci completion code of 91h indicates the pcu (power control unit) detected an uncorrectable error that prevented processing of the peci request. due to this erratum, certain pcu or vrm error conditions may lead to a persistent 91h completion code for subsequent peci request. uncorrectable pcu errors are reported with an ia32_mc4_status.mcacod (msr 411h, bits[15:0]) value of 0000_0100_0000_0010, ia32_mc4_status.valid (bit 63) set to 1, and ia32_mc4_status.uc (bit 61) set to 1.										
implication	peci processing may be blocked until either a cold reset or software running on one of the cores clears the ia32_mc4_status register.										
workaround	none identified. software running on one of the cores can clear the ia32_mc4_status register to restore peci functionality.										
											
title	machine check during vm exit may result in vmx abort										
problem	a machine check signaled during vm exit should cause a vmx abort only if the machine check would prevent successful completion of the vm exit; ordinarily, the machine check should be delivered after the vm exit completes. due to this erratum, certain machine checks (for example, an uncorrectable cache error detected by another logical processor) may force a vm exit to result in a vmx abort even when that machine check does not interfere with the vm exit completing correctly.										
implication	certain machine checks that could be reported in the host context for orderly logging and analysis may instead induce a vmx abort and shut down the logical processor.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	routing intel® high definition audio traffic through vc1 may result in system hang										
problem	when bit 9 in the iiomiscctrl csr (bus 0; device 5; function 0; offset 1c0h) is set, vcp inbound traffic (intel® hd audio) is routed through vc1 to optimize isochronous traffic performance. due to this erratum, vc1 may not have sufficient bandwidth for all traffic routed through it; overflows may occur.										
implication	this erratum can result in lost completions that may cause a system hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel® quickdata technology dma suspend does not transition from armed to halt state										
problem	suspending an intel quickdata technology dma channel while in the armed state should transition the channel to the halt state. due to this erratum, suspending a dma channel while in the armed state does not change the state to halt and will cause the dma engine, when subsequently activated, to ignore the first descriptor's fence control bit and may cause the dma engine to prematurely discard the first descriptor during the copy stage.										
implication	suspending a dma channel while in the armed state will cause the dma engine to ignore descriptor fencing, possibly issue completion status without actually completing all descriptors, and may be subject to unexpected activation of dma transfers.										
workaround	check the dma_trans_state (chansts_0; bus 0; mmio bar 88h; bits[2:0]) to ensure the channel state is either idle (001b) or active (000b) before setting susp_dma (chancmd; bus 0; mmio bar: cb_bar [0:7]; offset 84h; bit 2).										
											
title	package_energy_counter register may incorrectly report power consumed by the execution of intel® advanced vector extensions (intel® avx) instructions										
problem	the processor includes a package_energy_counter register to provide real-time energy consumption information. this facility can be accessed by the peci rdpkgconfig() command with an index value of 03h (the accumulated energy status read service), by reading the pkg_energy_status msr (611h) or by reading package_energy_status csr (bus 1; device 10; function 0; offset 90h). due to this erratum, the power consumption reported during the execution of intel® advanced vector extensions (intel® avx) instructions is inaccurate.										
implication	software that uses the package_energy_counter register value during the execution of intel avx instructions may not behave as expected, possibly compromising thermal load balancing, processor throttling, or other platform management operations.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	suspending/resetting a dma xor channel may cause an incorrect data transfer on other active channels										
problem	suspending an active dma xor channel by setting chancmd.suspend dma bit (offset 84; bit 2) while xor type dma channels are active may cause incorrect data transfer on the other active legacy channels. this erratum may also occur while resetting an active dma xor channel chancmd.reset dma bit (offset 84; bit 5). chancmd is in the region described by cb_bar (bus 0; device 4; function 0-7; offset 10h).										
implication	due to this erratum, an incorrect data transfer may occur on the active legacy dma channels.										
workaround	software must suspend all legacy dma channels before suspending an active dma xor channel (channel 0 or 1).										
											
title	intel® qpi l0s exit may cause an uncorrectable machine check										
problem	intel qpi links can transition to a lower power state, l0s, to reduce power consumption during transmitter idle periods. due to this erratum, when an intel qpi link exits l0s state, the resulting retraining may not be successful.										
implication	due to this erratum, an uncorrectable error signaled with ia32_mci_status.mcacod value of 0000_1110_0000_1111 and ia32_mci_status.mscod[5:0] value of 00_0000 may occur when an intel qpi link exits from l0s state.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	coherent interface write cache may report false correctable ecc errors during cold reset										
problem	the integrated i/o's coherent interface write cache includes ecc logic to detect errors. due to this erratum, the write cache can report false ecc errors. this error is signaled by asserting bit 1 (write cache corrected ecc) in the irpp0errst csr (bus 0; device 5; function 2; offset 230h) or the irpp1errst csr (bus 0; device 5; function 2; offset 2b0h).										
implication	if the coherent interface write cache ecc is enabled, the processor may incorrectly indicate correctable ecc errors in the write cache.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel quickdata technology continues to issue requests after detecting 64-bit addressing errors										
problem	intel quickdata technology utilizes the lower 48 address bits of a 64-bit address field. detection of accesses to source address, destination address, descriptor address, chain address, or completion address outside of this 48-bit range are flagged as “64-bit addressing errors” and should halt dma processing. due to this erratum, the intel quickdata dma continues to issue requests after detecting certain 64-bit addressing errors involving raid operations. the failing condition occurs for 64-bit addressing errors in either a channel completion upper address register (chancmp_0, chancmp_1) (bus 0; mmio bar cb_bar [0:7]; offset 98h, 9ch), or in the source or destination addresses of a raid descriptor.										
implication	programming out of range dma address values may result in unpredictable system behavior.										
workaround	ensure all raid descriptors, chancmp_0, and chancmp_1 addresses are within the 48-bit range before starting the dma engine.										
											
title	pcie* ro may result in a system hang or unpredictable system behavior										
problem	pcie ro (relaxed ordering) is not supported on this processor. due to this erratum, enabling ro or, equivalently, not disabling ro throughout the integrated i/o logic may lead to unpredictable system behavior or a system hang.										
implication	enabling ro for any port or channel may lead to system instability.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel vt-d invalidation time-out error may not be signaled										
problem	intel vt-d (intel virtualization technology for directed i/o) utilizes itags to identify ats (address translation services) invalidation requests for invalidating device-tlbs on endpoint devices. when an ats invalidation response time-out is detected, the corresponding itag is freed and an invalidation time-out error is signaled through the vt-d fault status register. due to this erratum, an ats invalidation response timeout is detected and reported only for the first outstanding itag entry.										
implication	as a result of the erratum, the ats invalidation response timeout condition may not be reliably reported when multiple invalidation requests are outstanding. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	spurious machine check errors may occur										
problem	the ia32_mci_ctl msr comprises enable bits for various machine check events. when a particular machine check event occurs but the associated bit in ia32_mci_ctl msr is not set, the error is not signaled but is logged with the en flag (bit 60 in ia32_mci_status msr) set to zero. further, the logged error report is not protected from being overwritten by succeeding machine check events (whether those events have the associated ia32_mci_ctl bit set or cleared). due to this erratum, it is possible that a ucr (uncorrectable recoverable) error with the associated bit in ia32_mci_ctl msr set will only set the over flag (ia32_mci_status msr bit 62) rather than correctly overwriting the entire previously logged error when that previously logged error does not have ia32_mci_status.en set.										
implication	the machine check handler may interpret the failed overwrite as a spurious error.										
workaround	none identified										
											
title	enhanced intel speedstep® technology hardware coordination cannot be disabled										
problem	the processor should permit hardware coordination of enhanced intel speedstep technology requests to be disabled (then use the most recent p-state request from any core or logical processor to set the processor-wide p-state target). due to this erratum, the enhanced intel speedstep technology hardware coordination disable value in bit 0 of the misc_pwr_mgmt msr (1aah) is ignored; hardware coordination is always enabled.										
implication	it is not possible to prevent hardware p-state coordination.										
workaround	none identified.										
											
title	pcie link upconfigure capability is incorrectly advertised as supported										
problem	the processor does not allow pcie devices to dynamically change link width but, due to this erratum, the pcie link upconfigure capability bit is incorrectly advertised as supported.										
implication	when a downstream device attempts to dynamically change the link's width, the link may not correctly retrain, resulting in an incorrect link width, reversed lane numbers, or surprise link down (sld).										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	the ia32_mci_misc										
problem	the ia32_mci_misc.hadbbank field should be ignored										
implication	when analyzing machine check register bank contents, the ia32_mci_misc.hadbbank field should be ignored.										
workaround	none identified										
											
title	when a pcie x4 port detects a logical lane 0 failure, the link will advertise incorrect lane numbers										
problem	the pcie interface incorporates a recovery mechanism for link degradation by retraining the link without affecting pending transactions. when a x4 port detects a lane failure on logical lane 0, the link degrades from x4 to x2 and lane reversal occurs. due to this erratum, after degrading to x2 and reversing the lanes, the link will incorrectly advertise lane numbers as “pad 0 1 0" instead of the correct “pad pad 1 0".										
implication	devices that have the ability to negotiate a link with logical lane 0 on a mid physical lane may fail to successfully train the link.										
workaround	none identified.										
											
title	a machine check exception concurrent with an i/o smi may be erroneously reported as re-startable										
problem	a machine check exception that is delivered between the execution of an i/o instruction (in, ins, out, or outs) and an smi (system-management interrupt) triggered by that instruction may prevent proper handling of the smi; because of this, the machine check exception should not be reported as restartable. due to this erratum, such a machine check exception may be reported as restartable.										
implication	a restartable machine check exception on an i/o instruction concurrent with a resulting smi may result in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	vex										
problem	the vex.l bit should be ignored for the vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions, however due to this erratum the vex.l bit is not ignored and will cause a #ud.										
implication	unexpected #uds will be seen when the vex.l bit is set to 1 with vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions.										
workaround	software should ensure that the vex.l bit is set to 0 for all scalar instructions.										
											
title	the system agent temperature is not available										
problem	due to this erratum, the processor does not record the temperature of the system agent in the temperature field in bits [7:0] of the sa_temperature csr (device 10; function 2; offset: 044h).										
implication	firmware  cannot  read  the  temperature  of  the  system agent  via accessing  the sa_temperature csr.										
workaround	none identified. the system agent temperature is available via peci rdpkgconfig command service, parameter value 00ffh.										
											
title	incorrect retry packets may be sent by a pcie x16 port operating at 8 gt/s										
problem	a pcie x16 port operating at 8 gt/s transmitting 256 byte completion tlps may not replay tlps correctly.										
implication	due to this erratum, unpredictable system behavior may result when a 256 byte completion tlp is replayed on a pcie x16 port operating at 8 gt/s.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel® quickdata technology may incorrectly signal a master abort										
problem	under complex conditions, a master abort error suffered by an intel quickdata technology dma channel running non-raid operations may be reported for both the failing  transfer  and  a  transfer  on  a  different  channel  actively  performing  raid operations. note that master abort errors on intel quickdata technology dma transfers are unusual, generally indicating dma transfer configuration errors.										
implication	due to this erratum, raid intel quickdata technology transfers may receive spurious master abort errors.										
workaround	none identified. to avoid this erratum any master aborts errors, (2) do not request fencing (by asserting bit 4) or interrupt on completion (by asserting bit 0) in the descriptor control field, or (3) do not use raid operations.										
											
title	mci_addr may be incorrect for cache parity errors										
problem	in cases when a wbinvd instruction evicts a line containing an address or data parity error (mcacod of 0x124, and mscod of 0x10), the address of this error should be logged in the mci_addr register. due to this erratum, the logged address may be incorrect, even though mci_status.addrv (bit 63) is set.										
implication	the address reported in mci_addr may not be correct for cases of a parity error found during wbinvd execution.										
workaround	none identified.										
											
title	instruction fetch page-table walks may be made speculatively to uncacheable memory										
problem	page-table walks on behalf of instruction fetches may be made speculatively to uncacheable (uc) memory.										
implication	if any paging structures are located at addresses in uncacheable memory that are used for memory-mapped i/o, such i/o operations may be invoked as a result of speculative execution that would never actually occur in the executed code path. intel has not observed this erratum with any commercially available software.										
workaround	software should avoid locating paging structures at addresses in uncacheable memory that are used for memory-mapped i/o.										
											
title	the processor may not properly execute code modified using a floating-point store										
problem	under complex internal conditions, a floating-point store used to modify the next sequential instruction may result in the old instruction being executed instead of the new instruction.										
implication	self- or cross-modifying code may not execute as expected. intel has not observed this erratum with any commercially available software.										
workaround	none identified. do not use floating-point stores to modify code.										
											
title	execution of getsec[sexit] may cause a debug exception to be lost										
problem	a debug exception occurring at the same time that getsec[sexit] is executed or when an sexit doorbell event is serviced may be lost.										
implication	due to this erratum, there may be a loss of a debug exception when it happens concurrently with the execution of getsec[sexit]. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	warm reset may cause pcie hot-plug to fail										
problem	the integrated i/o unit uses the vpp (virtual pin port) to communicate with devices that interface to the switches and leds associated with pcie hot-plug sequencing. due to this erratum, vpp operation stalls when a warm reset occurs and then experiences delayed reset. depending on timing alignment with the warm reset event, a vpp transaction in progress around the time of a warm reset may suffer an extended stall or an immediate termination.										
implication	hot-plug sequencing may suffer failures during or shortly after warm resets which may be temporary or persist until the next cold reset.										
workaround	none identified.										
											
title	ia32_mc5_ctl2 is not cleared by a warm reset										
problem	ia32_mc5_ctl2 msr (285h) is documented to be cleared on any reset. due to this erratum this msr is only cleared upon a cold reset.										
implication	the algorithm documented in software developer's manual, volume 3, section titled “cmci initialization” or any other algorithm that counts the ia32_mc5_ctl2 msr being cleared on reset will not function as expected after a warm reset.										
workaround	none identified.										
											
title	monitor counters may produce incorrect results										
problem	when operating with smt enabled, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled event on the corresponding counter with the same number on the physical core's other thread rather than the thread experiencing the event. processors with smt disabled in bios are not affected by this erratum the list of affected memory at-retirement events is as follows: mem_uop_retired.loads mem_uop_retired.stores mem_uop_retired.lock mem_uop_retired.split mem_uop_retired.stlb_miss mem_load_uops_retired.hit_lfb mem_load_uops_retired.l1_hit mem_load_uops_retired.l2_hit mem_load_uops_retired.llc_hit mem_load_uops_llc_hit_retired.xsnp_hit mem_load_uops_llc_hit_retired.xsnp_hitm mem_load_uops_llc_hit_retired.xsnp_miss mem_load_uops_llc_hit_retired.xsnp_none mem_load_uops_retired.llc_miss mem_load_uops_llc_miss_retired.local_dram mem_load_uops_llc_miss_retired.remote_dram mem_load_uops_retired.l2_miss										
implication	due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.										
workaround	none identified.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in the ia32_ mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding										
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9 any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9 write all vmcs fields may omit one field.										
workaround	none identified.										
											
title	the upper 32 bits of cr3 may be incorrectly used with 32-bit paging										
problem	when 32-bit paging is in use, the processor should use a page directory located at the 32-bit physical address specified in bits 31:12 of cr3; the upper 32 bits of cr3 should be ignored. due to this erratum, the processor will use a page directory located at the 64-bit physical address specified in bits 63:12 of cr3.										
implication	the processor may use an unexpected page directory or, if ept (extended page tables) is in use, cause an unexpected ept violation. this erratum applies only if software enters 64-bit mode, loads cr3 with a 64-bit value, and then returns to 32-bit paging without changing cr3. intel has not observed this erratum with any commercially available software.										
workaround	software that has executed in 64-bit mode should reload cr3 with a 32-bit value before returning to 32-bit paging.										
											
title	ept violations may report bits 11:0 of guest linear address incorrectly										
problem	if a memory access to a linear address requires the processor to update an accessed or dirty flag in a paging-structure entry and if that update causes an ept violation, the processor should store the linear address into the “guest linear address” field in the vmcs. due to this erratum, the processor may store an incorrect value into bits 11:0 of this field. (the processor correctly stores the guest-physical address of the paging- structure entry into the “guest-physical address” field in the vmcs.)										
implication	software may not be easily able to determine the page offset of the original memory access that caused the ept violation. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	software requiring the page offset of the original memory access address can derive it by simulating the effective address computation of the instruction that caused the ept violation.										
											
title	virtual-apic page accesses with 32-bit pae paging may cause a system crash										
problem	if a logical processor has ept (extended page tables) enabled, is using 32-bit pae paging, and accesses the virtual-apic page then a complex sequence of internal processor micro-architectural events may cause an incorrect address translation or machine check on either logical processor.										
implication	this erratum may result in unexpected faults, an uncorrectable tlb error logged in ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_0000_0001_xxxxb (where x stands for 0 or 1), a guest or hypervisor crash, or other unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* header of a malformed tlp is logged incorrectly										
problem	if a pcie port receives a malformed tlp (transaction layer packet), an error is logged in the uncerrsts register (device 0; function 0; offset 14ch and device 2-3; function 0-3; offset 14ch). due to this erratum, the header of the malformed tlp is logged incorrectly in the hdrlog register (device 0; function 0; offset 164h and device 2-3; function 0-3; offset 164h).										
implication	the pcie header of a malformed tlp is not logged correctly.										
workaround	none identified.										
											
title	vm exit may set ia32_efer set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe.  due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	pcie* correctable error status register may not log receiver error at caused by a caterr#. 8.0 gt/s										
problem	due to this erratum, correctable pcie receiver errors may not be logged in the dpe field (bit 15) of the pcists csr (bus:0; device 1,2,3; function 0-1,0-3,0-3; offset 6h) when operating at 8.0 gt/s.										
implication	correctable receiver errors during 8.0 gt/s operation may not be visible to the os or driver software.										
workaround	none identified										
											
title	configuring pcie* port 3a as an ntb disables eoi forwarding to port 2a										
problem	configuring pcie port 3a as an ntb (non-transparent bridge) requires disabling eoi (end of interrupt) broadcast forwarding to this port by setting bit 26 of miscctrlsts csr (bus 0; device 3; function 0; offset 188h) to 0. due to this erratum, disabling eoi broadcast forwarding to port 3a improperly disables eoi broadcast forwarding to port 2a.										
implication	some platform configurations will not behave as expected.										
workaround	if port 3a is configured as an ntb then devices requiring eoi messages (those using message signaled interrupts and those with their own io apic) must not be connected to port 2a.										
											
title	pcie* lbms bit incorrectly set										
problem	if a pcie link autonomously changes width or speed for reasons other than to attempt to correct unreliable link operation, the port should set labs bit (link autonomous bandwidth status) (bus 0; device 0; function 0 and device 1; function 0-1 and device 2-3; function 0-3; offset 0x1a2; bit 15). due to this erratum, the processor will not set this bit and will incorrectly set lbms bit (link bandwidth management status) (bus 0; device 0; function 0 and device 1; function 0-1 and device 2-3; function 0-3; offset 0x1a2; bit14) instead.										
implication	software that uses the lbms bit or labs bit may behave incorrectly.										
workaround	none identified										
											
title	local pcie* p2p traffic on x4 ports may cause a system hang										
problem	under certain conditions, p2p (peer-to-peer) traffic between x4 pcie ports on the same processor (i.e., local) may cause a system hang.										
implication	due to this erratum, the system may hang.										
workaround	none identified.										
											
title	pcie* slave loopback may transmit incorrect sync headers										
problem	the pcie base specification requires that, in the loopback.active state, a loopback slave re-transmits the received bit stream bit-for-bit on the corresponding tx. if the link is directed to enter loopback slave mode at 8 gt/s via ts1 ordered sets with both the loopback and compliance receive bits set, the processor may place sync headers in incorrect locations in the loopback bit stream.										
implication	in pcie cem (card electromechanical specification) rx compliance testing directing the link to loopback slave mode, the received data may not be correctly re-transmitted on the tx, causing the test to fail.										
workaround	none identified										
											
title	performance monitor instructions retired event may not count consistently										
problem	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.										
implication	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	intel® vt-d memory check error on an intel® quickdata technology channel may cause all other channels to master abort										
problem	an intel quickdata dma access to intel® vt-d protected memory that results in a protected memory check error may cause master abort completions on all other intel quickdata dma channels.										
implication	due to this erratum, an error during intel quickdata dma access to an intel® vt-d protected memory address may cause a master abort on other intel quickdata dma channels.										
workaround	none identified.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	intel® interconnect bist (intel® ibist) does not work in intel® qpi in slow mode										
problem	the intel® ibist (intel® interconnect built-in self test) does not work in the intel® qpi (intel® quickpath interconnect) slow mode and only works at operational speed.										
implication	the intel ibist does not work in intel® qpi slow mode.										
workaround	do not run the intel ibist in slow mode.										
											
title	retraining parameter negotiation is not implemented for intel® qpi										
problem	the intel® qpi specification states that the physical layer initialization process needs to negotiate retraining parameters with a remote agent. the protocol is that agents should first exchange their respective retraining interval and duration as part of the link initialization flow. then, each agent should compare the local and remote values and choose common values by selecting the shortest interval and the longest duration. this erratum is conveying that the described negotiation feature is not implemented in the processor.										
implication	the processor does not perform the hardware-based retraining parameter negotiation.										
workaround	bios will need to perform the necessary computations to determine the proper parameters and program them into the processor.										
											
title	intel® ibist slave ignores loop count values sent by master on intel® qpi										
problem	during intel ibist (interconnect built-in self test) loopback, one agent is the master agent while the other is the slave agent on intel® qpi. the slave should extract an intel ibist loop count from the training sequence sent by the master, and use this count to time its stay in the loopback.pattern state before returning to loopback.marker state. while the processor is operating as a slave, it does not extract this loop count and times its stay in the loopback.pattern state based on its locally programmed loop count.										
implication	when operating as an intel ibist slave, the processor ignores the loop count values sent by the master.										
workaround	software needs to program the same loop count into the master and the slave.										
											
title	system hangs when skipping stop req2 and start req1 messages in quiesce/lock sequence										
problem	quiesce master skipping the stopreq2 and the startreq1 intel® qpi messages in the lock sequence will result in a system hang.										
implication	due to this erratum, quiesce master lock flows with no stopreq2 and startreq1 messages will cause a system hang.										
workaround	stopreq2 and startreq1 messages should not be considered optional by quiesce master and must be sent to the processor as part of any lock flow.										
											
title	integrated memory controller signals spurious cmci when home agent failover count saturation occurs										
problem	when home agent failover count saturation occurs, the memory controller signals a spurious cmci (corrected machine check interrupt) without logging an error. failover count saturation is not an error and a cmci should not be issued.										
implication	due to this erratum, software receives a cmci with no error logged.										
workaround	none identified.										
											
title											
problem	if an uncorrectable memory controller error is followed by a software recoverable error, the memory controller will not set the s (signaling flag) bit of the mci_status to indicate that a software recoverable error occurred.										
implication	due to this erratum, the mci_status of the memory controller will have the fields valid=1, uc=1, pcc=0, over=1 and s=0 xlogged. when the mca handler comes in, it ignores the mci_status since s=0; and the mca is treated as a spurious mca.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	running sddc+1b with nb crc error may result in incorrect data										
problem	when a read with a single bit error is made to a rank with sddc+1b (single device data correction plus an additional single bit ecc error), along with the nb (north bound) crc error, it could result in incorrect data.										
implication	due to this erratum, incorrect data may be returned when sddc+1b is used with nb crc error. this only has been observed in a synthetic validation environment.										
workaround	disable sddc+1b ecc correction by setting the register field m_pcsr_ecc_corr_ctl.en_sgl_on_kill = 0 (device:0x05; function:0x4; offset:0xb8; bit 6), so that every single-bit error to a rank with sddc will become an uncorrectable error.										
											
title	mci_status s bit not set for llc software recoverable errors										
problem	when an explicit llc (last level cache) write-back software recoverable error is detected while there is already a poison error in the mci_status register, a machine check is signaled but the mci_status.s (signaling flag) bit is not set. in this case the mci_status.pcc (processor context corrupt) bit and the s bit are both 0. as a result, the machine check handler assumes this to be a spurious error.										
implication	if there is already a poison error in the mci_status register and an llc recoverable error is then logged the mca handler may assume this to be a spurious error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	correctable sb crc error may be propagated to an uncorrected ecc error										
problem	due to the processor not having a mechanism to detect incorrect alert frames, correctable sb (south bound) crc error may be propagated to an uncorrected ecc error.										
implication	an incorrect alert frame will not be detected by the processor. in most cases there is no issue, due to the memory buffer issuing a series of alert frames. in a specific case   where a sb intel® scalable memory interconnect (intel® smi) crc error (transient or persistent) is detected and the nb (north bound) alert frame responding to this error is also corrupted by an error, the original packet may not be reissued. however, since the memory controller uses two intel smi channels in lockstep for each cache line access, on a future read if one channel was affected by this issue the other would return valid data. due to this erratum, the correctable sb crc error may get propagated to be a detected but uncorrected ecc error. intel has not observed this erratum on any commercially available system.										
workaround	none identified.										
											
title	memory controller patrol scrub ceases to function with crc errors and the imt31 reclaim feature enabled										
problem	the processor does not fully implement the protocol in the memory controller-home agent for sharing the imt31 (in-flight memory table) entry resulting in a patrol scrub deadlock. this issue can occur whenever the error flow state is invoked in response to crc errors or hardware injected periodic zqcal (zq calibration).										
implication	patrol scrub may not function with crc errors and the imt31 reclaim feature enabled.										
workaround	a bios workaround has been identified. please refer to the latest version of the memory reference code.										
											
title	false patrol read error logging may occur with patrol scrub enabled and with sb crc errors										
problem	when there is a link level crc on the sb (south bound) intel smi lanes and patrol scrubbing is enabled, patrol scrubs may detect false uncorrectable ecc errors (logged as patrol read errors). the data at this location is not corrupted and poison bit is not set. the probability of this happening increases with a higher patrol rate or a higher sb crc error rate.										
implication	under poison mode, a patrol read error is a software recoverable error. if enabled system software should perform its programmed recovery action. this erratum has only been observed in a synthetic testing environment. intel has not observed this erratum with any commercially available system.										
workaround	none identified. performing patrol scrub through memory no more than once in 12 hours can minimize the occurrence of this erratum.										
											
title	electrically idle intel smi and intel® qpi lanes may deliver data that may look like deskew headers										
problem	intel smi or intel® qpi lanes that are not physically connected on the board, or have become unconnected, may result in a deskew failure.										
implication	improper deskew headers may be observed if the intel smi or intel® qpi lane of a port is not physically connected.										
workaround	none identified.										
											
title	a sequence of instruction fetches and snoops to locked cache lines may cause processor to hang										
problem	during a sequence of instruction fetches with specific address relationships to other system traffic a snoop beat pattern that includes snoops to locked cache lines may become established which could cause the processor to hang.										
implication	the processor may hang under a set of conditions involving instruction fetches, and snoops to locked cache lines.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writing to unimplemented bits of uu_cr_u_msr_pmon_evnt_sel msr does not result in #gp fault										
problem	the bits [31:23,17,15:8] in uu_cr_u_msr_pmon_evnt_sel msr (c10h) are not implemented on the processor and are marked as reserved. due to this erratum writing 1's to these bits does not generate a #gp (general protection fault) as expected.										
implication	writing 1's to the unimplemented bits in uu_cr_u_msr_pmon_evnt_sel msr does not result in a #gp fault.										
workaround	none identified.										
											
title	mixed rank size memory configurations may cause a missing refresh event										
problem	when using dimms of different rank sizes on the same memory channel, a refresh may be missed when a write command to a memory rank is blocked by sustained reads to another memory rank. this erratum has been seen only in a synthetic testing environment. intel has not observed this erratum with any commercially available software.										
implication	a missing refresh may cause the refresh rate to be lower than the programmed value.										
workaround	a bios workaround has been identified. please refer to the latest version of the memory reference code.										
											
title	mirror slave may deliver incorrect data when a read to the mirror master completes before the write-back from the ioh										
problem	a read from the mirror master may complete before the write-back from the ioh completes. this will result in the ioh write-data not being immediately visible and can lead to the ioh write-data never becoming visible. in the case of a rdinvown transaction, the reading caching agent will take ownership which can then overwrite the ioh data. this is especially visible in false-sharing of cache lines which involve the ioh.										
implication	due to this erratum, correct data is not delivered by the mirror slave. this erratum only occurs during mirror failover.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	uu_cr_u_msr_pmon_global_ovf_ctl msr does not follow rw1c access method										
problem	the uu_cr_u_msr_pmon_global_ovf_ctl msr (c02h) is access type rw1c (read write 1 clear) and when written with 1's should clear the corresponding bit in the uu_cr_u_msr_pmon_ global_status msr (c01h). due to this erratum, a read of the uu_cr_u_msr_pmon_global_ovf_ctl msr does not return zeros however a read of the uu_cr_u_msr_pmon_ global_status msr will show appropriate clearing.										
implication	the uu_cr_u_msr_pmon_global_ovf_ctl msr does not return zeros on a read.										
workaround	none identified.										
											
title	hnid field is incorrect for cmp messages from prefetchhint										
problem	the hnid (home node id) field used in the pmon (performance monitoring) match/ mask is incorrect for cmp (complete) messages from prefetchhint. the same incorrect hnid is logged in the event of an error condition on a cmp for a prefetchhint in the caching agent. the logging of the rnid (requester node id) in the error logs for ndr (non data response) messages is incorrect and impacts the caching agent system bound errors.										
implication	there are two implications: incorrect hnid is filtered or matched for cmp's using the caching agent pmon match/mask. the incorrect rnid will be logged only for errors on ndr messages.										
workaround	there are two potential workarounds:										
											
title	processor internal initialization code may become damaged under certain conditions										
problem	under certain platform conditions, it is possible for the processor's internal initialization code to become damaged or erased over the course of power cycling vio and vcache multiple times. at least four such power cycles are required to encounter this erratum.										
implication	if this erratum occurs, the processor internal initialization code will become damaged or erased and the processor will no longer be functional.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	debug exception flags dr6.b0-b3 flags may be incorrect for disabled breakpoints										
problem	when a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (dr7.g0-g3 and dr7.l0-l3), the dr6.b0-b3 flags may be incorrect.										
implication	the debug exception dr6.b0-b3 flags may be incorrect for the load if the corresponding breakpoint enable flag in dr7 is disabled.										
workaround	none identified.										
											
title	monitor or clflush on the local xapic's address space results in hang										
problem	if the target linear address range for a monitor or clflush is mapped to the local xapic's address space, the processor will hang.										
implication	when this erratum occurs, the processor will hang. the local xapic's address space must be uncached. the monitor instruction only functions correctly if the specified linear address range is of the type write-back. clflush flushes data from the cache. intel has not observed this erratum with any commercially available software.										
workaround	do not execute monitor or clflush instructions on the local xapic address space.										
											
title	corruption of cs segment register during rsm while transitioning from real mode to protected mode										
problem	during the transition from real mode to protected mode, if an smi (system management interrupt) occurs between the mov to cr0 that sets pe (protection enable, bit 0) and the first far jmp, the subsequent rsm (resume from system management mode) may cause the lower two bits of cs segment register to be corrupted.										
implication	the corruption of the bottom two bits of the cs segment register will have no impact unless software explicitly examines the cs segment register between enabling protected mode and the first far jmp. intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, part 1, in the section titled “switching to protected mode” recommends the far jmp immediately follows the write to cr0 to enable protected mode. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	the processor may report a #ts instead of a #gp fault										
problem	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss exception) instead of a #gp fault (general protection exception).										
implication	operation systems that access a busy tss may get invalid tss fault instead of a #gp fault. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	rep movs/stos executing with fast strings enabled and crossing page boundaries with inconsistent memory types may use an incorrect data size or lead to memory-ordering violations										
problem	under certain conditions as described in the software developers manual section “out- of-order stores for string operations in pentium 4, intel xeon, and p6 family processors” the processor performs rep movs or rep stos as fast strings. due to this erratum fast string rep movs/rep stos instructions that cross page boundaries from wb/wc memory types to uc/wp/wt memory types, may start using an incorrect data size or may observe memory ordering violations.										
implication	upon crossing the page boundary the following may occur, dependent on the new page memory type: uc the data size of each write will now always be 8 bytes, as opposed to the original data size.   wp the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. wt there may be a memory ordering violation.										
workaround	software should avoid crossing page boundaries from wb or wc memory type to uc, wp or wt memory type within a single rep movs or rep stos instruction that will execute with fast strings enabled.										
											
title	code segment limit/canonical faults on rsm may be serviced before higher priority interrupts/exceptions and may push the wrong address onto the stack										
problem	normally, when the processor encounters a segment limit or canonical fault due to code execution, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. due to this erratum, if rsm (resume from system management mode) returns to execution flow that results in a code segment limit or canonical fault, the #gp fault may be serviced before a higher priority interrupt or exception (for example, nmi (non-maskable interrupt), debug break(#db), machine check (#mc), and so forth). if the rsm attempts to return to a noncanonical address, the address pushed onto the stack for this #gp fault may not match the noncanonical address that caused the fault.										
implication	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	performance monitor sse retired instructions may return incorrect values										
problem	performance monitoring counter simd_inst_retired (event: c7h) is used to track retired sse instructions. due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.										
implication	performance monitoring counter simd_inst_retired may report count higher than expected.										
workaround	none identified.										
											
title	premature execution of a load operation prior to exception handler invocation										
problem	if any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. if an instruction that performs a memory load causes a code segment limit violation. if a waiting x87 floating-point (fp) instruction or mmx™ technology (mmx) instruction that performs a memory load has a floating-point exception pending. if an mmx or sse/sse2/sse3/ssse3 extensions (sse) instruction that performs a memory load and has either cr0.em=1 (emulation bit set), or a floating-point top- of-stack (fp tos) not equal to 0, or a dna exception pending.										
implication	in normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. if the   target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the side- effect. particularly, while cr0.ts [bit 3] is set, a movd/movq with mmx/xmm register operands may issue a memory load before getting the dna exception.										
workaround	code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory.										
											
title	mov to/from debug registers causes debug exception										
problem	when in v86 mode, if a mov instruction is executed to/from a debug registers, a general-protection exception (#gp) should be generated. however, in the case when the general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.										
implication	with debug-register protection enabled (that is, the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception will be generated instead of the expected general-protection fault.										
workaround	in general, operating systems do not set the gd bit when they are in v86 mode. the gd bit is generally set and used by debuggers. the debug exception handler should check that the exception did not occur in v86 mode before continuing. if the exception did occur in v86 mode, the exception may be directed to the general-protection exception handler.										
											
title	incorrect address computed for last byte of fxsave/fxrstor image leads to partial memory update										
problem	a partial memory state save of the 512-byte fxsave image or a partial memory state restore of the fxrstor image may occur if a memory address exceeds the 64kb limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4gb limit while the processor is operating in 32-bit mode.										
implication	fxsave/fxrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.										
workaround	software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits.										
											
title	values for lbr/bts/btm will be incorrect after an exit from smm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect. this issue would only occur when one of the 2 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.										
workaround	none identified.										
											
title	single step interrupts with floating point exception pending may be mishandled										
problem	in certain circumstances, when a floating point exception (#mf) is pending during single-step execution, processing of the single-step debug exception (#db) may be mishandled.										
implication	when this erratum occurs, #db will be incorrectly handled as follows: #db is signaled before the pending higher priority #mf (interrupt 16) #db is generated twice on the same instruction										
workaround	none identified.										
											
title	fault on enter instruction may result in unexpected values on stack frame										
problem	the enter instruction is used to create a procedure stack frame. due to this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).										
implication	data in the created stack frame may be altered following a fault on the enter instruction. please refer to “procedure calls for block-structured languages” in intel® 64 and ia-32 architectures software developer's manual, volume 1: basic architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3. faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	iret under certain conditions may cause an unexpected alignment check exception										
problem	in ia-32e mode, it is possible to get an alignment check exception (#ac) on the iret instruction even though alignment checks were disabled at the start of the iret. this can only occur if the iret instruction is returning from cpl3 code to cpl3 code. irets from cpl0/1/2 are not affected. this erratum can occur if the eflags value on the stack has the ac flag set, and the interrupt handler's stack is misaligned. in ia-32e mode, rsp is aligned to a 16-byte boundary before pushing the stack frame.										
implication	in ia-32e mode, under the conditions given above, an iret can get a #ac even if alignment checks are disabled at the start of the iret. this erratum can only be observed with a software generated stack frame.										
workaround	software should not generate misaligned stack frames for use with iret.										
											
title	general protection fault (#gp) for instructions greater than 15 bytes may be preempted										
problem	when the processor encounters an instruction that is greater than 15 bytes in length, a #gp is signaled when the instruction is decoded. under some circumstances, the #gp fault may be preempted by another lower priority fault (for example, page fault (#pf)). however, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #gp fault will occur.										
implication	software may observe a lower-priority fault occurring before or in lieu of a #gp fault. instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.										
workaround	none identified.										
											
title	general protection (#gp) fault may not be signaled on data segment limit violation above 4-g limit										
problem	in 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4g limit (0ffffffffh) may not signal a #gp fault.										
implication	when such memory accesses occur in 32-bit mode, the system may not issue a #gp fault.										
workaround	software should ensure that memory accesses in 32-bit mode do not occur above the 4g limit (0ffffffffh).										
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1's. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified.										
											
title	a vm exit on mwait may incorrectly report the monitoring hardware as armed										
problem	a processor write to the address range armed by the monitor instruction may not immediately trigger the monitoring hardware. consequently, a vm exit on a later mwait may incorrectly report the monitoring hardware as armed, when it should be reported as unarmed due to the write occurring prior to the mwait.										
implication	if a write to the range armed by the monitor instruction occurs between the monitor and the mwait, the mwait instruction may start executing before the monitoring hardware is triggered. if the mwait instruction causes a vm exit, this could cause its exit qualification to incorrectly report 0x1. in the recommended usage model for monitor/mwait, there is no write to the range armed by the monitor instruction between the monitor and the mwait.										
workaround	software should never write to the address range armed by the monitor instruction between the monitor and the subsequent mwait.										
											
title	performance monitor event segment_reg_loads counts inaccurately										
problem	the performance monitor event segment_reg_loads (event 06h) counts instructions that load new values into segment registers. the value of the count may be inaccurate.										
implication	the performance monitor event segment_reg_loads may reflect a count higher or lower than the actual number of events.										
workaround	none identified.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	improper parity error signaled in the iq following reset when a code breakpoint is set on a #gp instruction										
problem	while coming out of cold reset or exiting from c6, if the processor encounters an instruction longer than 15 bytes (which causes a #gp) and a code breakpoint is enabled on that instruction, an iq (instruction queue) parity error may be incorrectly logged resulting in an mce (machine check exception).										
implication	when this erratum occurs, an mce may be incorrectly signaled.										
workaround	none identified.										
											
title	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception										
problem	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.										
implication	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software or system.										
workaround	as recommended in the intel® 64 and ia-32 intel® architectures software developer’s manual, the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.										
											
title	ia32_mperf counter stops counting during on-demand tm1										
problem	according to the intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, the ratio of ia32_mperf (msr e7h) to ia32_aperf (msr e8h) should reflect actual performance while tm1 or on-demand throttling is activated. due to this erratum, ia32_mperf msr stops counting while tm1 or on-demand throttling is activated, and the ratio of the two will indicate higher processor performance than actual.										
implication	the incorrect ratio of ia32_aperf/ia32_mperf can mislead software p-state (performance state) management algorithms under the conditions described above. it is possible for the operating system to observe higher processor utilization than actual, which could lead the os into raising the p-state. during tm1 activation, the os p-state request is irrelevant and while on-demand throttling is enabled, it is expected that the os will not be changing the p-state. this erratum should result in no practical implication to software.										
workaround	none identified.										
											
title	synchronous reset of ia32_aperf/ia32_mperf counters on overflow does not work										
problem	when either the ia32_mperf or ia32_aperf msr (e7h, e8h) increments to its maximum value of 0xffff_ffff_ffff_ffff, both msrs are supposed to synchronously reset to 0x0 on the next clock. this synchronous reset does not work. instead, both msrs increment and overflow independently.										
implication	software can not rely on synchronous reset of the ia32_aperf/ia32_mperf registers.										
workaround	none identified.										
											
title	disabling thermal monitor while processor is hot, then re-enabling, may result in stuck core operating ratio										
problem	if a processor is at its tcc (thermal control circuit) activation temperature and then thermal monitor is disabled by a write to ia32_misc_enables msr (1a0h) bit [3], a subsequent re--enable of thermal monitor will result in an artificial ceiling on the maximum core p-state. the ceiling is based on the core frequency at the time of thermal monitor disable. this condition will only correct itself once the processor reaches its tcc activation temperature again.										
implication	since intel requires that thermal monitor be enabled in order to be operating within specification, this erratum should never be seen during normal operation.										
workaround	software should not disable thermal monitor during processor operation.										
											
title	over bit for ia32_mci_status register may get set on specific lnternal error										
problem	if a specific type of internal unclassified error is detected, as identified by ia32_mci_status.mcacod=0x0405, the ia32_mci_ status.over (overflow) bit [62] may be erroneously set.										
implication	the over bit of the mci_status register may be incorrectly set for a specific internal unclassified error.										
workaround	none identified.										
											
title	writing the local vector table (lvt) when an interrupt is pending may cause an unexpected interrupt										
problem	if a local interrupt is pending when the lvt entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.										
implication	an interrupt may immediately be generated with the new vector when a lvt entry is written, even if the new lvt entry has the mask bit set. if there is no interrupt service routine (isr) set up for that vector the system will gp fault. if the isr does not do an   end of interrupt (eoi) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.										
workaround	any vector programmed into an lvt entry must have an isr associated with it, even if that vector was programmed as masked. this isr routine must do an eoi to clear any unexpected interrupts that may occur. the isr associated with the spurious vector does not generate an eoi, therefore the spurious vector should not be used when writing the lvt.										
											
title	reading reserved apic registers may not signal an apic error										
problem	reads of reserved apic registers in xapic compatibility mode should signal an apic error with the illegal register address bit [11] set in the error status register (offset 0x280). due to the erratum, the error is neither logged nor signaled.										
implication	a reserved apic register access error interrupt may not be logged or signaled, even though the apic error interrupt is enabled, on a read of a reserved apic register.										
workaround	none identified.										
											
title	faulting mmx instruction may incorrectly update x87 fpu tag word										
problem	under a specific set of conditions, mmx stores (movd, movq, movntq, maskmovq) which cause memory access faults (#gp, #ss, #pf, or #ac), may incorrectly update the x87 fpu tag word register. this erratum will occur when the following additional conditions are also met. the mmx store instruction must be the first mmx instruction to operate on x87 fpu state (that is, the x87 fp tag word is not already set to 0x0000). for movd, movq, movntq stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to maskmovq).										
implication	if the erratum conditions are met, the x87 fpu tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.										
workaround	none identified.										
											
title	certain store parity errors may not log correct address in ia32_mci_addr										
problem	when store parity errors in the level 0 hierarchy (as defined in the ll subfield of the ia32_mci_status msr) occur, it is possible that the address of the error will not be logged in ia32_mci_addr msr. the error itself will be logged properly.										
implication	the address in ia32_mci_addr may be incorrect after certain store parity errors occur.										
workaround	none identified.										
											
title											
problem	when the xapic timer is automatically reloaded by counting down to zero in periodic mode, the xapic timer may slip in its synchronization with the external clock. the xapic timer may be shortened by up to one xapic timer tick.										
implication	when the xapic timer is automatically reloaded by counting down to zero in periodic mode, the xapic timer may slip in its synchronization with the external clock. the xapic timer may be shortened by up to one xapic timer tick.										
workaround	none identified.										
											
title	certain undefined opcodes crossing a segment limit may result in #ud instead of #gp exception										
problem	processor may take a #ud (invalid opcode) exception instead of a #gp (general protection) exception when certain undefined opcodes (opcodes 0f 01 d0 - 0f 01 d5) extend beyond the segment limit.										
implication	due to this erratum, processor may not take a #gp exception in this situation.										
workaround	none identified.										
											
title											
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of movntdqa that loads from wc (write combining) memory may appear to pass an earlier locked instruction to a different cache line.										
implication	software that expects a lock to fence subsequent movntdqa instructions may not operate properly. if the software does not rely on locked instructions to fence the subsequent execution of movntdqa then this erratum does not apply.										
workaround	software that requires a locked instruction to fence subsequent executions of movntdqa should insert an lfence instruction before the first execution of movntdqa following the locked instruction. if there is already a fencing or serializing instruction between the locked instruction and the movntdqa, then an additional lfence is not necessary.										
											
title	changing the memory type for an in-use page translation may lead to memory-ordering violations										
problem	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.										
implication	memory ordering may be violated. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure pages are not being actively used before requesting their memory type be changed.										
											
title	delivery of certain events immediately following a vm exit may push a corrupted rip onto the stack										
problem	if any of the following events is delivered immediately following a vm exit to 64-bit mode from outside 64-bit mode, bits 63:32 of the rip value pushed on the stack may be cleared to 0: a nonmaskable interrupt (nmi); a machine-check exception (#mc); a page fault (#pf) during instruction fetch; or a general-protection exception (#gp) due to an attempt to decode an instruction whose length is greater than 15 bytes.										
implication	unexpected behavior may occur due to the incorrect value of the rip on the stack. specifically, return from the event handler via iret may encounter an unexpected page fault or may begin fetching from an unexpected code address.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the combination of a bus lock and a data access that is split across page boundaries may lead to processor livelock										
problem	under certain complex microarchitectural conditions, the coincidence of a bus lock initiated by one logical processor of a hyper-threading enabled processor core and data accesses that are split across page boundaries, initiated on the other logical processor on the same core, may lead to processor livelock.										
implication	due to this erratum, a livelock may occur that can only be terminated by a processor reset. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	an unexpected page fault may occur following the unmapping and remapping of a page										
problem	an unexpected page fault (#pf) may occur for a page under the following conditions: the paging structures initially specify a valid translation for the page. software modifies the paging structures so that there is no valid translation for the page (for example, by clearing to 0 the present bit in one of the paging-structure entries used to translate the page). software later modifies the paging structures so that the translation is again a valid translation for the page (for example, by setting to 1 the bit that was cleared earlier). a subsequent instruction loads from a linear address on the page. software did not invalidate tlb entries for the page between the first modification of the paging structures and the load from the linear address. in this case, the load bye the later instruction may cause a page fault that indicates that there is no translation for the page.										
implication	software may see an unexpected page fault that indicates that there is no translation for the page.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	two xapic timer event interrupts may unexpectedly occur										
problem	if an xapic timer event is enabled and while counting down the current count reaches 1 at the same time that the processor thread begins a transition to a low power c-state, the xapic may generate two interrupts instead of the expected one when the processor returns to c0.										
implication	due to this erratum, two interrupts may unexpectedly be generated by an xapic timer event.										
workaround	none identified.										
											
title											
problem	in general, a pebs record should be generated on the first count of the event after the counter has overflowed. however, ia32_debugctl_msr.freeze_while_smm (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if a performance counter overflowed before an smi a pebs record has not yet been generated because another count of the event has not occurred the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.										
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm even when freeze_while_smm is set.										
workaround	none identified.										
											
title	pebs records for load latency monitoring may contain an incorrect linear address										
problem	the load latency performance monitoring feature stores information about a load into a record in the pebs (precise event-based sampling) buffer in the ds save area. this information includes the data source encoding, latency value, and data linear address of the load causing the performance counter to overflow. under certain conditions it is possible for the linear address to be incorrect.										
implication	the linear address reported by the load latency performance monitoring feature for pebs may be incorrect.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pebs field “data linear address” is not sign extended to 64 bits										
problem	the data linear address field of the pebs (precise event-based sampling) record is not correctly sign extended to 64 bits and may appear as a noncanonical address when observed in the pebs record.										
implication	the pebs data linear address field may not have the sign bit correctly extended to bits [63:48].										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	cpuid incorrectly indicates the unhalted reference cycle architectural event is supported										
problem	the architectural performance monitoring event for unhalted reference cycles (3ch, umask 01h) is not supported on the processor. the cpuid instruction, when executed with eax = 0ah, should return bit 2 of ebx as 1 to indicate that this event is not supported. due to this erratum, cpuid will improperly return bit 2 as 0.										
implication	software relying on the cpuid instruction to determine support of the unhalted reference cycles event will incorrectly assume the event is available.										
workaround	none identified.										
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (that is, following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang										
problem	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).										
implication	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.										
workaround	none identified.										
											
title	ia32_perf_global_ctrl msr may be incorrectly initialized										
problem	the ia32_perf_global_ctrl msr (38fh) bits [34:32] may be incorrectly set to 7h after reset; the correct value should be 0h.										
implication	the ia32_perf_global_ctrl msr bits [34:32] may be incorrect after reset (en_fixed_ctr{0, 1, 2} may be enabled).										
workaround	none identified.										
											
title	processors with smt may hang on p-state transition or acpi clock modulation throttling										
problem	when smt is enabled, it is possible that a p-state transition or acpi clock modulation throttling may hang and log a machine check error with ia32_mci_status.mcacod = 0x0150. this hang condition requires a specific sequence of instructions coincident with the p-state or acpi event.										
implication	when this erratum occurs, the processor will unexpectedly hang. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	sleeping cores may not be woken up on logical cluster mode broadcast ipi using destination field instead of shorthand										
problem	if software sends a logical cluster broadcast ipi using a destination shorthand of 00b (no shorthand) and writes the cluster portion of the destination field of the interrupt command register to all ones while not using all 1s in the mask portion of the destination field, target cores in a sleep state that are identified by the mask portion of the destination field may not be woken up. this erratum does not occur if the destination shorthand is set to 10b (all including self) or 11b (all excluding self).										
implication	when this erratum occurs, cores which are in a sleep state may not wake up to handle the broadcast ipi. intel has not observed this erratum with any commercially available software.										
workaround	use destination shorthand of 10b or 11b to send broadcast ipis.										
											
title	faulting executions of fxrstor may update state inconsistently										
problem	the state updated by a faulting fxrstor instruction may vary from one execution to another.										
implication	software that relies on x87 state or sse state following a faulting execution of fxrstor may behave inconsistently.										
workaround	software handling a fault on an execution of fxrstor can compensate for execution variability by correcting the cause of the fault and executing fxrstor again.										
											
title	performance monitor counters may count incorrectly										
problem	under certain circumstances, a general purpose performance counter, ia32_pmc0-4 (c1h – c4h), may count at core frequency or not count at all instead of counting the programmed event.										
implication	the performance monitor counter ia32_pmcx may not properly count the programmed event. due to the requirements of the workaround there may be an interruption in the counting of a previously programmed event during the programming of a new event.										
workaround	before programming the performance event select registers, ia32_perfevtselx msr (186h – 189h), the internal monitoring hardware must be cleared. this is accomplished by first disabling, saving valid events and clearing from the select registers, then programming three event values 0x4300d2, 0x4300b1 and 0x4300b5 into the ia32_perfevtselx msrs, and finally continuing with new event programming and restoring previous programming if necessary. each performance counter, ia32_pmcx, must have its corresponding ia32_prefevtselx msr programmed with at least one of the event values and must be enabled in ia32_perf_global_ctrl msr (38fh) bits [3:0]. all three values must be written to either the same or different ia32_perfevtselx msrs before programming the performance counters. note that the performance counter will not increment when its ia32_perfevtselx msr has a value of 0x4300d2, 0x4300b1 or 0x4300b5 because those values have a zero umask field (bits [15:8]).										
											
title	performance monitor event offcore_response_0 (b7h) does not count nt stores to local dram correctly										
problem	when a ia32_perfevtselx msr is programmed to count the offcore_response_0 event (event:b7h), selections in the offcore_rsp_0 msr (1a6h) determine what is counted. the following two selections do not provide accurate counts when counting nt (non-temporal) stores: offcore_rsp_0 msr bit [14] is set to 1 (local_dram) and bit [7] is set to 1 (other): nt stores to local dram are not counted when they should have been. offcore_rsp_0 msr bit [9] is set to (other_core_hit_snoop) and bit [7] is set to 1 (other): nt stores to local dram are counted when they should not have been.										
implication	the counter for the offcore_response_0 event may be incorrect for nt stores.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to nonwritable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/ shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept-induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	ler and lbr msrs may be incorrectly updated during a task switch										
problem	ler (last exception record) and lbr (last brand record) msrs (msr_ler_from_lip (1ddh), msr_ler_to_lip (1deh) and msr_lastbranch{0:15}_from_ip (680h – 68fh)) may contain incorrect values after a fault or trap that does a task switch.										
implication	after a task switch the value of the ler and lbr msrs may be updated to point to incorrect instructions.										
workaround	none identified.										
											
title											
problem	when back-to-back uncorrected machine check errors occur that would both be logged in the ia32_mc3_status msr (40ch), the ia32_mc3_status.mscod (bits [31:16]) field may reflect the status of the most recent error and not the first error. the rest of the ia32_mc3_status msr contains the information from the first error.										
implication	software should not rely on the value of ia32_mc3_status.mscod if ia32_mc3_status.over (bit [62]) is set.										
workaround	none identified.										
											
title	corrected errors with a yellow error indication may be overwritten by other corrected errors										
problem	a corrected cache hierarchy data or tag error that is reported with ia32_mci_status.mcacod (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one) and a yellow threshold-based error status indication (bits [54:53] equal to 10b) may be overwritten by a corrected error with a no tracking indication (00b) or green indication (01b).										
implication	corrected errors with a yellow threshold-based error status indication may be overwritten by a corrected error without a yellow indication.										
workaround	none identified.										
											
title	a string instruction that remaps a page may encounter an unexpected page fault										
problem	an unexpected page fault (#pf) may occur for a page under the following conditions: the paging structures initially specify a valid translation for the page. software modifies the paging structures so that there is no valid translation for the page (for example, by clearing to 0 the present bit in one of the paging-structure entries used to translate the page). an iteration of a string instruction modifies the paging structures so that the translation is again a valid translation for the page (for example, by setting to 1 the bit that was cleared earlier). a later iteration of the same string instruction loads from a linear address on the page. software did not invalidate tlb entries for the page between the first modification of the paging structures and the string instruction. in this case, the load in the later iteration may cause a page fault that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page).										
implication	software may see an unexpected page fault that indicates that there is no translation for the page. intel has not observed this erratum with any commercially available software or system.										
workaround	software should not update the paging structures with a string instruction that accesses pages mapped the modified paging structures.										
											
title	performance monitor events dcache_cache_ld and dcache_cache_st may overcount										
problem	the performance monitor events dcache_cache_ld (event 40h) and dcache_cache_st (event 41h) count cacheable loads and stores that hit the l1 cache. due to this erratum, in addition to counting the completed loads and stores, the counter will incorrectly count speculative loads and stores that were aborted prior to completion.										
implication	the performance monitor events dcache_cache_ld and dcache_cache_st may reflect a count higher than the actual number of events.										
workaround	none identified.										
											
title	rapid core c3 transition may cause unpredictable system behavior										
problem	under a complex set of internal conditions, cores rapidly performing c3 transitions in a system with intel® hyper-threading technology enabled may cause a machine check error (ia32_mci_status.mcacod = 0x0106), system hang or unpredictable system behavior.										
implication	this erratum may cause a machine check error, system hang or unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitor events instr_retired and mem_inst_retired may count inaccurately										
problem	the performance monitor event instr_retired (event c0h) should count the number of instructions retired, and mem_inst_ retired (event 0bh) should count the number of load or store instructions retired. however, due to this erratum, they may undercount.										
implication	the performance monitor event instr_retired and mem_inst_retired may reflect a count lower than the actual number of events.										
workaround	none identified.										
											
title	storage of pebs record delayed following execution of mov ss or sti										
problem	when a performance monitoring counter is configured for pebs (precise event-based sampling), overflow of the counter results in storage of a pebs record in the pebs buffer. the information in the pebs record represents the state of the next instruction to be executed following the counter overflow. due to this erratum, if the counter overflow occurs after execution of either mov ss or sti, storage of the pebs record is delayed by one instruction.										
implication	when this erratum occurs, software may observe storage of the pebs record being delayed by one instruction following execution of mov ss or sti. the state information in the pebs record will also reflect the one instruction delay.										
workaround	none identified.										
											
title	performance monitoring events store_blocks.not_sta and store_blocks.sta may not count events correctly										
problem	performance monitor events store_blocks.not_sta and store_blocks.sta should only increment the count when a load is blocked by a store. due to this erratum, the count will be incremented whenever a load hits a store, whether it is blocked or can forward. in addition this event does not count for specific threads correctly.										
implication	if intel hyper-threading technology is disabled, the performance monitor events store_blocks.not_sta and store_blocks.sta may indicate a higher occurrence of loads blocked by stores than have actually occurred. if intel hyper-threading technology is enabled, the counts of loads blocked by stores may be unpredictable and they could be higher or lower than the correct count.										
workaround	none identified.										
											
title	vmx-preemption timer does not count down at the rate specified										
problem	the vmx-preemption timer should count down by 1 every time a specific bit in the tsc (time stamp counter) changes. (this specific bit is indicated by ia32_vmx_misc bits [4:0] (0x485h) and has a value of 5 on the affected processors.) due to this erratum, the vmx-preemption timer may instead count down at a different rate and may do so only intermittently.										
implication	the vmx-preemption timer may cause vm exits at a rate different from that expected by software.										
workaround	none identified.										
											
title	vm exits due to lidt/lgdt/sidt/sgdt do not report correct operand size										
problem	when a vm exit occurs due to a lidt, lgdt, sidt, or sgdt instruction with a 32-bit operand, bit 11 of the vm-exit instruction-information field should be set to 1. due to this erratum, this bit is instead cleared to 0 (indicating a 16-bit operand).										
implication	virtual machine monitors cannot rely on bit 11 of the vm-exit instruction-information field to determine the operand size of the instruction causing the vm exit.										
workaround	virtual machine monitor software may decode the instruction to determine operand size.										
											
title	multiple performance monitor interrupts are possible on overflow of ia32_fixed_ctr2										
problem	when multiple performance counters are set to generate interrupts on an overflow and more than one counter overflows at the same time, only one interrupt should be generated. however, if one of the counters set to generate an interrupt on overflow is the ia32_fixed_ctr2 (msr 30bh) counter, multiple interrupts may be generated when the ia32_fixed_ctr2 overflows at the same time as any of the other performance counters.										
implication	multiple counter overflow interrupts may be unexpectedly generated.										
workaround	none identified.										
											
title	vm exits due to “nmi-window exiting” may be delayed by one instruction										
problem	if vm entry is executed with the “nmi-window exiting” vm-execution control set to 1, a vm exit with exit reason “nmi window” should occur before execution of any instruction if there is no virtual-nmi blocking, no blocking of events by mov ss, and no blocking of events by sti. if vm entry is made with no virtual-nmi blocking but with blocking of events by either mov ss or sti, such a vm exit should occur after execution of one instruction in vmx nonroot operation. due to this erratum, the vm exit may be delayed by one additional instruction.										
implication	vmm software using “nmi-window exiting” for nmi virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual nmi, which is virtually asynchronous. the erratum may affect vmms relying on deterministic delivery of the affected vm exits.										
workaround	none identified.										
											
title	lbrs may not be initialized during power-on reset of the processor										
problem	if a second reset is initiated during the power-on processor reset cycle, the lbrs (last branch records) may not be properly initialized.										
implication	due to this erratum, debug software may not be able to rely on the lbrs out of power- on reset.										
workaround	ensure that the processor has completed its power-on reset cycle prior to initiating a second reset.										
											
title	power controller performance monitor counters may not operate correctly										
problem	the programmable power controller performance monitor counters msr_w_pmon_ctr{0,1,2,3} msrs (c91h, c93h, c95h, c97h) do not operate correctly in some scenarios. these programmable counters have two common usage models: polled and pmi (performance monitor interrupt). polled: the polled usage model starts the counters from zero, and reads the values after some period. as long as the accumulated event count is less than 2^24, the counter value is correct. if the counter value exceeds 2^24, then in cases when the counter value modulo 2^24 equals 0 or 1 the value of the counter will be too low by 2^24. pmi: the interrupt usage model loads the counter with a value of -n and takes a pmi after n events (when the counter rolls over to zero). the most common usage model triggers a pmi on the first (or second) occurrence of an event; this corresponds to loading a value of -1 or -2 into the counter. these values work correctly. values of n from 3 to 2^24 will generate a pmi after n+2 events (two events later than requested). values of n greater than 2^24 will in almost all cases also generate a pmi after n+2 events; the exceptions occur when (n mod 2^24) equals 1 or 2, in which case the pmi will be generated after n-(2^24-2) events.										
implication	power controller performance monitor counter read values may be incorrect and/or pmis may occur at the wrong time.										
workaround	workarounds have been identified for the polled and pmi usage models.										
											
title	intel® qpi hnid field is incorrect for cmp messages from prefetchhint										
problem	the hnid (home node id) field used in the pmon (performance monitoring) match/ mask is incorrect for cmp (complete) messages from prefetchhint. the same incorrect hnid is logged in the event of an error condition on a cmp for a prefetchhint in the caching agent. the logging of the rnid (requester node id) in the error logs for ndr (non data response) messages is incorrect and impacts the caching agent system bound errors.										
implication	there are three implications: incorrect hnid is filtered or matched for cmps using the caching agent pmon match/mask.   caching agent mca logs will have incorrect hnid in the event of an error on a cmp due to a prefetchhint. the mask/match and error logs will be unable to correctly distinguish cmps from a prefetchhint versus an interrupt. the incorrect rnid will be logged for errors on ndr messages.										
workaround	there are two potential workarounds:										
											
title	system configuration controller misaligned error may result in a system hang										
problem	under certain conditions the system configuration controller may not correctly handle ncrd (non-coherent read) packets which may result in a misaligned uncorrectable error, machine check exception or system hang.										
implication	the system configuration controller incorrectly signals an uncorrectable error resulting in a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	recoverable errors signaled from intel® qpi or intel® smi port to the system configuration controller may get lost if the ports are disabled										
problem	each intel® quick-path interconnect (intel® qpi) and intel® scalable memory interconnect (intel smi) physical layer port may be configured through its pboxerrmask register (device:0x14, function:0x2, offset:0x68) to generate ras (reliability accessibility serviceability) recoverable error signals in any of the four situations: initialization failure, width reduction (intel® qpi) or lane failover (intel smi), drift buffer alarm, or latency buffer roll-over. when generated, the error signal is sent to the system configuration controller where it is processed into a system management interrupt (smi). under specific conditions, a ras recoverable error signal is generated and logged in a physical layer port, but the interrupt is not generated. more specifically, the error signal is lost on the way from the port to the system configuration controller. the problem arises when the error signal tries to pass through a port that has been disabled. each physical layer port has its own internal clock generator. when a port is disabled, its clock generator is off, and the error signal cannot propagate through that port.										
implication	if any physical layer ports are configured to signal errors of the ras recoverable type, then depending on the pattern of disabled ports, the errors may be logged properly in the physical layer port, but a matching system management interrupt may not occur. fatal error signals are not affected; they will always be transmitted successfully										
workaround	do not disable physical layer ports, or if they have been disabled then reenable them, such that ports that may generate ras recoverable errors have paths to send their error signals to the system configuration controller.										
											
title	performance monitor events for hardware prefetches which miss the l1 data cache may be over counted										
problem	hardware prefetches that miss the l1 data cache but cannot be processed immediately due to resource conflicts will count and then retry. this may lead to incorrectly   incrementing the l1d_prefetch.miss (event 4eh, umask 02h) event multiple times for a single miss.										
implication	the count reported by the l1d_prefetch.miss event may be higher than expected.										
workaround	none identified.										
											
title	vm exit may incorrectly clear ia32_perf_global_ctrl [34:32]										
problem	if the “load ia32_perf_global_ctrl” vm-exit control is 1, a vm exit should load the ia32_perf_global_ctrl msr (38fh) from the ia32_perf_global_ctrl field in the guest-state area of the vmcs. due to this erratum, such a vm exit may instead clear bits 34:32 of the msr, loading only bits 31:0 from the vmcs.										
implication	all fixed-function performance counters will be disabled after an affected vm exit, even if the vm exit should have enabled them based on the ia32_perf_global_ctrl field in the guest-state area of the vmcs.										
workaround	a vm monitor that wants the fixed-function performance counters to be enabled after a vm exit may do one of two things: (1) clear the “load ia32_perf_global_ctrl” vm- exit control; or (2) include an entry for the ia32_perf_global_ctrl msr in the vm- exit msr-load list.										
											
title	direct connect flash rom may become overwritten										
problem	under certain platform conditions, it is possible for the dc (direct connect) flash rom contents to become overwritten when glitches during power cycling on the flash rom interface pins are interpreted as dc flash rom opcodes and alter the dc flash rom. this erratum is only possible over the course of multiple power cycles due to the programming requirements on this interface.										
implication	if this erratum occurs, the dc flash rom contents could be overwritten or erased and, depending on how the dc flash rom is used, it could prevent the system from booting.										
workaround	a platform update and bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	memory controller does not handle mca overwrite rules for software recoverable errors correctly										
problem	the following overwrite rules for software recoverable errors (mcacod form: 000f 0000 1mmm cccc) are handled incorrectly: if the first logged error is a software recoverable error srao (software recoverable action optional), and the second logged error is a corrected error, the ia32_mci_status msr addrv bit 58 and mscod bits [31:16] fields should not be overwritten, but are overwritten. if the first logged error is a software recoverable error srao, and the second logged error is a fatal error, the second error is expected to overwrite the first error, but does not overwrite the ia32_mci_status msr miscv bit 59. if the first logged error is ucna (uncorrected no action) error and the second logged error is a software recoverable srao error the ia32_mci_status msr miscv bit 59 of the second error should not overwrite bit 59 of the first error. due to this erratum, the ia32_mci_status msr miscv bit 59 of the second error overwrites the miscv bit of the first error. if the first logged error is a software recoverable srao error with and the second logged error is an ucna error the ia32_mci_status msr addrv bit 58 of the second error should not overwrite bit 58 of the first error. due to this erratum, the   ia32_mci_status msr addrv bit 58 of the second error overwrites the addrv bit of the first error.										
implication	the ia32_mci_status msr overwrite rules are not handled correctly when the software recoverable error is the first error.										
workaround	none identified.										
											
title	intel® qpi reutphrds register only records bad lanes										
problem	the intel® quickpath interconnect (intel® qpi) physical layer includes the reutphrds (device:0x14; function:0x0; offset:0x78) register which has a bit for each rx lane, and is supposed to indicate which rx lanes are in use and which are not. the processor however, only marks a lane as unused if the lane was actually discovered to be bad. if a port is constrained to run at something less than full width (e.g. by setting the reutphwci (device: 0x14; function:0x0; offset:0x88) register, then certain quadrants will not be used, but the reutphrds register may report all lanes to be in use.										
implication	due to this erratum, the reutphrds register indicates only those lanes that were found to be bad and does not indicate lanes that are unused.										
workaround	information about the unused quadrants is available in the reutphlms (device: 0x14; function: 0x0; offset: 0x8c) register.										
											
title	memory aliasing of code pages may cause unpredictable system behavior										
problem	the type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. specifically, if one code page is mapped by one logical processor as write-back and by another as uncacheable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.										
implication	the type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. specifically, if one code page is mapped by one logical processor as write-back and by another as uncacheable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.										
workaround	code pages should not be mapped with uncacheable and cacheable memory types at the same time.										
											
title											
problem	performance monitor event ept.epdpe_miss (event: 4fh, umask: 08h) is used to count page directory pointer table misses while ept (extended page tables) is enabled. due to this erratum, the processor will count page directory pointer table misses regardless of whether ept is enabled or not.										
implication	due to this erratum, performance monitor event ept.epdpe_miss may report counts higher than expected.										
workaround	software should ensure this event is only enabled while in ept mode.										
											
title	peci command get_temp does not take into account uncore temperature										
problem	the peci command get_temp returns the highest core temperature and its reported values are used to determine the temperature of the processor in order to regulate fan speed. in some instances the uncore temperature is higher than the core temperature and in these instances the get_temp command may return a lower temperature than the processor is actually experiencing. note that the uncore temperature may tend to be higher than the core temperature only under very unique workloads, for example, if there is intensive traffic directed to the processor socket when the cores are in a deep c-state.										
implication	the peci command get_temp may report a temperature that is lower than the actual temperature.										
workaround	it is possible for the bios to contain a workaround for this erratum. this workaround adds a peci get_uncore_temp command to allow software to read the uncore temperature in order to make the comparison (core vs. uncore) to determine the highest temperature in the processor.										
											
title	intel qpi lane may be dropped during full frequency deskew phase of training										
problem	a random intel qpi lane may be dropped during the lane deskew phase while the intel qpi bus is training at full frequency.										
implication	when there are multiple resets after the intel qpi bus has reached full speed operation there is a small chance that a lane could be dropped during the deskew phase of training. in the case of a lane being dropped this will be detected and a retry will be done until the link is established and the lane is retrained.										
workaround	none identified.										
											
title	eoi transaction may not be sent if software enters core c6 during an interrupt service routine										
problem	if core c6 is entered after the start of an interrupt service routine but before a write to the apic eoi (end of interrupt) register, and the core is woken up by an event other than a fixed interrupt source the core may drop the eoi transaction the next time apic eoi register is written and further interrupts from the same or lower priority level will be blocked.										
implication	eoi transactions may be lost and interrupts may be blocked when core c6 is used during interrupt service routines.										
workaround	software should check the isr register and if any interrupts are in service only enter c1.										
											
title	intel® qpi and smi links do not meet the vtx-cm-ac-pin specification and may cause unexpected in-band resets										
problem	the processor does not meet the intel® quickpath interconnect (intel® qpi) and intel® scalable memory interconnect (intel® smi) vtx-cm-ac-pin specification that is documented in the intel xeon processor 7500 series datasheet, volume 1. the datasheet documents the vtx-cm-ac-pin to be -0.0375 and +0.0375 of vtx-diff-pp-pin for the intel® qpi and smi links running at all speeds. the processor's vtx-cm-ac-pin is between the range of -0.050 and +0.050 of vtx-diff-pp-pin.										
implication	when the processor is the transmitter and the intel 7500 chipset is the receiver, intel has observed unexpected intel® qpi link behavior while the intel® qpi link is running at 6.4 gt/s under specific system-level conditions. the behavior has been observed particularly on system designs with high attenuation on the intel® qpi channel. intel® qpi links may observe unexpected ibr (in-band resets) from the chipset.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	system quiesce events initiated while power events are in progress may cause system hangs										
problem	bios initiation of a system quiesce flow via the quiesce_control2 msr (51h) and exit of a system quiesce flow quiesce_control1 msr (50h) via may conflict with a power event on the bsp (boot strap processor) core. due to this conflict, the bsp core, which bios code runs on, may have one thread take the power event and the other thread not take the power event, resulting in a system hang.										
implication	as a result of this erratum, the system may hang after bios initiates a system quiesce flow.										
workaround	a bios code change has been identified and may be implemented to fix this erratum.										
											
title	uncorrected memory error detected by a memory patrol scrub with smi generated by other memory controllers may cause mce/smi race condition										
problem	bios may configure a smi to be signaled when the patrol scrub engine has reached the end of scrubbing a memory range. if the smi is generated while an uncorrected error is detected by another memory patrol scrub engine, it may result mce/smi race condition which may lead to system shut down.										
implication	due to this erratum, the system may shut down.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	an intel qpi link layer retry quickly followed by an intel qpi physical layer reset may cause an mce										
problem	while an intel® quickpath interconnect (intel® qpi) link is processing a link level retry requested by a remote qpi agent (due to link crc errors), if an intel qpi phy layer reset is triggered and aligns with a specific retry stage, a packet may get dropped and cause time out error with mca error code, ia32_mci_status [15:0] encoded as a bus and interconnect error with timeout [bit 8] = 1, cache hierarchy error, or internal timer error.										
implication	due to this erratum, a fatal mce may be signaled with mca error code, ia32_mci_status [15:0] encoded as a bus and interconnect error with timeout [bit 8] = 1, cache hierarchy error, or internal timer error.										
workaround	none identified										
											
title	a transient uecc error on memory reads on systems with mirrored memory may assert mce										
problem	in a system with mirrored memory, where multiple agents share a cache line with multiple read / write requests outstanding to that line, a transient uecc (uncorrectable ecc) error on the mirrored master may be improperly handled resulting in the assertion of the mce (machine check error). this erratum only occurs with specific timing conflicts on the outstanding requests. intel has not observed this erratum with any commercially available system.										
implication	as a result of this erratum, the processor home-agent may mce instead of properly returning data from the mirror slave.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	perfmon overflow status can not be cleared after certain conditions have occurred										
problem	under very specific timing conditions, if software tries to disable a perfmon counter through msr ia32_perf_global_ctrl (0x38f) or through the per-counter event- select (e.g. msr 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in msr ia32_perf_global_stat (0x38e) may be left set with no way for software to clear it.										
implication	due to this erratum, software may be unable to clear the perfmon counter overflow status indication.										
workaround	software may avoid this erratum by clearing the perfmon counter value prior to disabling it and then clearing the overflow status indication bit.										
											
title	an unexpected page fault or ept violation may occur after another logical processor creates a valid translation for a page										
problem	an unexpected page fault (#pf) or ept violation may occur for a page under the following conditions: the paging structures initially specify no valid translation for the page. software on one logical processor modifies the paging structures so that there is a valid translation for the page (for example, by setting to 1 the present bit in one of the paging-structure entries used to translate the page). software on another logical processor observes this modification (for example, by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). shortly thereafter, software on that other logical processor performs a store to a linear address on the page.  in this case, the store may cause a page fault or ept violation that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). intel has not observed this erratum with any commercially available software.										
implication	an unexpected page fault may be reported. there are no other side effects due to this erratum.										
workaround	system software can be constructed to tolerate these unexpected page faults. see section “propagation of paging-structure changes to multiple processors” of volume 3a of ia-32 intel® architecture software developer’s manual, for recommendations for software treatment of asynchronous paging-structure updates.										
											
title	intel® qpi and intel® smi drift buffer alarms may be observed on the processor										
problem	false drift buffer alarms may be observed in the pr{0-3}_cr_p_pcsr_reutphpls (device 14h,15h,16h,17h; function 0; offset 90h) and pz{0- 1}_cr_p_pcsr_reutphpls (device 18h, 19h; function 0; offset 90h) registers of the intel® quickpath interconnect (intel® qpi) and intel® scalable memory interconnect (intel® smi) of the processor, without crcs logged on the port/link.										
implication	unexpected intel® qpi and intel® smi drift buffer alarms flagged by the processor.										
workaround	drift buffer alarms should be ignored. pr{0-										
											
title	l1 data cache errors may be logged with level set to 1 instead of 0										
problem	when an l1 data cache error is logged in ia32_mci_status[15:0], which is the mca error code field, with a cache error type of the format 0000 0001 rrrr ttll, the ll field may be incorrectly encoded as 01b instead of 00b.										
implication	an error in the l1 data cache may report the same ll value as the l2 cache. software should not assume that an ll value of 01b is the l2 cache.										
workaround	none identified.										
											
title	stack pushes may not occur properly for events delivered immediately after vm entry to 16-bit software										
problem	the stack pushes for an event delivered after vm entry and before execution of an instruction in vmx nonroot operation may not occur properly. the erratum applies only if the vm entry establishes ia32_efer.lma = 0 and cs.d = 0 and only if the event handler is also invoked with cs.d = 0.										
implication	this erratum affects events that are pending upon completion of vm entry and that do not cause vm exits. examples include debug exceptions, interrupts, and general- protection faults generated in virtual-8086 mode by the mode’s virtual interrupt mechanism. the erratum applies only if the vm entry is not to ia-32e mode and is to 16-bit operation, and only if the relevant handler uses 16-bit operation. the incorrect stack pushes resulting from the erratum may cause incorrect guest operation. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	vm entries that return from smm using vmlaunch may not update the launch state of the vmcs										
problem	successful vm entries using the vmlaunch instruction should set the launch state of the vmcs to “launched”. due to this erratum, such a vm entry may not update the launch state of the current vmcs if the vm entry is returning from smm.										
implication	subsequent vm entries using the vmresume instruction with this vmcs will fail. rflags.zf is set to 1 and the value 5 (indicating vmresume with non-launched vmcs) is stored in the vm-instruction error field. this erratum applies only if dual monitor treatment of smi and smm is active.										
workaround	none identified.										
											
title	vm entry may clear bytes 81h-83h on virtual-apic page when “use tpr shadow” is 0										
problem	vm entry should not clear bytes 81h-83h on the virtual-apic page if the “use tpr shadow” vm-execution control is 0. due to this erratum, vm entry will do so if the “virtualize x2apic mode” vm-execution control is 1.										
implication	vm entries with the 0-setting of the “use tpr shadow” vm-execution control and the setting of the “virtualize x2apic mode” vm-execution control cause any nonzero data at bytes 81h-83h on the virtual-apic page to be lost. note that this combination of settings is not allowed; any such vm entry will fail after clearing these bytes.										
workaround	software should always set the “use tpr shadow” vm-execution control to 1 whenever it sets that “virtualize x2apic mode” vm-execution control to 1.										
											
title	system hangs possible due to ecc correctable errors with ept and dcu 16kb mode enabled										
problem	under a complex set of internal conditions, a system hang may occur in the presence of l2 ecc correctable errors that set bit [54:53] = 0x2 in ia32_mci_status for a system with ept (extended page tables) and dcu (data cache unit) 16 kb mode (which is a 16 kb, 4-way, ecc-enabled mode) enabled.										
implication	this erratum may cause a system hang.										
workaround	do not enable dcu 16kb mode in a system that uses ept.										
											
title	concurrent updates to a segment descriptor may be lost										
problem	if a logical processor attempts to set the accessed bit in a code or data segment descriptor while another logical processor is modifying the same descriptor, both modifications of the descriptor may be lost.										
implication	due to this erratum, updates to segment descriptors may not be preserved. intel has not observed this erratum with any commercially available software or system.										
workaround	none identified.										
											
title	invlpg following invept or invvpid may fail to flush all translations for a large page										
problem	this erratum applies if the address of the memory operand of an invept or invvpid instruction resides on a page larger than 4kbytes and either (1) that page includes the low 1 mbytes of physical memory; or (2) the physical address of the memory operand matches an mtrr that covers less than 4 mbytes. a subsequent execution of invlpg that targets the large page and that occurs before the next vm-entry instruction may fail to flush all tlb entries for the page. such entries may persist in the tlb until the next vm-entry instruction.										
implication	accesses to the large page between invlpg and the next vm-entry instruction may incorrectly use translations that are inconsistent with the in-memory page tables.										
workaround	none identified.										
											
title	a 2 mb page split lock accesses combined with complex internal events may cause unpredictable system behavior										
problem	a 2 mb page split lock (a locked access that spans two 2 mb large pages) coincident with additional requests that have particular address relationships in combination with a timing sensitive sequence of complex internal conditions may cause unpredictable system behavior.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	changes to reserved bits of some nonarchitectural msrs may cause unpredictable system behavior										
problem	under normal circumstances, an operation fails if it attempts to modify a reserved bit of a model-specific register (msr). due to this erratum and for some nonarchitectural msrs, such an attempt may cause unpredictable system behavior.										
implication	unpredictable system behavior may occur if software attempts to modify reserved bits of some nonarchitectural msrs. (note that documentation of the wrmsr instruction states that “undefined or reserved bits in an msr should be set to values previously read.”)										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	io_smi indication in smram state save area may be set incorrectly										
problem	the io_smi bit in smram’s location 7fa4h is set to “1” by the processor to indicate a system management interrupt (smi) occurred as the result of executing an instruction that reads from an i/o port. due to this erratum, the io_smi bit may be incorrectly set by:										
implication	a non-i/o instruction an event where an i/o read sets the io_smi bit but another interrupt is taken before the recognition of the smi event a rep ins instruction an i/o read that redirects to mwait										
workaround	smm handlers may get false io_smi indication.the smm handler has to evaluate the saved context to determine if the smi was triggered by an instruction that read from an i/o port. the smm handler must not restart an i/o instruction if the platform has not been configured to generate a synchronous smi for the recorded i/o port address.										
											
title	l1 cache uncorrected errors may be recorded as correctable in 16k mode										
problem	when the l1 cache is operating in 16k redundant parity mode and a parity error occurs on both halves of the duplicated cache on the same cacheline, an uncorrectable error should be logged. due to this erratum, the uncorrectable error will be recorded as correctable, however a machine check exception will be appropriately taken in this case.										
implication	due to this erratum, the ia32_mci_status.uc bit will incorrectly contain a value of 0 indicating a correctable error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writing an illegal vector to the ia32_x2apic_self_ipi msr will hang the processor										
problem	writing an illegal vector (0 to 15) to the ia32_x2apic_self_ipi msr while the local apic is in x2apic mode will cause the processor to hang.										
implication	when this erratum occurs, the processor will hang.										
workaround	software should not write an illegal vector to the ia32_x2apic_self_ipi msr while the local apic is in x2apic mode. virtual-machine monitors should not allow guest software to write to the ia32_x2apic_self_ipi msr.										
											
title	successive fixed counter overflows may be discarded										
problem	under specific internal conditions, when using freeze perfmon on pmi feature (bit 12 in ia32_debugctl.freeze_perfmon_on_pmi, msr 1d9h), if two or more perfmon fixed counters overflow very closely to each other, the overflow may be mishandled for some of them. this means that the counter’s overflow status bit (in msr_perf_global_status, msr 38eh) may not be updated properly; additionally, pmi interrupt may be missed if software programs a counter in sampling-mode (pmi bit is set on counter configuration).										
implication	successive fixed counter overflows may be discarded when freeze perfmon on pmi is used.										
workaround	software can avoid this by doing the following:										
											
title											
problem	if vm entry is made with the “virtual nmis” and “nmi-window exiting”, vm-execution controls set to 1, and if there is no virtual-nmi blocking after vm entry, a vm exit with exit reason “nmi window” should occur immediately after vm entry unless the vm entry put the logical processor in the wait-for sipi state. due to this erratum, such vm exits do not occur if the vm entry put the processor in the shutdown state.										
implication	a vmm may fail to deliver a virtual nmi to a virtual machine in the shutdown state.										
workaround	before performing a vm entry to the shutdown state, software should check whether the “virtual nmis” and “nmi-window exiting” vm-execution controls are both 1. if they are, software should clear “nmi-window exiting” and inject an nmi as part of vm entry.										
											
title	execution of invvpid outside 64-bit mode cannot invalidate translations for 64-bit linear addresses										
problem	executions of the invvpid instruction outside 64-bit mode with the invvpid type “individual-address invalidation” ignore bits 63:32 of the linear address in the invvpid descriptor and invalidate translations for bits 31:0 of the linear address.										
implication	the invvpid instruction may fail to invalidate translations for linear addresses that set bits in the range 63:32. because this erratum applies only to executions outside 64-bit mode, it applies only to attempts by a 32-bit virtual-machine monitor (vmm) to invalidate translations for a 64-bit guest. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	a combination of data accesses that are split across cacheline boundaries may lead to a processor hang										
problem	under certain complex micro-architectural conditions, closely spaced data accesses that are split across cacheline boundaries may lead to a processor hang.										
implication	due to this erratum, the processor may hang. this erratum has not been observed with any general purpose operating systems.										
workaround	none identified.										
											
title	a load may appear to be ordered before an earlier locked instruction										
problem	under certain timing conditions involving multiple cores, a cacheable load may appear to be ordered before an earlier cacheable locked instruction that accesses a different location.										
implication	locked instructions and subsequent loads may not occur in the expected order when run on multiple cores. in some circumstances this could lead to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a machine check occurring during vm entry may cause unpredictable behavior										
problem	a machine check occurring during vm entry may cause the vm entry to fail. due to this erratum, such a vm entry failure may be followed by unpredictable behavior, including a processor hang.										
implication	this erratum may result in a system hang. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	mci_addr may be incorrect for cache parity errors										
problem	in cases when a wbinvd instruction evicts a line containing an address or data parity error (mcacod of 0x124, and mscod of 0x10), the address of this error should be logged in the mci_addr register. due to this erratum, the logged address may be incorrect, even though mci_status.addrv (bit 63) is set.										
implication	the address reported in mci_addr may not be correct for cases of a parity error found during wbinvd execution.										
workaround	none identified.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	the upper 32 bits of cr3 may be incorrectly used with 32-bit paging										
problem	when 32-bit paging is in use, the processor should use a page directory located at the 32-bit physical address specified in bits 31:12 of cr3; the upper 32 bits of cr3 should be ignored. due to this erratum, the processor will use a page directory located at the 64-bit physical address specified in bits 63:12 of cr3.										
implication	the processor may use an unexpected page directory or, if ept (extended page tables) is in use, cause an unexpected ept violation. this erratum applies only if software enters 64-bit mode, loads cr3 with a 64-bit value, and then returns to 32-bit paging without changing cr3. intel has not observed this erratum with any commercially available software.										
workaround	software that has executed in 64-bit mode should reload cr3 with a 32-bit value before returning to 32-bit paging.										
											
title	ept violations may report bits 11:0 of guest linear address incorrectly										
problem	if a memory access to a linear address requires the processor to update an accessed or dirty flag in a paging-structure entry and if that update causes an ept violation, the processor should store the linear address into the “guest linear address” field in the vmcs. due to this erratum, the processor may store an incorrect value into bits 11:0 of this field. (the processor correctly stores the guest-physical address of the paging- structure entry into the “guest-physical address” field in the vmcs.)										
implication	software may not be easily able to determine the page offset of the original memory access that caused the ept violation. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	software requiring the page offset of the original memory access address can derive it by simulating the effective address computation of the instruction that caused the ept violation.										
											
title	smram state-save area above the 4-gb boundary may cause unpredictable system behavior										
problem	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	ensure that the smram state-save area is located entirely below the 4-gb address boundary.										
											
title	virtual-apic page accesses with 32-bit pae paging may cause a system crash										
problem	if a logical processor has ept (extended page tables) enabled, is using 32-bit pae paging, and accesses the virtual-apic page then a complex sequence of internal   processor micro-architectural events may cause an incorrect address translation or machine check on either logical processor.										
implication	this erratum may result in unexpected faults, an uncorrectable tlb error logged in ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_0000_0001_xxxxb (where x stands for 0 or 1), a guest or hypervisor crash, or other unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	performance monitor counter mem_inst_retired.stores may count higher than expected										
problem	performance monitoring counter mem_inst_retired.stores (event: 0bh, umask: 02h) is used to track retired instructions which contain a store operation. due to this erratum, the processor may also count other types of instructions including wrmsr and mfence.										
implication	performance monitoring counter mem_inst_retired.stores may report counts higher than expected.										
workaround	none identified.										
											
title	the processor may report a #ts instead of a #gp fault										
problem	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss exception) instead of a #gp fault (general protection exception).										
implication	operation systems that access a busy tss may get invalid tss fault instead of a #gp fault. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	rep movs/stos executing with fast strings enabled and crossing page boundaries with inconsistent memory types may use an incorrect data size or lead to memory-ordering violations.										
problem	under certain conditions as described in the software developers manual section “out- of-order stores for string operations in pentium 4, intel xeon, and p6 family processors” the processor performs rep movs or rep stos as fast strings. due to this erratum fast string rep movs/rep stos instructions that cross page boundaries from wb/wc memory types to uc/wp/wt memory types, may start using an incorrect data size or may observe memory ordering violations.										
implication	upon crossing the page boundary the following may occur, dependent on the new page memory type: uc the data size of each write will now always be 8 bytes, as opposed to the original data size. wp the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. wt there may be a memory ordering violation.										
workaround	software should avoid crossing page boundaries from wb or wc memory type to uc, wp or wt memory type within a single rep movs or rep stos instruction that will execute with fast strings enabled.										
											
title	io_smi indication in smram state save area may be set incorrectly										
problem	the io_smi bit in smram’s location 7fa4h is set to “1” by the cpu to indicate a system management interrupt (smi) occurred as the result of executing an instruction that reads from an i/o port. due to this erratum, the io_smi bit may be incorrectly set by: a non-i/o instruction smi is pending while a lower priority event interrupts a rep i/o read										
implication	smm handlers may get false io_smi indication.										
workaround	the smm handler has to evaluate the saved context to determine if the smi was										
											
title	performance monitor sse retired instructions may return incorrect values										
problem	performance monitoring counter simd_inst_retired (event: c7h) is used to track retired sse instructions. due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.										
implication	performance monitoring counter simd_inst_retired may report count higher than expected.										
workaround	none identified.										
											
title	iret under certain conditions may cause an unexpected alignment check exception										
problem	in ia-32e mode, it is possible to get an alignment check exception (#ac) on the iret instruction even though alignment checks were disabled at the start of the iret. this can only occur if the iret instruction is returning from cpl3 code to cpl3 code. irets from cpl0/1/2 are not affected. this erratum can occur if the eflags value on the stack has the ac flag set, and the interrupt handler's stack is misaligned. in ia-32e mode, rsp is aligned to a 16-byte boundary before pushing the stack frame.										
implication	in ia-32e mode, under the conditions given above, an iret can get a #ac even if alignment checks are disabled at the start of the iret. this erratum can only be observed with a software generated stack frame.										
workaround	software should not generate misaligned stack frames for use with iret.										
											
title	performance monitoring event fp_mmx_trans_to_mmx may not count some transitions										
problem	performance monitor event fp_mmx_trans_to_mmx (event cch, umask 01h) counts transitions from x87 floating point (fp) to mmx™ instructions. due to this erratum, if only a small number of mmx instructions (including emms) are executed immediately after the last fp instruction, a fp to mmx transition may not be counted.										
implication	the count value for performance monitoring event fp_mmx_trans_to_mmx may be lower than expected. the degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. intel has not observed this erratum with any commercially available software.										
workaround	none identified										
											
title	general protection fault (#gp) for instructions greater than 15 bytes may be preempted										
problem	when the processor encounters an instruction that is greater than 15 bytes in length, a #gp is signaled when the instruction is decoded. under some circumstances, the #gp fault may be preempted by another lower priority fault (e.g. page fault (#pf)). however, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #gp fault will occur.										
implication	software may observe a lower-priority fault occurring before or in lieu of a #gp fault. instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.										
workaround	none identified.										
											
title											
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified.										
											
title	incorrect address computed for last byte of fxsave/fxrstor or xsave/xrstor image leads to partial memory update										
problem	a partial memory state save of the fxsave or xsave image or a partial memory state restore of the fxrstor or xrstor image may occur if a memory address exceeds the 64kb limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4gb limit while the processor is operating in 32-bit mode.										
implication	fxsave/fxrstor or xsave/xrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.										
workaround	software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits.										
											
title	values for lbr/bts/btm will be incorrect after an exit from smm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect. note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	b0-b3 bits in dr6 for non-enabled breakpoints may be incorrectly set										
problem	some of the b0-b3 bits (breakpoint conditions detect flags, bits [3:0]) in dr6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: mov or pop instruction to ss (stack segment) selector; next instruction is fp (floating point) that gets fp assist another instruction after the fp instruction completes successfully a breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in b0-b3 after the breakpoint occurs in step 4.										
implication	due to this erratum, b0-b3 bits in dr6 may be incorrectly set for non-enabled breakpoints.										
workaround	software should not execute a floating point instruction directly after a mov ss or pop ss instruction.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	debug exception flags dr6.b0-b3 flags may be incorrect for disabled breakpoints										
problem	when a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (dr7.g0-g3 and dr7.l0-l3), the dr6.b0-b3 flags may be incorrect.										
implication	the debug exception dr6.b0-b3 flags may be incorrect for the load if the corresponding breakpoint enable flag in dr7 is disabled.										
workaround	none identified.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title	pebs record not updated when in probe mode										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflows of the counter can result in storage of a pebs record in the pebs buffer. due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new pebs record may not be added to the pebs buffer.										
implication	due to this erratum, the pebs buffer may not be updated by overflows that occur during probe mode.										
workaround	none identified.										
											
title	monitor or clflush on the local xapic's address space results in hang										
problem	if the target linear address range for a monitor or clflush is mapped to the local xapic's address space, the processor will hang.										
implication	when this erratum occurs, the processor will hang. the local xapic's address space must be uncached. the monitor instruction only functions correctly if the specified linear address range is of the type write-back. clflush flushes data from the cache. intel has not observed this erratum with any commercially available software.										
workaround	do not execute monitor or clflush instructions on the local xapic address space.										
											
title	faulting mmx instruction may incorrectly update x87 fpu tag word										
problem	under a specific set of conditions, mmx stores (movd, movq, movntq, maskmovq) which cause memory access faults (#gp, #ss, #pf, or #ac), may incorrectly update the x87 fpu tag word register. this erratum will occur when the following additional conditions are also met. the mmx store instruction must be the first mmx instruction to operate on x87 fpu state (i.e. the x87 fp tag word is not already set to 0x0000). for movd, movq, movntq stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to maskmovq).										
implication	if the erratum conditions are met, the x87 fpu tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.										
workaround	none identified.										
											
title	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang										
problem	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).										
implication	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.										
workaround	none identified.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store or an mmx instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (i.e., following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	changing the memory type for an in-use page translation may lead to memory-ordering violations										
problem	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.										
implication	memory ordering may be violated. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure pages are not being actively used before requesting their memory type be changed.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	lbr, btm or bts records may have incorrect branch from information after an eist/t-state/s-state/c1e transition or adaptive thermal throttling										
problem	the “from” address associated with the lbr (last branch record), btm (branch trace message) or bts (branch trace store) may be incorrect for the first branch after a transition of: eist (enhanced intel® speedstep technology) t-state (thermal monitor states) s1-state (acpi package sleep state) c1e (enhanced c1 low power state) adaptive thermal throttling										
implication	when the lbrs, btm or bts are enabled, some records may have incorrect branch “from” addresses for the first branch after a transition of eist, t-states, s-states, c1e, or adaptive thermal throttling.										
workaround	none identified.										
											
title	fault not reported when setting reserved bits of intel® vt-d queued invalidation descriptors										
problem	reserved bits in the queued invalidation descriptors of intel vt-d (virtualization technology for directed i/o) are expected to be zero, meaning that software must program them as zero while the processor checks if they are not zero. upon detection of a non-zero bit in a reserved field an intel vt-d fault should be recorded. due to this erratum the processor does not check reserved bit values for queued invalidation descriptors.										
implication	due to this erratum, faults will not be reported when writing to reserved bits of intel vt-d queued invalidation descriptors.										
workaround	none identified.										
											
title	fp data operand pointer may be incorrectly calculated after an fp access which wraps a 4-gbyte boundary in code that uses 32-bit address size in 64-bit mode										
problem	the fp (floating point) data operand pointer is the effective address of the operand associated with the last non-control fp instruction executed by the processor. if an 80- bit fp access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-gbyte boundary and the fp environment is subsequently saved, the value contained in the fp data operand pointer may be incorrect.										
implication	due to this erratum, the fp data operand pointer may be incorrect. wrapping an 80-bit fp load around a 4-gbyte boundary in this way is not a normal programming practice. intel has not observed this erratum with any commercially available software.										
workaround	if the fp data operand pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit fp accesses are wrapped around a 4-gbyte boundary.										
											
title	vmread/vmwrite instruction may not fail when accessing an unsupported field in vmcs										
problem	the intel® 64 and ia-32 architectures software developer’s manual, volume 2b states that execution of vmread or vmwrite should fail if the value of the instruction’s register source operand corresponds to an unsupported field in the vmcs (virtual machine control structure). the correct operation is that the logical processor will set the zf (zero flag), write 0ch into the vm-instruction error field and for vmread leave the instruction’s destination operand unmodified. due to this erratum, the instruction may instead clear the zf, leave the vm-instruction error field unmodified and for vmread modify the contents of its destination operand.										
implication	accessing an unsupported field in vmcs will fail to properly report an error. in addition, vmread from an unsupported vmcs field may unexpectedly change its destination operand. intel has not observed this erratum with any commercially available software.										
workaround	software should avoid accessing unsupported fields in a vmcs.										
											
title	spurious interrupts may be generated from the intel® vt-d remap engine										
problem	if software clears the f (fault) bit 127 of the fault recording register (frcd_reg at offset 0x208 in remap engine bar) by writing 1b through rw1c command (read write 1 to clear) when the f bit is already clear then a spurious interrupt from intel vt-d (virtualization technology for directed i/o) remap engine may be observed.										
implication	due to this erratum, spurious interrupts will occur from the intel vt-d remap engine following rw1c clearing f bit.										
workaround	none identified.										
											
title	malformed pcie transactions may be treated as unsupported requests instead of as critical errors										
problem	pcie msg/msg_d tlps (transaction layer packets) with incorrect routing code as well as the deprecated tcfgrd and tcfgwr types should be treated as malformed transactions leading to a critical error. due to this erratum, the integrated pcie controller's root ports may treat such messages as ur (unsupported requests).										
implication	legacy malformed pcie transactions may be treated as ur instead of as critical errors. workaround none identified.										
workaround											
											
title	reception of certain malformed transactions may cause pcie port to hang rather than reporting an error										
problem	if the processor receives an upstream malformed non posted packet for which the type field is io, configuration or the deprecated tcfgrd and the format is 4 dw header, then due to this erratum the integrated pcie controller may hang instead of reporting the malformed packet error or issuing an unsupported request completion transaction.										
implication	due to this erratum, the processor may hang without reporting errors when receiving a malformed pcie transaction. intel has not observed this erratum with any commercially available device.										
workaround	none identified. upstream transaction initiators should avoid issuing unsupported requests with 4 dw header formats.										
											
title	clock modulation duty cycle cannot be programmed to 6.25%										
problem	when programming field t_state_req of the ia32_clock_modulation msr (19ah) bits [3:0] to '0001, the actual clock modulation duty cycle will be 12.5% instead of the expected 6.25% ratio.										
implication	due to this erratum, it is not possible to program the clock modulation to a 6.25% duty cycle.										
workaround	none identified.										
											
title	processor may fail to acknowledge a tlp request										
problem	when a pcie root port’s receiver is in receiver l0s power state and the port initiates a recovery event, it will issue training sets to the link partner. the link partner will respond by initiating an l0s exit sequence. prior to transmitting its own training sets, the link partner may transmit a tlp (transaction layer packet) request. due to this erratum, the root port may not acknowledge the tlp request.										
implication	after completing the recovery event, the pcie link partner will replay the tlp request. the link partner may set a correctable error status bit, which has no functional effect.										
workaround	none identified.										
											
title	an unexpected pmi may occur after writing a large value to ia32_fixed_ctr2										
problem	if the fixed-function performance counter ia32_fixed_ctr2 msr (30bh) is configured to generate a performance-monitor interrupt (pmi) on overflow and the counter’s value is greater than ffffffffffc0h, then this erratum may incorrectly cause a pmi if software performs a write to this counter.										
implication	a pmi may be generated unexpectedly when programming ia32_fixed_ctr2. other than the pmi, the counter programming is not affected by this erratum as the attempted write operation does succeed.										
workaround	none identified.										
											
title	a write to the ia32_fixed_ctr1 msr may result in incorrect value in certain conditions										
problem	under specific internal conditions, if software tries to write the ia32_fixed_ctr1 msr (30ah) a value that has all bits [31:1] set while the counter was just about to overflow when the write is attempted (i.e. its value was 0xffff ffff ffff), then due to this erratum the new value in the msr may be corrupted.										
implication	due to this erratum, ia32_fixed_ctr1 msr may be written with a corrupted value.										
workaround	software may avoid this erratum by writing zeros to the ia32_fixed_ctr1 msr,										
											
title	pcie* ltr incorrectly reported as being supported										
problem	ltr (latency tolerance reporting) is a new optional feature specified in pcie rev. 2.1. the processor reports ltr as supported in ltrs bit in dcap2 register (bus 0; device 1; function 0; offset 0xc4), but this feature is not supported.										
implication	due to this erratum, ltr is always reported as supported by the ltrs bit in the dcap2 register.										
workaround	none identified.										
											
title	perfmon overflow status can not be cleared after certain conditions have occurred										
problem	under very specific timing conditions, if software tries to disable a perfmon counter through msr ia32_perf_global_ctrl (0x38f) or through the per-counter event- select (e.g. msr 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in msr ia32_perf_global_stat (0x38e) may be left set with no way for software to clear it.										
implication	due to this erratum, software may be unable to clear the perfmon counter overflow status indication.										
workaround	software may avoid this erratum by clearing the perfmon counter value prior to disabling it and then clearing the overflow status indication bit.										
											
title	#gp may be signaled when invalid vex prefix precedes conditional branch instructions										
problem	when a 2-byte opcode of a conditional branch (opcodes 0f8xh, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid vex prefix, it may sometimes signal a #gp fault (illegal instruction length > 15-bytes) instead of a #ud (illegal opcode) fault.										
implication	due to this erratum, #gp fault instead of a #ud may be signaled on an illegal instruction.										
workaround	none identified.										
											
title	interrupt from local apic timer may not be detectable while being delivered										
problem	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.										
implication	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.										
workaround	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.										
											
title	pcmpestri, pcmpestrm, vpcmpestri and vpcmpestrm always operate with 32-bit length registers										
problem	in 64-bit mode, using rex.w=1 with pcmpestri and pcmpestrm or vex.w=1 with vpcmpestri and vpcmpestrm should support a 64-bit length operation with rax/ rdx. due to this erratum, the length registers are incorrectly interpreted as 32-bit values.										
implication	due to this erratum, using rex.w=1 with pcmpestri and pcmpestrm as well as vex.w=1 with vpcmpestri and vpcmpestrm do not result in promotion to 64-bit length registers.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	multiple performance monitor interrupts are possible on overflow of fixed counter 0										
problem	the processor can be configured to issue a pmi (performance monitor interrupt) upon overflow of the ia32_fixed_ctr0 msr (309h). a single pmi should be observed on overflow of ia32_fixed_ctr0, however multiple pmis are observed when this erratum occurs. this erratum only occurs when ia32_fixed_ctr0 overflows and the processor and counter are configured as follows: intel® hyper-threading technology is enabled ia32_fixed_ctr0 local and global controls are enabled ia32_fixed_ctr0 is set to count events only on its own thread (ia32_fixed_ctr_ctrl msr (38dh) bit [2] = ‘0). pmis are enabled on ia32_fixed_ctr0 (ia32_fixed_ctr_ctrl msr bit [3] = ‘1) freeze_on_pmi feature is enabled (ia32_debugctl msr (1d9h) bit [12] = ‘1)										
implication	when this erratum occurs there may be multiple pmis observed when ia32_fixed_ctr0 overflows.										
workaround	disable the freeze_perfmon_on_pmi feature in ia32_debugctl msr (1d9h) bit [12].										
											
title	ia32_feature_control msr may be uninitialized on a cold reset										
problem	ia32_feature_control msr (3ah) may have random values after reset (including the reserved and lock bits), and the read-modify-write of the reserved bits and/or the lock bit being incorrectly set may cause an unexpected gp fault.										
implication	due to this erratum, an unexpected gp fault may occur and bios may not complete initialization.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a rep movsb or stosb										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an rep movsb or rep stosb.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (i.e., following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	setting hardware autonomous speed disable configuration bit will block initial speed upgrade										
problem	the pci express* base specification revision 3.0 states that the hardware autonomous speed disable bit (link control register 2, bit 5) does not block the initial transition to the highest supported common link speed. setting this bit will block all autonomous speed changes.										
implication	due to this erratum, if the hardware autonomous speed disable bit is set, a given pcie link may remain at 2.5 gt/s transfer rate. this erratum has not been observed with any commercially available add-in cards.										
workaround	it is possible for software to initiate a directed speed change.										
											
title	ltr message is not treated as an unsupported request										
problem	the pcie* root port does not support ltr (latency tolerance reporting) capability. however, a received ltr message is not treated as a ur (unsupported request).										
implication	due to this erratum, an ltr message does not generate a ur error.										
workaround	none identified.										
											
title	64-bit rep movsb/stosb may clear the upper 32-bits of rcx, rdi and rsi before any data is transferred										
problem	if a rep movsb/stosb is executed in 64-bit mode with an address size of 32 bits, and if an interrupt is being recognized at the start of the instruction operation, the upper 32-bits of rcx, rdi and rsi may be cleared, even though no data has yet been copied or written.										
implication	due to this erratum, the upper 32-bits of rcx, rdi and rsi may be prematurely cleared.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	an interrupt recognized prior to first iteration of rep movsb/stosb may result eflags.rf being incorrectly set										
problem	if a rep movsb/stosb is executed and an interrupt is recognized prior to completion of the first iteration of the string operation, eflags may be saved with rf=1 even though no data has been copied or stored. the software developer’s manual states that rf will be set to 1 for such interrupt conditions only after the first iteration is complete.										
implication	software may not operate correctly if it relies on the value saved for eflags.rf when an interrupt is recognized prior to the first iteration of a string instruction. debug exceptions due to instruction breakpoints are delivered correctly despite this erratum; this is because the erratum occurs only after the processor has evaluated instruction- breakpoint conditions.										
workaround	software whose correctness depends on value saved for eflags.rf by delivery of the affected interrupts can disable fast-string operation by clearing fast-string enable in bit 0 in the ia32_misc_enable msr (1a0h).										
											
title	accessing physical memory space 0-640k through the graphics aperture may cause unpredictable system behavior										
problem	the physical memory space 0-640k when accessed through the graphics aperture may result in a failure for writes to complete or reads to return incorrect results.										
implication	a hang or functional failure may occur during graphics operation such as ogl or ocl conformance tests, 2d/3d games and graphics intensive application.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pebs may unexpectedly signal a pmi after the pebs buffer is full										
problem	the software developer’s manual states that no pmi should be generated when pebs index reaches pebs absolute maximum. due to this erratum, a pmi may be generated even though the pebs buffer is full.										
implication	pebs may trigger a pmi even though the pebs index has reached the pebs absolute maximum.										
workaround	none identified.										
											
title	instructions retired event may over count execution of iret instructions										
problem	under certain conditions, the performance monitoring event instructions retired (event c0h, unmask 00h) may over count the execution of iret instruction.										
implication	due to this erratum, performance monitoring event instructions retired may over count.										
workaround	none identified.										
											
title	pcie* link may unexpectedly exit loopback state										
problem	the pcie port is capable of functioning as 3 independent pcie controllers. due to this erratum, if more than one of the controllers is in loopback.active state and configured as a loopback slave and if any one of these controllers transition to loopback.exit, all controllers in loopback.active will transition to loopback.exit.										
implication	loopback.active state on a given link may unexpectedly exit. software should avoid configuring more than one of the pcie controllers as loopback slave concurrently.										
workaround	pcie endpoints should avoid configuring more than one of pcie controllers as loopback slave.										
											
title	the rdrand instruction will not execute as expected										
problem	on processors that support the rdrand instruction, that capability should be reported via the setting of cpuid.01h:ecx.rdrand[bit 30]. due to this erratum, that bit will not be set, and the execution of the rdrand instruction will result in a #ud exception.										
implication	software will not be able to utilize the rdrand instruction										
workaround	it is possible for the bios to contain a workaround for this erratum to report rdrand as present via cpuid and allow proper execution of rdrand.										
											
title	a pcie* device that initially transmits minimal posted data credits may cause a system hang										
problem	under certain conditions, if a pcie device that initially transmits posted data credits less than max_payload_size/16 + 4 (16b/4dw is unit of data flow control) and is the target of a peer-to-peer write of max_payload_size, the system may hang due to posted data credit starvation.										
implication	under certain conditions, the processor may encounter a posted data credit starvation scenario and hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pci express* gen3 receiver return loss may exceed specifications										
problem	the pcie base specification includes a graph that sets requirements for maximum receiver return loss versus frequency. due to this erratum, the receiver return loss for common mode and differential mode may exceed those requirements at certain frequencies. under laboratory conditions, intel has observed violations of as much as 1 db.										
implication	the pci express gen3 base specification for receiver return loss may be exceeded. no functional failures have been observed due to this erratum.										
workaround	none identified.										
											
title	direct access via vt-d to the processor graphics device may lead to a system hang										
problem	under a complex set of conditions, while using vt-d (virtualization technology for directed i/o) with the processor graphics device, direct access to the virtualized processor graphics device can lead to a system hang or restart.										
implication	systems providing direct access to processor graphics device via vt-d may hang or restart. intel has not observed this erratum with any commercially available system.										
workaround	vmm’s should ensure that all processor graphics device interactions conform to guidance published in the intel® open source hd graphics programmer's reference manual and driver writers guide.										
											
title	an event may intervene before a system management interrupt that results from in or ins										
problem	if an i/o instruction (in, ins, out, or outs) results in an smi (system-management interrupt), the processor will set the io_smi bit at offset 7fa4h in smram. this interrupt should be delivered immediately after execution of the i/o instruction so that the software handling the smi can cause the i/o instruction to be re-executed. due to this erratum, it is possible for another event (e.g., a nonmaskable interrupt) to be delivered before the smi that follows the execution of an in or ins instruction.										
implication	if software handling an affected smi uses i/o instruction restart, the handler for the intervening event will not be executed.										
workaround	the smm handler has to evaluate the saved context to determine if the smi was triggered by an instruction that read from an i/o port. the smm handler must not restart an i/o instruction if the platform has not been configured to generate a synchronous smi for the recorded i/o port address.										
											
title	pcie* may associate lanes that are not part of initial link training to l0 during upconfiguration										
problem	the processor should not associate any lanes that were not part of the initial link training in subsequent upconfiguration requests from an endpoint. due to this erratum, the processor may associate any lane that has exited electrical idle, even if it is beyond the width of the initial link training.										
implication	upconfiguration requests may result in a link wider than the initially-trained link.										
workaround	endpoints must ensure that upconfiguration requests do not request a link width wider than that negotiated during initial link training.										
											
title	the processor may not comply with pcie* equalization preset reflection requirements for 8 gt/s mode of operation										
problem	in endpoint-initiated transitions to polling.compliance at the 8 gt/s transfer rate, the processor must reflect, in its ordered sets, the transmitter preset requested by the endpoint regardless of preset legality. due to this erratum, the processor will reflect the transmitter preset in use after an endpoint requests a reserved transmitter preset rather than the requested preset.										
implication	endpoints requiring reserved transmitter presets to be reflected may be adversely affected. intel has not observed failures due to this erratum with any commercially available devices.										
workaround	none identified.										
											
title	processor may issue pcie* eieos at incorrect rate										
problem	when initiating a secondary bus reset or link disable procedure while a pcie link is in recovery state, the processor should send an eieos (electrical idle exit ordered set) after every 32 ts (training set) ordered sets. due to this erratum, the processor may send an eieos after every 33 ts ordered sets.										
implication	the processor may send an incorrect number of ts ordered sets between two eieos ordered sets when it initiates secondary bus reset or link disable. intel has not observed any failures with commercially available devices due to this erratum.										
workaround	none identified.										
											
title	reduced swing output mode needs zero de-emphasis to be supported in pcie* 5gt/s speed										
problem	it may not be possible to support the pcie transmitter preset 1 and/or transmitter preset 0 equalization requests in phase 0 or phase 2 of recovery.equalization ltssm states when operating in 8gt/s in reduced or half swing mode, if 0db transmitter de- emphasis needs to be supported when operating at 5gt/s.										
implication	this erratum does not affect normal full swing mode of operation. endpoints requiring 0db support in half-swing mode should avoid requesting transmitter preset 1 and/or transmitter preset 0 as preset requests in phase 0 or phase 2 of recovery.equalization when operating in 8gt/s.										
workaround	none identified.										
											
title	pcie* root-port initiated compliance state transmitter equalization settings may be incorrect										
problem	if the processor is directed to enter pcie polling.compliance at 5.0 gt/s or 8.0 gt/s transfer rates, it should use the link control 2 compliance preset/de-emphasis field (bits [15:12]) to determine the correct de-emphasis level. due to this erratum, when the processor is directed to enter polling.compliance from 2.5 gt/s transfer rate, it retains 2.5 gt/s de-emphasis values.										
implication	the processor may operate in polling.compliance mode with an incorrect transmitter de-emphasis level.										
workaround	none identified.										
											
title	pcie* controller may incorrectly log errors on transition to rxl0s										
problem	due to this erratum, if a link partner transitions to rxl0s state within 20 ns of entering l0 state, the pcie controller may incorrectly log an error in ?correctable error status.receiver error status? field (bus 0, device 2, function 0, 1, 2 and device 6, function 0, offset 1d0h, bit 0).										
implication	correctable receiver errors may be incorrectly logged. intel has not observed any functional impact due to this erratum with any commercially available add-in cards.										
workaround	none identified.										
											
title	reception of certain malformed transactions may cause pcie* port to hang rather than reporting an error										
problem	if the processor receives an upstream malformed non posted packet for which the type field is io, configuration or the deprecated tcfgrd and the format is 4 dw header, then due to this erratum the integrated pcie controller may hang instead of reporting the malformed packet error or issuing an unsupported request completion transaction.										
implication	due to this erratum, the processor may hang without reporting errors when receiving a malformed pcie transaction. intel has not observed this erratum with any commercially available device.										
workaround	none identified. upstream transaction initiators should avoid issuing unsupported requests with 4 dw header formats.										
											
title	pcie* link width may degrade after a warm reset										
problem	pcie link width may degrade after a warm reset if the link is operating at 8.0 gt/s or 5.0 gt/s transfer speeds prior to the reset.										
implication	due to this erratum, the pcie link may retain to a narrower width, e.g. from x16 to x4.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum. .										
											
title	pcie* link may not enter loopback.active when directed										
problem	when an endpoint directs the processor to enter loopback slave mode at 8 gt/s via ts1 ordered sets with both the loopback and compliance receive bits set, the pcie link should directly enter loopback.active state. due to this erratum, the processor must achieve block alignment on all looped back lanes prior to entering loopback.active.										
implication	the processor will not enter loopback.active state as a loopback slave if any lane in a link cannot achieve block alignment.										
workaround	none identified.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	unexpected #ud on vzeroall/vzeroupper										
problem	execution of the vzeroall or vzeroupper instructions in 64-bit mode with vex.w set to 1 may erroneously cause a #ud (invalid-opcode exception).										
implication	the affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.										
workaround	compilers should encode vex.w = 0 for the vzeroall and vzeroupper instructions.										
											
title	pcie* root port may not initiate link speed change										
problem	the pcie base specification requires the upstream component to maintain the pcie link at the target link speed or the highest speed supported by both components on the link, whichever is lower. pcie root port will not initiate the link speed change without being triggered by the software when the root port maximum link speed is configured to be 5.0 gt/s. system bios will trigger the link speed change under normal boot scenarios. however, bios is not involved in some scenarios such as link disable/re- enable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. this erratum does not affect the ability of the downstream component to initiate a link speed change. all known 5.0gb/s-capable pcie downstream components have been observed to initiate the link speed change without relying on the root port to do so.										
implication	due to this erratum, the pcie root port may not initiate a link speed change during some hardware scenarios causing the pcie link to operate at a lower than expected speed. intel has not observed this erratum with any commercially available platform.										
workaround	none identified.										
											
title	successive fixed counter overflows may be discarded										
problem	under specific internal conditions, when using freeze perfmon on pmi feature (bit 12 in ia32_debugctl.freeze_perfmon_on_pmi, msr 1d9h), if two or more perfmon fixed counters overflow very closely to each other, the overflow may be mishandled for some of them. this means that the counter’s overflow status bit (in msr_perf_global_status, msr 38eh) may not be updated properly; additionally, pmi interrupt may be missed if software programs a counter in sampling-mode (pmi bit is set on counter configuration).										
implication	successive fixed counter overflows may be discarded when freeze perfmon on pmi is used.										
workaround	software can avoid this by:										
											
title											
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not- available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	vm exits due to “nmi-window exiting” may not occur following a vm entry to the shutdown state										
problem	if vm entry is made with the “virtual nmis” and “nmi-window exiting”, vm-execution controls set to 1, and if there is no virtual-nmi blocking after vm entry, a vm exit with exit reason “nmi window” should occur immediately after vm entry unless the vm entry put the logical processor in the wait-for sipi state. due to this erratum, such vm exits do not occur if the vm entry put the processor in the shutdown state.										
implication	a vmm may fail to deliver a virtual nmi to a virtual machine in the shutdown state.										
workaround	before performing a vm entry to the shutdown state, software should check whether the “virtual nmis” and “nmi-window exiting” vm-execution controls are both 1. if they are, software should clear “nmi-window exiting” and inject an nmi as part of vm entry.										
											
title	execution of invvpid outside 64-bit mode cannot invalidate translations for 64-bit linear addresses										
problem	executions of the invvpid instruction outside 64-bit mode with the invvpid type “individual-address invalidation” ignore bits 63:32 of the linear address in the invvpid descriptor and invalidate translations for bits 31:0 of the linear address.										
implication	the invvpid instruction may fail to invalidate translations for linear addresses that set bits in the range 63:32. because this erratum applies only to executions outside 64-bit mode, it applies only to attempts by a 32-bit virtual-machine monitor (vmm) to invalidate translations for a 64-bit guest. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	pcie* controller may not properly indicate link electrical idle condition										
problem	the processor supports a x16 pcie* port, which can be bifurcated into three independent links, enumerated as bus 0, device 1, function 0-2. due to this erratum, if the port is bifurcated and function 1 or 2 is disabled, the pcie controller may not properly indicate link electrical idle condition to the power control unit.										
implication	an incorrect link electrical idle indication may prevent the processor from entering the lowest power mode, which may cause higher power consumption on vccio and vccsa. intel has not observed any functional failure or performance impact due to this erratum.										
workaround	if bus 0, device 1, function 1 or 2 is disabled, do not configure the x16 port to allocate lanes to those functions.										
											
title	pcie* controller may not enter loopback										
problem	the pcie controller is expected to enter loopback if any lane in the link receives two consecutive ts1 ordered sets with the loopback bit set. due to this erratum, if two consecutive ts1 ordered sets are received only on certain lanes, the controller may not enter loopback.										
implication	intel has not observed any functional issue with any commercially available pcie devices.										
workaround	none identified										
											
title	link margin characterization may hang link										
problem	the processor supports tools and mechanisms to characterize and measure margins for the pcie interface. due to this erratum, when performing link margin-to-failure characterization, it is possible that a high bit error rate may cause the link to hang.										
implication	under extreme conditions, poor link quality during link characterization may result in processor hang. intel has not observed this erratum with any commercially available platforms under normal operating conditions.										
workaround	none identified.										
											
title	unused pcie* lanes may report correctable errors										
problem	due to this erratum, during pcie* link down configuration, unused lanes may report a correctable error detected in bus 0, device 1, function 0-2, and device 6, function 0, offset 158h, bit 0.										
implication	correctable errors may be reported by a pcie controller for unused lanes.										
workaround	none identified.										
											
title	rdmsr of ia32_perfevtsel{4-7} may return erroneous information										
problem	when cpuid.0ah:eax[15:8] reports 8 general-purpose performance monitoring counters per logical processor, rdmsr of ia32_perfevtsel{4-7} (msr 18ah-18dh) may not return the same value previously written by software.										
implication	software should not rely on values read from these msrs.										
workaround	none identified.										
											
title	pcie* link may fail link width upconfiguration										
problem	the processor supports pcie hardware autonomous width management, in which a pcie link can autonomously vary its width. due to this erratum, a link that performs a speed change while in a reduced width may no longer be able to return to a wider link width.										
implication	pcie links that perform speed changes while at a reduced link width may be limited to the link width in effect at the time of the speed change. intel has not observed this erratum with any commercially available devices or platforms.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	graphics l3 cache parity errors may not be detected										
problem	the graphics engine should detect parity errors within the graphics l3 cache. however, due to this erratum, graphics l3 cache parity errors may not be detected.										
implication	there may be undetected parity errors from workloads submitted to the execution units of the graphics engine leading to unpredictable graphics system behavior.										
workaround	it is possible for the graphics driver to contain a workaround for this erratum.										
											
title	a pcie* link that is in link disable state may prevent ddr i/o buffers from entering a power gated state										
problem	when entering link disable ltssm state, the pcie controller may not properly indicate the link electrical idle condition.										
implication	an incorrect link electrical idle indication may prevent the ddr i/o buffers from entering a power gated state, which may cause higher power consumption on vccio and vccsa. intel has not observed any functional failure or performance impact due to this erratum.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	graphics l3 cache redundancy may not behave as expected										
problem	the processor graphics l3 cache is designed to have redundancy to improve resilience to cache related errors. due to this erratum, that redundancy may not function as expected, resulting in a potential increase in l3 cache related errors.										
implication	under certain conditions, the lack of redundancy may lead to unpredictable graphics system behavior when processor graphics l3 cache is utilized.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	rep movsb may incorrectly update ecx, esi, and edi										
problem	under certain conditions, if the execution of a rep movsb instruction is interrupted, the values of ecx, esi and edi may contain values that represent a later point in the execution of the instruction than the actual interruption point.										
implication	due to this erratum ecx, esi, and edi may be incorrectly advanced, resulting in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	under certain conditions (listed below) when a performance counter overflows, its overflow indication may remain set indefinitely. this erratum affects the general- purpose performance counters ia32_pmc{0-7} and the fixed-function performance counters ia32_fixed_ctr{0-2}. the erratum may occur if any of the following conditions are applied concurrent to when an actual counter overflow condition is reached:  software disables the counter either globally through the ia32_perf_global_ctrl msr (38fh), or locally through the ia32_perfevtsel{0-7} msrs (186h-18dh), or the ia32_fixed_ctr_ctrl msr (38dh). software sets the ia32_debugctl msr (1d9h) freeze_perfmon_on_pmi bit [12]. the processor attempts to disable the counters by updating the state of the ia32_perf_global_ctrl msr (38fh) as part of transitions such as vm exit, vm entry, smi, rsm, or processor c-state.										
implication	due to this erratum, the corresponding overflow status bit in ia32_perf_global_status msr (38dh) for an affected counter may not get cleared when expected. if a corresponding counter is configured to issue a pmi (performance monitor interrupt), multiple pmis may be signaled from the same overflow condition. likewise, if a corresponding counter is configured in pebs mode (applies to only the general purpose counters), multiple pebs events may be signaled.										
workaround	none identified.										
											
title	rdmsr of ia32_perfevtsel4-7 may return an incorrect result										
problem	when cpuid.a.eax[15:8] reports 8 general-purpose performance monitoring counters per logical processor, rdmsr of ia32_perfevtsel4-7 (msr 18ah:18dh) may not return the same value as previously written.										
implication	software should not rely on the value read from these msrs. writing these msrs functions as expected.										
workaround	none identified.										
											
title	vex.l is not ignored with vcvt*2si instructions										
problem	the vex.l bit should be ignored for the vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions, however due to this erratum the vex.l bit is not ignored and will cause a #ud.										
implication	unexpected #uds will be seen when the vex.l bit is set to 1 with vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions.										
workaround	software should ensure that the vex.l bit is set to 0 for all scalar instructions.										
											
title	intel® turbo boost technology may be incorrectly reported as supported on intel® core™ i3-3217u										
problem	the intel® core™ i3-3217u processor may incorrectly report support for intel® turbo boost technology via cpuid.06h.eax bit 1.										
implication	the cpuid instruction may report turbo boost technology as supported even though the processor does not permit operation above the maximum non-turbo frequency.										
workaround	none identified										
											
title											
problem	under a complex set of microarchitectural conditions, the system may hang if software changes the memory type and page size used to translate a linear address while a tlb (translation lookaside buffer) holds a valid translation for that linear address.										
implication	due to this erratum, the system may hang. intel has not observed this erratum with any commercially available software.										
workaround	none identified. please refer to software developer’s manual, volume 3, section “recommended invalidation” for the proper procedure for concurrently changing page attributes and page size.										
											
title	mci_addr may be incorrect for cache parity errors										
problem	in cases when a wbinvd instruction evicts a line containing an address or data parity error (mcacod of 0x124, and mscod of 0x10), the address of this error should be logged in the mci_addr register. due to this erratum, the logged address may be incorrect, even though mci_status.addrv (bit 63) is set.										
implication	the address reported in mci_addr may not be correct for cases of a parity error found during wbinvd execution.										
workaround	none identified.										
											
title	during package power states repeated pcie* and/or dmi l1 transitions may cause a system hang										
problem	under a complex set of internal conditions and operating temperature, when the processor is in a deep power state (package c3, c6 or c7) and the pcie and/or dmi links are toggling in and out of l1 state, the system may hang.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	instruction fetches page-table walks may be made speculatively to uncacheable memory										
problem	page-table walks on behalf of instruction fetches may be made speculatively to uncacheable (uc) memory.										
implication	if any paging structures are located at addresses in uncacheable memory that are used for memory-mapped i/o, such i/o operations may be invoked as a result of speculative execution that would never actually occur in the executed code path. intel has not observed this erratum with any commercially available software.										
workaround	software should avoid locating paging structures at addresses in uncacheable memory that are used for memory-mapped i/o.										
											
title	the processor may not properly execute code modified using a floating-point store										
problem	under complex internal conditions, a floating-point store used to modify the next sequential instruction may result in the old instruction being executed instead of the new instruction.										
implication	self- or cross-modifying code may not execute as expected. intel has not observed this erratum with any commercially available software.										
workaround	none identified. do not use floating-point stores to modify code.										
											
title	execution of getsec[sexit] may cause a debug exception to be lost										
problem	a debug exception occurring at the same time that getsec[sexit] is executed or when an sexit doorbell event is serviced may be lost.										
implication	due to this erratum, there may be a loss of a debug exception when it happens concurrently with the execution of getsec[sexit]. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	vm exits due to getsec may save an incorrect value for “blocking by sti” in the context of probe-mode redirection										
problem	the getsec instruction causes a vm exit when executed in vmx non-root operation. such a vm exit should set bit 0 in the interruptability-state field in the virtual-machine control structure (vmcs) if the sti instruction was blocking interrupts at the time getsec commenced execution. due to this erratum, a vm exit executed in vmx non-root operation may erroneously clear bit 0 if redirection to probe mode occurs on the getsec instruction.										
implication	after returning from probe mode, a virtual interrupt may be incorrectly delivered prior to getsec instruction. intel has not observed this erratum with any commercially software.										
workaround	none identified.										
											
title	none										
problem	cific source-copy blitter instructions in intel® hd graphics 2500 and 4000 processor may result in unpredictable behavior when a blit source and destination overlap.										
implication	to this erratum, the processor may exhibit unpredictable graphics controller behavior. intel has not observed this erratum with any commercially available software.										
workaround											
											
title	ia32_mc5_ctl2 is not cleared by a warm reset										
problem	ia32_mc5_ctl2 msr (285h) is documented to be cleared on any reset. due to this erratum this msr is only cleared upon a cold reset.										
implication	the algorithm documented in software developer's manual, volume 3, section titled "cmci initialization” or any other algorithm that counts the ia32_mc5_ctl2 msr being cleared on reset will not function as expected after a warm reset.										
workaround	none identified.										
											
title	cpuid instruction may not report the processor number in the brand string for intel® core™ i3-3227u and i5-3337u processors.										
problem	when the cpuid instruction is executed with eax = 80000002h, 80000003h, and 80000004h, the returned brand string may be incomplete; it may be missing the processor number.										
implication	when this erratum occurs, the processor may be missing the processor number in the brand string. in addition, if the affected processors are paired with the intel® 7 series chipset bd82um77 chipset, the bios may incorrectly report this combination as unsupported.										
workaround	it is possible for the bios to contain a workaround for this erratum, except if paired with the intel 7 series chipset bd82um77 chipset.										
											
title	performance monitor counters may produce incorrect results										
problem	when operating with smt enabled, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled event on the corresponding counter with the same number on the physical core’s other thread rather than the thread experiencing the event. processors with smt disabled in bios are not affected by this erratum. the list of affected memory at-retirement events is as follows: mem_uop_retired.loads mem_uop_retired.stores mem_uop_retired.lock mem_uop_retired.split mem_uop_retired.stlb_miss mem_load_uops_retired.hit_lfb mem_load_uops_retired.l1_hit mem_load_uops_retired.l2_hit mem_load_uops_retired.llc_hit mem_load_uops_llc_hit_retired.xsnp_hit mem_load_uops_llc_hit_retired.xsnp_hitm mem_load_uops_llc_hit_retired.xsnp_miss mem_load_uops_llc_hit_retired.xsnp_none mem_load_uops_retired.llc_miss mem_load_uops_llc_miss_retired.local_dram mem_load_uops_llc_miss_retired.remote_dram mem_load_uops_retired.l2_miss										
implication	due to this erratum, certain performance monitoring event may produce unreliable results when smt is enabled.										
workaround	none identified.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	spurious vt-d interrupts may occur when the pfo bit is set										
problem	when the pfo (primary fault overflow) field (bit [0] in the vt-d fsts [fault status] register) is set to 1, further faults should not generate an interrupt. due to this erratum, further interrupts may still occur.										
implication	unexpected invalidation queue error interrupts may occur. intel has not observed this erratum with any commercially available software.										
workaround	software should be written to handle spurious vt-d fault interrupts.										
											
title	processor may livelock during on demand clock modulation										
problem	the processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the ia32_clock_modulation msr (19ah) and the clock modulation duty cycle is set to 12.5% (02h in bits 3:0 of the same msr), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access uc memory.										
implication	program execution may stall on both threads of the core subject to this erratum.										
workaround	this erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the ia32_clock_modulation msr is 18.75% or higher.										
											
title	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding										
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9:1 report the highest index value used for any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9:1] to read and write all vmcs fields may omit one field.										
workaround	none identified.										
											
title	the upper 32 bits of cr3 may be incorrectly used with 32-bit paging										
problem	when 32-bit paging is in use, the processor should use a page directory located at the 32- bit physical address specified in bits 31:12 of cr3; the upper 32 bits of cr3 should be ignored. due to this erratum, the processor will use a page directory located at the 64-bit physical address specified in bits 63:12 of cr3.										
implication	the processor may use an unexpected page directory or, if ept (extended page tables) is in use, cause an unexpected ept violation. this erratum applies only if software enters 64-bit mode, loads cr3 with a 64-bit value, and then returns to 32-bit paging without changing cr3. intel has not observed this erratum with any commercially available software.										
workaround	software that has executed in 64-bit mode should reload cr3 with a 32-bit value before returning to 32-bit paging.										
											
title	ept violations may report bits 11:0 of guest linear address incorrectly										
problem	if a memory access to a linear address requires the processor to update an accessed or dirty flag in a paging-structure entry and if that update causes an ept violation, the processor should store the linear address into the “guest linear address” field in the vmcs. due to this erratum, the processor may store an incorrect value into bits 11:0 of this field. (the processor correctly stores the guest-physical address of the paging- structure entry into the “guest-physical address” field in the vmcs.)										
implication	software may not be easily able to determine the page offset of the original memory access that caused the ept violation. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	software requiring the page offset of the original memory access address can derive it by simulating the effective address computation of the instruction that caused the ept violation.										
											
title	dma remapping faults for the graphics vt-d unit may not properly report type of faulted request										
problem	when a fault occurs during dma remapping of graphics accesses at the graphics vt-d unit, the type of faulted request (read or write) should be reported in bit 126 of the frcd_reg register in the remapping hardware memory map register set. due to this erratum, the request type may not be reported correctly.										
implication	software processing the dma remapping faults may not be able to determine the type of faulting graphics device dma request.										
workaround	none identified.										
											
title	intel® trusted execution technology acm authentication failure										
problem	sinit acm 3rd_gen_i5_i7-sinit_51.bin or earlier are revoked and will not launch with new processor configuration information.										
implication	due to this erratum, sinit acm 3rd_gen_i5_i7-sinit_51.bin or earlier will fail to run.										
workaround	it is possible for the bios to contain a workaround for this erratum. all intel® txt enabled software must use sinit acm 3rd_gen_i5_i7-sinit_67.bin or later.										
											
title	virtual-apic page accesses with 32-bit pae paging may cause a system crash										
problem	if a logical processor has ept (extended page tables) enabled, is using 32-bit pae paging, and accesses the virtual-apic page then a complex sequence of internal processor micro-architectural events may cause an incorrect address translation or machine check on either logical processor.										
implication	this erratum may result in unexpected faults, an uncorrectable tlb error logged in ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_0000_0001_xxxxb (where x stands for 0 or 1), a guest or hyper visor crash, or other unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	address translation faults for intel® vt-d may not be reported for display engine memory accesses										
problem	the intel® vt-d (intel® virtualization technology for directed i/o) hardware unit supporting the processor graphics device (bus 0; device 2; function 0) may not report address translation faults detected on display engine memory accesses when the context cache is disabled or during time periods when context cache is being invalidated.										
implication	due to this erratum, display engine accesses that fault are correctly aborted but may not be reported in the fsts_reg fault reporting register (gfxvtdbar offset 034h).										
workaround	none identified										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation										
problem	if ept (extended page tables) is enabled, a mov to cr3 may be followed by an unexpected page fault or the use of an incorrect page translation.										
implication	guest software may crash or experience unpredictable behavior as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	this erratum may cause a machine-check error (ia32_mci_status.mcacod=0150h) on the fetch of an instruction that crosses a 4-kbyte address boundary. it applies only if the 4-kbyte linear region on which the instruction begins is originally translated using a 4-kbyte page with the wb memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-mbyte, 4-mbyte, or 1-gbyte) with the uc memory type; and (3) the instruction fetch occurs after the paging-structure modification but before software invalidates any tlb entries for the linear region.										
implication	due to this erratum an unexpected machine check with error code 0150h may occur, possibly resulting in a shutdown. intel has not observed this erratum with any commercially available software.										
workaround	software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. it can instead use the following algorithm: first clear the p flag in the relevant paging-structure entry (e.g., pde); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the p flag and establish the new page size and memory type.										
											
title	high frequency noise on ddr smbus signals may prevent proper detection of memory										
problem	during the processor power up sequence, high frequency noise may occur on the ddr smbus sda and scl signals interfering with correct information transfer.										
implication	when this erratum occurs, high frequency noise may cause certain voltage translator components to latch up and, as a result, the system may not be able to detect memory.										
workaround	none identified										
											
title	pcie* ports do not support dll link active reporting										
problem	the pcie base specification requires every “downstream port that supports link speeds greater than 5.0 gt/s” to support dll (data link layer) link active reporting, however, the pcie ports do not support dll link active reporting.										
implication	due to this erratum, the pcie ports do not support dll link active reporting. this may be reported by a pcie compliance test.										
workaround	none identified.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title	monitor or clflush on the local xapic's address space results in hang										
problem	if the target linear address range for a monitor or clflush is mapped to the local xapic's address space, the processor will hang.										
implication	when this erratum occurs, the processor will hang. the local xapic's address space must be uncached. the monitor instruction only functions correctly if the specified linear address range is of the type write-back. clflush flushes data from the cache. intel has not observed this erratum with any commercially available software.										
workaround	do not execute monitor or clflush instructions on the local xapic address space.										
											
title	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang										
problem	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).										
implication	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.										
workaround	none identified.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	freeze_while_smm does not prevent event from pending pebs during smm										
problem	in general, a pebs record should be generated on the first count of the event after the counter has overflowed. however, ia32_debugctl_msr.freeze_while_smm (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if: a performance counter overflowed before an smi. a pebs record has not yet been generated because another count of the event has not occurred. the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction.  when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.										
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.										
workaround	none identified.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	changing the memory type for an in-use page translation may lead to memory-ordering violations										
problem	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.										
implication	memory ordering may be violated. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure pages are not being actively used before requesting their memory type be changed.										
											
title	performance monitor precise instruction retired event may present wrong indications										
problem	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).										
implication	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.										
workaround	the sampling driver should avoid using sav<100.										
											
title	cr0.cd is ignored in vmx operation										
problem	if cr0.cd=1, the mtrrs and pat should be ignored and the uc memory type should be used for all memory accesses. due to this erratum, a logical processor in vmx operation will operate as if cr0.cd=0 even if that bit is set to 1.										
implication	algorithms that rely on cache disabling may not function properly in vmx operation.										
workaround	algorithms that rely on cache disabling should not be executed in vmx root operation.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	processor may fail to acknowledge a tlp request										
problem	when a pcie root port’s receiver is in receiver l0s power state and the port initiates a recovery event, it will issue training sets to the link partner. the link partner will respond by initiating an l0s exit sequence. prior to transmitting its own training sets, the link partner may transmit a tlp (transaction layer packet) request. due to this erratum, the root port may not acknowledge the tlp request.										
implication	after completing the recovery event, the pcie link partner will replay the tlp request. the link partner may set a correctable error status bit, which has no functional effect.										
workaround	none identified.										
											
title	interrupt from local apic timer may not be detectable while being delivered										
problem	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.										
implication	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.										
workaround	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.										
											
title	pcie* root-port initiated compliance state transmitter equalization settings may be incorrect										
problem	if the processor is directed to enter pcie polling.compliance at 5.0 gt/s or 8.0 gt/s transfer rates, it should use the link control 2 compliance preset/de-emphasis field (bits [15:12]) to determine the correct de-emphasis level. due to this erratum, when the processor is directed to enter polling.compliance from 2.5 gt/s transfer rate, it retains 2.5 gt/s de-emphasis values.										
implication	the processor may operate in polling.compliance mode with an incorrect transmitter de-emphasis level.										
workaround	none identified.										
											
title	pcie* controller may incorrectly log errors on transition to rxl0s										
problem	due to this erratum, if a link partner transitions to rxl0s state within 20 ns of entering l0 state, the pcie controller may incorrectly log an error in “correctable error status.receiver error status” field (bus 0, device 2, function 0, 1, 2 and device 6, function 0, offset 1d0h, bit 0).										
implication	correctable receiver errors may be incorrectly logged. intel has not observed any functional impact due to this erratum with any commercially available add-in cards.										
workaround	none identified.										
											
title	unused pcie* lanes may report correctable errors										
problem	due to this erratum, during pcie* link down configuration, unused lanes may report a correctable error detected in bus 0, device 1, function 0-2, and device 6, function 0, offset 158h, bit 0.										
implication	correctable errors may be reported by a pcie controller for unused lanes.										
workaround	none identified.										
											
title	accessing physical memory space 0-640k through the graphics aperture may cause unpredictable system behavior										
problem	the physical memory space 0-640k when accessed through the graphics aperture may result in a failure for writes to complete or reads to return incorrect results.										
implication	a hang or functional failure may occur during graphics operation such as ogl or ocl conformance tests, 2d/3d games and graphics intensive application.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie root port may not initiate link speed change										
problem	the pcie base specification requires the upstream component to maintain the pcie link at the target link speed or the highest speed supported by both components on the link, whichever is lower. pcie root port will not initiate the link speed change without being triggered by the software when the root port maximum link speed is configured to be 5.0 gt/s. system bios will trigger the link speed change under normal boot scenarios. however, bios is not involved in some scenarios such as link disable/re- enable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. this erratum does not affect the ability of the downstream component to initiate a link speed change. all known 5.0gb/s-capable pcie downstream components have been observed to initiate the link speed change without relying on the root port to do so.										
implication	due to this erratum, the pcie root port may not initiate a link speed change during some hardware scenarios causing the pcie link to operate at a lower than expected speed. intel has not observed this erratum with any commercially available platform.										
workaround	none identified.										
											
title	pending x87 fpu exceptions (#mf) may be signaled earlier than expected										
problem	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executed while enhanced intel speedstep® technology transitions, intel® turbo boost technology transitions, or thermal monitor events occur, the pending #mf may be signaled before pending interrupts are serviced.										
implication	software may observe #mf being signaled before pending interrupts are serviced.										
workaround	none identified.										
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store or an mmx instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (i.e., following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	vex.l is not ignored with vcvt*2si instructions										
problem	the vex.l bit should be ignored for the vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions, however due to this erratum the vex.l bit is not ignored and will cause a #ud.										
implication	unexpected #uds will be seen when the vex.l bit is set to 1 with vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions.										
workaround	software should ensure that the vex.l bit is set to 0 for all scalar instructions.										
											
title	some dram and l3 cache performance monitoring events may count incorrectly										
problem	due to this erratum, the supplier information may become stale, and the following events may count incorrectly. mem_load_uops_retired.l3_hit (event d1h umask 04h) mem_load_uops_retired.l3_miss (event d1h umask 20h) mem_load_uops_l3_hit_retired.xsnp_miss (event d2h umask 01h) mem_load_uops_l3_hit_retired.xsnp_hit (event d2h umask 02h) mem_load_uops_l3_hit_retired.xsnp_hitm (event d2h umask 04h) mem_load_uops_l3_hit_retired.xsnp_none (event d2h umask 08h) mem_load_uops_l3_miss_retired.local_dram (event d3h umask 01h) mem_trans_retired.load_latency (event cdh umask 01h) page_walker_loads.dtlb_l3 (event bch umask 14h) page_walker_loads.itlb_l3 (event bch umask 24h) page_walker_loads.dtlb_memory (event bch umask 18h) page_walker_loads.itlb_memory (event bch umask 28h)										
implication	the affected events may count incorrectly, resulting in inaccurate memory profiles. for the affected events that are precise, pebs records may be generated at incorrect points. intel has observed incorrect counts by as much as 40%.										
workaround	none identified.										
											
title	specific graphics blitter instructions may result in unpredictable graphics controller behavior										
problem	specific source-copy blitter instructions in intel® hd graphics 4600 processor may result in unpredictable behavior when a blit source and destination overlap.										
implication	due to this erratum, the processor may exhibit unpredictable graphics controller behavior. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	processor may enter shutdown unexpectedly on a second uncorrectable error										
problem	if an ia32_mci_status msr contains an uncorrectable error with mcacod=0x406 and a second uncorrectable error occurs after warm reset but before the first error is cleared by zeroing the ia32_mci_status msr, a shutdown will occur.										
implication	when this erratum occurs, the processor will unexpectedly shut down instead of executing the machine check handler.										
workaround	none identified. software should clear ia32_mci_status msrs as early as possible to minimize the possibility of this erratum occurring.										
											
title	modified compliance patterns for 2.5 gt/s and 5 gt/s transfer rates do not follow pcie* specification										
problem	the pcie controller does not produce the pcie specification defined sequence for the modified compliance pattern at 2.5 gt/s and 5 gt/s transfer rates. this erratum is not seen at 8 gt/s transfer rates.										
implication	normal pcie operation is unaffected by this erratum.										
workaround	none identified.										
											
title	performance monitor counters may produce incorrect results										
problem	when operating with smt enabled, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled event on the corresponding counter with the same number on the physical core’s other thread rather than the thread experiencing the event. processors with smt disabled in bios are not affected by this erratum. the list of affected memory at-retirement events is as follows: mem_uop_retired.loads mem_uop_retired.stores mem_uop_retired.lock mem_uop_retired.split mem_uop_retired.stlb_miss mem_load_uops_retired.hit_lfb mem_load_uops_retired.l1_hit mem_load_uops_retired.l2_hit mem_load_uops_retired.l3_hit mem_load_uops_l3_hit_retired.xsnp_hit mem_load_uops_l3_hit_retired.xsnp_hitm mem_load_uops_l3_hit_retired.xsnp_miss mem_load_uops_l3_hit_retired.xsnp_none mem_load_uops_retired.l3_miss mem_load_uops_l3_miss_retired.local_dram mem_load_uops_l3_miss_retired.remote_dram mem_load_uops_retired.l2_miss										
implication	due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.										
workaround	none identified.										
											
title	performance monitor uops_executed event may undercount										
problem	the performance monitor event uops_executed (event b1h, any unmask) should count the number of uops executed each cycle. however due to this erratum, when eight uops execute in one cycle, these uops will not be counted.										
implication	the performance monitor event uops_executed may reflect a count lower than the actual number of events.										
workaround	none identified.										
											
title	pcie* atomic transactions from two or more pcie controllers may cause starvation										
problem	on a processor pcie controller configuration in which two or more controllers receive concurrent atomic transactions, a pcie controller may experience starvation which eventually can lead to a completion timeout.										
implication	atomic transactions from two or more pcie controllers may lead to a completion timeout. atomic transactions from only one controller will not be affected by this erratum. intel has not observed this erratum with any commercially available device.										
workaround	none identified.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title											
problem	when execution of an avx gather instruction causes an ept (extended page table) violation due to a specific element, all previous elements should be complete. due to this erratum, such an execution may fail to complete previous elements. in addition, the instruction's mask operand is not updated. this erratum applies only if the ept violation occurs while updating an accessed or dirty flag in a paging-structure entry. instructions impacted by this erratum are: vgatherdps, vgatherdpd, vgatherqps, vgatherqpd, vpgatherdd, vpgatherdq, vpgatherqd, and vpgatherqq.										
implication	this erratum may prevent a gather instruction from making forward progress.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	platform_power_limit msr not visible										
problem	the platform_power_limit msr (615h) is used to control the pl3 (power limit 3) mechanism of the processor. due to this erratum, this msr is not visible to software.										
implication	software is unable to read or write the platform_power_limit msr. if software attempts to access this msr, a general protection fault will occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	lpddr memory may report incorrect temperature										
problem	when any of the four possible lpddr ranks are not populated, the unpopulated ranks will report a default temperature of 85c as a three bit value of 011b. if the system has unpopulated ranks the temperature of memory will be reported as 85c in pcu_cr_ddr_dimm_hottest_absolute (mchbar bus 0; device 0; function 0; offset 58b8h) in bits [5:7], until any of the populated ranks report a higher temperature than this.										
implication	when the memory temperature is less than or equal to 85c it may be reported as 85c. this erratum does not affect ddr3 and ddr3l memory types.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* host bridge did may be incorrect										
problem	the pcie host bridge did register (bus 0; device 0; offset 2h) contents may be incorrect after a package c7 exit.										
implication	software that depends on the host bridge did value may not behave as expected after a package c7 exit.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	tsc may be incorrect after a deep c-state exit										
problem	on exiting from package c6 or deeper, the processor may incorrectly restore the tsc (time stamp counter).										
implication	software using the tsc may produce incorrect result and/or may not behave as expected.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	pcie* controller may initiate speed change while in dl_init state causing certain pcie devices to fail to train										
problem	the pcie controller supports hardware autonomous speed change capabilities. due to this erratum, the pcie controller may initiate speed change while in the dl_init state which may prevent link training for certain pcie devices.										
implication	certain pcie devices may fail to complete dl_init causing the pcie link to fail to train.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	spurious vt-d interrupts may occur when the pfo bit is set										
problem	when the pfo (primary fault overflow) field (bit [0] in the vt-d fsts [fault status] register) is set to 1, further faults should not generate an interrupt. due to this erratum, further interrupts may still occur.										
implication	unexpected invalidation queue error interrupts may occur. intel has not observed this erratum with any commercially available software.										
workaround	software should be written to handle spurious vt-d fault interrupts.										
											
title	avx gather instruction that causes a fault or vm exit may incorrectly modify its destination register										
problem	an execution of a 128-bit avx gather instruction zeroes the upper 128 bits of the instruction's destination register unless access to the first unmasked element causes a fault or vm exit. due to this erratum, these bits may be cleared even when accessing the first unmasked element causes a fault or vm exit. instructions impacted by this erratum are: vgatherdps, vgatherdpd, vgatherqps, vgatherqpd, vpgatherdd, vpgatherdq, vpgatherqd, and vpgatherqq.										
implication	software that depends on the destination register of a 128-bit avx gather instruction to remain unchanged after access of the first unmasked element results in fault or vm exit may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	inconsistent nan propagation may occur when executing (v)dpps instruction										
problem	upon completion of the (v)dpps instruction with multiple different nan encodings in the input elements, software may observe different nan encodings in the destination elements.										
implication	inconsistent nan encodings in the destination elements for the (v) dpps instruction may be observed.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	display may flicker when package c-states are enabled										
problem	when package c-states are enabled, the display may not be refreshed at the correct rate.										
implication	when this erratum occurs, the user may observe flickering on the display.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain combinations of avx instructions may cause unpredictable system behavior										
problem	execution of certain combinations of avx instructions may lead to unpredictable system behavior.										
implication	when this erratum occurs, unpredictable system behaviors, including system hang or incorrect results can occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor may incorrectly estimate peak power delivery requirements										
problem	under certain conditions, the processor may incorrectly calculate the frequency at which the cores and graphics engine can operate while still meeting voltage regulator and power supply peak power delivery capabilities. when this occurs, combined with high power workloads, system shutdown may be observed.										
implication	when this erratum occurs, system shutdown may be observed under high power workloads.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_perf_ctl msr is incorrectly reset										
problem	the ia32_perf_ctl msr (199h) is not initialized correctly after a processor reset.										
implication	if software reads the ia32_perf_ctl msr before writing it, software can observe an incorrect reset value. although incorrect values are reported to software, the correct default values for this register are still used by the processor. no performance or power impact occurs due to this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor may hang during a function level reset of the display										
problem	when package c-states are enabled, it is possible that the processor may hang when software performs a function level reset of the display via bit 1 of the advanced features control register (bus 0; device 2; function 0; offset 0a8h).										
implication	when this erratum occurs, the processor may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	avx gather instruction that should result in #df may cause unexpected system behavior										
problem	due to this erratum, an execution of a 128-bit avx gather instruction may fail to generate a #df (double fault) when expected. instructions impacted by this erratum are: vgatherdps, vgatherdpd, vgatherqps, vgatherqpd, vpgatherdd, vpgatherdq, vpgatherqd, and vpgatherqq.										
implication	when this erratum occurs, an operation which should cause a #df may result in unexpected system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	throttling and refresh rate maybe be incorrect after exiting package c-state										
problem	when the oltm (open loop thermal management) feature is enabled, the dimm thermal status reported in ddr_therm_perdimm_status (mchbar offset 588ch) may be incorrect following an exit from package c3 or deeper.										
implication	the incorrect dimm thermal status may result in degraded performance from unneeded memory throttling and excessive dimm refresh rates.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	processor may livelock during on demand clock modulation										
problem	the processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the ia32_clock_modulation msr (19ah) and the clock modulation duty cycle is set to 12.5% (02h in bits 3:0 of the same msr), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access uc memory.										
implication	program execution may stall on both threads of the core subject to this erratum.										
workaround	this erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the ia32_clock_modulation msr is 18.75% or higher.										
											
title	ia32_debugctl.freeze_perfmon_on_pmi is incorrectly cleared by smi										
problem	freeze_perfmon_on_pmi (bit 12) in the ia32_debugctl msr (1d9h) is erroneously cleared during delivery of an smi (system-management interrupt).										
implication	as a result of this erratum, the performance monitoring counters will continue to count after a pmi occurs in smm (system-management mode).										
workaround	none identified.										
											
title	the from-ip for branch tracing may be incorrect										
problem	btm (branch trace message) and bts (branch trace store) report the “from-ip” indicating the source address of the branch instruction. due to this erratum, btm and bts may repeat the “from-ip” value previously reported. the “to-ip” value is not affected.										
implication	using btm or bts reports to reconstruct program execution may be unreliable.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	tm1 throttling may continue indefinitely										
problem	tm1 (thermal monitor 1) throttling may continue when the processor’s temperature decreases below the throttling point while the processor is in package c3 or deeper.										
implication	the processor will continue thermal throttling but does not indicate it is hot.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	internal parity errors may incorrectly report overflow in the ia32_mc2_status msr										
problem	due to this erratum, uncorrectable internal parity error with an ia32_mc2_status.mcacod (bits [15:0]) value of 0005h and an ia32_mc2_status.mscod (bits [31:16]) value of 0004h may incorrectly set the ia32_mc2_status.over flag (bit 62) indicating an overflow when a single error has been observed.										
implication	ia32_mc2_status.over may not accurately indicate multiple occurrences of uncorrectable internal parity errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	performance monitor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count										
problem	the performance monitor events other_assists.avx_to_sse (event c1h; umask 08h) and other_assists.sse_to_avx (event c1h; umask 10h) incorrectly increment and over count when an hle (hardware lock elision) abort occurs.										
implication	the performance monitor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count.										
workaround	none identified.										
											
title	processor may run at incorrect p-state										
problem	the processor package may use stale software p-state (performance state) requests when one or more logical processors are idle.										
implication	the processor package may run at a higher or lower than expected p-state. this issue may persist as long as any logical processor is idle.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitor event dsb2mite_switches.count may over count										
problem	the performance monitor event dsb2mite_switches.count (event abh; umask 01h) should count the number of dsb (decode stream buffer) to mite (macro instruction translation engine) switches. due to this erratum, the dsb2mite_switches.count event will count speculative switches and cause the count to be higher than expected.										
implication	the performance monitor event dsb2mite_switches.count may report count higher than expected.										
workaround	none identified.										
											
title	performance monitor register unc_perf_global_status not restored on package c7 exit										
problem	msr_unc_perf_global_status (392h) is a global status register which indicates the overflow of uncore performance monitor counters. the content of this register is lost in package c7 state.										
implication	if any uncore performance monitor counter has overflowed before entering the package c7 state, the msr_unc_perf_global_status register will no longer reflect the overflow after exiting c7 state.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor may not enter package c6 or deeper c-states when pcie* links are disabled										
problem	if the pcie links are disabled via link disable (bus 0, device 1, functions [2:1], offset b0h, bit 4) and the pcie controller is enabled (bus 0, device 0, function 0, offset 54h, bits [2:1] = ’11), then the processor will be unable to enter package c6 or deeper c- states.										
implication	due to this erratum, the process will not enter package c6 or deeper c-states.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitor event for outstanding offcore requests and snoop requests may over count										
problem	the performance monitor event offcore_requests_outstanding (event 60h, any umask value) should count the number of offcore outstanding transactions each cycle. due to this erratum, the counts may be higher than actual number of events.										
implication	the performance monitor events offcore_requests_outstanding may reflect counts higher than the actual number of events.										
workaround	none identified.										
											
title	some performance monitor event counts may be inaccurate during smt mode										
problem	the performance monitor event offcore_requests_outstanding (event 60h, any umask value) should count the number of occurrences that loads or stores stay in the super queue each cycle. the performance monitor event cycle_activity.cycles_l2_pending (event a3h, umask 01h) should count the number of cycles that demand loads stay in the super queue. however, due to this erratum, these events may count inaccurately during smt mode.										
implication	the performance monitor events offcore_requests_outstanding and cycle_activity.l2_ pending may be unreliable during smt mode.										
workaround	none identified.										
											
title	the upper 32 bits of cr3 may be incorrectly used with 32-bit paging										
problem	when 32-bit paging is in use, the processor should use a page directory located at the 32-bit physical address specified in bits 31:12 of cr3; the upper 32 bits of cr3 should be ignored. due to this erratum, the processor will use a page directory located at the 64-bit physical address specified in bits 63:12 of cr3.										
implication	the processor may use an unexpected page directory or, if ept (extended page tables) is in use, cause an unexpected ept violation. this erratum applies only if software enters 64-bit mode, loads cr3 with a 64-bit value, and then returns to 32-bit paging without changing cr3. intel has not observed this erratum with any commercially available software.										
workaround	software that has executed in 64-bit mode should reload cr3 with a 32-bit value before returning to 32-bit paging.										
											
title	performance monitor events hle_retired.aborted_misc4 and rtm_retired.aborted_misc4 may over count										
problem	the performance monitor events hle_retired.aborted_misc4 (event c8h; umask 40h) and rtm_retired.aborted_misc4 (event c9h; umask 40h) are defined to count the number of transactional aborts due to incompatible memory types. due to this erratum, they may count additional unrelated transactional aborts.										
implication	the performance monitor events hle_retired.aborted_misc4 and rtm_retired.aborted_misc4 counts may be greater than the number of aborts due to incompatible memory types. this can result in nonzero counts when all memory types are compatible.										
workaround	none identified.										
											
title	a pcie* ltr update message may cause the processor to hang										
problem	if a pcie device sends an ltr (latency tolerance report) update message while the processor is in a package c6 or deeper, the processor may hang.										
implication	due to this erratum the processor may hang if a pcie ltr update message is received while in a package c6 or deeper.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	getsec does not report support for s-crtm										
problem	processors with intel® boot guard technology that has getsec[parameters] leaf 5 eax bit 5 set indicates support for processor rooted s-ctrm (static core root of trust for measurement). due to this erratum, that bit will not be set even though processor rooted s-crtm is supported.										
implication	software may be unaware of support for processor rooted s-ctrm.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ept violations may report bits 11:0 of guest linear address incorrectly										
problem	if a memory access to a linear address requires the processor to update an accessed or dirty flag in a paging-structure entry and if that update causes an ept violation, the processor should store the linear address into the “guest linear address” field in the vmcs. due to this erratum, the processor may store an incorrect value into bits 11:0 of this field. (the processor correctly stores the guest-physical address of the paging- structure entry into the “guest-physical address” field in the vmcs.)										
implication	software may not be easily able to determine the page offset of the original memory access that caused the ept violation. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	software requiring the page offset of the original memory access address can derive it by simulating the effective address computation of the instruction that caused the ept violation.										
											
title	apic timer might not signal an interrupt while in tsc-deadline mode										
problem	if the apic timer is in tsc-deadline mode and is armed when a timed mwait instruction is executed, the timer expiration might not cause an interrupt.										
implication	software depending on apic timer tsc-deadline mode interrupts may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding										
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9:1 report the highest index value used for any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9:1] to read and write all vmcs fields may omit one field.										
workaround	none identified.										
											
title	incorrect from_ip value for an rtm abort in btm or bts may be observed										
problem	during rtm (restricted transactional memory) operation when branch tracing is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.										
implication	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.										
workaround	none identified.										
											
title	vt-d hardware may perform strp and sirtp operations on a package c7 exit										
problem	on a package c7 exit, vt-d hardware may spuriously perform srtp (set root table pointer) and sirtp (set interrupt remapping table pointer) operations. a package c7 exit can cause the value programmed by software in the rta_reg (irta_reg) to be visible to hardware before software executes a gcmd.srtp command. this will result in hardware using the new values for the dma and interrupt translation page-walks, possibly before they are intended to be used by software.										
implication	if software has updated the root table pointer but has not executed the srtp command then the root table pointer update will happen unexpectedly, causing the vmm to walk incorrect or non-existent tables. intel has not observed this erratum with any commercially available software.										
workaround	privileged software should not execute a mwait (because it can trigger a package c7 entry/exit) between writing to rta_reg (irta_reg) and gcmd_reg.srtp (gcmd_reg.sirtp) registers.										
											
title	general-purpose performance counters can unexpectedly increment										
problem	a performance monitor event programmed in a general-purpose performance counter should count the number of occurrences of the event selected in ia32_perfevtsel{0- 7} msr (186h-18dh). if inv (invert, bit 23) is set to 1 and a non-zero cmask (counter mask) bits [31:24] value is used, due to this erratum, the event may over count in the case that either of os (operating system mode, bit 17) or usr (user mode, bit 16) is selected. over counting will occur for the cycles spent in the non- matching cpl.										
implication	general-purpose performance counters may reflect counts higher than the actual number of events when the inv bit is set, cmask is a non-zero value and either the os or usr bit is set.										
workaround	none identified.										
											
title	performance monitoring events may report incorrect number of load hits or misses to llc										
problem	the following performance monitor events should count the numbers of loads hitting or missing llc. however due to this erratum, the l3_hit related events may over count and the l3_miss related events may undercount. mem_load_retired.l3_hit (event d1h, umask 40h) mem_load_retired.l3_miss (event d1h, umask 20h) mem_load_l3_hit_retired. xsnp_none (event d2h, umask 08h) mem_load_llc_miss_retired. local_dram (event d3h, umask 01h)										
implication	the listed performance monitoring events may be inaccurate.										
workaround	none identified.										
											
title	locked load performance monitoring events may under count										
problem	the performance monitoring events mem_trans_retired.load_latency (event cdh; umask 01h), mem_load_retired.l2_hit (event d1h; umask 02h), and mem_uops_retired.locked (event doh; umask 20h) should count the number of locked loads. due to this erratum, these events may under count for locked transactions that hit the l2 cache.										
implication	the above event count will under count on locked loads hitting the l2 cache.										
workaround	none identified.										
											
title											
problem	if ratio or c-state changes involving the processor core and processor graphics occur at the same time or while processor graphics are active, under certain internal conditions the ratio change may not complete.										
implication	the system may hang during c-state or ratio changes.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain performance monitoring events may over count software demand loads										
problem	the following performance monitor events should count the number of software demand loads. however due to this erratum, they may also include requests from the next page prefetcher and over count. offcore_requests_outstanding.demand_data (event 60h; umask 01h) offcore_requests.demand_data (event b0h; umask 01h) cycle_activity.l2_pending (event a3h; umask 01h) l2_hit_miss.load (event 24h; umask 01h)										
implication	the listed performance monitoring events may reflect a count higher than the actual number of events.										
workaround	none identified.										
											
title	accessing nonexistent uncore performance monitoring msrs may not signal a #gp										
problem	an access to an uncore performance monitor msr beyond the number reported in the msr_unc_cbo_config msr (396h) bits[3:0] should signal a #gp (general- protection exception); due to this erratum, the processor may hang instead of signaling #gp.										
implication	when software accesses nonexistent uncore performance monitoring msrs, the logical processor may hang instead of signaling a #gp.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	call stack profiling may produce extra call records										
problem	the performance monitoring call stack profiling function should not generate call records for “zero length calls” (call instructions targeting the location following the instruction). however, due to this erratum, the processor will produce call records for zero length calls.										
implication	the performance monitoring lbr call stack msrs are incorrect in the presence of “zero length calls” because calls and returns do not match.										
workaround	none identified.										
											
title	warm reset may fail or lead to incorrect power regulation										
problem	due to this erratum, after a warm reset, the processor may fail to boot properly or may cause power to be regulated to an incorrect level.										
implication	the processor may not be able to control the vr (voltage regulator) to advertised specifications, leading to in a system hang, a machine check, or improper power regulation.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* host bridge did may be incorrect										
problem	the pcie host bridge did register (bus 0; device 0; function 0; offset 2h) contents may be incorrect.										
implication	software that depends on the host bridge did value may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	transactional abort may produce an incorrect branch record										
problem	if an intel® tsx transactional abort event occurs during a string instruction, the from- ip in the lbr (last branch record) is not correctly reported.										
implication	due to this erratum, an incorrect from-ip on the lbr stack may be observed.										
workaround	none identified.										
											
title	smram state-save area above the 4gb boundary may cause unpredictable system behavior										
problem	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	ensure that the smram state-save area is located entirely below the 4gb address boundary.										
											
title	dma remapping faults for the graphics vt-d unit may not properly report type of faulted request										
problem	when a fault occurs during dma remapping of graphics accesses at the graphics vt-d unit, the type of faulted request (read or write) should be reported in bit 126 of the frcd_reg register in the remapping hardware memory map register set. due to this erratum, the request type may not be reported correctly.										
implication	software processing the dma remapping faults may not be able to determine the type of faulting graphics device dma request.										
workaround	none identified.										
											
title	avx gather instructions page faults may report an incorrect faulting address										
problem	if software modifies a paging-structure entry to relax the access rights for a linear address and does not perform a tlb invalidation, a subsequent execution of an avx gather instruction that accesses that address may generate a page fault that loads cr2 (which should containing the faulting linear address) with an incorrect value.										
implication	software handling an affected page fault may not operate correctly.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	event injection by vm entry may use an incorrect b flag for ss										
problem	the stack accesses made by vm-entry event injection may use an incorrect value for the b flag (default stack-pointer size and upper bound) for the stack segment (ss).										
implication	an affected stack access may use an incorrect address or an incorrect segment upper bound. this may result in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a fault in smm may result in unpredictable system behavior										
problem	the value of the ss register as well as the current privilege level (cpl) may be incorrect following a fault in smm (system-management mode). the erratum can occur only if a fault occurs following an smi (system-management interrupt) and before software has loaded the ss register (e.g., with the mov ss instruction).										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	processor frequency is unexpectedly limited below nominal p1 when ctdp down is enabled										
problem	when ctdp (configurable thermal design power) down is enabled on a processor branded as core® i3 or pentium®, the processor frequency will be limited to ctdp down p1 frequency (max non-turbo frequency) when it should be able to operate between the ctdp down frequency p1 and the nominal p1 frequency.										
implication	when ctdp is enabled, the processor cannot achieve expected frequencies.										
workaround	none identified.										
											
title	pmi may be signaled more than once for performance monitor counter overflow										
problem	due to this erratum, pmi (performance monitoring interrupt) may be repeatedly issued until the counter overflow bit is cleared in the overflowing counter.										
implication	multiple pmis may be received when a performance monitor counter overflows.										
workaround	none identified. if the pmi is programmed to generate an nmi, software may delay the										
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not- available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	rdrand execution in a transactional region may cause a system hang										
problem	execution of the rdrand (random number generator) instruction inside an intel® tsx transactional region may cause the logical processor to hang.										
implication	a system hang may occur as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	uncore clock frequency changes may cause audio/video glitches										
problem	on some processors, the time required to change the uncore clock frequency may be large enough to significantly lengthen the latency of i/o requests to memory, possibly resulting in audio or video glitches.										
implication	audio/video glitches may occur during uncore ratio changes.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor may experience a spurious llc-related machine check during periods of high activity										
problem	due to certain internal conditions while running core and memory intensive operations, some processors may incorrectly report an llc (last level cache) related machine check with a ia32_mci_status.mcacod value of 110ah.										
implication	due to this erratum, the processor may experience a machine check.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the processor may not enter package c7 when using a psr display										
problem	the processor datasheet specifies that entering package c7 requires enabling psr (panel self refresh) for certain display resolutions, along with other conditions. due to this erratum, the processor may not enter package c7 when connected to a psr- enabled display even if all of the required conditions are met.										
implication	due to this erratum, the processor may not enter package c7.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	video/audio distortion may occur										
problem	due to this erratum, internal processor operations can occasionally delay the completion of memory read requests enough to cause video or audio streaming underrun.										
implication	visible artifacts such as flickering on a video device or glitches on audio may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	system may hang when audio is enabled during package c3										
problem	when audio is enabled while in package c3 state or deeper, audio memory traffic continues to be generated. due to this erratum, the processor logic required for memory traffic may be powered down.										
implication	when this erratum occurs, the processor logic required for audio memory traffic may not be operational resulting in a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	invpcid may not cause #ud in vmx non-root operation										
problem	the invpcid instruction should cause an invalid opcode exception (#ud) in vmx non- root operation if either bit 31 of the primary processor-based vm-execution controls (activate secondary controls) or bit 12 of the secondary processor-based vm-execution controls (enable invpcid) is 0. due to this erratum, the invpcid instruction will not cause #ud if “activate secondary controls” is 0 and “enable invpcid” is 1. instead, the instruction will either execute normally or cause a vm exit if the “invlpg exiting” vm- execution control is 1.										
implication	the processor may cause a vm exit that software does not expect. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	non-compliant pfat module base address may cause unpredictable system behavior										
problem	pfat (platform firmware armoring technology) requires the pfat module base address be 256kb aligned and reside in the first 4gb of memory. if bios does not comply with these requirements when setting up the pfat module, the processor should gp# at pfat launch. due to this erratum, a #gp fault may not be generated.										
implication	a pfat module that does not follow the pfat module base address requirements may result in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this issue.										
											
title	incorrect lbr source address may be reported for a transactional abort										
problem	if the fetch of an instruction in a transactional region causes a fault, a transactional abort occurs. if lbrs are enabled, the source address recorded for such a transactional abort is the address of the instruction being fetched. if that instruction was itself the target of an earlier branch instruction, this erratum may erroneously record the address of the branch instruction as the source address for the transactional abort.										
implication	trace reconstruction software that uses lbr information may fail when this erratum occurs.										
workaround	none identified.										
											
title	address translation faults for intel® vt-d may not be reported for display engine memory accesses										
problem	the intel® vt-d (intel® virtualization technology for directed i/o) hardware unit supporting the processor graphics device (bus 0; device 2; function 0) may not report address translation faults detected on display engine memory accesses when the context cache is disabled or during time periods when context cache is being invalidated.										
implication	due to this erratum, display engine accesses that fault are correctly aborted but may not be reported in the fsts_reg fault reporting register (gfxvtdbar offset 034h).										
workaround	none identified.										
											
title	l3 cache corrected error count may be inaccurate after package c7 exit										
problem	the corrected error count for l3 cache errors reported in ia32_mci_status.corrected error count (bits [52:38]) with an mcacod of 0001 0001 xxxx xxxx (x can be 0 or 1) may be incorrectly restored to a smaller value during exit from package c7.										
implication	the corrected error count for l3 cache errors in ia32_mci_status may be inaccurate after package c7 exit.										
workaround	none identified.										
											
title	pcie* device’s svid is not preserved across the package c7 c-state										
problem	bus 0, device 7, function 0’s svid register (subsystem vendor identification, offset 2ch) is not preserved across package c7 c-state transitions.										
implication	this may cause the operating system to think the device has been replaced with a different device.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	warm reset does not stop gt power draw										
problem	due to this erratum, if gt is enabled prior to a warm reset, it will remain powered after the warm reset. the processor will make incorrect power management decisions because it assumes the gt is not drawing power after a warm reset.										
implication	the processor may draw more current than expected from an external vr (voltage regulator). the processor may also put the external vr into a low power state where it will be unable to supply the sufficient power resulting in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	unused pcie* lanes may remain powered after package c7										
problem	if a pcie controller is enabled and either has unused lanes or no pcie device is present, the link and/or unused lanes should enter a low power state. due to this erratum, after exiting package c7, the unused link and/or unused lanes may remain powered.										
implication	power consumption may be greater than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	bmi1 and bmi2 instruction groups are not available										
problem	feature flags bmi1 and bmi2 (cpuid leaf 7, sub-leaf 0, ebx bits 3 and 8) report these two groups of bit manipulation instructions are not present for theintel® core™ i3- 4330te these instruction groups should be available. an attempt to execute any of these instructions will generate a #ud fault.										
implication	software attempting to use any of instructions in the bmi1 and bmi2 groups will result in a #ud fault										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	virtual-apic page accesses with 32-bit pae paging may cause a system crash										
problem	if a logical processor has ept (extended page tables) enabled, is using 32-bit pae paging, and accesses the virtual-apic page then a complex sequence of internal processor micro-architectural events may cause an incorrect address translation or machine check on either logical processor.										
implication	this erratum may result in unexpected faults, an uncorrectable tlb error logged in ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_0000_0001_xxxxb (where x stands for 0 or 1), a guest or hypervisor crash, or other unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor energy policy selection may not work as expected										
problem	when the ia32_energy_perf_bias msr (1b0h) is set to a value of 4 or more, the processor will try to increase the energy efficiency of turbo mode. however, this functionality is effectively disabled if the software requested p-state exceeds the maximum p-state supported by the processor. this has the effect of decreasing the energy efficiency of the processor while in turbo mode.										
implication	when this erratum occurs, reduced battery life and reduced energy efficiency may occur.										
workaround	bios should set the max acpi _pst object to the max supported turbo ratio, ensuring that the software p-state request does not exceed the maximum ratio supported by the processor. note that this workaround will disable core ratio overclocking.										
											
title	a pebs record may contain processor state for an unexpected instruction										
problem	if a performance counter has overflowed and is configured for pebs (precise event- based sampling), the processor will arm the pebs hardware within a bounded number of cycles called the skid (see the discussion of skid and related topics in the precise distribution of instructions retired section of the intel® 64 and ia-32 architectures software developer manual). once the pebs hardware is armed, the processor should capture processor state in a pebs record following the execution of the next instruction that causes the counter to increment (a “triggering” instruction). due to this erratum, the capture of processor state may occur at an instruction after the first triggering instruction following the skid but not beyond the second triggering instruction after the skid.										
implication	a pebs record may contain processor state (including instruction pointer) not associated with the triggering instruction.										
workaround	none identified.										
											
title	msr_pp1_energy_status reports incorrect energy data										
problem	the msr_pp1_energy_status msr (641h) bits [31:0] reports incorrect energy data.										
implication	due to this erratum, reported intel integrated graphics domain energy consumption may not be accurate.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	x87 fpu dp may be incorrect after instructions that save fp state to memory										
problem	under certain conditions, the value of the x87 fpu dp (floating point unit data pointer) saved by the fsave/fnsave, fstenv/fnstenv, fxsave, xsave, or xsaveopt instructions may be incorrect.										
implication	due to this erratum, the x87 fpu dp may be incorrect.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor may hang during package c7 exit										
problem	under certain internal timing conditions, the processor might not properly exit package c7 leading to a hang.										
implication	due to this erratum, the package c7 state may not be reliable. intel has not observed this erratum with any commercially available system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	spurious llc machine check may occur										
problem	under certain stressful conditions while running at ring ratios higher than 30, the processor may experience a spurious llc machine check as indicated by ia32_mci_status.mcacod (bits [15:0]) with value 000x 0001 0000 1010 (where x is 0 or 1).										
implication	when this erratum occurs, an uncorrectable llc error will be logged and the system may hang or restart.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	page fault may report incorrect fault information										
problem	under the following conditions: a read-modify-write instruction’s memory source/destination (e.g., add memory, reg) crossing a cache line boundary. that instruction executing without fault. while the read-modify-write instruction is executing, one or more of the following page table attributes associated with its memory operand are modified: the d (dirty) flag was 0 when the instruction was initiated but was concurrently set to 1, and/or one of the relevant r/w flags was 0 when the instruction was initiated but was concurrently set to 1, and/or if the read-modify-write instruction executes at cpl = 3 and one of the relevant u/s flags was 0 when the instruction was initiated but was concurrently set to 1. a subsequent instruction executing within a narrow timing window that experiences a page fault. there is no serializing instruction between the read-modify-write instruction and the faulting instruction.  the page fault (in #4) may report an incorrect error code and faulting linear address; these would describe the read-modify-write instruction’s memory access instead of that of the faulting instruction. (the address of the faulting instruction is reported correctly.)										
implication	the erratum makes it appear that the page fault resulted from an access that occurred prior to the faulting instruction. because the earlier access completed without faulting, a page-fault handler may identify the page fault as transient (or spurious) and re- execute the faulting instruction (e.g., by executing iret). in such cases, the erratum will not recur; the page fault on the later access will recur and will be reported correctly. if the page-fault handler does not re-execute the faulting instruction, this erratum may result in unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	caterr# pin assertion is not cleared on a warm reset										
problem	if the caterr# pin is held asserted to indicate a fatal error, a subsequent warm reset event will not cause the caterr# pin to de-assert.										
implication	when this erratum occurs, platforms that monitor the caterr# pin may be unable to detect a fatal error after a warm reset or may incorrectly respond to a caterr# pin assertion although an error may not have occurred subsequent to the warm reset event.										
workaround	the caterr# pin can be de-asserted by a cold reset event.										
											
title	uncorrectable machine check error during core c6 entry may not be signaled										
problem	machine check exceptions occurring during core c6 entry may be ignored.										
implication	when this erratum occurs, incorrect state may be saved during core c6 entry and subsequently restored during core c6 exit resulting in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the sample/preload jtag command does not sample the display transmit signals										
problem	the display transmit signals are not correctly sampled by the sample/preload jtag command, violating the boundary scan specification (ieee 1149.1).										
implication	the sample/preload command cannot be used to sample display transmit signals.										
workaround	none identified.										
											
title	performance monitor event for outstanding offcore requests and snoop requests may be incorrect										
problem	the performance monitor event offcore_requests_outstanding (event 60h, any umask value) should count the number of offcore outstanding transactions each cycle. due to this erratum, the counts may be higher or lower than expected.										
implication	the performance monitor event offcore_requests_outstanding may reflect an incorrect count.										
workaround	none identified.										
											
title	processor energy policy selection may not work as expected										
problem	when the ia32_energy_perf_bias msr (1b0h) is set to a value of 4 or more, the processor will try to increase the energy efficiency of turbo mode. however, this functionality is effectively disabled if the software requested p-state exceeds the maximum p-state supported by the processer.										
implication	when this erratum occurs, the energy efficiency control may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie link may incorrectly train to 8.0 gt/s										
problem	during pcie* 8.0 gt/s phase 2 equalization training, the received per-lane transmitter coefficients for physical lanes 8-15 may be incorrectly applied to the pcie transmitters.										
implication	due to this erratum, a pcie link may either fail to train to the 8.0 gt/s transfer speed, experience link errors, or periodically retrain (possibly dropping to a lower link speed).										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie tx voltage reference cannot be changed										
problem	pcie* tx voltage reference select is available via the pcie_cr_afebnd[0:7]cfg1 (device 1; function 0) registers in field txvrefsel bits [9:5]. due to this erratum, changes to these values will have no effect.										
implication	for pcie, setting the tx voltage reference select to non-default values will not produce the reference levels documented in the register description. tx swing control utilizes tx voltage reference; tx swing cannot be adjusted from default.										
workaround	none identified.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	re-enabling edram may log a machine check and hang										
problem	if the edram was disabled as a result of a package c-state entry of c2 or higher or a software request, the subsequent package c-state exit or software request to re-enable edram may result in a machine check logged in ia32_mci_status.mcacod [15:0] with of value 402h and subsequent system hang.										
implication	due to this erratum, the system may log a machine check and hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	warm reset does not stop edram power draw										
problem	due to this erratum, if edram is enabled prior to a warm reset, it will remain powered after the warm reset. the processor will make incorrect power management decisions because it assumes the edram is not drawing power after a warm reset.										
implication	the processor may draw more current than expected from an external vr (voltage regulator). the processor may also put the external vr into a low power state where it will be unable to supply the sufficient power resulting in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	opcode bytes f3 0f bc may execute as tzcnt even when tzcnt not enumerated by cpuid										
problem	if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 then opcode bytes f3 0f bc should be interpreted as tzcnt otherwise they will be interpreted as rep bsf. due to this erratum, opcode bytes f3 0f bc may execute as tzcnt even if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 0.										
implication	software that expects rep prefix before a bsf instruction to be ignored may not operate correctly since there are cases in which bsf and tzcnt differ with regard to the flags that are set and how the destination operand is established.										
workaround	software should use the opcode bytes f3 0f bc only if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 and only if the functionality of tzcnt (and not bsf) is desired.										
											
title	intel® s2ddt may not function correctly with certain high resolution displays										
problem	a limitation in intel s2ddt (intel® smart 2d display technology), commonly known as frame buffer compression, may result in pixel data being supplied too slowly to the display.										
implication	screen flickering or blank screen may be observed on certain high resolution displays.										
workaround	the latest version of the intel graphics driver disables intel s2ddt for resolutions with a pixel clock between 513 mhz and 540 mhz.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	spurious corrected errors may be reported										
problem	due this erratum, spurious corrected errors may be logged in the ia32_mc0_status register with the valid field (bit 63) set, the uncorrected error field (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.										
implication	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.										
workaround	none identified.										
											
title	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation										
problem	if ept (extended page tables) is enabled, a mov to cr3 or vmfunc may be followed by an unexpected page fault or the use of an incorrect page translation.										
implication	guest software may crash or experience unpredictable behavior as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package c7 power consumption has been observed to be higher than package c6										
problem	package c7 power consumption may be higher than package c6 power consumption.										
implication	when this erratum occurs, power consumption will be higher than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum which demotes										
											
title	a hyperthreading™ enabled processor may exhibit unpredictable behavior during power or thermal management operations										
problem	when both logical processors in a core are idled due to power or thermal management operations such as thermal events or c-state entry, under certain circumstances, instruction fetches initiated before entering the idle state may not complete correctly, resulting in unpredictable system behavior.										
implication	due to this erratum, the processor may exhibit unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain perfmon events may be counted incorrectly when the processor is not in c0 state										
problem	due to this erratum, the perfmon events listed below may be counted when the logical processor is not in c0 state. idq.empty (event code 0x79 and umask 0x02) idq_uops_not_delivered.core (event code 0x9c and umask 0x01) resource_stalls.any (event core 0xa2 umask 0x01) cycle_activity.cycles_ldm_pending (event a3h, umask 02h, cmask 02h) cycle_activity.cycles_no_execute (event a3h, umask 04h, cmask 04h) cycle_activity.stalls_ldm_pending (event a3h, umask 06h, cmask 06h)										
implication	the count will be higher than expected.										
workaround	none identified.										
											
title	software using intel® tsx may result in unpredictable system behavior										
problem	under a complex set of internal timing conditions and system events, software using the intel tsx (transactional synchronization extensions) instructions may result in unpredictable system behavior.										
implication	this erratum may result in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	if the vr (voltage regulator) reports a high temperature condition, the processor will limit the ratio on all domains (core/graphics/ring) to their respective maximum non- turbo ratios. when the thermal condition is no longer present, it’s expected that the processor should release this constraint and allow the domains operate in their turbo region. due to this erratum, if the thermal event ends when the processor is in package c6 or deeper, the constraint will not be removed.										
implication	the processor will not operate at the highest available frequencies and will have a negative impact on performance. this constraint on the ratios are cleared upon a warm or cold reset.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	running all cores may incorrectly limit the processor frequency										
problem	when all ia cores in the processor are running but not executing avx instructions and the processor is not constrained by pl1/pl2 power limits or thermal limits, the cores should be able to operate at the 4c turbo frequency. due to this erratum, the processor may limit core frequency under these conditions as much as several bins below the 4c turbo frequency.										
implication	when this erratum occurs, the processor will not meet specified performance levels.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	concurrent core and graphics operation at turbo ratios may lead to system hang										
problem	workloads that attempt concurrent operation of cores and graphics in their respective turbo ranges, under certain conditions may result in a system hang.										
implication	concurrent core and graphics operation may hang the system										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitor instructions retired event may not count consistently										
problem	performance monitor instructions retired (event c0h; umask 00h) and the instruction retired fixed counter (ia32_fixed_ctr0 msr (309h)) are used to track the number of instructions retired. due to this erratum, certain situations may cause the counter(s) to increment when no instruction has retired or to not increment when specific instructions have retired.										
implication	a performance counter counting instructions retired may over or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	some configurations may violate embedded dram refresh requirements leading to a system hang										
problem	due to this erratum, embedded dram refresh requirements may be violated for some configurations leading to memory errors.										
implication	when this erratum occurs, the resulting memory errors may cause a system shutdown or hang.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	interactions between multiple unaligned memory accesses and locked instructions may lead to a machine check										
problem	under a complex set of conditions, interactions between multiple locked operations sharing certain low order address bits and data accesses that span a 4-kbyte boundary may result in a processor internal timeout machine check (ia32_mci_status.mcacod = 0x0400).										
implication	due to this erratum, the processor may signal a machine check exception. intel has not observed this erratum with any commercially available system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	fixed-function performance counter may over count instructions retired by 32 when intel® hyper-threading technology is enabled										
problem	if, while intel hyper-threading technology is enabled, the ia32_fixed_ctr0 msr (309h) is enabled by setting bits 0 and/or 1 in the ia32_perf_fixed_ctr_ctrl msr (38dh) before setting bit 32 in the ia32_perf_global_ctrl msr (38fh) then ia32_fixed_ctr0 may over count by up to 32.										
implication	when this erratum occurs, the fixed-function performance counter ia32_fixed_ctr0 may over count by up to 32.										
workaround	the following sequence avoids this erratum (steps 1 and 2 are needed if the counter was previously enabled):										
											
title	performance monitor uops_executed event may be inaccurate when using intel® hyper-threading technology										
problem	the performance monitor event uops_executed (event b1h, umask 01h) counts the number of uops executed each cycle. however, due to this erratum, when using intel hyper-threading technology, the uops may not be assigned to the correct logical processor.										
implication	the total number of uops executed by a core will be counted correctly but the division of uops between its logical processors may be incorrect.										
workaround	none identified.										
											
title	operand-size override prefix causes 64-bit operand form of movbe instruction to cause a #ud										
problem	execution of a 64 bit operand movbe instruction with an operand-size override instruction prefix (66h) may incorrectly cause an invalid-opcode exception (#ud).										
implication	a movbe instruction with both rex.w=1 and a 66h prefix will unexpectedly cause an invalid-opcode exception (#ud). intel has not observed this erratum with any commercially available software										
workaround	do not use a 66h instruction prefix with a 64-bit operand movbe instruction.										
											
title	popcnt instruction may take longer to execute than expected										
problem	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.										
implication	software using the popcnt instruction may experience lower performance than expected.										
workaround	none identified.										
											
title	unpredictable operation at turbo frequencies above 4.0 ghz										
problem	machine check errors, system hangs or other unpredictable system behavior may occur when operating at turbo frequencies above 4.0 ghz.										
implication	the processor may signal machine check errors, hang, or exhibit other unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	system may hang or video may be distorted after graphics rc6 exit										
problem	in a specific scenario, when the processor graphics exits rc6 and a processor core exits c6 at the same time, the system may become unresponsive or the video may become distorted.										
implication	the system may hang or video may be distorted.										
workaround	none identified.										
											
title	certain edp* displays may not function as expected										
problem	when the processor attempts to receive data on the edp aux bus, the impedance seen by the display’s aux bus drivers will be significantly below the vesa* edp (embedded displayport*) specification’s requirement for the vaux(rx) (edp auxiliary channel) input impedance.										
implication	certain edp displays may not operate as expected.										
workaround	none identified.										
											
title	some offcore_response performance monitoring events may undercount										
problem	the performance monitoring events offcore_response (events b7h and bbh) should count uncore responses matching the request-response configuration specified in msr_offcore_rsps (1a6h and 1a7h, respectively) for core-originated requests. however due to this erratum, corewb (bit 3), pf_l3_data_rd (bit 7), pf_l3_rfo (bit 8), pr_l3_code_rd (bit 9), split_lock_uc_lock (bit 10), and streaming_stores (bit 11) request types may undercount.										
implication	these performance monitoring events may not produce reliable results for the listed request types.										
workaround	none identified.										
											
title	certain settings of vm-execution controls may result in incorrect linear-address translations										
problem	if vm exit occurs from a guest with primary processor-based vm-execution control “activate secondary controls” set to 0 and the secondary processor-based vm- execution control “enable vpid” set to 1, then after a later vm entry with vpid fully enabled (“activate secondary controls” and “enable vpid” set to 1), the processor may use stale linear address translations.										
implication	the processor may incorrectly translate linear addresses. intel has not observed this erratum with any commercially available software.										
workaround	software should not enter a guest with “enable vpid” set to 1 when “activate secondary controls” is set to 0.										
											
title	an iret instruction that results in a task switch does not serialize the processor										
problem	an iret instruction that results in a task switch by returning from a nested task does not serialize the processor (contrary to the software developer’s manual vol. 3 section titled “serializing instructions”).										
implication	software which depends on the serialization property of iret during task switching may not behave as expected. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	none identified. software can execute an mfence instruction immediately prior to the iret instruction if serialization is needed.										
											
title	attempting to disable turbo mode may cause a #gp										
problem	bit 38 of ia32_misc_enable msr (1a0h) is turbo mode disable on processors that support intel® dynamic acceleration. due to this erratum, that bit may be incorrectly treated as reserved; attempting to set turbo mode disable results in a #gp (general protection exception) even when it reads as 1.										
implication	when this erratum occurs, a wrmsr to ia32_misc_enable unexpectedly causes a #gp.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	machine check threshold based error status may be set incorrectly										
problem	a corrected error may be logged in ia32_mci_status with the threshold based error field (bits[54:53]) indicating yellow status (10b) although the part is not above the threshold.										
implication	this erratum may be associated with a cache hierarchy error reported in the compound error code (bits[15:0]) of ia32_mci_status in the form 000f 0001 rrrr ttll where ll is 11 and there are valid values for the other sub-fields (f, rrrr, and tt).										
workaround	none identified. a power-on reset of the processor will clear the yellow bit indication. if, during system operation after that reset, yellow status is signaled again then it should be treated as a valid yellow status condition.										
											
title	peci frequency limited to 1 mhz										
problem	the peci (platform environmental control interface) 3.1 specification’s operating frequency range is 0.2 mhz to 2 mhz. due to this erratum, peci may be unreliable when operated above 1 mhz.										
implication	platforms attempting to run peci above 1 mhz may not behave as expected.										
workaround	none identified. platforms should limit peci operating frequency to 1 mhz.										
											
title	vgatherqps that loads an element from the apic-access page may load other elements from incorrect addresses										
problem	if the “virtualize apic accesses” vm-execution control is 1, a 256-bit vgatherqps with an element that maps to the apic-access page may use incorrect addresses to load other elements.										
implication	loading from an incorrect address can result in unexpected behavior with respect to data, faults or vm exits. this erratum will occur only if a guest operating system attempts to access the apic using the vgatherqps instruction. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	mtf vm exit on xbegin instruction may save state incorrectly										
problem	execution of an xbegin instruction while the "monitor trap flag" vm-execution control is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save the address of the xbegin instruction as the instruction pointer (instead of the fallback instruction address specified by the xbegin instruction). in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.										
implication	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.										
workaround	none identified										
											
title	uncore performance monitoring counters may be disabled or cleared after package c7										
problem	upon exiting package c7, the following uncore performance monitoring msrs may be cleared to zero: msr_ unc _perf_global_ctrl (391h) msr_ unc _perf_global_status (392h) msr_ unc _perf_fixed_ctrl (394h) msr_ unc _perf_fixed_ctr (395h)										
implication	uncore performance monitoring counters may be disabled and some counter state may be cleared after package c7.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pebs record may be generated after being disabled										
problem	a performance monitoring counter may generate a pebs (precise event based sampling) record after disabling pebs or the performance monitoring counter by clearing the corresponding enable bit in ia32_pebs_enable msr (3f1h) or ia32_perf_global_ctrl msr (38fh).										
implication	a pebs record generated after a vmx transition will store into memory according to the post-transition ds (debug store) configuration. these stores may be unexpected if pebs is not enabled following the transition.										
workaround	it is possible for the bios to contain a workaround for this erratum. a software workaround is possible through disallowing pebs during vmx non-root operation and disabling pebs prior to vm entry.										
											
title	pcie* ports do not support dll link active reporting										
problem	the pcie base specification requires every “downstream port that supports link speeds greater than 5.0 gt/s" to support dll (data link layer) link active reporting, however, the pcie ports do not support dll link active reporting.										
implication	due to this erratum, the pcie ports do not support dll link active reporting. this may be reported by a pcie compliance test.										
workaround	none identified.										
											
title	pcie* link speed negotiation may fail after link is re-enabled										
problem	if a pcie link is established then disabled and the link partner's advertised speeds are changed while the link is disabled, the link may fail to correctly negotiate link speed when it is re-enabled.										
implication	due to this erratum, the pcie link speed negotiation may fail after re-enabling a disabled port.										
workaround	none identified.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	data breakpoint coincident with a machine check exception may be lost										
problem	if a data breakpoint occurs coincident with a machine check exception, then the data breakpoint may be lost.										
implication	due to this erratum, a valid data breakpoint may be lost.										
workaround	none identified.										
											
title	a corrected internal parity error may result in a system hang										
problem	a corrected internal parity error (ia32_mc0_status.mcacod=0005h and ia32_mc0_status.mscod=000fh, msr 401h bits [15:0] and bits [31:16] respectively) may cause a system hang.										
implication	due to this erratum, a corrected internal parity error may cause a system hang. reset, smi, or init will end the system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	an apic timer interrupt during core c6 entry may be lost										
problem	due to this erratum, an apic timer interrupt coincident with the core entering c6 state may be lost rather than held for servicing later.										
implication	a lost apic timer interrupt may lead to missed deadlines or a system hang.										
workaround	none identified.										
											
title	internal power state transitions may cause the graphics device to hang										
problem	on certain processors, when the graphics device transitions among active power states in response to dynamic power demand, the graphics device may become unresponsive.										
implication	when this erratum occurs, the graphics device may hang, resulting in a frozen or blank display. the graphics driver may be able to restart the graphics device.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	pebs eventingip field may be incorrect under certain conditions										
problem	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.										
implication	when this erratum occurs, performance monitoring software may not attribute the pebs events to the correct instruction.										
workaround	none identified.										
											
title	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts										
problem											
implication											
workaround											
											
title											
problem											
implication	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.										
workaround	software should always prevent faults on pebs or bts.										
											
title	some memory performance monitoring events may produce incorrect results when filtering on either os or usr modes										
problem	the memory at-retirement performance monitoring events (listed below) may produce incorrect results when a performance counter is configured in os-only or usr-only modes (bits 17 or 16 in ia32_perfevtselx msr). counters with both os and usr bits set are not affected by this erratum.										
implication	the listed performance monitoring events may produce incorrect results including pebs records generated at an incorrect point.  the list of affected hsw memory at-retirement events is as follows: mem_uops_retired.stlb_miss_loads event d0h, umask 11h mem_uops_retired.stlb_miss_stores event d0h, umask 12h mem_uops_retired.lock_loads event d0h, umask 21h mem_uops_retired.split_loads event d0h, umask 41h mem_uops_retired.split_stores event d0h, umask 42h mem_load_uops_retired.l2_hit event d1h, umask 02h mem_load_uops_retired.l3_hit event d1h, umask 04h mem_load_uops_retired.l1_miss event d1h, umask 08h mem_load_uops_retired.l2_miss event d1h, umask 10h mem_load_uops_retired.l3_miss event d1h, umask 20h mem_load_uops_retired.hit_lfb event d1h, umask 40h mem_load_l3_hit_retired.xsnp_miss event d2h, umask 01h mem_load_l3_hit_retired.xsnp_hit event d2h, umask 02h mem_load_l3_hit_retired.xsnp_hitm event d2h, umask 04h mem_load_l3_hit_retired.xsnp_none event d2h, umask 08h mem_load_uops_l3_miss_retired.local_dram event d3h, umask 01h										
workaround	none identified.										
											
title	an x87 store instruction which pends #pe while ept is enabled may lead to an unexpected machine check and/or incorrect x87 state information										
problem	the execution of an x87 store instruction which causes a #pe (precision exception) to be pended and also causes a vm-exit due to an ept violation or misconfiguration may lead the vmm logging a machine check exception with a cache hierarchy error (ia32_mci_status.mcacod = 0150h and ia32_mci_status.mscod = 000fh). additionally, fsw.pe and fsw.es (bits 5 and 7 of the fpu status word) may be incorrectly set to 1, and the x87 last instruction opcode (fop) may be incorrect.										
implication	when this erratum occurs, the vmm may receive an expected machine check exception and software attempting to handle the #pe may not behave as expected.										
workaround	none identified.										
											
title	load latency performance monitoring facility may stop counting										
problem	the performance monitoring events mem_trans_retired.load_latency_* (event cdh; umask 01h; any latency) count load instructions whose latency exceed a predefined threshold, where the loads are randomly selected using the load latency facility (pebs extension). however due to this erratum, load latency facility may stop counting load instructions when intel® hyperthreading technology is enabled.										
implication	counters programmed with the affected events stop incrementing and do not generate pebs records.										
workaround	none identified.										
											
title	writing msr_lastbranch_x_from_ip may #gp when intel® tsx is not supported										
problem	due to this erratum, on processors that do not support intel tsx (intel® transactional synchronization extensions) (cpuid.07h.ebx bits 4 and 11 are both zero), writes to msr_lastbranch_x_from_ip (msr 680h to 68fh) may #gp unless bits [62:61] are equal to bit [47].										
implication	the value read from msr_lastbranch_x_from_ip is unaffected by this erratum; bits [62:61] contain in_tsx and tsx_abort information respectively. software restoring these msrs from saved values are subject to this erratum.										
workaround	before writing msr_lastbranch_x_from_ip, ensure the value being written has bit										
											
title	apic timer interrupt may not be generated at the correct time in tsc-deadline mode										
problem	after writing to the ia32_tsc_adjust msr (3bh), any subsequent write to the ia32_tsc_deadline msr (6e0h) may incorrectly process the desired deadline. when this erratum occurs, the resulting timer interrupt may be generated at the incorrect time.										
implication	when the local apic (advanced programmable interrupt controller) timer is configured for tsc-deadline mode, a timer interrupt may be generated much earlier than expected or much later than expected. intel has not observed this erratum with most commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record),   bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a  linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb)  error  can  incorrectly  set  the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an  accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title	monitor or clflush on the local xapic's address space results in hang										
problem	if the target linear address range for a monitor or clflush is mapped to the local xapic's address space, the processor will hang.										
implication	when this erratum occurs, the processor will hang. the local xapic's address space must be uncached. the monitor instruction only functions correctly if the specified linear address range is of the type write-back. clflush flushes data from the cache. intel has not observed this erratum with any commercially available software.										
workaround	do not execute monitor or clflush instructions on the local xapic address space.										
											
title	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang										
problem	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).										
implication	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.										
workaround	none identified.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	freeze_while_smm does not prevent event from pending pebs during smm										
problem	in general, a pebs record should be generated on the first count of the event after the counter has overflowed.  however,  ia32_debugctl_msr.freeze_while_smm  (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if 1.a performance counter overflowed before an smi 2.a pebs record has not yet been generated because another count of the event has not occurred 3.the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction.  when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.										
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.										
workaround	none identified.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error  status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	changing the memory type for an in-use page translation may lead to memory-ordering violations										
problem	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.										
implication	memory ordering may be violated. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure pages are not being actively used before requesting their memory type be changed.										
											
title	performance monitor precise instruction retired event may present wrong indications										
problem	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).										
implication	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.										
workaround	the sampling driver should avoid using sav<100.										
											
title	cr0.cd is ignored in vmx operation										
problem	if cr0.cd=1, the mtrrs and pat should be ignored and the uc memory type should be used for all memory accesses. due to this erratum, a logical processor in vmx operation will operate as if cr0.cd=0 even if that bit is set to 1.										
implication	algorithms that rely on cache disabling may not function properly in vmx operation.										
workaround	algorithms that rely on cache disabling should not be executed in vmx root operation.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	processor may fail to acknowledge a tlp request										
problem	when a pcie root port’s receiver is in receiver l0s power state and the port initiates a recovery event, it will issue training sets to the link partner. the link partner will respond by initiating an l0s exit sequence. prior to transmitting its own training sets, the link partner may transmit a tlp (transaction layer packet) request. due to this erratum, the root port may not acknowledge the tlp request.										
implication	after completing the recovery event, the pcie link partner will replay the tlp request. the link partner may set a correctable error status bit, which has no functional effect.										
workaround	none identified.										
											
title	interrupt from local apic timer may not be detectable while being delivered										
problem	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.										
implication	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.										
workaround	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.										
											
title	pcie* root-port initiated compliance state transmitter equalization settings may be incorrect										
problem	if the processor is directed to enter pcie polling.compliance at 5.0 gt/s or 8.0 gt/s transfer rates, it should use the link control 2 compliance preset/de-emphasis field (bits [15:12]) to determine the correct de-emphasis level. due to this erratum, when the processor is directed to enter polling.compliance from 2.5 gt/s transfer rate, it retains 2.5 gt/s de-emphasis values.										
implication	the processor may operate in polling.compliance mode with an incorrect transmitter de-emphasis level.										
workaround	none identified.										
											
title	pcie* controller may incorrectly log errors on transition to rxl0s										
problem	due to this erratum, if a link partner transitions to rxl0s state within 20 ns of entering l0 state, the pcie controller may incorrectly log an error in “correctable error status.receiver error status” field (bus 0, device 2, function 0, 1, 2 and device 6, function 0, offset 1d0h, bit 0).										
implication	correctable receiver errors may be incorrectly logged. intel has not observed any functional impact due to this erratum with any commercially available add-in cards.										
workaround	none identified.										
											
title	unused pcie* lanes may report correctable errors										
problem	due to this erratum, during pcie* link down configuration, unused lanes may report a correctable error detected in bus 0, device 1, function 0-2, and device 6, function 0, offset 158h, bit 0.										
implication	correctable errors may be reported by a pcie controller for unused lanes.										
workaround	none identified.										
											
title	pcie root port may not initiate link speed change										
problem	the pcie base specification requires the upstream component to maintain the pcie link at the target link speed or the highest speed supported by both components on the link, whichever is lower. pcie root port will not initiate the link speed change without being triggered by the software when the root port maximum link speed is configured to be 5.0 gt/s. system bios will trigger the link speed change under normal boot scenarios. however, bios is not involved in some scenarios such as link disable/re- enable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. this erratum does not affect the ability of the downstream component to initiate a link speed change. all known 5.0gb/s-capable pcie downstream components have been observed to initiate the link speed change without relying on the root port to do so.										
implication	due to this erratum, the pcie root port may not initiate a link speed change during some hardware scenarios causing the pcie link to operate at a lower than expected speed. intel has not observed this erratum with any commercially available platform.										
workaround	none identified.										
											
title	pending x87 fpu exceptions (#mf) may be signaled earlier than expected										
problem	x87 instructions that trigger #mf normally service interrupts before the #mf.  due to   this erratum, if an instruction that triggers #mf is executed while enhanced intel speedstep® technology transitions, intel® turbo boost technology transitions, or thermal monitor events occur, the pending #mf may be signaled before pending interrupts are serviced.										
implication	software may observe #mf being signaled before pending interrupts are serviced.										
workaround	none identified.										
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store or an mmx instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not  cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (i.e., following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	vex.l is not ignored with vcvt*2si instructions										
problem	the vex.l bit should be ignored for the vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions, however due to this erratum the vex.l bit is not ignored and will cause a #ud.										
implication	unexpected #uds will be seen when the vex.l bit is set to 1 with vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions.										
workaround	software should ensure that the vex.l bit is set to 0 for all scalar instructions.										
											
title	pcie* atomic transactions from two or more pcie controllers may cause starvation										
problem	on a processor pcie controller configuration in which two or more controllers receive concurrent atomic transactions, a pcie controller may experience starvation which eventually can lead to a completion timeout.										
implication	atomic transactions from two or more pcie controllers may lead to a completion timeout. atomic transactions from only one controller will not be affected by this erratum. intel has not observed this erratum with any commercially available device.										
workaround	none identified.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in  the  ia32_mc0_status  msr  (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	pcie* controller may initiate speed change while in dl_init state causing certain pcie devices to fail to train										
problem	the pcie controller supports hardware autonomous speed change capabilities. due to  this erratum, the pcie controller may initiate speed change while in the dl_init state which may prevent link training for certain pcie devices.										
implication	certain pcie devices may fail to complete dl_init causing the pcie link to fail to train.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	spurious vt-d interrupts may occur when the pfo bit is set										
problem	when the pfo (primary fault overflow) field (bit [0] in the vt-d fsts [fault status] register) is set to 1, further faults should not generate an interrupt. due to this erratum, further interrupts may still occur.										
implication	unexpected invalidation queue error interrupts may occur. intel has not observed this erratum with any commercially available software.										
workaround	software should be written to handle spurious vt-d fault interrupts.										
											
title	processor may livelock during on demand clock modulation										
problem	the processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the ia32_clock_modulation msr (19ah) and the clock modulation duty cycle is set to 12.5% (02h in bits 3:0 of the same msr), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access uc memory.										
implication	program execution may stall on both threads of the core subject to this erratum.										
workaround	this erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the ia32_clock_modulation msr is 18.75% or higher.										
											
title	internal parity errors may incorrectly report overflow in the ia32_mc2_status msr										
problem	due to this erratum, uncorrectable internal parity error reports with an ia32_mc2_status.mcacod (bits [15:0]) value of 0005h and an ia32_mc2_status.mscod (bits [31:16]) value of 0004h may incorrectly set the ia32_mc2_status.over flag (bit 62) indicating an overflow even when only a single error has been observed.										
implication	ia32_mc2_status.over may not accurately indicate multiple occurrences of uncorrectable internal parity errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	performance monitor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count										
problem	the performance monitor events other_assists.avx_to_sse (event c1h; umask   08h) and other_assists.sse_to_avx (event c1h; umask 10h) incorrectly increment and over count when an hle (hardware lock elision) abort occurs.										
implication	the	performance	monitor	events	other_assists.avx_to_sse	and other_assists.sse_to_avx may over count.					
workaround	none identified.										
											
title	performance monitor event dsb2mite_switches.count may over count										
problem	the performance monitor  event  dsb2mite_switches.count  (event  abh;  umask 01h) should count the number of dsb (decode stream buffer) to mite (macro instruction translation engine) switches. due to this erratum, the dsb2mite_switches.count event will count speculative switches and cause the count to be higher than expected.										
implication	the performance monitor event dsb2mite_switches.count may report count higher than expected.										
workaround	none identified.										
											
title	timed mwait may use deadline of a previous execution										
problem	a timed mwait instruction specifies a tsc deadline for execution resumption. if a wake event causes execution to resume before the deadline is reached, a subsequent timed mwait instruction may incorrectly use the deadline of the previous timed mwait when that previous deadline is earlier than the new one.										
implication	a timed mwait may end earlier than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding										
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9:1 report the highest index value used for  any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9:1] to read and write all vmcs fields may omit one field.										
workaround	none identified.										
											
title	incorrect from_ip value for an rtm abort in btm or bts may be observed										
problem	during rtm (restricted transactional memory)  operation  when  branch  tracing  is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.										
implication	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.										
workaround	none identified.										
											
title	locked load performance monitoring events may under count										
problem	the performance  monitoring  events  mem_trans_retired.load_latency  (event cdh; umask 01h), mem_load_retired.l2_hit (event d1h; umask 02h), and mem_uops_retired.locked (event doh; umask 20h) should count the number of locked loads. due to this erratum, these events may under count for locked transactions that hit the l2 cache.										
implication	the above event count will under count on locked loads hitting the l2 cache.										
workaround	none identified.										
											
title	transactional abort may produce an incorrect branch record										
problem	if an intel® tsx transactional abort event occurs during a string instruction, the from- ip in the lbr (last branch record) is not correctly reported.										
implication	due to this erratum, an incorrect from-ip on the lbr stack may be observed.										
workaround	none identified.										
											
title	smram state-save area above the 4gb boundary may cause unpredictable system behavior										
problem	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	ensure that the smram state-save area is located entirely below the 4gb address boundary.										
											
title	pmi may be signaled more than once for performance monitor counter overflow										
problem	due to this erratum, pmi (performance monitoring interrupt) may be repeatedly issued until the counter overflow bit is cleared in the overflowing counter.										
implication	multiple pmis may be received when a performance monitor counter overflows.										
workaround	none identified. if the pmi is programmed to generate an nmi, software may delay the										
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not- available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	intel® turbo boost technology may be incorrectly reported as supported on 5th generation intel® core™ i3 u-series, and select mobile intel® pentium® processors and mobile intel® celeron® processors										
problem	the 5th generation intel core™ i3 u-series, and select mobile intel pentium and intel celeron processors may incorrectly report support for intel turbo boost technology via cpuid.06h.eax bit 1.										
implication	the cpuid instruction may report turbo boost technology as supported even though the processor does not permit operation above the maximum non-turbo frequency.										
workaround	none identified.										
											
title	the sample/preload jtag command does not sample the display transmit signals										
problem	the display transmit signals are not correctly sampled by the sample/preload jtag command, violating the boundary scan specification (ieee 1149.1).										
implication	the sample/preload command cannot be used to sample display transmit signals.										
workaround	none identified.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it   should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled  by  the  ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	chap counter values may be cleared after package c7 or deeper c- state										
problem	the chap (chipset hardware architecture performance) counters which do not have a "start" opcode present in the cmd register will not be preserved across a package c7 or deeper c-state.										
implication	chap counter data is not saved/restored after package c7 or deeper c-state causing counts to be lost; actions based on those counts may not occur as expected.										
workaround	none identified.										
											
title	opcode bytes f3 0f bc may execute as tzcnt even when tzcnt not enumerated by cpuid										
problem	if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 then opcode bytes f3 0f bc should be interpreted as tzcnt otherwise they will be interpreted as rep bsf. due to this erratum, opcode bytes f3 0f bc may execute as tzcnt even if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 0.										
implication	software that expects rep prefix before a bsf instruction to be ignored may not operate correctly since there are cases in which bsf and tzcnt differ with regard to the flags that are set and how the destination operand is established.										
workaround	software should use the opcode bytes f3 0f bc only if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 and only if the functionality of tzcnt (and not bsf) is desired.										
											
title	back to back updates of the vt-d root table pointer may lead to an unexpected dma remapping fault										
problem	a vt-d  (intel®  virtualization technology  for directed i/o) root table  pointer update  that completes followed by a second root table pointer update that also completes, without performing a global invalidation of either the context-cache or the iotlb between the two updates, may lead to an unexpected dma remapping fault.										
implication	back to back root table pointer updates may cause an unexpected dma remapping fault. intel has not observed this erratum with any commercially available software.										
workaround	software must not perform a second root table pointer update before doing a global invalidation of either the context-cache or the iotlb.										
											
title	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation										
problem	if ept (extended page tables) is enabled, a mov to cr3 or vmfunc may be followed by an unexpected page fault or the use of an incorrect page translation.										
implication	guest software may crash or experience unpredictable behavior as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peer io device writes to the gmadr may lead to a system hang										
problem	the system may hang when a peer io device uses the peer aperture to directly write into the gmadr (graphics memory address range).										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	spurious corrected errors may be reported										
problem	due this erratum, spurious corrected errors may be logged in the ia32_mc0_status register with the valid field (bit 63) set, the uncorrected error field (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.										
implication	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.										
workaround	none identified.										
											
title	intel® pt packet generation may stop sooner than expected										
problem	setting the stop bit (bit 4) in a table of physical addresses entry directs the processor to stop intel pt (processor trace) packet generation when the associated output region is filled. the processor indicates this has occurred by setting the stopped bit (bit 5) of ia32_rtit_status msr (571h). due to this erratum, packet generation may stop earlier than expected.										
implication	when this erratum occurs, the outputoffset field (bits [62:32]) of the ia32_rtit_output_mask_ptrs msr (561h) holds a value that is less than the size of the output region which triggered the stop condition; intel pt analysis software should not attempt to decode packet data bytes beyond the outputoffset.										
workaround	none identified.										
											
title	pebs eventing ip field may be incorrect after not-taken branch										
problem	when a pebs (precise-event-based-sampling) record is logged immediately after a not-taken conditional branch (jcc instruction), the eventing ip field should contain the address of the first byte of the jcc instruction. due to this erratum, it may instead contain the address of the instruction preceding the jcc instruction.										
implication	performance monitoring software using pebs may incorrectly attribute pebs events that occur on a jcc to the preceding instruction.										
workaround	none identified.										
											
title	reading the memory destination of an instruction that begins an hle transaction may return the original value										
problem	an hle (hardware lock elision) transactional region begins with an instruction with the xacquire prefix. due to this erratum, reads from within the transactional region of the memory destination of that instruction may return the value that was in memory before the transactional region began.										
implication	due to this erratum, unpredictable system behavior may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package c7 entry may cause display artifact										
problem	due to this erratum, package c7 entry may exceed published latencies.										
implication	when this erratum occurs, it is possible that isochronous requirements may not be met. intel has not observed this erratum to affect isochronous elements other than display.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® tsx instructions not available										
problem	intel tsx (transactional synchronization extensions) instructions are not supported and not reported by cpuid.										
implication	the intel tsx feature is not available.										
workaround	none identified.										
											
title	spurious corrected errors may be reported										
problem	due this erratum, spurious corrected errors may be logged in the mc0_status register with the valid (bit 63) set, the uncorrected error (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.										
implication	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring event instr_retired.all may generate redundant pebs records for an overflow										
problem	due to this erratum, the performance monitoring feature pdir (precise distribution of instructions retired) for instr_retired.all (event c0h; umask 01h) will generate redundant pebs (precise event based sample) records for a counter overflow. this can occur if the lower 6 bits of the performance monitoring counter are not initialized or reset to 0, in the pebs counter reset field of the ds buffer management area.										
implication	the performance monitor feature pdir, may generate redundant pebs records for an overflow.										
workaround	initialize or reset the counters such that lower 6 bits are 0.										
											
title	concurrent core and graphics operation at turbo ratios may lead to system hang										
problem	workloads that attempt concurrent operation of cores and graphics in their respective turbo ranges, under certain conditions may result in a system hang.										
implication	concurrent core and graphics operation may hang the system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the system may hang on first package c6 or deeper c-state										
problem	under certain conditions following a cold boot, exiting the first package c6 or deeper c- state may hang the system.										
implication	due to this erratum, the system may hang exiting a package c6 or deeper c-state.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	svm doorbells are not correctly preserved across package c-states										
problem	svm (shared virtual memory) doorbell registers are incorrectly preserved across package c-states (c7 and deeper).										
implication	due to this erratum, software that uses svm may experience unreliable behavior from the graphics device.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	using the fivr spread spectrum control mailbox may not produce the requested range										
problem	values programmed into the fivr ssc (fully integrated voltage regulator spread spectrum control) mailbox may not result in the expected spread spectrum range.										
implication	the actual fivr spread spectrum range may not be the same as the programmed values affecting the usefulness of fivr ssc mailbox as a means to reduce emi (electromagnetic interference).										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	intel® processor trace (intel® pt) mode.exec, pip, and cbr packets are not generated as expected										
problem	the intel® pt mode.exec (mode packet – execution mode  leaf),  pip  (paging  information packet), and cbr (core:bus ratio) packets are generated at the following psb+ (packet stream boundary) event rather than at the time of the originating event as expected.										
implication	the decoder may not be able to properly disassemble portions of the binary or interpret portions of the trace because many packets may be generated between the mode.exec, pip, and cbr events and the following psb+ event.										
workaround	the processor inserts these packets as status packets in the psb+ block. the decoder may have to skip forward to the next psb+ block in the trace to obtain the proper updated information to continue decoding.										
											
title	performance monitor instructions retired event may not count consistently										
problem	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.										
implication	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	general-purpose performance counters may be inaccurate with any thread										
problem	the ia32_pmcx msr (c1h - c8h) general-purpose performance counters may report inaccurate counts when the associated event selection ia32_perfevtselx msr’s (186h - 18dh) anythread field (bit 21) is set and either the os field (bit 17) or usr field (bit 16) is set (but not both set).										
implication	due to this erratum, ia32_pmcx counters may be inaccurate.										
workaround	none identified										
											
title	glitches on internal voltage planes during package c9/c10 exit may cause a system hang										
problem	internally generated processor voltage planes may exhibit unexpected voltage glitches during a package c9/c10 exit.										
implication	when this erratum occurs, the system may hang. intel has not observed this erratum with any commercially available system.										
workaround	it is possible for bios to contain a workaround for this erratum										
											
title	an incorrect lbr or intel® processor trace packet may be recorded following a transactional abort										
problem	use of intel® transactional synchronization extensions (intel® tsx) may result in a transactional abort. if an abort occurs immediately following a branch instruction, an incorrect branch target may be logged in an lbr (last branch record) or in an intel® processor trace (intel® pt) packet before the lbr or intel pt packet produced by the abort.										
implication	the lbr or intel pt packet immediately preceding a transactional abort may indicate an unexpected branch target.										
workaround	none identified.										
											
title	executing an rsm instruction with intel® processor trace enabled will signal a #gp										
problem	upon delivery of a system management interrupt (smi), the processor saves and then clears traceen in the ia32_rtit_ctl msr (570h), thus disabling intel® processor trace (intel® pt). if the smi handler enables intel pt and it remains enabled when an rsm instruction is executed, a shutdown event should occur. due to this erratum, the processor does not shutdown but instead generates a #gp (general-protection exception).										
implication	when this erratum occurs, a #gp will be signaled.										
workaround	if software enables intel® pt in system-management mode, it should disable intel® pt before executing rsm.										
											
title	intel® processor trace pip may be unexpectedly generated										
problem	when intel® processor trace (intel® pt) is enabled, psb+ (packet stream boundary) packets may include a pip (paging information packet) even though the os field (bit 2) of ia32_rtit_ctl msr (570h) is 0.										
implication	when this erratum occurs, user-mode tracing (indicated by ia32_rtit_ctl.os = 0) may include cr3 address information. this may be an undesirable leakage of kernel information.										
workaround	it is possible for bios to contain a workaround for this erratum										
											
title	a #ve may not invalidate cached translation information										
problem	an ept (extended page table)  violation that causes a  #ve (virtualization exception)   may not invalidate the guest-physical mappings that were used to translate the guest- physical address that caused the ept violation.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	frequent entries into package c8, c9, or c10 may cause a hang										
problem	it is possible for the processor to signal a machine check exception when deep    packages c-states, c8, c9, or c10, are entered too frequently, typically less than 200us apart. the processor will not be able to process the machine check and will hang.										
implication	due to this erratum, the processor may signal a machine check exception (ia32_mci_status.mccod = 0x0400) and the processor will hang.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	some performance monitor events may overcount during tlb misses										
problem	the following performance monitor events may significantly overcount when multiple tlb misses happen nearly concurrently: itlb_misses (event 85h, umask 01h, 02h, 04h, 08h, 10h) dtlb_load_misses (event 08h, umask 01h, 02h, 04h, 08h, 10h) dtlb_store_misses (event 49h, umask 01h, 02h, 04h, 08h, 10h) page_walker_loads (event bch, all umasks)										
implication	when this erratum occurs, counts accumulated for the listed events may significantly exceed the correct counts.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® processor trace psb+ packets may contain unexpected packets										
problem	some intel processor trace packets should be issued only between tip.pge (target ip packet.packet generation enable) and tip.pgd (target ip packet.packet generation disable) packets. due to this erratum, when a tip.pge packet is generated it may be preceded by a psb+ (packet stream boundary) that incorrectly includes fup (flow update packet) and mode.exec packets.										
implication	due to this erratum, fup and mode.exec may be generated unexpectedly.										
workaround	decoders should ignore fup and mode.exec packets that are not between tip.pge and										
											
title	writing non-zero value to ia32_rtit_cr3_match [63:48] will cause #gp										
problem	bits [63:48] of the ia32_rtit_cr3_match msr (0572h) are incorrectly treated as reserved and therefore writing non-zero values to them will cause a #gp										
implication	due to this erratum, a #gp fault will occur if a non-zero value is written to ia32_rtit_cr3_match[63:48].										
workaround	software should avoid writing non-zero values to bits										
											
title	core c6 may cause interrupts to be serviced out of order										
problem	if the apic isr (in-service register) indicates in-progress interrupt(s) at core c6    entry, a lower priority interrupt pending in the irr (interrupt request register) may be executed after core c6 exit, delaying completion of the higher priority interrupt’s service routine.										
implication	an interrupt may be processed out of its intended priority order immediately after core c6 exit.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	the display may not resume correctly after package c8-c10 exit										
problem	display configuration is not properly restored after a package c8-c10 exit.										
implication	the display engine may not function correctly after package c8-c10 exit leading to an incorrect display.										
workaround	it is possible for bios to contain a workaround for this erratum										
											
title	lpddr3 memory training may cause platform boot failure										
problem	due to this erratum, lpddr3 memory sub-systems may not successfully complete training.										
implication	when this erratum occurs, the platform may fail to boot successfully										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	aggressive ramp down of voltage may result in unpredictable behavior										
problem	aggressive ramp down of vcc voltage may result in insufficient voltage to meet power demand.										
implication	due to this erratum, unpredictable system behavior or hangs may be observed.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitor event for outstanding offcore requests and snoop requests may be incorrect										
problem	the performance monitor event offcore_requests_outstanding (event 60h, any umask value) should count the number of offcore outstanding transactions each cycle. due to this erratum, the counts may be higher or lower than expected.										
implication	the performance monitor event offcore_requests_outstanding may reflect an incorrect count.										
workaround	none identified.										
											
title	dr6 register may contain an incorrect value when a mov to ss or pop ss instruction is followed by an xbegin instruction										
problem	if xbegin is executed immediately after an execution of mov to ss or pop ss, a transactional abort occurs and the logical processor restarts execution from the fallback instruction address. if execution of the instruction at that address causes a debug exception, bits [3:0] of the dr6 register may contain an incorrect value.										
implication	when the instruction at the fallback instruction address causes a debug exception, dr6 may report a breakpoint that was not triggered by that instruction, or it may fail to report a breakpoint that was triggered by the instruction.										
workaround	avoid following a mov ss or pop ss instruction immediately with an xbegin instruction.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated after a uc error is logged										
problem	when a uc (uncorrected) error is logged in the ia32_mc0_status  msr (401h),  corrected errors will continue to update the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated after a uc error is logged.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	processor may incorrectly enter into package-c states c8, c9, or c10										
problem	the processor may not fully honor all ltr (latency tolerance register) values when selecting the package c-state level.										
implication	due to this erratum, the exit latency of an incorrect package c-state may lead to media artifacts such as audio glitching. intel has not observed this erratum with any commercially available software										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain llc frequency changes may result in unpredictable system behavior										
problem	a large frequency or voltage change for the llc (last level cache) and associated logic can lead to unpredictable system behavior										
implication	due to this erratum, unpredictable system behavior may be observed.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	operand-size override prefix causes 64-bit operand form of movbe instruction to cause a #ud										
problem	execution of a 64 bit operand movbe instruction with an operand-size override instruction prefix (66h) may incorrectly cause an invalid-opcode exception (#ud).										
implication	a movbe instruction with both rex.w=1 and a 66h prefix will unexpectedly cause an invalid-opcode exception (#ud). intel has not observed this erratum with any commercially available software.										
workaround	do not use a 66h instruction prefix with a 64-bit operand movbe instruction.										
											
title	processor operation at turbo frequencies above 3.2 ghz may cause the processor to hang										
problem	the processor may not run reliably when operating at turbo frequencies above 3.2 ghz.										
implication	due to this erratum, the processor may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ddr-1600 with a reference clock of 100 mhz may cause s3 entry failure										
problem	due to this erratum, platform state s3 entry with a ddr-1600 memory subsystem may cause the ddr reference clock, when configured at 100 mhz, to briefly switch to 133 mhz resulting in unpredictable system behavior.										
implication	when this erratum occurs, the system may experience unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	popcnt instruction may take longer to execute than expected										
problem	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.										
implication	software using the popcnt instruction may experience lower performance than expected.										
workaround	none identified.										
											
title	system may hang or video may be distorted after graphics rc6 exit										
problem	in a specific scenario, when the processor graphics exits rc6 and a processor core exits c6 at the same time, the system may become unresponsive or the video may become distorted.										
implication	the system may hang or video may be distorted.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain edp* displays may not function as expected										
problem	when the processor attempts to receive data on the edp aux bus, the impedance seen by the display’s aux bus drivers will be significantly below the vesa* edp* (embedded displayport*) specification’s requirement for the vaux(rx) (edp auxiliary channel) input impedance.										
implication	certain edp displays may not operate as expected.										
workaround	none identified.										
											
title	instruction fetch power saving feature may cause unexpected instruction execution										
problem	under a complex set of micro-architectural conditions, an instruction fetch dynamic power savings feature may cause the processor to execute unexpected instructions.										
implication	when this erratum occurs, instances of unexpected #gp (general protection fault) or #pf (page fault) have been observed. unexpected faults may lead to an application or operating system crash.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	c8 or deeper sleep state exit may result in an incorrect hdcp key										
problem	the hdcp (high-bandwidth digital content protection) key may be incorrect after a package c8 or deeper sleep state exit.										
implication	when this erratum occurs, drm (digital rights management) video playback may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia core ratio change coincident with outstanding read to the de may cause a system hang										
problem	an outstanding read from an ia core to the de (display engine) that is coincident with an ia core ratio change may result in a system hang.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ddr1600 clocking marginality may lead to unpredictable system behavior										
problem	the memory controller’s ddr clock, when operating at ddr1600 frequencies and at elevated temperatures, may not operate within tolerance and may lead to unpredictable system behavior.										
implication	due to this erratum, unpredictable system behavior may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package c9/c10 exit may cause a system hang										
problem	certain processors may not reliably exit package c9/c10 states.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	pl3 power limit control mechanism may not release frequency restrictions										
problem	the pl3 mechanism imposes peak frequency  constraints  on  all  domains  (core, graphics, and ring) when a current spike that might cause accelerated battery aging is detected. due to this erratum, these constraints may not be released when the current spike has ended.										
implication	the processor clock frequencies may be unnecessarily limited.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	operating one or more of the ia (intel® architecture) cores at a frequency significantly higher than the ring operating frequency may cause unpredictable system behavior. intel has observed this erratum to occur when the software explicitly requests the ring and ia core(s) to operate at different frequencies or when ia core(s) are transitioning in and out of c-states with the ia core(s) operating at frequencies much higher than the ring frequency. exposure to this erratum may be increased when the ia cores run at or close to p0 p-state frequency.										
implication	due to this erratum, system may hang or experience unpredictable system behavior.										
workaround	it is possible for bios to contain processor a workaround for this erratum.										
											
title	i/o subsystem clock gating may cause a system hang										
problem	certain complex internal conditions and timing relationships during clock gating of the  i/o subsystem may cause a system hang and may lead to a timeout machine check with an ia32_mci_status.mcacod of 0400h.										
implication	due to this erratum, the processor may hang and may report a machine check.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® trusted execution technology uses incorrect tpm 2.0 nv space index handles										
problem	intel® txt (trusted  execution technology) uses tpm (trusted  platform module) 2.0   draft specification handles (indices) aux 01800003, ps 01800001,  and  po 01400003. those handles conflict with the released tcg (trusted computing group) “registry of reserved tpm 2.0 handles and localities”, version 1.0, revision 1.										
implication	txt tpm 2.0 handles may conflict with platform manufacturer or owner usage of tpm nv space. intel has not identified any functional impact due to this erratum.										
workaround	none identified.										
											
title	transitions through package c7 or deeper may result in a system hang										
problem	under certain conditions, entry into a package c7 or deeper c-state may result in a system hang on the subsequent c-state exit										
implication	due to this erratum, the processor may experience a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	page_walker_loads performance monitoring event may count incorrectly										
problem	due to this erratum, the page_walker_loads (event bch) performance monitoring event may overcount or may undercount										
implication	these performance monitoring events may not produce reliable results										
workaround	none identified.										
											
title	the system may hang when exiting from deep package c-states										
problem	when exiting from package c7-c10, the system may hang.										
implication	the system may hang when exiting from package c-states										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	certain local memory read/load retired perfmon events may undercount										
problem	due to this erratum, the local memory read/load retired perfmon events listed below may undercount.										
implication	the affected events may undercount, resulting in inaccurate memory profiles. intel has observed under counts by as much as 20%.										
workaround	none identified.										
											
title	the system may hang when executing a complex sequence of locked instructions										
problem	under certain internal timing conditions while executing a complex sequence of locked instructions, the system may hang										
implication	the system may hang while executing a complex sequence of locked instructions and cause an internal timeout error machine check (ia32_mci_status.mcacod=0400h).										
workaround	it is possible for the bios to contain a workaround for this problem.										
											
title	certain settings of vm-execution controls may result in incorrect linear-address translations										
problem	if vm exit occurs from a guest with primary processor-based vm-execution control “activate secondary controls” set to 0 and the secondary processor-based vm- execution control “enable vpid” set to 1, then after a later vm entry with vpid fully enabled (“activate secondary controls” and “enable vpid” set to 1), the processor may use stale linear address translations.										
implication	the processor may incorrectly translate linear addresses. intel has not observed this erratum with any commercially available software.										
workaround	software should not enter a guest with “enable vpid” set to 1 when “activate secondary controls” is set to 0.										
											
title	an iret instruction that results in a task switch does not serialize the processor										
problem	an iret instruction that results in a task switch by returning from a nested task does  not serialize the processor (contrary to the software developer’s manual vol. 3 section titled "serializing instructions").										
implication	software which depends on the serialization property of iret during task switching  may not behave as expected. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	none identified. software can execute an mfence instruction immediately prior to the iret instruction if serialization is needed.										
											
title	attempting concurrent enabling of intel® pt with lbr, bts, or btm results in a #gp										
problem	if lbr (last branch records), bts (branch trace store),  or  btm  (branch  trace messages) are enabled in the ia32_debugctl msr (1d9h), an attempt to enable intel pt (intel® processor trace) in ia32_rtit_ctl msr (570h) results in a #gp (general protection exception). (note that the btm enable bit in ia32_debugctl msr is named “tr”.) correspondingly, if intel pt was previously enabled when an attempt is made to enable lbr, bts, or btm, a #gp will occur.										
implication	an unexpected #gp may occur when concurrently enabling any one of lbr, bts, or btm with intel pt.										
workaround	none identified										
											
title	processor may hang when package c-states are enabled										
problem	when package c6 or deeper c-states are enabled, certain micro-architectural conditions during a c-state exit may cause the processor to hang.										
implication	due to this erratum, a system hang may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	setting traceen while clearing branchen in ia32_rtit_ctl causes a #gp										
problem	a wrmsr to ia32_rtit_ctl (msr 0570h) that sets traceen (bit 0) and clears branchen (bit 13) will cause a #gp (general protection exception)										
implication	intel® processor trace cannot be enabled without enabling control flow trace packets.										
workaround	none identified.										
											
title	processor graphics iommu unit may not mask dma remapping faults										
problem	intel® virtualization technology for directed i/o specification specifies setting the fpd (fault processing disable) field in the context (or extended-context) entry of iommu to mask recording of qualified dma remapping faults for dma requests processed through that context entry. due to this erratum, the iommu unit for processor graphics device may record dma remapping faults from processor graphics device (bus: 0; device: 2; function: 0) even when the fpd field is set to 1.										
implication	software may continue to observe dma remapping faults recorded in the iommu fault recording register even after setting the fpd field.										
workaround	none identified. software may mask the fault reporting event by setting the im (interrupt mask) field in the iommu fault event control register (offset 038h in gfxvtbar).										
											
title	processor graphics iommu unit may report spurious faults										
problem	the iommu unit for processor graphics pre-fetches context (or extended-context)   entries to improve performance. due to the erratum, the iommu unit may report spurious dma remapping faults if prefetching encounters a context (or extended- context) entry which is not marked present.										
implication	software may observe spurious dma remapping faults when the present bit for the context (or extended-context) entry corresponding to the processor graphics device (bus: 0; device: 2; function: 0) is cleared. these faults may be reported when the processor graphics device is quiescent.										
workaround	none identified. instead of marking a context not present, software should mark the context (or extended-context) entry present while using the page table to indicate all the memory pages referenced by the context entry is not present.										
											
title	peci frequency limited to 1 mhz										
problem	the processor should ensure internal graphics  configuration  is  restored  during  a package c7 or deeper exit event. due to this erratum, some internal graphics configurations may not be correctly restored.										
implication	when this erratum occurs, a graphics driver restart may lead to system instability. such a restart may occur when upgrading the graphics driver.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	reads or writes to lbrs with intel® pt enabled will result in a #gp										
problem	on processors where the use of intel pt (intel® processor trace)  and lbrs (last   branch records) are mutually exclusive, reads of the lbr msrs should return 0s and writes to them should be ignored. due to this erratum, reads and writes to the lbr msrs while ia32_rtit_ctl msr (570h) traceen bit 0 is 1 will result in a #gp.										
implication	when this erratum occurs, a #gp will occur. lbrs are not available when intel pt is enabled.										
workaround	none identified.										
											
title	graphics configuration may not be correctly restored after a package c7 exit										
problem	the processor should ensure internal graphics  configuration  is  restored  during  a package c7 or deeper exit event. due to this erratum, some internal graphics configurations may not be correctly restored.										
implication	when this erratum occurs, a graphics driver restart may lead to system instability. such a restart may occur when upgrading the graphics driver.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	mtf vm exit on xbegin instruction may save state incorrectly										
problem	execution of an xbegin instruction while the “monitor trap flag” vm-execution control  is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save the address of the xbegin instruction as the instruction pointer (instead of the fallback instruction address specified by the xbegin instruction). in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.										
implication	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	back-to-back page walks due to instruction fetches may cause a system hang										
problem	multiple code fetches in quick succession that generate page walks may result in a  system hang causing an internal timer error (an mcacod value of 0400h) logged into ia32_mci_status bits [15:0].										
implication	due to this erratum, the processor may hang and report a machine check.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pebs record may be generated after being disabled										
problem	a performance monitoring counter may generate a pebs  (precise  event  based  sampling) record after disabling pebs or the performance monitoring counter by clearing the corresponding enable bit in ia32_pebs_enable msr (3f1h) or ia32_perf_global_ctrl msr (38fh).										
implication	a pebs record generated after a vmx transition will store into memory according to the post-transition ds (debug store) configuration. these stores may be unexpected if pebs is not enabled following the transition.										
workaround	it is possible for the bios to contain a workaround for this erratum. a software workaround is possible through disallowing pebs during vmx non-root operation and disabling pebs prior to vm entry.										
											
title	some offcore_response performance monitoring events related to rfo request types may count incorrectly										
problem	the performance monitoring events  offcore_response  (events  b7h  and  bbh) should count uncore responses matching the request-response configuration specified in msr_offcore_rsp_0 (1a6h) and msr_offcore_rsp_1 (1a7h) for core- originated requests. however, due to this erratum, response type no_supp bit [17] may be reported instead of local bit [26] for request types dmnd_rfo bit [1] and pf_rfo bit [5].										
implication	the specified performance monitoring events may count incorrectly.										
workaround	none identified.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	data breakpoint coincident with a machine check exception may be lost										
problem	if a data breakpoint occurs coincident with a machine check exception, then the data breakpoint may be lost.										
implication	due to this erratum, a valid data breakpoint may be lost.										
workaround	none identified.										
											
title	internal parity errors may incorrectly report overflow in the ia32_mc0_status msr										
problem	due to this erratum, an uncorrectable internal parity error with an ia32_mc0_status.mcacod (bits [15:0]) value of 0005h may incorrectly set the ia32_mc0_status.over flag (bit 62) indicating an overflow when a single error has been observed.										
implication	ia32_mc0_status.over may not accurately indicate multiple occurrences of errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	an intel® hyper-threading technology enabled processor may exhibit internal parity errors or unpredictable system behavior										
problem	under a complex series of microarchitectural events while running hyper-threading technology, a correctable internal parity error or unpredictable system behavior may occur.										
implication	a correctable error (ia32_mc0_status.mcacod=0005h and ia32_mc0_status.mscod=0001h) may be logged. the unpredictable system behavior frequently leads to faults (e.g. #ud, #pf, #gp).										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring counters may undercount when using cpl filtering										
problem	performance monitoring counters configured to count only os or only usr events by   setting exactly one of bits 16 or 17 in ia32_perfevtselx msrs (186h-18dh) may not count for a brief period during the transition to a new cpl.										
implication	due to this erratum, performance monitoring counters may report counts lower than expected.										
workaround	none identified.										
											
title	pebs eventingip field may be incorrect under certain conditions										
problem	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.										
implication	a measurement of ring transitions (using the edge-detect bit 18 in ia32_perfevtselx) may undercount, such as cpl_cycles.ring0_trans (event 5ch, umask 01h). additionally, the sum of an os-only event and a usr-only event may not exactly equal an event counting both os and usr. intel has not observed any other software-visible impact.										
workaround	none identified.										
											
title	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts										
problem	after a fault due to a failed pebs (processor event based sampling) or bts (branch   trace store) address translation, the rf (resume flag) may be incorrectly set in the eflags image that is saved.										
implication	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.										
workaround	software should always prevent faults on pebs or bts.										
											
title	some memory performance monitoring events may produce incorrect results when filtering on either os or usr modes										
problem	the memory at-retirement performance monitoring events (listed below) may produce incorrect results when a performance counter is configured in os-only or usr-only modes (bits 17 or 16 in ia32_perfevtselx msr). counters with both os and usr bits set are not affected by this erratum. the list of affected memory at-retirement events for bdw is as follows: mem_uops_retired.stlb_miss_loads event d0h, umask 11h mem_uops_retired.stlb_miss_stores event d0h, umask 12h mem_uops_retired.lock_loads event d0h, umask 21h mem_uops_retired.split_loads event d0h, umask 41h mem_uops_retired.split_stores event d0h, umask 42h mem_load_uops_retired.l2_hit event d1h, umask 02h mem_load_uops_retired.l3_hit event d1h, umask 04h mem_load_uops_retired.l1_miss event d1h, umask 08h mem_load_uops_retired.l2_miss event d1h, umask 10h mem_load_uops_retired.l3_miss event d1h, umask 20h mem_load_uops_retired.hit_lfb event d1h, umask 40h mem_load_l3_hit_retired.xsnp_miss event d2h, umask 01h mem_load_l3_hit_retired.xsnp_hit event d2h, umask 02h mem_load_l3_hit_retired.xsnp_hitm event d2h, umask 04h mem_load_l3_hit_retired.xsnp_none event d2h, umask 08h mem_load_uops_l3_miss_retired.local_dram event d3h, umask 01h										
implication	the listed performance monitoring events may produce incorrect results including pebs records generated at an incorrect point.										
workaround	none identified.										
											
title	some dram and l3 cache performance monitoring events may undercount										
problem	due to this erratum, the supplier may be misattributed to unknown, and the following events may undercount: mem_load_uops_retired.l3_hit (event d1h umask 04h) mem_load_uops_retired.l3_miss (event d1h umask 20h) mem_load_uops_l3_hit_retired.xsnp_miss (event d2h umask 01h) mem_load_uops_l3_hit_retired.xsnp_hit (event d2h umask 02h) mem_load_uops_l3_hit_retired.xsnp_hitm (event d2h umask 04h) mem_load_uops_l3_hit_retired.xsnp_none (event d2h umask 08h) mem_load_uops_l3_miss_retired.local_dram (event d3h umask 01h) mem_trans_retired.load_latency (event cdh umask 01h)										
implication	the affected events may undercount, resulting in inaccurate memory profiles.for the affected events that are precise, pebs records may be generated at incorrect points. intel has observed incorrect counts by as much as 20%										
workaround	none identified										
											
title	an x87 store instruction which pends #pe while ept is enabled may lead to an unexpected machine check and/or incorrect x87 state information										
problem	the execution of an x87 store instruction which causes a #pe (precision exception) to  be pended and also causes a vm-exit due to an ept violation or misconfiguration may lead the vmm logging a machine check exception with a cache hierarchy error (ia32_mci_status.mcacod = 0150h and ia32_mci_status.mscod = 000fh). additionally, fsw.pe and fsw.es (bits 5 and 7 of the fpu status word) may be incorrectly set to 1, and the x87 last instruction opcode (fop) may be incorrect.										
implication	when this erratum occurs, the vmm may receive an expected machine check exception and software attempting to handle the #pe may not behave as expected.										
workaround	none identified										
											
title	general-purpose performance monitoring counters 4-7 do not count with usr mode only filtering										
problem	the ia32_pmc4-7 msr (c5h-c8h) general-purpose performance monitoring counters  will not count when the associated cpl filter selection in ia32_perfevtselx msr's (18ah-18dh) usr field (bit 16) is set while os field (bit 17) is not set.										
implication	software depending upon ia32_pmc4-7 to count only usr events will not operate as expected. counting os only events or os and usr events together is unaffected by this erratum.										
workaround	none identified										
											
title	writing msr_lastbranch_x_from_ip may #gp when intel® tsx is not supported										
problem	due to this erratum, on processors that do not support intel tsx (intel® transactional synchronization extensions) (cpuid.07h.ebx bits 4 and 11 are both zero), writes to msr_lastbranch_x_from_ip (msr 680h to 68fh) may #gp unless bits[62:61] are equal to bit[47].										
implication	the value read from msr_lastbranch_x_from_ip is unaffected by this erratum; bits [62:61] contain in_tsx and tsx_abort information respectively. software restoring these msrs from saved values are subject to this erratum.										
workaround	before writing msr_lastbranch_x_from_ip, ensure the value being written has bit[47] replicated in bits[62:61]. this is most easily accomplished by sign extending from bit[47] to bits[62:48].										
											
title	apic timer interrupt may not be generated at the correct time in tsc-deadline mode										
problem	after writing to the ia32_tsc_adjust msr (3bh), any subsequent write to the ia32_tsc_deadline msr (6e0h) may incorrectly process the desired deadline. when this erratum occurs, the resulting timer interrupt may be generated at the incorrect time.										
implication	when the local apic (advanced programmable interrupt controller) timer is configured for tsc-deadline mode, a timer interrupt may be generated much earlier than expected or much later than expected. intel has not observed this erratum with most commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a cap error while entering package c6 may cause dram to fail to enter self-refresh										
problem	a cap (command/address parity) error that occurs on the command to direct dram to enter self-refresh may cause the dram to fail to enter self-refresh although the processor enters package-c6.										
implication	due to this erratum, dram may fail to be refreshed, which may result in uncorrected errors being reported from the dram.										
workaround	none identified.										
											
title	pcie* lane error status register may log false correctable error										
problem	due to this erratum, pcie* lnerrsts (device 0; function 0; offset 258h; bits [3:0]) may log false lane-based correctable errors.										
implication	diagnostics cannot reliably use lnerrsts to report correctable errors.										
workaround	none identified										
											
title	in memory mirror mode, dataerrorchunk field may be incorrect										
problem	in memory mirror mode, dataerrorchunk bits (ia32_mc7_misc register msr(41fh) bits [61:60]) may not correctly report the chunk containing an error.										
implication	due to this erratum, this field is not accurate when memory mirror mode is enabled.										
workaround	none identified.										
											
title	intel® rdt mbm does not accurately track write bandwidth										
problem	intel® rdt (resource director technology) mbm (memory bandwidth monitoring) does not count cacheable write-back traffic to local memory. this will result in the rdt mbm feature under counting total bandwidth consumed.										
implication	applications using this feature may report incorrect memory bandwidth.										
workaround	none identified.										
											
title	intel upi initialization aborts may be logged										
problem	if intel® upi (ultra path interconnect) is configured for slow mode operation, initialization aborts may occur.										
implication	unexpected initialization aborts may be logged in the ktireut_ph_ctr1 register (bus: 3; device: 16-14; function 1; offset 12h; bit 4).										
workaround	none identified.										
											
title	pcie* port may incorrectly log malformed_tlp error										
problem	if the pcie port receives a tlp that triggers both a malformed_tlp error and an ecrc_tlp error, the processor should only log an ecrc_tlp error. however, the processor logs both errors.										
implication	due to this erratum, the processor may incorrectly log malformed_tlp errors.										
workaround	none identified										
											
title	short loops which use ah/bh/ch/dh registers may cause unpredictable system behavior										
problem	under complex micro-architectural conditions, short loops of less than 64 instructions that use ah, bh, ch or dh registers as well as their corresponding wider register (e.g. rax, eax or ax for ah) may cause unpredictable system behavior. this can only happen when both logical processors on the same physical processor are active.										
implication	due to this erratum, the system may experience unpredictable system behavior										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	credits not returned for pcie* packets that fail ecrc check										
problem	the processor's iio does not return credits back to the pcie* link in case of end-to-end crc (ecrc) errors.										
implication	due to this erratum, the link may experience degraded performance or may eventually fail due to a loss of credits.										
workaround	for processors that support ler (live error recovery) the link would be reset and credits would be restored. processors that do not support ler should configure ecrc errors to be fatal.										
											
title	link training error due to single polarity of a pcie* differential data pair being disconnected										
problem	a pcie port may not reach l0 state if a single polarity of a pcie* differential data pair is disconnected.										
implication	due to this erratum, the port will not downlink and be able to train up to l0.										
workaround	none identified.										
											
title	upi crc32 rolling mode is not functional										
problem	with upi crc32 rolling mode enabled, upi rx crc errors may be seen.										
implication	due to this erratum, when upi crc32 rolling mode is enabled, upi rx crc errors may be seen.										
workaround	none. do not enable upi crc32 setting in bios.										
											
title	iodc entry 0 cannot be masked										
problem	the individual iodc (io directory cache) entry 0 cannot be masked using ha_coh_cfg_1, (bus 1; devices 11-8; functions 7-0, offset 0x11c, bit 0) therefore entry 0 is always allocated.										
implication	no functional implications.										
workaround	none.										
											
title	with emca2 enabled a 3-strike may cause an unnecessary caterr# instead of only msmi										
problem	when emca2 is enabled to cause an msmi due to a 3-strike event, a pulsed caterr# and msmi# event may both be observed on the pins.										
implication	when this erratum occurs, an unnecessary caterr# pulse may be observed.										
workaround	none.										
											
title	cmci may not be signalled for corrected error										
problem	machine check banks 9, 10, and 11 may not signal cmci after the first corrected error is reported in the bank even if the mci_status register has been cleared.										
implication	after the first corrected error is reported in one of the affected machine check banks, subsequent errors will be logged but may not result in a cmci.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	a upi phy reset and rx crc error on same packet are causing the retry sequence to abort leading to a upi phy re-initialization.										
implication	due to this erratum, an unexpected upi phy re-initialization may occur before the program llsrm threshold has been hit.										
workaround	none identified.										
											
title	csrs svid and sdid are not implemented for some ddrio and pcu devices										
problem	the ddrio (bus: 3; device 19,22; function 6,7 and “bus: 0; device: 20,23; function: 4,5,6,7;) and pcu (bus: 3; device 31; functions 0,2) do not implement the svid (offset 0x2c) and sdid (offset 0x2e) csrs.										
implication	sw relying on ddrio and pcu svid and sdid csr support may not function correctly. workaround none. do not use svid and sdid for these devices and functions.										
workaround											
											
title	register broadcast read from ddrio may return a zero value										
problem	when performing a bios broadcast register read to ddrio a value of 0 is always returned.										
implication	when this erratum occurs, bios may not be able to proceed due to always reading a value of 0.										
workaround	none. use unicast register read for each instance instead of broadcast register read for all instances at once.										
											
title	intel® cmt counters may not count accurately										
problem	under complex microarchitectural conditions, the cmt (cache monitoring technology) counters may overcount.										
implication	software relying on cmt registers to enable resource allocation may not operate correctly. this may lead to reporting of more cachelines used than the cache supports or the counter wrapping and returning a too small value. wbinvd may not result in the cmt counters being zeroed. intel has not observed this erratum in commercially available software.										
workaround	none.										
											
title	intel® cat may not restrict cacheline allocation under certain conditions										
problem	under certain microarchitectural conditions involving heavy memory traffic , cachelines may fill outside the allocated l3 capacity bitmask (cbm) associated with the current class of service (clos).										
implication	cat (cache allocation technology) may appear less effective at protecting certain classes of applications, including cache-sensitive workloads than on previous platforms.										
workaround	none identified.										
											
title	intel® mbm counters may undercount										
problem	the mbm (memory bandwidth monitoring) counters will increment for reads but will not increment for memory writes. the performance counters in the imc (integrated memory controller) are not affected and can report the read and write memory bandwidths.										
implication	mbm accuracy may be reduced, which can affect performance monitoring or bandwidth-aware scheduling. applications may be unevenly charged for bandwidth depending on their characteristics.										
workaround	none identified. this erratum can be mitigated by using the imc performance monitoring counters to derive a read/write ratio that can be used to adjust the mbm counters.										
											
title	intel® pcie* corrected error threshold does not consider overflow count when incrementing error counter										
problem	the pcie* corrected error counter feature does not take the overflow bit in the count (bit 15 of xpcorerrcounter (bus; rootbus device; 0 function; 0 offset; 4d0h)) into account when comparing the count to the threshold in xpcorerrthreshold.error_threshold. therefore, you end up with another interrupt once the counter has rolled over and hit your threshold + 0x8000.										
implication	due to this erratum, the pcie* corrected error signaling may occur even after the error count has exceeded the corrected error count threshold, not just a single time when reaching the threshold. intel has not observed this erratum with any commercially available system.										
workaround	none identified										
											
title	iio ras vpp hangs during the warm reset test										
problem	when vppcl bit 0 of vpp_reset_mode (bus 1; device 30; function 5; offset 0xf0) bit is set to 0, and the cpu is undergoing reset flow while pcie* hotplug operation is in process, the vpp (virtual pin port) hotplug commands may stop responding.										
implication	due to this erratum, during cpu reset hotplug commands may not get completed.										
workaround	none. do not set vpp reset mode to 0.										
											
title	crc store operation corner case may result in hang										
problem	intel quickdata technology local and remote crc store operations may result in a dma channel hang when the crc store transfer size is less than 32 bytes and the destination offset is not dword-aligned.										
implication	due to this erratum, the processor may hang.										
workaround	software must configure intel quickdata technology local and remote crc store operations to have descriptor destination offset addresses dword-aligned.										
											
title	intel® pcie* slot presence detect and presence detect changed logic not pcie* specification compliant										
problem	when hot-plug surprise is set in the slot capabilities register (bus: rootbus, dev: 1-3, function: 0, offset: a4h, bit: 5), the presence detect state and presence detect change in the slot status register (bus: rootbus, dev: 1-3, function: 0, offset: a2h), incorrectly ignores the out-of-band presence detect mechanism and only reflects the physical layer in-band presence detect mechanism.										
implication	due to this erratum, if the hot-plug surprise bit is set in the slot capabilities register, software will not be able to detect the presence of an adapter inserted while a slot is powered down. therefore, hot-plug surprise must only be set in configurations where the slot power is always enabled.										
workaround	none identified.										
											
title	unexpected ddr ecc errors may be seen										
problem	the processor may incorrectly configure the processor's vccp rail voltage.										
implication	due to this erratum, unexpected memory ecc errors may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	in patrol scrub system address mode, address is not loaded from csrs after re-enable										
problem	the patrol scrub starting address registers (scrubaddresshi (bus 2; devices 12, 10; function 0; offset 910) and scrubaddresslo bus 2; devices 12, 10; function 0; offset 90c) should indicate when the first memory address from which patrol logic should start scrubs (when scrubctl.startscrub (bus 2; devices 12, 10; function 0; offset 914; bit 24)is set). due to this erratum, after patrol is disabled, if the patrol scrub engine is re-enabled in system address mode with scrubctl.startscrub set, the patrol scrubbing engine may ignore the starting address registers. re-enabling patrol after s3 exit or other warm reset event is not impacted by this.										
implication	due to this erratum, when configured in system address mode, patrol scrubs will not start from the address specified in the starting address registers. this may cause certain memory lines to be scrubbed more or less frequently than expected. intel has not seen this erratum to affect the operation of any commercially available software.										
workaround	none identified.										
											
title	none										
problem	the performance monitoring event that counts intel thermal monitor 2 (enhanced intel speedstep® technology based) transitions may have inaccurate results.										
implication	there is no functional impact of this erratum. however this performance monitoring event should not be used when accurate performance monitoring is required.										
workaround	none.										
											
title	performance monitoring event that counts the number of instructions decoded (d0h) is not accurate										
problem	the performance-monitoring event that counts the number of instructions decoded may have inaccurate results.										
implication	there is no functional impact of this erratum. however the results/counts from this performance monitoring event should not be considered as being accurate.										
workaround	none.										
											
title	rdtsc instruction may report the wrong time-stamp counter value										
problem	the time-stamp counter is a 64-bit counter that is read in two 32-bit chunks. the counter incorrectly advances and therefore the two chunks may go out of synchronization causing the read time-stamp counter (rdtsc) instruction to report the wrong time-stamp counter value.										
implication	this erratum may cause software to see the wrong representation of processor time and may result in unpredictable software operation.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	code segment limit violation may occur on 4 gigabyte limit check										
problem	code segment limit violation may occur on 4 gigabyte limit check when the code stream wraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0x0.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	avoid code that wraps around segment limit.										
											
title	fst instruction with numeric and null segment exceptions may cause general protection faults to be missed and fp linear address (fla) mismatch										
problem	fst instruction combined with numeric and null segment exceptions may cause general protection faults to be missed and fp linear address (fla) mismatch.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	none.										
											
title	code segment (cs) is wrong on smm handler when smbase is not aligned										
problem	with smbase being relocated to a non-aligned address, during smm entry the cs can be improperly updated which can lead to an incorrect smm handler.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	align smbase to 32 kb.										
											
title	a locked data access that spans across two pages may cause the system to hang										
problem	an instruction with lock data access that spans across two pages may, given some rare internal conditions, hang the system.										
implication	when this erratum occurs, the system may hang. intel has not observed this erratum with any commercially available software or system.										
workaround	a locked data access should always be aligned.										
											
title	processor can enter a livelock condition under certain conditions when fp exception is pending										
problem	processor clock modulation may be controlled via a processor register (ia32_therm_control) or via the stpclk# signal. while the processor clock is constantly being actively modulated at 12.5% and 25% duty cycles and there is a   pending unmasked fp exception (es pending), if you attempt a fp load (or mmx™ technology mov instruction) and the load has an longer than typical latency the processor can enter a livelock.										
implication	when this erratum occurs, the processor will enter a livelock condition. intel has not observed this erratum with any commercially available software or system.										
workaround	none.										
											
title	write cycle of write combining memory type does not self snoop										
problem	write cycles of wc memory type do not self-snoop. this may result in data inconsistency – if the addresses of the wc data are aliased to wb memory type memory, which has been cached. in such a case, the internal caches will not be updated with the wc data sent on the system bus.										
implication	this condition may result in a data inconsistency. intel has not observed this erratum with any commercially available software, system, nor components.										
workaround	software should detect via the self-snoop bit in the cpuid features flags if the processor supports a self-snooping capability. software should perform explicit memory management/flushing for aliased memory ranges on processors that do not self-snoop.										
											
title	performance monitoring event that counts floating point computational exceptions (11h) is not accurate										
problem	performance monitoring event that counts floating point compare exceptions may have inaccurate results.										
implication	there is no functional impact of this erratum. however this performance monitoring event should not be used when accurate performance monitoring is required.										
workaround	none.										
											
title	inconsistent reporting of data breakpoints on fp (mmx™ technology) loads										
problem	the reporting of data breakpoints on either fp or mmx technology loads is dependent upon the code faulting behavior prior to the execution of the load. if there is a fault pending prior to the execution of the load and fp exceptions are enabled there is a chance that data breakpoint on successive fp/mmx technology loads may be reported twice.										
implication	software debuggers should be aware of this possibility. there should be no implications to software operated outside of a debug environment.										
workaround	none.										
											
title	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception										
problem	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled  debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.										
implication	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software, or system.										
workaround	as recommended in the ia32 intel® architecture software developer’s manual,   the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.										
											
title	sysenter and sysexit instructions may write incorrect requestor privilege level (rpl) in the fp code segment selector (fcs)										
problem	sysenter and sysexit instructions may write incorrect rpl in the fp code segment selector (fcs). as a result of this, the rpl field in fcs may be corrupted.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	memory aliasing with inconsistent a and d bits may cause processor deadlock										
problem	this erratum has not been observed with commercially available software.										
implication	this erratum has not been observed with commercially available software.										
workaround	software that needs to implement memory aliasing in this way should manage   the consistency of the accessed and dirty bits.										
											
title	rdmsr or wrmsr to invalid msr address may not cause gp fault										
problem	the rdmsr and wrmsr instructions allow reading or writing of msrs (model specific registers) based on the index number placed in ecx. the processor should reject access to any reserved or unimplemented msrs by generating #gp(0). however, there are some invalid msr addressers for which the processor will not generate #gp(0). this erratum has not been observed with commercially available software.										
implication	for rdmsr, undefined values will be read into edx:eax. for wrmsr, undefined processor behavior may result.										
workaround	do not use invalid msr addresses with rdmsr or wrmsr.										
											
title	fp tag word corruption										
problem	in some rare cases, fault information generated as the result of instruction execution may be incorrect. the result is an incorrect fp stack entry.										
implication	this erratum may result in corruption of the fp tag word in a way that a non-valid entry in the fp stack may become valid. the software is not expected to read a non- valid entry. if the software attempts to use the stack entry (which is expected to be empty) the result may be an erroneous “stack overflow”.										
workaround	do not disable sse/sse2 in control register cr4 and avoid code segment limit violation.										
											
title	unable to disable reads/writes to performance monitoring related msrs										
problem	the performance monitoring available bit in the miscellaneous processor features msr (ia32_misc_enables.7) was defined so that when it is cleared to a 0, rdmsr/wrmsr/rdpmc instructions would return all zeros for reads of and prevent any writes to performance monitoring related msrs. currently it is possible to read from or write to performance monitoring related msrs when the performance monitoring available bit is cleared to a 0.										
implication	it is not possible to disallow reads and writes to the performance monitoring msrs. intel has not observed this erratum with any commercially available software or system.										
workaround	none.										
											
title	move to control register instruction may generate a breakpoint report										
problem	a move (mov) to control register (cr) instruction where control register is cr0, cr3 or cr4 may generate a breakpoint report.										
implication	mov to control register instruction is not expected to generate a breakpoint report.										
workaround	ignore breakpoint data from mov to cr instruction.										
											
title	rep movs/stos executing with fast strings enabled and crossing page boundaries with inconsistent memory types may use an incorrect data size or lead to memory-ordering violations										
problem	under certain conditions as described in the software developers manual section “out-of-order stores for string operations in pentium 4, intel xeon, and p6 family processors” the processor performs rep movs or rep stos as fast strings. due to this erratum fast string rep movs/rep stos instructions that cross page boundaries from wb/wc memory types to uc/wp/wt memory types, may start using an incorrect data size or may observe memory ordering violations.										
implication	upon crossing the page boundary the following may occur, dependent on the new page memory type:  uc the data size of each write will now always be 8 bytes, as opposed to the original data size. wp the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. wt there may be a memory ordering violation.										
workaround	software should avoid crossing page boundaries from wb or wc memory type to   uc, wp or wt memory type within a single rep movs or rep stos instruction that will execute with fast strings enabled.										
											
title											
problem	if the data from an fxsave, stos, or movs instruction crosses a page boundary from wb to uc memory type and this instruction is immediately followed by a second instruction that also issues a store to memory, the final data stores from both instructions may occur in the wrong order.										
implication	the impact of this store ordering behavior may vary from normal software execution to potential software failure. intel has not observed this erratum in commercially available software.										
workaround	fxsave, stos, or movs data must not cross page boundary from wb to uc memory type.										
											
title	machine check exception may occur due to improper line eviction in the ifu										
problem	the processor is designed to signal an unrecoverable machine check exception (mce) as a consistency checking mechanism. under a complex set of circumstances  involving multiple speculative branches and memory accesses, there exists a one cycle long window in which the processor may signal a mce in the instruction fetch unit (ifu) because instructions previously decoded have been evicted from the ifu. the one cycle long window is opened when an opportunistic fetch receives a partial  hit on a previously executed but not as yet completed store resident in the store buffer. the resulting partial hit erroneously causes the eviction of a line from the ifu at a time when the processor is expecting the line to still be present. if the mce for this particular ifu event is disabled, execution will continue normally.										
implication	while this erratum may occur on a system with any number of processors, the probability of occurrence increases with the number of processors. if this erratum does occur, a machine check exception will result. note systems that implement an operating system that does not enable the machine check architecture will be completely unaffected by this erratum (e.g., windows* 95 and windows 98).										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title											
problem	in some rare cases, popf and popfd instructions that set the trap flag (tf) bit in the eflags register (causing the processor to enter single-step mode) may cause unpredictable processor behavior.										
implication	single-step operation is typically enabled during software debug activities, not during normal system operation.										
workaround	there is no workaround for single-step operation in commercially available software. for debug activities on custom software the popf and popfd instructions could be immediately followed by a nop instruction to facilitate correct execution.										
											
title											
problem	the performance event counter returns an incorrect value on l2_lines_in event (emon event #24h) when the l2 cache is disabled.										
implication	due to this erratum, l2_lines_in performance event counter should not be monitored while the l2 cache is disabled. this erratum has no functional impact.										
workaround	ignore l2_lines_in event when the l2 cache is disabled.										
											
title	vm bit will be cleared on a double fault handler										
problem	following a task switch to a double fault handler that was initiated while the processor was in virtual-8086 (vm86) mode, the vm bit will be incorrectly cleared in eflags.										
implication	when the os recovers from the double fault handler, the processor will no longer be in vm86 mode.										
workaround	none.										
											
title	code fetch matching disabled debug register may cause debug exception										
problem	the bits l0-3 and g0-3 enable breakpoints local to a task and global to all tasks, respectively. if one of these bits is set, a breakpoint is enabled, corresponding to the addresses in the debug registers dr0-dr3. if at least one of these breakpoints is enabled, any of these registers are disabled (i.e., ln and gn are 0), and rwn for the disabled register is 00 (indicating a breakpoint on instruction execution), normally an instruction fetch will not cause an instruction-breakpoint fault based on a match with the address in the disabled register(s). however, if the address in a disabled register matches the address of a code fetch which also results in a page fault, an instruction- breakpoint fault will occur.										
implication	while debugging software, extraneous instruction-breakpoint faults may be encountered if breakpoint registers are not cleared when they are disabled. debug software which does not implement a code breakpoint handler will fail, if this occurs. if a handler is present, the fault will be serviced. mixing data and code may exacerbate this problem by allowing disabled data breakpoint registers to break on an instruction fetch.										
workaround	the debug handler should clear breakpoint registers before they become disabled.										
											
title	upper four pat entries not usable with mode b or mode c paging										
problem											
implication	only the lower four pat entries are useful for 4-kb translations when mode b or c paging is used. in mode a paging (4-kbyte pages only), all eight entries may be used. all eight entries may be used for large pages in mode b or c paging.										
workaround	none identified.										
											
title	sse/sse2 streaming store resulting in a self-modifying code (smc) event may cause unexpected behavior										
problem	an sse or sse2 streaming store that results in a self-modifying code (smc) event may cause unexpected behavior. the smc event occurs on a full address match of code contained in l1 cache.										
implication	due to this erratum, any of the following events may occur:  a data access break point may be incorrectly reported on the instruction pointer (ip) just before the store instruction. a non-cacheable store can appear twice on the external bus (the first time it will write only 8 bytes, the second time it will write the entire 16 bytes). intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	page with pat (page attribute table) set to uswc (uncacheable speculative write combine) while associated mtrr (memory type range register) is uc (uncacheable) may consolidate to uc										
problem	a page whose pat memory type is uswc while the relevant mtrr memory type is uc, the consolidated memory type may be treated as uc (rather than wc as specified in ia-32 intel® architecture software developer's manual).										
implication	when this erratum occurs, the memory page may be as uc (rather than wc). this may have a negative performance impact.										
workaround	none identified.										
											
title	under certain conditions ltr (load task register) instruction may result in system hang										
problem	an ltr instruction may result in a system hang if all the following conditions are met:   invalid data selector of the tr (task register) resulting with either #gp (general protection fault) or #np (segment not present fault). gdt (global descriptor table) is not 8-bytes aligned. data bp (breakpoint) is set on cache line containing the descriptor data. when this erratum occurs, the memory page may be as uc (rather than wc). this may have a negative performance impact.										
implication	this erratum may result in system hang if all conditions have been met. this erratum has not been observed in commercial operating systems or software. for  performance reasons, gdt is typically aligned to 8-bytes.										
workaround	do not use memory type uswc for memory that has read side-effects.										
											
title	loading from memory type uswc (uncacheable speculative write combine) may get its data internally forwarded from a previous pending store										
problem	a load from memory type uswc may get its data internally forwarded from a pending store. as a result, the expected load may never be issued to the external bus.										
implication	when this erratum occurs, a uswc load request may be satisfied without being observed on the external bus. there are no known usage models where this behavior results in any negative side-effects.										
workaround	do not use memory type uswc for memory that has read side-effects.										
											
title	fpu operand pointer may not be cleared following finit/fninit										
problem	initializing the floating point state with either finit or fnint, may not clear the x87 fpu operand (data) pointer offset and the x87 fpu operand (data) pointer selector (both fields form the fpudatapointer). saving the floating point environment with fstenv, fnstenv, or floating point state with fsave, fnsave or fxsave before an intervening fp instruction may save uninitialized values for the fpudatapointer.										
implication	when this erratum occurs, the values for fpudatapointer in the saved floating point image or floating point environment structure may appear to be random values. executing any non-control fp instruction with memory operand will initialize the fpudatapointer. intel has not observed this erratum with any commercially available software.										
workaround	after initialization, do not expect the fpudatapointer in a floating point state or floating point environment saved memory image to be correct, until at least one non- control fp instruction with a memory operand has been executed.										
											
title	fstp (floating point store) instruction under certain conditions may result in erroneously setting a valid bit on an fp (floating point) stack register										
problem	an fstp instruction with a pde/pte (page directory entry/page table entry) a/d bit update followed by user mode access fault due to a code fetch to a page that has supervisor only access permission may result in erroneously setting a valid bit of an fp stack register. the fp top of stack pointer is unchanged.										
implication	this erratum may cause an unexpected stack overflow.										
workaround	user mode code should not count on being able to recover from illegal accesses       to memory regions protected with supervisor only access when using fp instructions.										
											
title	snoops during the execution of a hlt (halt) instruction may lead to unpredictable system behavior										
problem	if during the execution of a hlt instruction an external snoop causes an eviction from the instruction fetch unit (ifu) instruction cache, the processor may, on exit from the hlt state, erroneously read stale data from the victim cache.										
implication	this erratum may lead to unpredictable system behavior. intel has only observed this condition in non-mobile configurations.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	invalid entries in page-directory-pointer-table register (pdptr) may cause general protection (#gp) exception if the reserved bits are set to one										
problem	invalid entries in the page-directory-pointer-table register (pdptr) that have the reserved bits set to one may cause a general protection (#gp) exception.										
implication	intel has not observed this erratum with any commercially available software.										
workaround	do not set the reserved bits to one when pdptr entries are invalid.										
											
title	init does not clear global entries in the tlb										
problem	init may not flush a tlb entry when:  the processor is in protected mode with paging enabled and the page global enable flag is set (pge bit of cr4 register) g bit for the page table entry is set tlb entry is present in tlb when init occurs										
implication	software may encounter unexpected page fault or incorrect address translation due to a tlb entry erroneously left in tlb after init.										
workaround	write to cr3, cr4 (setting bits pse, pge or pae) or cr0 (setting bits pg or pe) registers before writing to memory early in bios code to clear all the global entries from tlb.										
											
title	use of memory aliasing with inconsistent memory type may cause system hang or a machine check exception										
problem	software that implements memory aliasing by having more than one linear addresses mapped to the same physical page with different cache types may cause the system to hang or to report a machine check exception (mce). this would occur if one of the addresses is non-cacheable and used in a code segment and the other is a cacheable address. if the cacheable address finds its way into the instruction cache, and the non-cacheable address is fetched in the ifu, the processor may invalidate the non- cacheable address from the fetch unit. any micro-architectural event that causes instruction restart will be expecting this instruction to still be in the fetch unit and  lack of it will cause a system hang or an mce.										
implication	this erratum has not been observed with commercially available software.										
workaround	although it is possible to have a single physical page mapped by two different linear addresses with different memory types, intel has strongly discouraged this practice as it may lead to undefined results. software that needs to implement memory aliasing should manage the memory type consistency.										
											
title	machine check exception may occur when interleaving code between different memory types										
problem	a small window of opportunity exists where code fetches interleaved between different memory types may cause a machine check exception. a complex set of micro-architectural boundary conditions is required to expose this window.										
implication	interleaved instruction fetches between different memory types may result in a machine check exception. the system may hang if machine check exceptions are disabled. intel has not observed the occurrence of this erratum while running commercially available applications or operating systems.										
workaround	software can avoid this erratum by placing a serializing instruction between code fetches between different memory types.										
											
title	split i/o writes adjacent to retry of apic end of interrupt (eoi) request may cause livelock condition										
problem	when split i/o instruction writes occur adjacent to a retry of a local apic end of interrupt (eoi) request by the chipset, a livelock condition may result. the required sequences of events are:  the processor issues a local apic eoi message. the chipset responds with a retry because its downstream ports are full. it expects the processor to return with the same eoi request. the processor issues a split i/o write instruction instead. the chipset responds with a retry because it expected the apic eoi.   the processor insists the split i/o write instruction must be completed and issues write instruction again.										
implication	a processor livelock may occur causing a system hang. this issue has only been observed in synthetic lab testing conditions and has not been seen in any commercially available applications. the erratum does not occur with intel mobile chipset-based platforms.										
workaround	use the pic instead of the apic for the interrupt controller.										
											
title	general protection (#gp) fault may not be signaled on data segment limit violation above 4-g limit										
problem	memory accesses to flat data segments (base = 00000000h) that occur above the 4- g limit (0ffffffffh) may not signal a #gp fault.										
implication	when such memory accesses occur, the system may not issue a #gp fault.										
workaround	software should ensure that memory accesses do not occur above the 4-g limit (0ffffffffh).										
											
title	none										
problem	performance monitoring for event cfh normally increments on saturating simd instruction retired. regardless of dr7 programming, if the linear address of a retiring memory store movd/movq/movntq instruction executed matches the address in dr3, the cfh counter may be incorrectly incremented.										
implication	the value observed for performance monitoring count for saturating simd instructions retired may be too high. the size of the error is dependent on the number of occurrences of the conditions described above, while the counter is active.										
workaround	none identified.										
											
title	processor init# will cause a system hang if triggered during an nmi interrupt routine performed during shutdown										
problem	during the execution of an nmi interrupt handler, if shutdown occurs followed by the init# signal being triggered, the processor will attempt initialization but fail soft reset.										
implication	due to this erratum, the system may hang.										
workaround	none identified.										
											
title	certain performance monitoring counters related to bus, l2 cache and power management are inaccurate										
problem	all performance monitoring counters in the ranges 21h-3dh and 60h-7fh may have inaccurate results up to ±7.’										
implication	there may be a small error in the affected counts.										
workaround	none identified.										
											
title	cs limit violation on rsm may be serviced before higher priority interrupts/exceptions										
problem	when the processor encounters a cs (code segment) limit violation, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. because of this erratum, if rsm (resume from system management mode) returns to execution flow where a cs limit violation occurs, the #gp fault may be serviced before a higher priority interrupt or exception (e.g. nmi (non-maskable interrupt), debug break(#db), machine check (#mc), etc.).										
implication	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions.										
workaround	none identified.										
											
title	a write to an apic register sometimes may appear to have not occurred										
problem	with respect to the retirement of instructions, stores to the uncacheable memory- based apic register space are handled in a non-synchronized way. for example if an instruction that masks the interrupt flag, e.g. cli, is executed soon after an uncacheable write to the task priority register (tpr) that lowers the apic priority, the interrupt masking operation may take effect before the actual priority has been lowered. this may cause interrupts whose priority is lower than the initial tpr, but higher than the final tpr, to not be serviced until the interrupt enabled flag is finally set, i.e. by sti instruction. interrupts will remain pending and are not lost.										
implication	in this example the processor may allow interrupts to be accepted but may delay their service.										
workaround	this non-synchronization can be avoided by issuing an  apic  register read  after the apic register write. this will force the store to the apic register before any subsequent instructions are executed. no commercial operating system is known to be impacted by this erratum.										
											
title	the processor may report a #ts instead of a #gp fault										
problem	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss exception) instead of a #gp fault (general protection exception).										
implication	operation systems that access a busy tss may get invalid tss fault instead of a #gp fault. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	writing the local vector table (lvt) when an interrupt is pending may cause an unexpected interrupt										
problem	if a local interrupt is pending when the lvt entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.										
implication	an interrupt may immediately be generated with the new vector when a lvt entry is written, even if the new lvt entry has the mask bit set. if there is no interrupt service routine (isr) set up for that vector the system will gp fault. if the isr does not do an end of interrupt (eoi) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.										
workaround	any vector programmed into an lvt entry must have an isr associated with it,   even if that vector was programmed as masked. this isr routine must do an eoi to clear any unexpected interrupts that may occur.  the isr associated with the spurious vector does not generate an eoi, therefore the spurious vector should not be used when writing the lvt.										
											
title	using 2m/4m pages when a20m# is asserted may result in incorrect address translations										
problem	an external a20m# pin if enabled forces address bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. however, if all of the following conditions are met, address bit 20 may not be masked.  paging is enabled a linear address has bit 20 set the address references a large page a20m# is enabled										
implication	when a20m# is enabled and an address references a large page the resulting translated physical address may be incorrect. this erratum has not been observed with any commercially available operating system.										
workaround	operating systems should not allow a20m# to be enabled if the masking of   address bit 20 could be applied to an address that references a large page. a20m# is normally only used with the first megabyte of memory.										
											
title	premature execution of a load operation prior to exception handler invocation										
problem	if any of the below circumstances occur it is possible that the load portion of the instruction will have executed before the exception handler is entered.  if an instruction that performs a memory load causes a code segment limit violation if a waiting floating-point instruction or mmx instruction that performs a memory load has a floating-point exception pending if an mmx or sse instruction that performs a memory load and has either cr0.em=1 (emulation bit set), or a floating-point top-of-stack (fp tos) not equal to 0, or a dna exception pending										
implication	in normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, nor from the restart and subsequent re-execution of that instruction by the exception handler. if the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the side-effect.										
workaround	code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory.										
											
title	incorrect address computed for last byte of fxsave/fxrstor image leads to partial memory update										
problem	a partial memory state save of the 512-byte fxsave image or a partial memory state restore of the fxrstor image may occur if a memory address exceeds the 64kb   limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4gb limit while the processor is operating in 32-bit mode.										
implication	fxsave/fxrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.										
workaround	software should avoid memory accesses that wrap around the respective 16-bit  and 32-bit mode memory limits.										
											
title	values for lbr/bts/btm will be incorrect after an exit from smm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect.  note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.										
workaround	none identified.										
											
title	fp inexact-result exception flag may not be set										
problem	when the result of a floating-point operation is not exactly representable in the destination format (1/3 in binary form, for example), an inexact-result (precision) exception occurs. when this occurs, the pe bit (bit 5 of the fpu status word) is normally set by the processor. under certain rare conditions, this bit may not be set when this rounding occurs. however, other actions taken by the processor (invoking the software exception handler if the exception is unmasked) are not affected. this erratum can only occur if the floating-point operation which causes the precision exception is immediately followed by one of the following instructions: fst m32real fst m64real fstp m32real fstp m64real fstp m80real| fist m16int fist m32int fistp m16int| fistp m32int fistp m64int  note that even if this combination of instructions is encountered, there is also a dependency on the internal pipelining and execution state of both instructions in the processor.										
implication	inexact-result exceptions are commonly masked or ignored by applications, as it happens frequently, and produces a rounded result acceptable to most applications. the pe bit of the fpu status word may not always be set upon receiving an inexact- result exception. thus, if these exceptions are unmasked, a floating-point error exception handler may not recognize that a precision exception occurred. note that this is a “sticky” bit, i.e., once set by an inexact-result condition, it remains set until cleared by software.										
workaround	this condition can be avoided by inserting two non-floating-point instructions between the two floating-point instructions.										
											
title	mov to/from debug registers causes debug exception										
problem	when in v86 mode, if a mov instruction is executed to/from debug register, a general-protection exception (#gp) should be generated. however, in the case when the general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.										
implication	with debug-register protection enabled (i.e., the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception will be generated instead of the expected general-protection fault.										
workaround	in general, operating systems do not set the gd bit when they are in v86 mode.										
											
title	sysenter/sysexit instructions can implicitly load “null segment selector” to ss and cs registers										
problem	according to the processor specification, attempting to load a null segment selector into the cs and ss segment registers should generate a general protection fault (#gp). although loading a null segment selector to the other segment registers is allowed, the processor will generate an exception when the segment register holding a null selector is used to access memory. however, the sysenter instruction can implicitly load a null value to the ss segment selector. this can occur if the value in sysenter_cs_msr is between fff8h and fffbh when the sysenter instruction is executed. this behavior is part of the sysenter/sysexit instruction definition; the content of the system_cs_msr is always incremented by 8 before it is loaded into the ss. this operation will set the null bit in the segment selector if a null result is generated, but it does not generate a #gp on the sysenter instruction itself. an exception will be generated as expected when the ss register is used to access memory, however. the sysexit instruction will also exhibit this behavior for both cs and ss when executed with the value in sysenter_cs_msr between fff0h and fff3h, or between ffe8h and ffebh, inclusive.										
implication	these instructions are intended for operating system use. if this erratum occurs (and the os does not ensure that the processor never has a null segment selector in the ss or cs segment registers), the processor’s behavior may become unpredictable, possibly resulting in system failure.										
workaround	do not initialize the system_cs_msr with the values between fff8h and fffbh, fff0h and fff3h, or ffe8h and ffebh before executing sysenter or sysexit.										
											
title	the bs flag in dr6 may be set for non-single-step #db exception										
problem	dr6 bs (single step, bit 14) flag may be incorrectly set when the tf (trap flag, bit 8) of the eflags register is set, and a #db (debug exception) occurs due to one of the following:  dr7 gd (general detect, bit 13) being bit set; int1 instruction; code breakpoint										
implication	the bs flag may be incorrectly set for non-single-step #db exception.										
workaround	none identified.										
											
title	fault on enter instruction may result in unexpected values on stack frame										
problem	the enter instruction is used to create a procedure stack frame. due to this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).										
implication	data in the created stack frame may be altered following a fault on the enter instruction. please refer to "procedure calls for block-structured languages" in ia- 32 intel® architecture software developer’s manual, vol. 1, basic architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3. faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	unaligned accesses to paging structures may cause the processor to hang										
problem	when an unaligned access is performed on paging structure entries, accessing a portion of two different entries simultaneously, the processor may live lock.										
implication	when this erratum occurs, the processor may live lock causing a system hang.										
workaround	do not perform unaligned accesses on paging structure entries.										
											
title	vlpg operation for large (2m/4m) pages may be incomplete under certain conditions										
problem	the invlpg instruction may not completely invalidate translation look-aside buffer (tlb) entries for large pages (2m/4m) when both of the following conditions exist:  address range of the page being invalidated spans several memory type range registers (mtrrs) with different memory types specified invlpg operation is preceded by a page assist event (page fault (#pf) or an access that results in either a or d bits being set in a page table entry (pte))										
implication	stale translations may remain valid in tlb after a pte update resulting in unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure that the memory type specified in the mtrrs is the same    for the entire address range of the large page.										
											
title	page access bit may be set prior to signaling a code segment limit fault										
problem	if code segment limit is set close to the end of a code page, then due to this erratum the memory page access bit (a bit) may be set for the subsequent page prior to general protection fault on code segment limit.										
implication	when this erratum occurs, a non-accessed page which is present in memory and follows a page that contains the code segment limit may be tagged as accessed.										
workaround	erratum can be avoided by placing a guard page (non-present or non-executable page) as the last page of the segment or after the page that includes the code segment limit.										
											
title	eflags, cr0, cr4 and the exf4 signal may be incorrect after shutdown										
problem	when the processor is going into shutdown due to an rsm inconsistency failure, eflags, cr0 and cr4 may be incorrect. in addition the exf4 signal may still be asserted. this may be observed if the processor is taken out of shutdown by nmi#.										
implication	a processor that has been taken out of shutdown may have an incorrect eflags, cr0 and cr4. in addition the exf4 signal may still be asserted.										
workaround	none identified.										
											
title	store ordering may be incorrect between wc and wp memory types										
problem	according to intel® 64 and ia-32 intel architecture software developer's manual, volume 3a "methods of caching available", wp (write protected) stores should drain the wc (write combining) buffers in the same way as uc (uncacheable) memory type stores do. due to this erratum, wp stores may not drain the wc buffers.										
implication	memory ordering may be violated between wc and wp stores.										
workaround	none identified.										
											
title	performance monitoring event fp_mmx_trans_to_mmx may not count some transitions										
problem	performance monitor event fp_mmx_trans_to_mmx (event cch, umask 01h) counts transitions from x87 floating point (fp) to mmx™ instructions. due to this erratum, if only a small number of mmx instructions (including emms) are executed immediately after the last fp instruction, a fp to mmx transition may not be counted.										
implication	the count value for performance monitoring event fp_mmx_trans_to_mmx may be lower than expected. the degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	corruption of cs segment register during rsm while transitioning from real mode										
problem	during the transition from real mode to protected mode, if an smi (system management interrupt) occurs between the mov to cr0 that sets pe (protection enable, bit 0) and the first far jmp, the subsequent rsm (resume from system management mode) may cause the lower two bits of cs segment register to be corrupted.										
implication	the corruption of the bottom two bits of the cs segment register will have no impact unless software explicitly examines the cs segment register between enabling protected mode and the first far jmp. intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, part 1, in the section titled "switching to protected mode" recommends the far jmp immediately follows the write to cr0 to enable protected mode. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	bus locks and smc detection may cause the processor to hang temporarily										
problem	the processor may temporarily hang in an hyper-threading technology enabled system if one logical processor executes a synchronization loop that includes one or more locks and is waiting for release by the other logical processor. if the releasing logical processor is executing instructions that are within the detection range of the self -modifying code (smc) logic, then the processor may be locked in the synchronization loop until the arrival of an interrupt or other event.										
implication	if this erratum occurs in an ht technology enabled system, the application may temporarily stop making forward progress. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	memory aliasing of pages as uncacheable memory type and write back (wb) may hang the system										
problem	when a page is being accessed as either uncacheable (uc) or write combining (wc) and wb, under certain bus and memory timing conditions, the system may loop in a continual sequence of uc fetch, implicit writeback, and request for ownership (rfo) retries.										
implication	this erratum has not been observed in any commercially available operating system or application. the aliasing of memory regions, a condition necessary for this erratum to occur, is documented as being unsupported in the ia-32 intel® architecture software developer's manual, volume 3, section 10.12.4, programming the pat. however, if this erratum occurs the system may hang.										
workaround	the pages should not be mapped as either uc or wc and wb at the same time.										
											
title	data breakpoints on the high half of a floating point line split may not be captured										
problem	when a floating point load which splits a 64-byte cache line gets a floating point stack fault, and a data breakpoint register maps to the high line of the floating point load, internal boundary conditions exist that may prevent the data breakpoint from being captured.										
implication	when this erratum occurs, a data breakpoint will not be captured.										
workaround	none identified.										
											
title	mov cr3 performs incorrect reserved bit checking when in pae paging										
problem	the mov cr3 instruction should perform reserved bit checking on the upper unimplemented address bits. this checking range should match the address width reported by cpuid instruction 0x8000008. this erratum applies whenever pae is enabled.										
implication	software that sets the upper address bits on a mov cr3 instruction and expects a fault may fail. this erratum has not been observed with commercially available software.										
workaround	none identified.										
											
title	vmentry from 64-bit host to 32-bit guest may cause ierr# with hyper-threading technology enabled										
problem	when transitioning from a 64-bit host environment to a 32-bit guest environment via a vmentry, internal conditions in a processor with hyper- threading enabled may cause a speculative page-table walk to be prematurely terminated, resulting in a processor hang and the assertion of ierr#.										
implication	an ierr# may occur on vmentry from a 64-bit to a 32-bit environment with hyper-threading enabled.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	fxrstor may not restore non-canonical effective addresses on processors with intel® extended memory 64 technology (intel® em64t) enabled										
problem	if an x87 data instruction has been executed with a non-canonical effective address, fxsave may store that non-canonical fp data pointer (fdp) value into the save image. an fxrstor instruction executed with 64-bit operand size may signal a general protection fault (#gp) if the fdp or fp instruction pointer (fip) is in non-canonical form.										
implication	when this erratum occurs, intel em64t enabled systems may encounter an unintended #gp fault.										
workaround	software should avoid using non-canonical effective addressing in em64t enabled processors. bios can contain a workaround for this										
											
title	a push of esp that faults may zero the upper 32 bits of rsp										
problem	in the event that a push esp instruction, that faults, is executed in compatibility mode, the processor will incorrectly zero upper 32-bits of rsp.										
implication	a push of esp in compatibility mode will zero the upper 32-bits of rsp. due to this erratum, this instruction fault may change the contents of rsp. this erratum has not been observed in commercially available software.										
workaround	none identified.										
											
title	checking of page table base address may not match the address bit width supported by the platform										
problem	if the page table base address, included in the page map level-4 table, page- directory pointer table, page-directory table or page table, exceeds the physical address range supported by the platform (e.g. 36-bit) and it is less than the implemented address range (e.g. 40-bit), the processor does not check if the address is invalid.										
implication	if software sets such invalid physical address in those tables, the processor does not generate a page fault (#pf) upon access to that virtual address, and the access results in an incorrect read or write. if bios provides only valid physical address ranges to the operating system, this erratum will not occur.										
workaround	bios must provide valid physical address ranges to the operating system.										
											
title	with tf (trap flag) asserted, fp instruction that triggers an unmasked fp exception may take single step trap before retirement of instruction										
problem	if an fp instruction generates an unmasked exception with the eflags.tf=1, it is possible for external events to occur, including a transition to a lower power state. when resuming from the lower power state, it may be possible to take the single step trap before the execution of the original fp instruction completes.										
implication	a single step trap will be taken when not expected.										
workaround	none identified.										
											
title	bts (branch trace store) and pebs (precise event based sampling) may update memory outside the bts/pebs buffer										
problem	if the bts/pebs buffer is defined such that: the difference between bts/pebs buffer base and bts/pebs absolute maximum is not an integer multiple of the corresponding record sizes bts/pebs absolute maximum is less than a record size from the end of the virtual address space the record that would cross bts/pebs absolute maximum will also continue past the end of the virtual address space a bts/pebs record can be written that will wrap at the 4g boundary (ia32) or 2^64 boundary (em64t mode), and write memory outside of the bts/pebs buffer.										
implication	software that uses bts/pebs near the 4g boundary (ia32) or 2^64 boundary (em64t mode), and defines the buffer such that it does not hold an integer multiple of records can update memory outside the bts/pebs buffer.										
workaround	define bts/pebs buffer such that bts/pebs absolute maximum minus bts/pebs buffer base is integer multiple of the corresponding record sizes as recommended in the ia-32 intel® architecture software developer’s manual, volume 3.										
											
title	control register 2 (cr2) can be updated during a rep movs/stos instruction with fast strings enabled										
problem	under limited circumstances while executing a rep movs/stos string instruction, with fast strings enabled, it is possible for the value in cr2 to be changed as a result of an interim paging event, normally invisible to the user. any higher priority architectural event that arrives and is handled while the interim paging event is occurring may see the modified value of cr2.										
implication	the value in cr2 is correct at the time that an architectural page fault is signaled. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	rep stos/movs instructions with rcx >=2^32 may cause a system hang										
problem	in ia-32e mode using intel em64t-enabled processors, executing a repeating string instruction with the iteration count greater than or equal to 2^32 and a pending event may cause the rep stos/movs instruction to live lock and hang.										
implication	when this erratum occurs, the processor may live lock and result in a system hang. intel has not observed this erratum with any commercially available software.										
workaround	do not use strings larger than 4 gb.										
											
title	a 64-bit value of linear instruction pointer (lip) may be reported incorrectly in the branch trace store (bts) memory record or in the precise event based sampling (pebs) memory record										
problem	on a processor supporting intel® em64t, if an instruction fetch wraps around the 4g boundary in compatibility mode, the 64-bit value of lip in the bts memory record will be incorrect (upper 32 bits will be set to ffffffffh when they should be 0). if a pebs event occurs on an instruction whose last byte is at memory location ffffffffh, the 64-bit value of lip in the pebs record will be incorrect (upper 32 bits will be set to ffffffffh when they should be 0).										
implication	intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	access to an unsupported address range in uniprocessor (up) or dual-processor (dp) systems supporting intel® virtualization technology may not trigger appropriate actions										
problem	when using processors supporting intel® virtualization technology and configured as dual- or single-processor-capable (i.e. not multiprocessor- capable), the processor should perform address checks using a maximum physical address width of 36. instead, these processors will perform address checks using a maximum physical address width of 40.										
implication	due to this erratum, actions which are normally taken upon detection of an unsupported address may not occur. software which does not attempt to access unsupported addresses will not experience this erratum.										
workaround	none identified.										
											
title	vm exit due to a mov from cr8 may cause an unexpected memory access										
problem	in a system supporting intel® virtualization technology and intel® extended memory 64 technology, if the "cr8-store exiting" bit in the processor-based vm-execution control field is set and the "use tpr shadow" bit is not set, a mov from cr8 instruction executed by a virtual machine extensions (vmx) guest that causes a vm exit may generate an unexpected memory access.										
implication	when this erratum occurs, a read access to unexpected address may be issued to the chipset. subsequent side effects are dependent on chipset operation and may include system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the processor may incorrectly respond to machine checks during vm entry/exit transitions										
problem	in systems supporting intel® virtualization technology, when machine checks are encountered during vm entry/exit transitions, the processor is expected to respond with a vm exit (if a machine check occurs during vm entry) or abort (if a machine check occurs during vm exit). as a result of this erratum when machine checks occur during vm entry/exit transitions the processor will attempt to service the machine check which may lead to ierr-shutdown or execution of the machine check handler, dependent on the cr4.mce setting.										
implication	the system may end up in the shutdown state if cr4.mce is not set.										
workaround	none identified.										
											
title	power down requests may not be serviced if a power down transition is interrupted by an in-target probe event in the presence of a specific type of vm exit										
problem	in a system supporting intel® virtualization technology, the processor may service a pended vm exit prior to completely exiting out of a low power state when the following sequences of events occur: chip-wide power down transition occurs and vm exit due to a vmlaunch, vmresume, sti, popf, popfd, or iret instruction is pended and chip-wide power down transition is interrupted by an in-target probe event.										
implication	due to this erratum the processor may not recognize further stpclk# assertions, tm1, tm2, or enhanced intel speedstep® technology. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	vm exit due to tpr shadow below threshold may improperly set and cause "blocking by sti" actions										
problem	in a system supporting intel® virtualization technology and intel® em64t, the “blocking by sti” bit of the interruptibility-state field may be saved as 1 rather than 0. this erratum may occur when a sti instruction is executed directly prior to a mov to cr8 which results in a vm exit due to a reduction of the tpr shadow value below the tpr threshold.										
implication	when this erratum occurs, delivery of an interrupt may be delayed by one instruction.										
workaround	none identified.										
											
title	two correctable l2 cache errors in close proximity may cause a system hang										
problem	if two correctable l2 cache errors are detected in close proximity to each other, a livelock may occur as a result of the processor being unable to resolve this condition.										
implication	when this erratum occurs, the processor may livelock and result in a system hang. intel has only observed this erratum while injecting cache errors in simulation..										
workaround	none identified.										
											
title	a vm exit due to smi or init in parallel with a pending fp exception may not correctly clear the interruptibility state bits										
problem	when a pending fp exception is ready to be taken, a vm exit due to smi or init may not clear blocking by sti and/or blocking by mov ss bits correctly in virtual-machine control structure (vmcs) as expected..										
implication	a vm exit due to smi or init may show incorrect sti and/or mov ss blocking state in vm-exit interruptibility field.										
workaround	it is possible for the bios to contain a workaround for this erratum. .										
											
title	processor may hang with a 25% or less stpclk# duty cycle										
problem	if a system de-asserts stpclk# at a 25% or less duty cycle and the processor thermal control circuit (tcc) on-demand clock modulation is active, the processor may hang. this erratum does not occur under the automatic mode of the tcc.										
implication	when this erratum occurs, the processor may hang.										
workaround	if use of the on-demand mode of the processor's tcc is desired in conjunction with stpclk# modulation, then assure that stpclk# is not asserted at a 25% duty cycle.										
											
title	attempting to use an ldt entry when the ldtr has been loaded with an unusable segment may cause unexpected memory accesses										
problem	in a system supporting intel® virtualization technology, the processor may incorrectly vm exit under the following conditions: interrupt-window-exiting vm-execution control is set rflags[if]=1 chipwide powerdown transition requests occur when the processor is in wait-for-sipi or shutdown states										
implication	due to this erratum, interrupt-window-exiting vm exits may take the logical processor out of wait-for-sipi and shutdown states. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	machine check exceptions may not update last-exception record msrs (lers)										
problem	the last-exception record msrs (lers) may not get updated when machine check exceptions occur										
implication	when this erratum occurs, the ler may not contain information relating to the machine check exception. they will contain information relating to the exception prior to the machine check exception.										
workaround	none identified										
											
title	vm entry/exit writes to lstar/syscall_flag msr's may cause incorrect data to be written to bits [63:32]										
problem	incorrect msr data in bits [63:32] may be observed in the following two cases: when ecx contains 0xc0000084 and a vm entry/exit writes the ia32_cr_lstar msr (msr address 0xc0000082) bits [63:32] of the data may be zeroed when ecx does not contain 0xc0000084 and a vm entry/exit writes the ia32_cr_syscall_flag_mask msr (msr address 0xc0000084) bits [63:32] of the data may not be zeroed										
implication	bits [63:32] of the affected msrs may contain the wrong data after a vm exit/entry which loads the affected msr.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	writing the local vector table (lvt) when an interrupt is pending may cause an unexpected interrupt										
problem	if a local interrupt is pending when the lvt entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.										
implication	an interrupt may immediately be generated with the new vector when a lvt entry is written, even if the new lvt entry has the mask bit set.	if there is no interrupt service routine (isr) set up for that vector the system will gp fault.	if the isr does not do an end of interrupt (eoi) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.								
workaround	any vector programmed into an lvt entry must have an isr associated with it, even if that vector was programmed as masked. this isr routine must do an eoi to clear any unexpected interrupts that may occur. the isr associated with the spurious vector does not generate an eoi, therefore the spurious vector should not be used when writing the lvt.										
											
title	at a bus ratio of 13:1, rcnt and address parity may be incorrect										
problem	in a system running at the 13:1 bus ratio, rcnt[0] ( addr# [28], phase b) may report incorrect information.										
implication	rcnt[0] may contain incorrect information and cause address parity machine check errors.										
workaround	address parity should be disabled and rcnt information should be ignored at the bus ratio of 13:1.										
											
title	the execution of a vmptrld instruction may cause an unexpected memory access										
problem	in a system supporting intel® virtualization technology, executing vmptrld may cause a memory access to an address not referenced by the memory operand.										
implication	this erratum may cause unpredictable system behavior including system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the execution of vmptrld or vmread may cause an unexpected memory access										
problem	on processors supporting intel® virtualization technology, executing a vmptrld or a vmread instruction outside of vmx mode may result in a load to an unexpected address.										
implication	this erratum may cause a load to an unexpected memory address.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	on a “failed vm-entry” vm exit, the vmcs pointer may have incorrect value										
problem	on a “failed vm-entry” vm exit, the vmcs pointer may have incorrect value.										
implication	the value of the vmcs pointer may be incorrect and may result in unpredictable behavior after the "failed vm-entry”.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	during an enhanced halt or enhanced intel speedstep® technology ratio transition the system may hang										
problem	the bnr signal may not function properly during an enhanced halt or enhanced intel speedstep technology ratio transition.										
implication	the system may hang due to incorrect bnr signaling.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	l2 cache ecc machine check errors may be erroneously reported after an asynchronous reset# assertion										
problem	machine check status msrs may incorrectly report the following l2 cache ecc machine-check errors when cache transactions are in-flight and reset# is asserted: •instruction fetch errors (ia32_mc2_status with mca error code 153) •l2 data write errors (ia32_mc1_status with mca error code 145)										
implication	uncorrected or corrected l2 ecc machine check errors may be erroneously reported. intel has not observed this erratum on any commercially available system.										
workaround	when a real run-time l2 cache ecc machine check occurs, a corresponding valid error will normally be logged in the ia32_mc0_status register. bios may clear ia32_mc2_status and/or ia32_mc1_status for these specific errors when ia32_mc0_status does not have its val flag set.										
											
title	vmcall to activate dual-monitor treatment of smis and smm ignores reserved bit settings in vm-exit control field										
problem	processors supporting intel® virtualization technology can execute vmcall from within the virtual machine monitor (vmm) to activate dual-monitor treatment of smis and smm. due to this erratum, if reserved bits are set to values inconsistent with vmx capability msrs, vmcall may not vmfail.										
implication	vmcall executed to activate dual-monitor treatment of smis and smm may not vmfail due to incorrect reserved bit settings in vm-exit control field.										
workaround	software should ensure that all vmcs reserved bits are set to values consistent with vmx capability msrs.										
											
title	using 2m/4m pages when a20m# is asserted may result in incorrect address translations										
problem	an external a20m# pin if enabled forces address bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. however, if all of the following conditions are met, address bit 20 may not be masked: paging is enabled a linear address has bit 20 set the address references a large page a20m# is enabled										
implication	when a20m# is enabled and an address references a large page the resulting translated physical address may be incorrect. this erratum has not been observed with any commercially available operating system.										
workaround	operating systems should not allow a20m# to be enabled if the masking of address bit 20 could be applied to an address that references a large page. a20m# is normally only used with the first megabyte of memory.										
											
title	writing shared unaligned data that crosses a cache line without proper semaphores or barriers may expose a memory ordering issue										
problem	software which is written so that multiple agents can modify the same shared unaligned memory location at the same time may experience a memory ordering issue if multiple loads access this shared data shortly thereafter. exposure to this problem requires the use of a data write which spans a cache line boundary.										
implication	this erratum may cause loads to be observed out of order. intel has not observed this erratum with any commercially available software or system.										
workaround	software should ensure at least one of the following is true when modifying shared data by multiple agents:										
											
title	the ia32_mc0_status and ia32_mc1_status overflow bit is not set when multiple un-correctable machine check errors occur at the same time										
problem	when two enabled mc0/mc1 un-correctable machine check errors are detected in the same bank in the same internal clock cycle, the highest priority error will be logged in ia32_mc0_status / ia32_mc1_status register, but the overflow bit may not be set.										
implication	the highest priority error will be logged and signaled if enabled, but the overflow bit in the ia32_mc0_status/ ia32_mc1_status register may not be set.										
workaround	none identified.										
											
title	iret under certain conditions may cause an unexpected alignment check exception										
problem	in ia-32e mode, it is possible to get an alignment check exception (#ac) on the iret instruction even though alignment checks were disabled at the start of the iret. this can only occur if the iret instruction is returning from cpl3 code to cpl3 code. irets from cpl0/1/2 are not affected. this erratum can occur if the eflags value on the stack has the ac flag set, and the interrupt handler's stack is misaligned. in ia-32e mode, rsp is aligned to a 16-byte boundary before pushing the stack frame.										
implication	in ia-32e mode, under the conditions given above, an iret can get a #ac even if alignment checks are disabled at the start of the iret. this erratum can only be observed with a software generated stack frame.										
workaround	software should not generate misaligned stack frames for use with iret.										
											
title	processor may fault when the upper 8 bytes of segment selector is loaded from a far jump through a call gate via the local descriptor table										
problem	in ia-32e mode of the intel em64t processor, control transfers through a call gate via the local descriptor table (ldt) that uses a 16-byte descriptor, the upper 8-byte access may wrap and access an incorrect descriptor in the ldt. this only occurs on an ldt with a limit>0x10008 with a 16-byte descriptor that has a selector of 0xfffc.										
implication	in the event this erratum occurs, the upper 8-byte access may wrap and access an incorrect descriptor within the ldt, potentially resulting in a fault or system hang. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	the processor may issue front side bus transactions up to 6 clocks after reset# is asserted										
problem	the processor may issue transactions beyond the documented 3 front side bus (fsb) clocks and up to 6 fsb clocks after reset# is asserted in the case of a warm reset. a warm reset is where the chipset asserts reset# when the system is running.										
implication	the processor may issue transactions up to 6 fsb clocks after the reset# is asserted										
workaround	none identified.										
											
title	front side bus machine checks may be reported as a result of on- going transactions during warm reset										
problem	processor front side bus (fsb) protocol/signal integrity machine checks may be reported if the transactions are initiated or in-progress during a warm reset. a warm reset is where the chipset asserts reset# when the system is running.										
implication	the processor may log fsb protocol/signal integrity machine checks if transactions are allowed to occur during reset# assertions.										
workaround	bios may clear fsb protocol/signal integrity machine checks for systems/chipsets which do not block new transactions during reset# assertions.										
											
title	nmi-blocking information recorded in vmcs may be incorrect after a #gp on an iret instruction										
problem	in a system supporting intel® virtualization technology, the nmi blocking bit in the interruption-information field in the guest vmcs may be set incorrectly. this erratum will happen if a vmexit occurs for a #gp fault on an iret instruction due to an eip that violates the segment limit or is non- canonical.										
implication	if this erratum occurs, monitor software may not be able to handle #gp and then inject an nmi since monitor software does not have information about whether nmis are blocked in the guest.										
workaround	monitor software can workaround this bug by avoiding injection of nmi after										
											
title	vmlaunch/vmresume may not fail when vmcs is programmed to cause vm exit to return to a different mode										
problem	vmlaunch/vmresume instructions may not fail if the value of the “host address-space size” vm-exit control differs from the setting of ia32_efer.lma.										
implication	programming the vmcs to allow the monitor to be in different modes prior to vmlaunch/vmresume and after vm-exit may result in undefined behavior.										
workaround	software should ensure that "host address-space size" vm-exit control has the same value as ia32_efer.lma at the time of vmlaunch/vmresume.										
											
title	a continuous loop executing bus lock transactions on one logical processor may prevent another logical processor from acquiring resources										
problem	in a system supporting hyper-threading technology, when one hardware thread is in a continuous loop executing bus locks plus other traffic, the other hardware thread may be prevented from acquiring resources to also execute a lock.										
implication	this erratum may cause system hang or unpredictable system behavior. this erratum has not been observed with commercially available software.										
workaround	none identified.										
											
title	an unexpected memory access may be issued during execution of the wrmsr instruction under certain conditions										
problem	the processor may generate an unexpected memory access during the wrmsr instruction under certain conditions.										
implication	when this erratum occurs, an unexpected read may be issued on fsb. subsequent side effects are dependent on platform operation and may include a system hang. this erratum has not been observed on any commercial operating system.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	combining some processors with intel 945® chipsets can lead to unpredictable system behavior										
problem	some processors with 800 mhz front side bus (fsb), when used in combination with a motherboard based on the intel 945® chipset, may observe fsb bit errors which may result in unpredictable system behavior.										
implication	due to this erratum, fsb marginality is observed during processor core to core transactions as well as during read transactions driven by the memory controller hub (mch) leading to unpredictable system behavior.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	none										
problem	if a vm exit occurs while the processor is in ia-32e mode and the “host address-space size” vm-exit control is 0, a vmx abort should occur. due to this erratum, the expected vmx aborts may not occur and instead the vm exit will occur normally. the conditions required to observe this erratum are a vm entry that returns from smm with the “ia-32e guest” vm-entry control set to 1 in the smm vmcs and the “host address-space size” vm-exit control cleared to 0 in the executive vmcs.										
implication	a vm exit will occur when a vmx abort was expected.										
workaround	an smm vmm should always set the “ia-32e guest” vm-entry control in the smm vmcs to be the value that was in the lma bit (ia32_efer.lma.lma[bit 10]) in the ia32_efer msr (c0000080h) at the time of the last smm vm exit. if this guideline is followed, that value will be 1 only if the “host address-space size” vm-exit control is 1 in the executive vmcs.										
											
title	none.										
problem	during system reset, there is insufficient time for handshake between ich and gmch lvds logic. as a result, timing from panel backlight enable going low to lvds data going low (tx) and timing from lvds data going low to panel vcc enable going low (t3) do not match the programmed values. panel backlight enable (lbklt_en), panel vcc enable (lvdd_en) and lvds data lines go low at the same time.										
implication	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss exception) instead of a #gp fault (general protection exception).										
workaround	none.										
											
title	writing the local vector table (lvt) when an interrupt is pending may cause an unexpected interrupt										
problem	if a local interrupt is pending when the lvt entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.										
implication	an interrupt may immediately be generated with the new vector when a lvt entry is written, even if the new lvt entry has the mask bit set. if there is no interrupt service routine (isr) set up for that vector the system will gp fault. if the isr does not do an end of interrupt (eoi) the bit for the vector is left set in the in-service register and mask all interrupts at the same or lower priority.										
workaround	any vector programmed into an lvt entry must have an isr associated with it, even if that vector was programmed as masked. this isr routine must do an eoi to clear any unexpected interrupts that may occur. the isr associated with the spurious vector does not generate an eoi; therefore the spurious vector should not be used when writing the lvt.										
											
title	mov to/from debug registers causes debug exception										
problem	when in v86 mode, if a mov instruction is executed to/from a debug registers, a general-protection exception (#gp) should be generated. however, in the case when the general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.										
implication	with debug-register protection enabled (i.e., the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception is generated instead of the expected general-protection fault.										
workaround	in general, operating systems do not set the gd bit when they are in v86 mode. the gd bit is generally set and used by debuggers. the debug exception handler should check that the exception did not occur in v86 mode before continuing. if the exception did occur in v86 mode, the exception may be directed to the general-protection exception handler.										
											
title	a write to an apic register sometimes may appear to have not occurred										
problem	with respect to the retirement of instructions, stores to the uncacheable memory based apic register space are handled in a non-synchronized way. for example if an instruction that masks the interrupt flag, for example cli, is executed soon after an uncacheable write to the task priority register (tpr) that lowers the apic priority, the interrupt masking operation may take effect before the actual priority has been lowered. this may cause interrupts whose priority is lower than the initial tpr, but higher than the final tpr, to not be serviced until the interrupt enabled flag is finally set, i.e. by sti instruction. interrupts will remain pending and are not lost.										
implication	in this example the processor may allow interrupts to be accepted but may delay their service.										
workaround	this non-synchronization can be avoided by issuing an apic register read after the apic register write. this will force the store to the apic register before any subsequent instructions are executed. no commercial operating system is known to be impacted by this erratum.										
											
title	using 2m/4m pages when a20m# is asserted may result in incorrect address translations										
problem	an external a20m# pin if enabled forces address bit-20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. however, if all of the following conditions are met, address bit-20 may not be masked. paging is enabled a linear address has bit-20 set the address references a large page a20m# is enabled										
implication	when a20m# is enabled and an address references a large page the resulting translated physical address may be incorrect. this erratum has not been observed with any commercially available operating system.										
workaround	operating systems should not allow a20m# to be enabled if the masking of address bit-20 could be applied to an address that references a large page. a20m# is normally only used with the first megabyte of memory.										
											
title	value for lbr/bts/btm will be incorrect after an exit from smm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect. note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.										
workaround	none.										
											
title	incorrect address computed for last byte of fxsave/fxrstor image leads to partial memory update										
problem	a partial memory state save of the 512-byte fxsave image or a partial memory state restore of the fxrstor image may occur if a memory address exceeds the 64kb limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4gb limit while the processor is operating in 32-bit mode.										
implication	fxsave/fxrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.										
workaround	software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits.										
											
title	a thermal interrupt is not generated when the current temperature is invalid										
problem	when the dts (digital thermal sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (ia32_therm_status msr (019ch) bits [9,7]). due to this erratum, if the dts reaches an invalid temperature (as indicated ia32_therm_status msr bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.										
implication	when the temperature reaches an invalid temperature the cpu does not generate a thermal interrupt even if a programmed threshold is crossed.										
workaround	none.										
											
title	programming the digital thermal sensor (dts) threshold may cause unexpected thermal interrupts										
problem	software can enable dts thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. when programming dts value, the previous dts threshold may be crossed. this will generate an unexpected thermal interrupt.										
implication	software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold.										
workaround	in the acpi/os implement a workaround by temporarily disabling the dts threshold interrupt before updating the dts threshold value.										
											
title	returning to real mode from smm with eflags.vm set may result in unpredictable system behavior										
problem	returning back from smm mode into real mode while eflags.vm is set in smram may result in unpredictable system behavior.										
implication	if smm software changes the value of the eflags.vm in smram, it may result in unpredictable system behavior. intel has not observed this behavior in commercially available software.										
workaround	smm software should not change the value of eflags.vm in smram.										
											
title	fault on enter instruction may result in unexpected value on stack frame										
problem	the enter instruction is used to create a procedure stack frame. due to this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected value (i.e. residual stack data as a result of processing the fault).										
implication	data in the created stack frame may be altered following a fault on the enter instruction. please refer to "procedure calls for block-structured languages" in ia-32 intel® architecture software developer’s manual, vol. 1, basic architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3. faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. intel has not observed this erratum on any commercially available software.										
workaround	none.										
											
title	with tf (trap flag) asserted, fp instruction that triggers an unmasked fp exception may take single step trap before retirement of instruction										
problem	if an fp instruction generates an unmasked exception with the eflags.tf=1, it is possible for external events to occur, including a transition to a lower power state. when resuming from the lower power state, it may be possible to take the single step trap before the execution of the original fp instruction completes.										
implication	a single step trap is taken when not expected.										
workaround	none.										
											
title	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception   errata										
problem	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.										
implication	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software, or system.										
workaround	as recommended in the ia32 intel® architecture software developer’s manual, the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.										
											
title	code segment limit/canonical faults on rsm may be serviced before higher priority interrupts/exceptions and may push the wrong address onto the stack										
problem	normally, when the processor encounters a segment limit or canonical fault due to code execution, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. due to this erratum, if rsm (resume from system management mode) returns to execution flow that results in a code segment limit or canonical fault, the #gp fault may be serviced before a higher priority interrupt or exception (for example nmi (non-maskable interrupt), debug break(#db), machine check (#mc), etc.). if the rsm attempts to return to a non- canonical address, the address pushed onto the stack for this #gp fault may not match the non-canonical address that caused the fault.										
implication	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions. intel has not observed this erratum on any commercially available software.										
workaround	none.										
											
title	bts(branch trace store) and pebs(precise event based sampling) may update memory outside the bts/pebs buffer										
problem	if the bts/pebs buffer is defined such that: the difference between bts/pebs buffer base and bts/pebs absolute maximum is not an integer multiple of the corresponding record sizes bts/pebs absolute maximum is less than a record size from the end of the virtual address space the record that would cross bts/pebs absolute maximum will also continue past the end of the virtual address space  a bts/pebs record can be written that will wrap at the 4g boundary (ia32) or 264 boundary (em64t mode), and write memory outside of the bts/pebs buffer.										
implication	software that uses bts/pebs near the 4g boundary (ia32) or 264 boundary (em64t mode), and defines the buffer such that it does not hold an integer multiple of records can update memory outside the bts/pebs buffer.										
workaround	define bts/pebs buffer such that bts/pebs absolute maximum minus bts/pebs buffer base is integer multiple of the corresponding record sizes as recommended in the ia-32 intel® architecture software developer’s manual, volume 3.										
											
title	single step interrupts with floating point exception pending may be mishandled										
problem	in certain circumstances, when a floating point exception (#mf) is pending during single-step execution, processing of the single-step debug exception (#db) may be mishandled.										
implication	when this erratum occurs, #db is incorrectly handled as follows: #db is signaled before the pending higher priority #mf (interrupt 16) #db is generated twice on the same instruction										
workaround	none.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the intel architecture software developer's manual volume 3a: system programming guide, including a general protection fault (#gp) or other unexpected behaviors.										
workaround	in order to avoid this erratum, programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3a: system programming guide, section: handling self- and cross-modifying code.										
											
title	a page fault may not be generated when the ps bit is set to “1” in a pml4e or pdpte										
problem	on processors supporting intel® 64 architecture, the ps bit (page size, bit 7) is reserved in pml4es and pdptes. if the translation of the linear address of a memory access encounters a pml4e or a pdpte with ps set to 1, a page fault should occur. due to this erratum, ps of such an entry is ignored and no page fault will occur due to its being set.										
implication	software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.										
workaround	software should not set bit 7 in any pml4e or pdpte that has present bit (bit 0) set to “1”.										
											
title	io_smi indication in smram state save area may be set incorrectly										
problem	the io_smi bit in smram’s location 7fa4h is set to "1" by the cpu to indicate a system management interrupt (smi) occurred as the result of executing an instruction that reads from an i/o port. due to this erratum, the io_smi bit may be incorrectly set by: a smi that is pending while a lower priority event is executing a rep i/o read a i/o read that redirects to mwait										
implication	smm handlers may get false io_smi indication.										
workaround	the smm handler has to evaluate the saved context to determine if the smi was triggered by an instruction that read from an i/o port. the smm handler must not restart an i/o instruction if the platform has not been configured to generate a synchronous smi for the recorded i/o port address.										
											
title	writes to ia32_debugctl msr may fail when freeze_lbrs_on_pmi is set										
problem	when the freeze_lbrs_on_pmi, ia32_debugctl msr (1d9h) bit [11], is set, future writes to ia32_debugctl msr may not occur in certain rare corner cases. writes to this register by software or during certain processor operations are affected.										
implication	under certain circumstances, the ia32_debugctl msr value may not be updated properly and will retain the old value. intel has not observed this erratum with any commercially available software.										
workaround	do not set the freeze_lbrs_on_pmi bit of ia32_debugctl msr.										
											
title	address reported by machine-check architecture (mca) on l2 cache errors may be incorrect										
problem	when an l2 cache error occurs (error code 0x010a or 0x110a reported in ia32_mci_status msr bits [15:0]), the address is logged in the mca address register (ia32_mci_addr msr). under some scenarios, the address reported may be incorrect.										
implication	software should not rely on the value reported in ia32_mci_addr msr for l2 cache errors.										
workaround	none.										
											
title	performance monitoring event for outstanding bus requests ignores anythread bit										
problem	the performance monitoring event of outstanding bus requests will ignore the anythread bit (ia32_perfevtsel0 msr (186h)/ ia32_perfevtsel1 msr (187h) bit [21]) and will instead always count all transactions across all logical processors, even when anythread is clear.										
implication	the performance monitor count may be incorrect when counting only the current logical processor’s outstanding bus requests on a processor supporting hyper- threading technology.										
workaround	none identified.										
											
title	corruption of cs segment register during rsm while transitioning from real mode to protected mode										
problem	during the transition from real mode to protected mode, if an smi (system management interrupt) occurs between the mov to cr0 that sets pe (protection enable, bit 0) and the first far jmp, the subsequent rsm (resume from system management mode) may cause the lower two bits of cs segment register to be corrupted.										
implication	the corruption of the bottom two bits of the cs segment register will have no impact unless software explicitly examines the cs segment register between enabling protected mode and the first far jmp. intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, part 1, in the section titled "switching to protected mode" recommends the far jmp immediately follows the write to cr0 to enable protected mode. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	gp and fixed performance monitoring counters with anythread bit set may not accurately count only os or only usr events										
problem	a fixed or gp (general purpose) performance counter with the anythread bit (ia32_fixed_ctr_ctrl_msr (38dh) bit[2] for ia32_fixed_ctr0, bit[6] for ia32_fixed_ctr1, bit [10] for ia32_fixed_ctr2; ia32_perfevtsel0 msr (186h)/ ia32_perfevtsel1 msr (187h) bit [21]) set may not count correctly when counting only os (ring 0) events or only usr (ring>0) events. the counters will count correctly if they are counting both os and usr events or if the anythread bit is clear.										
implication	a performance monitor counter may be incorrect when it is counting for all logical processors on that core and not counting at all privilege levels. this erratum will only occur on processors supporting multiple logical processors per core.										
workaround	none identified.										
											
title	pmi request is not generated on a counter overflow if its ovf bit is already set in ia32_perf_global_status										
problem	if a performance counter overflows and software does not clear the corresponding ovf (overflow) bit in ia32_perf_global_status msr (38eh) then future overflows of that counter will not trigger pmi (performance monitoring interrupt) requests.										
implication	if software does not clear the ovf bit corresponding to a performance counter then future counter overflows may not cause pmi requests.										
workaround	software should clear the ia32_perf_global_status.ovf bit in the pmi handler.										
											
title	processor may use an incorrect translation if the tlbs contain two different translations for a linear address										
problem	the tlbs may contain both ordinary and large-page translations for a 4-kbyte range of linear addresses. this may occur if software modifies a pde (page-directory entry) that is marked present to set the ps bit (this changes the page size used for the address range). if the two translations differ with respect to page frame, permissions, or memory type, the processor may use a page frame, permissions, or memory type that corresponds to neither translation.										
implication	due to this erratum, software may not function properly if it sets the ps flag in a pde and also changes the page frame, permissions, or memory type for the linear addresses mapped through that pde.										
workaround	software can avoid this problem by ensuring that the tlbs never contain both ordinary and large-page translations for a linear address that differ with respect to page frame, permissions, or memory type.										
											
title	pebs record not updated when in probe mode										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflows of the counter can result in storage of a pebs record in the pebs buffer. due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new pebs record may not be added to the pebs buffer.										
implication	due to this erratum, the pebs buffer may not be updated by overflows that occur during probe mode.										
workaround	none.										
											
title	lbr/btm/bts information immediately after a transition from legacy/compatibility mode to 64-bit mode may be incorrect										
problem	if a transition from legacy/compatibility mode to 64-bit mode occurs and another branch event occurs before the first instruction executes (for example an external interrupt or trap) then any from address recorded by lbr (last branch record), btm (branch trace message) or bts (branch trace store) on that second event may incorrectly report the upper 32-bits as zero.										
implication	due to this erratum, bits 63:32 of the ‘from’ value for lbr/btm/bts may be improperly zeroed after a transition to 64 bite mode when the rip (instruction pointer register) is greater than 4 gigabyte.										
workaround	none identified. this erratum may be detected by a ‘from’ address having its upper 32-bits zero but its lower 32-bits matching the previous ‘to’ address recorded.										
											
title	pending x87 fpu exceptions (#mf) following sti may be serviced before higher priority interrupts										
problem	interrupts that are pending prior to the execution of the sti (set interrupt flag) instruction are normally serviced immediately after the instruction following the sti. an exception to this is if the following instruction triggers a #mf. in this situation, the interrupt should be serviced before the #mf. because of this erratum, if following sti, an instruction that triggers a #mf is executed while stpclk#, enhanced intel speedstep technology transitions or thermal monitor events occur, the pending #mf may be serviced before higher priority interrupts.										
implication	software may observe #mf being serviced before higher priority interrupts.										
workaround	none identified.										
											
title	benign exception after a double fault may not cause a triple fault shutdown										
problem	according to the intel® 64 and ia-32 architectures software developer’s manual, volume 3a, “exception and interrupt reference”, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. however contributory exceptions and page faults will continue to cause a triple fault shutdown.										
implication	if a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	ia32_mc1_status msr bit[60] does not reflect machine check error reporting enable correctly										
problem	ia32_mc1_status msr (405h) bit[60] (en- error enabled) is supposed to indicate whether the enable bit in the ia32_mc1_ctl msr (404h) was set at the time of the last update to the ia32_mc1_status msr. due to this erratum, ia32_mc1_status msr bit[60] instead reports the current value of the ia32_mc1_ctl msr enable bit.										
implication	ia32_mc1_status msr bit [60] may not reflect the correct state of the enable bit in the ia32_mc1_ctl msr at the time of the last update.										
workaround	none identified.										
											
title	lint0 assertion and de-assertion during an inactive state may cause unexpected operation when apic is disabled										
problem	an interrupt delivered via lint0 pins when the apic is hardware disabled (ia32_apic_base msr (1bh) bit [11] is cleared) will usually keep the pin asserted until after the interrupt is acknowledged. however, if lint0 is asserted and then de- asserted before the interrupt is acknowledged and both of the following are true: the apic is hardware disabled (ia32_apic_base msr bit [11] is clear) and the processor is in an inactive state that was requested by mwait, i/o redirection, vm-entry or rsm,  then the processor may operate incorrectly										
implication	due to this erratum, the processor may run unexpected code and/or generate an unexpected exception. intel has not observed this erratum with any commercially available software.										
workaround	if lint0 is used, it is recommended to either leave the apic enabled (ia32_apic_base msr bit [11] set to 1) or do not use mwait, i/o redirection, vm- entry or rsm to enter an inactive state.										
											
title	iret under certain conditions may cause an unexpected alignment check exception										
problem	in ia-32e mode, it is possible to get an alignment check exception (#ac) on the iret instruction even though alignment checks were disabled at the start of the iret. this can only occur if the iret instruction is returning from cpl3 code to cpl3 code. irets from cpl0/1/2 are not affected. this erratum can occur if the eflags value on the stack has the ac flag set, and the interrupt handler's stack is misaligned. in ia-32e mode, rsp is aligned to a 16-byte boundary before pushing the stack frame.										
implication	in ia-32e mode, under the conditions given above, an iret can get a #ac even if alignment checks are disabled at the start of the iret. this erratum can only be observed with a software generated stack frame.										
workaround	software should not generate misaligned stack frames for use with iret.										
											
title	hsync/vsync buffer does not meet vesa rise & undershoot specification  specification update 27										
problem	both hsync (horizontal sync) and vsync (vertical sync) signals are violating vesa (video electronics standards association) specification due to non-monotonic slow rise time on both signals.										
implication	hsync and vsync signals may not meet vesa specification.										
workaround	insert a buffer in the hsync/vsync signal path before the video connector. refer to platform design guide and customer reference board (crb) schematic for reference.										
											
title	glitch on lvds display interface clocks and data lines may be observed during power-up sequences										
problem	during power up sequence (transition to s0 state from g3, s3, s4 or s5 states) when lvds (low voltage differential signal) power supply (1.8v source) ramps up, a glitch on lvds clocks (lvd_a_clkp, lvd_a_clkn) and data lines (lvd_a_dapap[2:0], lvd_a_datan[2:0]) may be observed.										
implication	due to this erratum, a glitch may be seen during power up sequence. the glitch is not seen once the lvds power supply is stable.										
workaround	none identified.										
											
title	cpuid instruction returns incorrect brand string										
problem	when the cpuid instructions is executed with eax = 80000002h, 80000003h and 80000004h, the returned brand string may be incorrect. the model number in the brand string may be prefixed with a “k” instead of the expected “d”.										
implication	when this erratum occurs, the processor will report an incorrect model number in the brand string.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_mc2_status [overflow] bit is not set when single-bit correctable ecc error occurs										
problem	the overflow bit should be set if the val bit (ia32_mc2_status (409h) bit [63]) is set when a new error occurs. due to this erratum, the overflow bit (ia32_mc2_status (409h) bit [62]) is only set when a prior uncorrected error (as indicated by the uc bit (ia32_mc2_status (409h) bit [61])) is present at the time the second error occurs.										
implication	any l2 correctable error will not set the ia32_mc2_status.overflow bit when overwriting a prior l2 correctable error.										
workaround	the frequency of occurrence of this problem is reduced greatly if an operating system regularly polls and clears the machine check banks as this reduces the likelihood of an overflow condition.										
											
title	fp data operand pointer may be incorrectly calculated after an fp access which wraps a 4-gbyte boundary in code that uses 32-bit address size in 64-bit mode										
problem	the fp (floating point) data operand pointer is the effective address of the operand associated with the last non-control fp instruction executed by the processor. if an 80-bit fp access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-gbyte boundary and the fp environment is subsequently saved, the value contained in the fp data operand pointer may be incorrect.										
implication	due to this erratum, the fp data operand pointer may be incorrect. wrapping an 80- bit fp load around a 4-gbyte boundary in this way is not a normal programming practice. intel has not observed this erratum with any commercially available software.										
workaround	if the fp data operand pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit fp accesses are wrapped around a 4-gbyte boundary.										
											
title	writes to set ia32_mcg_status.mcip will fail										
problem	an msr write that attempts to set the ia32_mcg_status msr (17ah) mcip (machine check in progress) bit [2] will fail (e.g. #gp fault on wrmsr) instead of setting the bit. an msr write that specifies 0 for the mcip bit will function correctly.										
implication	due to this erratum, software writes to set this bit will not succeed and may cause an unexpected general protection fault.										
workaround	none identified.										
											
title	synchronous reset of ia32_mperf on ia32_aperf overflow may not work										
problem	when either the ia32_mperf or ia32_aperf msr (e7h, e8h) increments to its maximum value of 0xffff_ffff_ffff_ffff, both msrs are supposed to synchronously reset to 0x0 on the next clock. due to this erratum, ia32_mperf may not be reset when ia32_aperf overflows. instead, ia32_mperf may continue to increment without being reset.										
implication	due to this erratum, software cannot rely on synchronous reset of the ia32_mperf register. the typical usage of ia32_mperf/ia32_aperf is to initialize them with a value of 0; in this case the overflow of the counter wouldn’t happen for over 10 years.										
workaround	none identified.										
											
title	aav42 during a c-state exit due to a pending external interrupt the system may hang										
problem	under a precise set of conditions, a processor waking from a c-state due to a pending external interrupt may not complete the exiting process and the system may hang.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	high temperature circuit marginality issue may cause the system to hang or auto reboot										
problem	a subset of processors may experience circuit marginality issues when operating at high temperature. due to this erratum a system hang may occur or the processor may proceed to reboot.										
implication	due to this erratum, the system may hang or auto reboot.										
workaround	a bios workaround has been identified. please refer to memory reference code version 1.12 or later.										
											
title	fp data operand pointer may be incorrectly calculated after an fp access which wraps a 64-kbyte boundary in 16-bit code										
problem	the fp (floating point) data operand pointer is the effective address of the operand associated with the last non-control fp instruction executed by the processor. if an 80-bit fp access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-kbyte boundary, and the fp environment is subsequently saved, the value contained in the fp data operand pointer may be incorrect.										
implication	due to this erratum, the fp data operand pointer may be incorrect. wrapping an 80- bit fp load around a segment boundary in this way is not a normal programming practice. intel has not observed this erratum with any commercially available software.										
workaround	if the fp data operand pointer is used in an operating system which may run 16-bit fp code, care must be taken to ensure that no 80-bit fp accesses are wrapped around a 64-kbyte boundary.										
											
title	executing ltr in 64-bit mode may access segment descriptor before checking for null selector										
problem	when executing the ltr instruction with a null segment selector, #gp(0) should be delivered without accessing the memory in the gdt (global descriptor table). due to this erratum, such an execution of the ltr instruction in 64-bit mode may access that memory. side effects of this memory access (e.g. a page fault or ept violation) that occur may prevent the #gp(0) from being delivered.										
implication	executing the ltr instruction with a null segment selector may incorrectly access the gdt. intel has not observed this erratum with any commercially available system.										
workaround	none identified.										
											
title	trefi exceeds ddr2 / ddr3 specifications										
problem	trefi (average dram refresh interval) is 7.825us which exceeds the 7.8us stated in the ddr2/ddr3 specification. due to this erratum, the processor will take more time to refresh rows. (example: 64.1ms instead of 64.0ms to issue 8192 refreshes)										
implication	trefi specification is exceeded. intel has not observed any other issues with dram refresh due to this erratum.										
workaround	none identified.										
											
title	fp data operand pointer may be incorrectly calculated after fp access which wraps 64 kbyte boundary in 16 bit code										
problem	the  fp data operand pointer is the  effective  address of the operand associated with the last non-control floating-point instruction executed by the machine. if an 80-bit floating-point access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wraps a 64-kbyte boundary, and the floating-point environment is subsequently saved, the value contained in the fp data operand pointer may be incorrect.										
implication	a 32-bit operating system running 16-bit floating-point code may encounter this erratum, under the following conditions: the operating system is using a segment greater than 64 kbytes in size. an application is running in a 16-bit mode other than protected mode. an 80-bit floating-point load or store which wraps the 64-kbyte boundary is executed.										
workaround	if the fp data  operand  pointer  is used in an os which may run 16-bit floating- point code, care must be taken to ensure that no 80-bit floating-point accesses are wrapped around a 64-kbyte boundary										
											
title	differences exist in debug exception reporting										
problem	there exist some differences in the reporting of code and data breakpoint matches between that specified by previous intel processor specifications and the behavior of the processor, as described below: case 1: the first case is for a breakpoint set on a movss or popss instruction, when the instruction following it causes a debug register protection fault (dr7.gd  is already set, enabling the fault). the processor reports delayed data breakpoint matches from the movss or popss instructions by setting the matching dr6.bi bits, along with the debug register protection fault   (dr6.bd). if additional breakpoint faults are matched during the call of the debug fault handler,  the  processor sets the breakpoint match bits (dr6.bi) to reflect the breakpoints matched by both the movss or popss breakpoint and the debug fault handler call. the processor only sets dr6.bd in either situation, and does not set any of the dr6.bi bits. case 2: in the second breakpoint reporting failure case, if a movss or popss instruction with a data breakpoint is followed by a store to memory which: crosses a 4-kbyte page boundary, or causes the page table access or dirty (a/d) bits to be modified, the breakpoint information for the movss or popss will be lost. previous processors retain this information under these boundary conditions. case 3: if they occur after a movss or popss instruction, the intn, into, and int3 instructions zero the dr6.bi bits (bits b0 through b3), clearing pending breakpoint information, unlike previous processors. case 4: if a data breakpoint and an smi (system management interrupt) occur simultaneously, the smi will be serviced via a call to the smm handler, and the pending breakpoint will be lost. case 5: when an instruction that accesses a debug register is executed, and a breakpoint is encountered on the instruction, the breakpoint is reported twice. case 6: unlike previous versions of intel architecture processors, p6 family  processors will not set the bi bits for a matching disabled breakpoint unless at least one other breakpoint is enabled.										
implication	when debugging or when developing debuggers for a p6 family processor-based system, this behavior should be noted. normal usage of the movss or popss instructions (i.e., following them with a mov esp) will not exhibit the behavior of cases 1-3. debugging in conjunction with smm will be limited by case 4.										
workaround	following movss and popss instructions with a mov esp instruction when using breakpoints will avoid the first three cases of this erratum. no workaround has been identified for cases 4, 5, or 6.										
											
title	flush# servicing delayed while waiting for startup_ipi in 2 way mp systems										
problem	in a 2-way mp system, if an application processor is waiting  for a  startup  inter- processor interrupt (startup_ipi), then it will not service a flush# pin assertion until it has received the startup_ipi.										
implication	after the 2-way mp initialization protocol, only one processor becomes the bootstrap processor (bsp). the other processor becomes a slave application processor (ap).   after losing the bsp arbitration, the ap goes into a wait loop, waiting for a startup_ipi. the bsp can wake up the ap to perform some tasks with a startup_ipi, and  then put it back to sleep with an initialization inter-processor interrupt (init_ipi, which  has the same effect as asserting init#), which returns it to a wait loop. the result is  a possible loss of cache coherency if the off-line processor is intended to service a flush# assertion at this point. the flush# will be serviced as soon as the processor is awakened by a startup_ipi, before any other instructions are executed. intel has not encountered any operating systems that are affected by this erratum.										
workaround	operating system developers should take care to execute a wbinvd instruction before the ap is taken off-line using an init_ipi										
											
title	code fetch matching disabled debug register may cause debug exception										
problem	the bits l0 3 and g0 3 enable breakpoints local to a task and global to all tasks, respectively. if one of these bits is set, a breakpoint is enabled, corresponding to the addresses in the debug registers dr0-dr3. if at least one of these breakpoints is enabled, any of these registers are disabled (i.e., ln and gn are 0), and rwn for the disabled register is 00 (indicating a breakpoint on instruction execution), normally an instruction fetch will not cause an instruction-breakpoint fault based on a match with the address in the disabled register(s). however, if the address in a disabled register matches the address of a code fetch which also results in a page fault, an instruction- breakpoint fault will occur.										
implication	while debugging software, extraneous instruction-breakpoint faults may be encountered if breakpoint registers are not cleared when they are disabled. debug software which does not implement a code breakpoint handler will fail, if this occurs.  if a handler is present, the fault will be serviced. mixing data and code may exacerbate this  problem by allowing disabled data breakpoint registers to break on  an instruction fetch.										
workaround	the debug handler should clear breakpoint registers before they become disabled										
											
title	double ecc error on read may result in binit#										
problem	for this erratum to occur, the following conditions must be met: machine check exceptions (mces) must be enabled. a dataless transaction (such as a write invalidate) must be occurring simultaneously with a transaction which returns data (a normal read). the read data must contain a double-bit uncorrectable ecc error. if these conditions are met, the pentium iii processor will not be able to determine which transaction was erroneous, and instead  of generating  an mce, it will generate a binit#.										
implication	the bus will be reinitialized in this case. however, since a double-bit uncorrectable  ecc error occurred on the read, the mce handler (which is normally reached on a double-bit uncorrectable ecc error for a read) would most likely cause the same binit# event.										
workaround	though the ability to drive binit# can be disabled in the pentium iii processor,  which would prevent the effects of this erratum, overall system behavior would not improve, since the error which would normally cause a binit# would instead cause the machine to shut down. no other workaround has been identified.										
											
title	fp inexact-result exception flag may not be set										
problem	when the result of a floating-point operation is not exactly representable  in the destination format (1/3 in binary form, for example), an inexact-result (precision) exception occurs. when this occurs, the pe bit (bit 5 of the fpu status word) is normally set by the processor. under certain rare conditions, this bit may not be set when this rounding occurs. however, other actions taken by the processor (invoking the software exception handler if the exception is unmasked) are not affected. this erratum can only occur if the floating-point operation which causes the precision exception is immediately followed by one of the following instructions: fst m32real fst m64real fstp m32real fstp m64real fstp m80real fist m16int fist m32int fistp m16int fistp m32int fistp m64int   note that even if this combination of instructions is encountered, there is also a dependency on the internal pipelining and execution state of both instructions in the processor.										
implication	inexact-result exceptions are commonly masked or ignored by applications, as it happens frequently, and produces a rounded result acceptable to most applications. the pe bit of the fpu status word may not always be set upon receiving an inexact- result exception. thus, if these exceptions are unmasked, a floating-point error exception handler may not recognize that a precision exception occurred. note that this is a “sticky” bit, i.e., once set by an inexact-result condition, it remains set until cleared by software.										
workaround	this condition can be avoided by inserting two nop instructions between the two floating-point instructions.										
											
title	btm for smi will contain incorrect from eip										
problem	a system management interrupt (smi) will produce a branch trace message (btm), if btms are enabled. however, the from eip field of the btm (used to determine the address of the instruction which was being executed when the smi was serviced) will not have been updated for the smi, so the field will report the same from eip as the previous btm.										
implication	a btm which is issued for an smi will not contain the correct from eip, limiting the usefulness of btms for debugging software in conjunction with system management mode (smm).										
workaround	none identified.										
											
title	i/o restart in smm may fail after simultaneous mce										
problem	if an i/o instruction (in, ins, rep ins, out, outs, or rep outs) is being executed,  and if the data for this instruction becomes corrupted, the pentium iii processor will signal a machine check exception (mce). if the instruction is directed at a device which is powered down, the processor may also receive an assertion of smi#. since mces have higher priority, the processor will call the mce handler, and the smi# assertion will remain pending. however, upon attempting to execute the first instruction of the mce handler, the smi# will be recognized and the processor will attempt to execute the smm handler. if the smm handler is completed successfully, it will attempt to restart the i/o instruction, but will not have the correct machine state, due to the call to the mce handler.										
implication	a simultaneous mce and smi# assertion may occur for one of the i/o instructions above. the smm handler may attempt to restart such an i/o instruction, but will have corrupted state due to the mce handler call, leading to failure of the restart and shutdown of the processor.										
workaround	if a system implementation must support both smm and mces, the first thing the smm handler code (when an i/o restart is to be performed) should do is check for a pending mce. if there is  an mce pending, the smm handler should immediately exit via an rsm instruction and allow the machine check exception handler to execute. if there is not, the smm handler may proceed with its normal operation.										
											
title	branch traps do not function if btms are also enabled										
problem	if branch traps or branch trace messages (btms) are enabled alone, both function as expected. however, if both are enabled, only the btms will function, and the branch traps will be ignored.										
implication	the branch traps and branch trace message debugging features cannot be used together.										
workaround	if branch trap functionality is desired, btms must be disabled.										
											
title	checker bist failure in frc mode not signaled										
problem	if a system is running in  functional  redundancy  checking  (frc)  mode,  and  the checker of the master-checker pair encounters a hard failure while running the built- in self test (bist), the checker will tri-state all outputs without signaling an ierr#.										
implication	assuming the master passes bist successfully, it will continue execution unchecked, operating without functional redundancy. however, the necessary pull-up on the frcerr pin will cause an frcerr to be signaled. the operation of the  master depends on the implementation of frcerr.										
workaround	for successful detection of bist failure in the checker of an frc pair, use the  frcerr signal, instead of ierr#.										
											
title	binit# assertion causes frcerr assertion in frc mode										
problem	if a pair  of  pentium  iii processors  are  running  in functional redundancy checking (frc) mode, and a catastrophic error condition causes binit# to be asserted, the checker in the master-checker pair will enter shutdown. the next bus  transaction from the master will then result in the assertion of frcerr.										
implication	bus initialization via an assertion of binit# occurs as the result of a catastrophic   error condition which precludes the continuing reliable execution of  the  system. under normal circumstances, the master-checker pair would remain synchronized in the execution of the binit# handler. however, due to this erratum, an frcerr will  be signaled. system behavior then depends on the system specific error recovery mechanisms.										
workaround	none identified.										
											
title	machine check exception handler may not always execute successfully										
problem	an  asynchronous  machine  check exception (mce), such as a binit# event, which  occurs during an access that splits a 4 kbyte  page boundary, may leave some  internal registers in an indeterminate state. thus, the mce handler code may not always run successfully if an asynchronous mce has occurred previously.										
implication	an mce may not always result in the successful execution of the mce handler. however, asynchronous mces usually occur upon detection of a catastrophic system condition that would also hang the processor. leaving mces disabled will result in the condition which caused the asynchronous mce instead causing the processor to enter shutdown. therefore, leaving mces disabled may not improve overall system behavior.										
workaround	no workaround  which would  guarantee  successful mce handler execution under this condition has been identified.										
											
title	mce due to l2 parity error gives l1 mcacod.ll										
problem	if a cache reply parity (crp) error, cache address parity (cap) error, or cache synchronous error (cser) occurs on an access to the pentium iii processor’s l2 cache, the resulting machine check architectural error code (mcacod) will be logged with ‘01’ in the ll field. this value indicates an l1 cache error; the value should be ‘10’, indicating an l2 cache error. note that l2 ecc errors have the correct value of ‘10’ logged.										
implication	an l2 cache access error, other than an ecc error, will be improperly logged as an l1 cache error in mcacod.ll.										
workaround	none identified.										
											
title	lber may be corrupted after some events										
problem	the last branch record (lbr) and the last branch before exception record (lber) can   be used to determine the source and destination information for previous branches or exceptions. the lbr contains the source and destination addresses for  the  last branch or exception, and the lber contains similar information for the last branch taken before the last exception. this information is typically used to determine the location of a branch which leads to execution of code which causes an exception. however, after a catastrophic bus condition which results in an assertion of binit# and the re-initialization of the buses, the value in the lber may be corrupted. also,   after either a call which results in a fault or a software interrupt, the lber and lbr will be updated to the same value, when the lber should not have been updated.										
implication	the lber and lbr registers are used only for debugging purposes.  when  this erratum occurs, the lber will not contain reliable address information. the value of lber should be used with caution when debugging branching code; if the values in  the lbr and lber are the same, then the lber value is incorrect. also, the value in the lber should not be relied upon after a binit# event.										
workaround	none identified.										
											
title	btms may be corrupted during simultaneous l1 cache line replacement										
problem	when branch trace messages (btms) are enabled and such a message is generated,   the btm may be corrupted when issued to the bus by the l1 cache if a new line of data is brought into the l1 data cache simultaneously. though the new line being stored in the l1 cache is stored correctly, and no corruption occurs in the data, the information in the btm may be incorrect due to the internal collision of the data line and the btm.										
implication	although btms may not be entirely reliable due to this erratum, the conditions necessary for this boundary condition to occur have only been exhibited during focused simulation testing. intel has currently not observed this erratum in a system level validation environment.										
workaround	none identified.										
											
title	eflags discrepancy on a page fault after a multiprocessor tlb shootdown										
problem	this erratum may occur when the pentium iii processor executes one of the following read-modify-write arithmetic instructions and a page fault occurs during the store of the memory operand: add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd. in this case, the eflags value pushed onto the stack of the page fault handler may reflect the status of the register after the instruction would have completed execution rather  than before it. the following conditions are required for the store to generate a page fault and call the operating system page fault handler: the store address entry must be evicted from the dtlb by speculative loads from other instructions that hit the same way of the dtlb before the store has completed. dtlb eviction requires at least three-load operations that have linear address  bits 15:12 equal to each other and address bits 31:16 different from  each other in close physical proximity to the arithmetic operation. the page table entry for the store address must have its permissions tightened during the very small window of time between the dtlb eviction and execution of   the store. examples of page permission tightening include from present to not present or from read/write to read only, etc. another processor, without corresponding synchronization and tlb flush, must cause the permission change.										
implication	this scenario may only occur on a multiprocessor platform running an operating system that performs “lazy” tlb shootdowns. the memory image of the eflags register on the page fault handler’s stack prematurely contains the  final arithmetic flag values although the instruction has not yet completed. intel has not identified  any operating systems that inspect the arithmetic portion of the eflags register during a page fault nor observed this erratum in laboratory testing of software applications.										
workaround	no workaround is needed upon normal restart  of  the  instruction,  since  this erratum is transparent to the faulting code and results in correct instruction behavior. operating systems may ensure that no processor is currently accessing a page that is scheduled to have its page permissions tightened or have a page fault handler that ignores any incorrect state.										
											
title	near call to esp creates unexpected eip address										
problem	as documented, the call instruction saves procedure linking information  in  the procedure stack and jumps to the called procedure specified with the destination (target) operand. the target operand specifies the address of the first instruction in the called procedure. this operand can be an immediate value, a general-purpose register, or a memory location. when accessing an absolute address indirectly using the  stack pointer (esp) as a base register, the base value used is the value in the  esp register before the instruction executes. however, when accessing an absolute address directly using esp as the base register, the base value used is the value of esp after the return value is pushed on the stack, not the value in the esp register before the instruction executed.										
implication	due to this erratum, the processor may transfer control to an unintended address. results are unpredictable, depending on the particular application, and can range  from no effect to the unexpected termination of the application due to an exception. intel has observed this erratum only in a focused testing environment. intel has not observed any commercially available operating system, application, or compiler that makes use of or generates this instruction.										
workaround	if the other seven general-purpose registers are unavailable for use, and it is necessary to do a call via the esp register, first push esp onto the stack, then perform an indirect call using esp (e.g., call [esp]). the saved version  of esp should be popped off the stack after the call returns.										
											
title	memory type undefined for nonmemory operations										
problem	the memory type field for nonmemory transactions such as i/o and special cycles    are undefined. although the memory type attribute for nonmemory operations logically should (and usually does) manifest itself as uc, this feature is not designed into the implementation and is therefore inconsistent.										
implication	bus agents may decode a non-uc memory type for nonmemory bus transactions.										
workaround	bus agents must consider transaction type  to  determine  the  validity  of  the memory type field for a transaction.										
											
title	infinite snoop stall during l2 initialization of mp systems										
problem	it is possible for snoop traffic generated on the system bus while a processor is executing its l2 cache initialization routine to cause the initializing processor to hang.										
implication	a dp (2-way) system which does not suppress snoop traffic while l2 caches are being initialized may hang during this initialization sequence.										
workaround											
											
title	fp data operand pointer may not be zero after power on or reset										
problem	the fp data operand pointer, as specified, should be reset to zero upon power on or  reset by the processor. due to this erratum, the fp data operand pointer may be nonzero after power on or reset.										
implication	software which uses the fp data operand pointer and count on its value being zero after power on or reset without first executing an finit/fninit instruction will use  an incorrect value, resulting in incorrect behavior of the software.										
workaround	software should follow the recommendation in  section  8.2  of  the  intel  architecture software developer’s manual, volume 3: system programming guide (order number 243192). this recommendation states that if the fpu will be used, software-initialization code should execute an finit/fninit instruction following a hardware reset. this will correctly clear the fp data operand pointer to zero.										
											
title	movd following zeroing instruction can cause incorrect result										
problem	an incorrect result may be calculated after the following circumstances occur: a register has been zeroed with either a sub reg, reg instruction or an xor reg, reg instruction, a value is moved with sign extension into the same register’s lower 16 bits; or a signed integer multiply is performed to the same register’s lower 16 bits, this register is then copied to an mmx™ technology register using the movd instruction prior to any other operations on the sign-extended value.   specifically, the sign may be incorrectly extended into bits 16-31 of the mmx technology register. only the mmx technology register is affected by this erratum. the erratum only occurs when the three following steps  occur in the  order shown. the erratum may occur with up to 40 intervening instructions that do not modify the sign-extended value between steps 2 and 3. xor eax,  eax or sub eax, eax movsx ax, bl or movsx ax, byte ptr <memory address> or movsx ax, bx or movsx ax, word ptr <memory address> or imul bl (ax implicit, opcode f6 /5) or imul byte ptr <memory address> (ax implicit, opcode f6 /5) or imul ax, bx (opcode 0f af /r) or imul ax, word ptr <memory address> (opcode 0f af /r) or imul ax, bx, 16 (opcode 6b /r ib) or imul ax, word ptr <memory address>, 16 (opcode 6b /r ib) or imul ax, 8 (opcode 6b /r ib) or imul ax, bx, 1024 (opcode 69 /r iw) or imul ax, word ptr <memory address>, 1024 (opcode 69 /r iw) or imul ax, 1024 (opcode 69 /r iw) or cbw movd mm0, eax note that the values for immediate byte/words are merely representative (i.e., 8, 16, 1024) and that any value in the range for the size may be affected. also, note that this erratum may occur with “eax” replaced with any 32 bit general-purpose register, and “ax” with the corresponding 16-bit version of that replacement. “bl” or “bx” can be replaced with any 8-bit or 16-bit general-purpose register. the cbw and imul (opcode f6 /5) instructions are specific to the eax register only. in the example, eax is forced to contain 0 by the xor or sub instructions. since the four types of the movsx or imul instructions and the cbw  instruction modify only bits 15:8 of eax by sign extending the lower 8 bits of eax, bits 31:16 of eax should always contain 0. this implies that when movd copies eax to mm0, bits 31:16 of  mm0 should also be 0. under certain scenarios, bits 31:16 of mm0 are not 0, but are replicas of bit 15 (the 16th bit) of ax. this is noticeable when the value in ax after  the movsx, imul, or cbw instruction is negative, i.e., bit 15 of ax is a 1. when ax is positive (bit 15 of ax is a 0), movd will always produce the correct answer. if ax is negative (bit 15 of ax is a 1), movd may produce the right answer  or the wrong answer depending on the point in time when the movd instruction is executed in relation to the movsx, imul, or cbw instruction.										
implication	the effect of incorrect execution will vary from unnoticeable, due to the code  sequence discarding the incorrect bits, to an application failure. if the mmx technology-enabled application in which movd is used to manipulate pixels, it is possible for one or more pixels to exhibit the wrong color or position momentarily. it  is also possible for a computational application that uses the movd instruction in the manner described above to produce incorrect data. note that this data may cause an unexpected page fault or general protection fault										
workaround	there are two possible workarounds for this erratum:										
											
title	premature execution of a load operation prior to exception handler invocation										
problem	this erratum can occur with any of the following situations: if an instruction that performs a memory load causes a code segment limit violation, if a waiting floating-point instruction or mmx™ instruction that performs a memory load has a floating-point exception pending, or if an mmx instruction that performs a memory load and has either cr0.em =1 (emulation bit set), or a floating-point top-of-stack (fp tos) not equal to 0, or a dna exception pending. if any of the above circumstances occur it is possible that the load portion of the instruction will have executed before the exception handler is entered.										
implication	in normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, nor from the restart and subsequent re-execution of that instruction by the exception handler. if the target of the load is to uncached memory that has a system side-effect,   restarting the instruction may cause unexpected system behavior due to  the repetition of the side-effect.										
workaround	code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a  code segment limit violation cannot occur as a part of reading from side-effect memory.										
											
title	read portion of rmw instruction may execute twice										
problem	when the pentium iii processor executes a read-modify-write (rmw) arithmetic instruction, with memory as the destination, it is possible for a page fault to occur during the execution of the store on the memory operand after the read operation  has completed but before the write operation completes. if the memory targeted for the instruction is uc (uncached), memory will observe the occurrence of the initial load before the page fault handler and again if the instruction is restarted.										
implication	this erratum has no effect if the memory targeted for the rmw instruction has no side-effects. if, however, the load targets a memory region that has side-effects, multiple occurrences of the initial load may lead to unpredictable system behavior.										
workaround	hardware and software developers who write device drivers for custom hardware  that may have a side-effect style of design should use simple loads and simple stores to transfer data to and from the device. then, the  memory location will simply be read twice with no additional implications.										
											
title	mc2_status msr has model-specific error code and machine check architecture error code reversed										
problem	the intel architecture software developer’s manual, volume 3: system programming guide, documents that for the mci_status msr, bits 15:0 contain the mca (machine-check architecture) error code field, and bits 31:16 contain the model- specific error code field. however, for the mc2_status msr, these bits have been reversed. for the mc2_status msr, bits 15:0 contain the model-specific error code field and bits 31:16 contain the mca error code field.										
implication	a machine check error may be decoded incorrectly if this erratum on the  mc2_status msr is not taken into account.										
workaround	when decoding the mc2_status msr, reverse the two error fields.										
											
title	mixed cacheability of lock variables is problematic in mp systems										
problem	this errata only affects multiprocessor systems  where  a  lock variable  address is  marked cacheable in one processor and uncacheable in any others. the processors which have it marked uncacheable may stall indefinitely when accessing the lock variable. the stall is only encountered if: one processor has the lock variable cached, and is attempting to execute a cache lock. if the processor which has that address cached has it cached in its l2 only. other processors, meanwhile, issue back to back accesses to that same address on the bus.										
implication	mp systems where all processors either use cache locks or consistent locks to uncacheable space will not encounter this problem. if, however, a lock variable’s cacheability varies in different processors, and  several processors are all attempting to perform the lock simultaneously, an indefinite stall may be experienced by the processors which have it marked uncacheable in locking the variable (if the conditions above are satisfied). intel has only encountered this problem in focus testing with artificially generated external events. intel has not currently identified  any commercial software which exhibits this problem.										
workaround	follow a homogenous model for the memory type  range  registers  (mtrrs), ensuring that all processors have the same cacheability attributes for each region of memory; do not use locks whose memory type is cacheable on one processor, and uncacheable on others. avoid page table aliasing, which may produce a nonhomogenous memory model.										
											
title	mov with debug register causes debug exception										
problem	when in v86 mode, if a mov instruction is executed on debug registers, a general- protection exception (#gp) should be generated, as documented in the intel architecture software developer's manual, volume 3: system programming guide, section 14.2. however, in the case when the  general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.										
implication	with debug-register protection enabled (i.e., the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception will be generated instead of the expected general-protection fault.										
workaround	in general, operating systems do not set the gd bit when they are in v86 mode.   the gd bit is generally set and used by debuggers. the debug exception handler should check that the exception did not occur in v86 mode before continuing. if the exception did occur in v86 mode, the exception may be directed to the general- protection exception handler.										
											
title	upper four pat entries not usable with mode b or mode c paging										
problem	the  page  attribute  table  (pat) contains eight entries, which must all be  initialized  and considered when setting up memory types for the pentium iii processor. however, in mode b or mode c paging, the upper four entries do not  function correctly for 4-kbyte pages. specifically, bit 7 of page table entries that translate addresses to 4-kbyte pages should be used as the upper bit of a 3-bit index to determine the pat entry that specifies the memory type for the page. when mode b (cr4.pse = 1) and/or mode c (cr4.pae) are enabled, the processor forces this bit to zero when determining the memory type regardless of the value in the page table entry. the upper four entries of the pat function correctly for 2-mbyte and 4-mbyte large pages (specified by bit 12 of the page directory entry for those translations).										
implication	only the lower four pat entries are useful for 4-kb translations when mode b or c paging is used. in mode a paging (4-kbyte pages only), all eight entries may be   used. all eight entries may be used for large pages in mode b or c paging.										
workaround	none identified										
											
title	data breakpoint exception in a displacement relative near call may corrupt eip										
problem	if a misaligned data breakpoint is  programmed  to  the  same  cache  line  as  the memory location where the stack push of a near call is performed and any data breakpoints are enabled, the processor will update the stack and esp appropriately, but may skip the code at the destination of the call. hence, program execution will continue with the next instruction immediately following the call, instead of the target of the call.										
implication	the failure mechanism for this erratum is that the call would not be taken; therefore, instructions in the called subroutine would not be executed. as a result, any code relying on the execution of the subroutine will behave unpredictably.										
workaround	whether  enabled or not, do not program a misaligned data breakpoint to the    same cache line on the stack where the push for the near call is performed.										
											
title	rdmsr or wrmsr to invalid msr address may not cause gp fault										
problem	the rdmsr and wrmsr instructions allow reading or writing of msrs (model specific registers) based on the index number placed in ecx. the processor should reject access to any reserved or unimplemented msrs by generating #gp(0). however, there are some invalid msr addresses for which the processor will not generate #gp(0).										
implication	for rdmsr, undefined values will be read into edx:eax. for wrmsr, undefined processor behavior may result.										
workaround	do not use invalid msr addresses with rdmsr or wrmsr.										
											
title	preload followed by extest does not load boundary scan data										
problem	according to the ieee 1149.1 standard, the extest  instruction  would  use  data “typically loaded onto the latched parallel outputs of boundary-scan shift-register stages using the sample/preload instruction prior to the selection of the extest instruction.” as a result of this erratum, this method cannot be used to load the data onto the outputs.										
implication	using the preload instruction prior to the extest instruction will not produce expected data after the completion of extest.										
workaround	none identified										
											
title	far jump to new tss with d-bit cleared may cause system hang										
problem	a task switch may be performed by executing a far jump through a task gate or to a   new task state segment (tss) directly. normally, when such a jump to a new tss occurs, the d-bit (which indicates that the page referenced by a page table entry (pte) has been modified) for the pte which maps the location of the previous tss will already be set, and the processor will operate as expected. however, if the d-bit is clear at the time of the jump to the new tss, the processor will hang.										
implication	if an os is used which can clear the d-bit for system pages, and which jumps to a  new tss on a task switch, then a condition may occur which results in a system  hang. intel has not identified any commercial software which may encounter this condition; this erratum was discovered in a focused testing environment.										
workaround	ensure that os code does  not  clear the  d-bit  for system pages (including any pages that contain a task gate or tss). use task gates rather than jumping to a new tss when performing a task switch.										
											
title	int 1 instruction handler execution could generate a debug exception										
problem	if the processor’s general detect enable flag is set and an explicit call is made to the interrupt procedure via the int 1 instruction, the general detect enable flag should be cleared prior to entering the handler. as a result of this erratum, the flag is not cleared prior to entering the handler. if an access is  made to the debug registers while inside of the handler, the state of the general detect enable flag will cause a second debug exception to be taken. the second debug exception clears the general detect enable flag and returns control to the handler which is now able to access the debug registers.										
implication	this erratum will generate an unexpected debug exception upon accessing the debug registers while inside of the int 1 handler.										
workaround	ignore the second debug exception that is taken as a result of this erratum.										
											
title	comiss/ucomiss may not update eflags under certain conditions										
problem	comiss/ucomiss instructions compare the least significant pairs of packed single- precision floating-point numbers and set the zf, pf, and cf bits in the eflags register accordingly (the of, sf, and af bits are cleared). under certain conditions when a memory location is loaded into cache, the eflags may not get set.										
implication	the result of the incorrect status of the eflags may range from no effect to an unexpected application/os behavior.										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	transmission error on cache read										
problem	during  reads  of the l2 cache, the processor may use certain l2 cache optimizations  that may result in a data transmission error										
implication	data corruption caused by this erratum will result in unpredictable system behavior.										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	potential loss of data coherency during mp data ownership transfer										
problem	in  mp  systems,  processors  may be sharing data in different cache lines, referenced as line a and line b in the discussion below. when this erratum occurs (with the following example given for a 2-way mp system with processors noted as ‘p0’ and ‘p1’), p0 contains a shared copy of line b in its l1. p1 has a shared copy of line a. each processor must manage the necessary invalidation and snoop cycles before that processor can modify and source the results of any internal writes to the other processor. there exists a narrow timing window when, if p1 requests a coy of line b it may be supplied by p0 in an exclusive state which allows p1 to modify the contents of the line with no further external invalidation cycles. in this narrow window p0 may also retire instructions that use the original data present before p1 performed the modification										
implication	multiprocessor or threaded application synchronization, required for low-level data sharing, that is implemented via operating system provided synchronization  constructs are not affected by this erratum. applications which rely upon the usage of locked semaphores rather than memory ordering are also unaffected. uniprocessor systems are not affected by this erratum. if the erratum does occur one processor may execute software with the stale data that was present from the previous shared state rather than the data written more recently by another processor.										
workaround	deterministic barriers beyond  which program variables will not be modified can    be achieved via the usage of locked semaphore operations. these should effectively prevent the occurrence of this erratum										
											
title	misaligned locked access to apic space results in hang										
problem	when the processor’s apic space is accessed with a  misaligned locked  access  a  machine check exception is expected. however, the processor’s machine check architecture is unable to handle the misaligned locked access.										
implication	if this erratum occurs the processor will hang. typical usage models for the apic address space do not use locked accesses. this erratum will not affect systems using such a model.										
workaround	ensure that all accesses to apic space are aligned.										
											
title	floating-point exception signal may be deferred										
problem	a one clock window exists where a pending x87 fp exception that should be signaled   on the execution of a cvtps2pi, cvtpi2ps, or cvttps2pi instruction may be  deferred to the next waiting floating-point instruction or instruction that  would  change mmx™ register state.										
implication	if this erratum occurs the floating-point exception will not be handled as expected.										
workaround	applications that follow intel programming  guidelines  (empty all x87  registers before executing mmx technology instructions) will not be affected by this erratum										
											
title	memory ordering based synchronization may cause a livelock condition in mp systems										
problem	in an mp environment, the following sequence of code  (or similar code) in  two  processors (p0 and p1) may cause them to each enter an infinite loop (livelock condition): p0	p1 mov [xyz], eax	(1) wait1:  mov ebx, [abc]	(2) .	cmp ebx, val1 (3) .	jne wait1 (4) . mov [abc], val1	-6		mov [abc], val2	(5) wait0:   mov ebx, [abc]	(7) cmp ebx, val2 (8) jne wait0 (9)   note the  eax and ebx can be any general-purpose register. addresses [abc] and [xyz]  can be any location in memory and must be in the same bank of the l1 cache. variables “val1” and “val2” can be any integer. the algorithm above involves processors p0 and p1, each of which use loops to keep them synchronized with each other. p1 is looping until instruction (6) in p0 is globally observed. likewise, p0 will loop until instruction (5) in p1 is globally observed.   the p6 architecture  allows for instructions (1) and (7) in p0 to be dispatched to the  l1 cache simultaneously. if the two instructions are accessing the same memory   bank in the l1 cache, the load (7) will be given higher priority and will complete, blocking instruction (1). instructions (8) and (9) may then execute and retire, placing the instruction pointer back to instruction (7). this is due to the condition at the end of the “wait0” loop being false. the livelock scenario can occur if the timing of the wait0 loop execution is such that instruction (7) in p0 is ready for completion every time that instruction (1) tries to complete. instruction (7) will again have higher priority, preventing the data ([xyz]) in instruction (1) from being written to the l1 cache. this causes instruction (6) in p0 to not complete and the sequence “wait0” to loop infinitely in p0. a livelock condition also occurs in p1 because instruction (6) in p0 does not complete (blocked by instruction (1) not completing). the problem with this scenario is that p0 should eventually allow for instruction (1) to write its data to the l1 cache. if this occurs, the data in instruction (6) will be written to memory, allowing the conditions  in both loops to be true.
implication	both processors will be  stuck in an infinite loop, leading to a hang condition. note  that if p0 receives any interrupt, the loop timing will be disrupted such that the livelock will be broken. the system timer, a keystroke, or mouse movement can provide an interrupt that will break the livelock.										
workaround	use  a  lock instruction to force  p0 to execute instruction (6) before instruction  (7).										
											
title	system bus address parity generator may report false aerr#										
problem	the processor’s address  parity error detection circuit may fail to meet its frequency  timing specification under certain environmental conditions. at the high end of the temperature specification and/or the low end of the voltage range, the processor may report false address parity errors.										
implication	if the system has aerr# drive enabled (bit [3] of the ebl_cr_poweron resister set to ‘1’) spurious address detection and reporting may occur. in some system configurations, binit# may be asserted on the system bus. this may cause some systems to generate a machine check exception and in others may cause a reboot.										
workaround	disable aerr# drive from the processor.  aerr#  drive  may  be  disabled  by clearing bit [3] in the ebl_cr_poweron register. in addition, if the chipset allows, aerr# drive should be enabled from the chipset and aerr# observation enabled on the processor. aerr# observation on the processor is enabled by asserting a8# on the active-to-inactive transition of reset#.										
											
title	system bus ecc not functional with 2:1 ratio										
problem	if  a processor is underclocked at a core  frequency to system bus frequency ratio of   2:1 and system bus ecc is enabled, the system bus ecc detection and correction will negatively affect internal timing dependencies.										
implication	if system bus ecc is enabled, and the processor is underclocked at a 2:1 ratio, the system may behave unpredictably due to these timing dependencies.										
workaround	all bus agents that  support  system bus ecc  must disable it when a 2:1 ratio is used.										
											
title	processor may assert drdy# on a write with no data										
problem	when a maskmovq instruction is misaligned across a chunk boundary in a way that   one chunk has a mask of all 0’s, the processor will initiate two partial write transactions with one having all byte enables deasserted. under these conditions, the expected behavior of the processor would be to perform both write transactions, but to deassert drdy# during the transaction which has no byte enables asserted. as a result of this erratum, drdy# is asserted even though no data is being transferred.										
implication	the implications of this erratum depend on the bus agent’s ability to handle this erroneous drdy# assertion. if a bus agent cannot handle a drdy# assertion in this situation, or attempts to use the invalid data on the bus during this transaction, unpredictable system behavior could result										
workaround	a system which can accept a drdy# assertion during a write with no data will not be affected by this erratum. in addition, this erratum will not occur if the maskmovq is aligned.										
											
title	gp# fault on wrmsr to rob_cr_bkuptmpdr6										
problem	writing a ‘1’ to unimplemented bit(s) in the rob_cr_bkuptmpdr6 msr (offset 1e0h) will result in a general protection fault (gp#).										
implication	the normal process  used to write an msr is to read the msr using rdmsr, modify  the bit(s) of interest, and then to write the msr using wrmsr. because of this erratum, this process may result in a gp# fault when used to modify the rob_cr_bkuptmpdr6 msr.										
workaround	when writing to rob_cr_bkuptmpdr6 all unimplemented bits must be ‘0.’ implemented bits may be set as ‘0’ or ‘1’ as desired.										
											
title	machine check exception may occur due to improper line eviction in the ifu										
problem	the pentium iii processor is designed to signal an unrecoverable machine check  exception (mce) as a consistency checking mechanism. under a complex set of circumstances involving multiple speculative branches and memory accesses there exists a one cycle long window in which the processor may signal a mce in the instruction fetch unit (ifu) because instructions previously decoded have been evicted from the ifu. the one cycle long window is opened when an opportunistic fetch receives a partial hit on a previously executed but not as yet completed store resident in the store buffer.  the resulting partial hit erroneously causes the eviction  of a line from the ifu at a time when the processor is expecting the line to still be present. if the mce for this particular ifu event is disabled, execution will continue normally.										
implication	while this erratum may occur on a system with any number of pentium  iii  processors, the probability of occurrence increases with the number of processors. if this erratum does occur, a machine check exception will result. note systems that implement an operating system that does not enable the machine check architecture will be completely unaffected by this erratum (e.g., windows* 95 and windows 98).										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	performance counters include streaming simd extensions l1 prefetch										
problem	the processor allows the measurement of the frequency and duration of numerous different internal and bus related events (see intel architecture software developer's manual, volume 3, for more details). the streaming simd extension (sse) architecture provides a mechanism to pre-load data into the l1 cache, bypassing the l2 cache. the number of these l1 pre-loads measured by the performance  monitoring logic will incorrectly be included in the count of “l2_lines_in” (24h) events and “l2_lines_out” (26h) events.										
implication	if application software is run which utilizes the sse l1 prefetch feature, the count of “l2_lines_in” (24h) and “l2_lines_out” (26h) will read a value that is greater than the correct value.										
workaround	the correct value of “l2_lines_in” and “l2_lines_out” may be calculated by subtracting the value of the “mmx_pre_miss” (4bh) from each of these registers.										
											
title	snoop request may cause dbsy# hang										
problem	a small window of time exists in which a snoop request originating from a bus agent   to a processor with one or more outstanding memory transactions may cause the processor to assert dbsy# without issuing a corresponding bus transaction, causing the processor to hang (livelock). the exact circumstances are complex, and include the relative timing of internal processor functions with the snoop request from a bus agent										
implication	this erratum may occur on a system with any number of processors. however, the probability of occurrence increases with the number of processors. if this erratum does occur, the system will hang with dbsy# asserted. at this point, the system requires a hard reset.										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	lower bits of smram smbase register cannot be written with an itp										
problem	the system management base  (smbase)  register  (7ef8h)  stores  the  starting  address of the system management ram (smram). this register is used by the processor when it is in system management mode (smm), and its contents serve as the memory base for code execution and data storage. the 32-bit smbase register can normally be programmed to any value. when programmed with an in-target probe (itp), however, any attempt to set the lower 11 bits of smbase to anything other than zeros via the wrmsr instruction will cause the attempted write to fail.										
implication	when set via itp, any attempt to relocate smram space must be made with 2-kb alignment.										
workaround	none identified										
											
title	task switch caused by page fault may cause wrong pte and pde access bit to be set										
problem	if an operating system executes a  task switch via a task state segment (tss), and   the tss is wholly or partially located within a clean page (a and d bits clear) and the gdt entry for the new tss is either misaligned across a cache line boundary or is in a clean page, the accessed and dirty bits  for an incorrect page table/directory entry may be set.										
implication	an operating system which uses hardware task switching (or hardware task management)  may encounter this erratum. the effect of the erratum depends on   the alignment of the tss and ranges from no anomalous behavior to unexpected errors.										
workaround	the operating system could align all tsss to be within page boundaries and set    the a and d bits for those pages to avoid this erratum. the operating system may alternately use software task management.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor, or system bus  master,  writing  data  into  a  currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected instruction execution from the processor that is executing the modified code.										
implication	in this case, the phrase "unexpected execution behavior" encompasses  the  generation of most of the exceptions listed in the intel architecture software developer's manual volume 3: system programming guide, including a general protection fault (gpf). in the event of a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	in order to avoid this erratum, programmers should use the xmc synchronization algorithm  as detailed in the intel architecture software developer's manual volume  3: system programming guide, section 7.1.3.										
											
title	processor will erroneously report a bist failure										
problem	if  the  processor performs  bist at  power-up,  the  eax register is  normally cleared  (0h) when the processor passes. the processor will erroneously report a non-zero value (signaling a bist failure) even if bist passes.										
implication	the processor will incorrectly signal an error after bist is performed.										
workaround	the system bios should ignore the bist results in the eax register.										
											
title	noise sensitivity issue on processor smi# pin										
problem	post silicon characterization has demonstrated a greater than expected sensitivity to  noise on the processor's smi# input, which may result in spurious smi# interrupts.										
implication	bios/smm code that is capable of handling spurious smi events will report a spurious smi#, but should not be negatively impacted by this erratum. systems whose bios code cannot handle spurious smi events may fail, resulting in a system hang or other anomalous behavior. spurious smi# interrupts should be controlled on the system board regardless of  bios implementation.										
workaround	possible workarounds that may reduce  or  eliminate  the  occurrence  of  the  spurious smi# interrupts include:										
											
title	limitation on cache line ecc detection and correction										
problem	ecc can detect and correct up to four single-bit ecc errors per cache line.  however,   the processor will only detect and correct one single-bit ecc error per cache line. while all ecc errors will be detected, multiple single bit errors will be incorrectly reported as uncorrectable double bit errors, rather than correctable single bit errors.										
implication	the processor may report fewer single bit ecc errors and more double bit ecc errors than previous processors.										
workaround	none identified										
											
title	l2_ld and l2_m_lines_outm performance-monitoring counters do not work										
problem	the  l2_ld  (29h) and l2_m_lines_outm (27h) performance-monitoring counters    are used to monitor l2 cache line activity. these counters incorrectly count their respective events.										
implication	these counters will report incorrect data.										
workaround	none identified										
											
title	ifu/dcu deadlock may cause system hang										
problem	an internal deadlock situation may occur in systems with multiple bus agents, with a failure signature such that a processor either asserts dbsy# without issuing the corresponding data, or fails to respond to a snoop request from another bus agent. should this erratum occur, the affected processor ceases code execution and the system will hang. the specific circumstances surrounding the occurrence of this erratum are: a locked operation to the data cache unit (dcu) is in process. a snoop occurs, but cannot complete due to the ongoing locked operation. the presence of the snoop prevents pending instruction fetch unit (ifu) requests from completing.   the ifu requests are periodically restarted. the continued ifu restart attempts create additional dcu snoops, which prevent the in-process locked operation from completing, keeping the dcu locked.										
implication	the system may hang										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	l2_dbus_busy performance monitoring counter will not count writes										
problem	the l2_dbus_busy (22h) performance monitoring counter is intended to count the number of cycles during which the l2 data bus is in use. for some steppings of the processor, the l2_dbus_busy counter will not be incremented during write cycles and therefore will only reflect the number of l2 data bus cycles resulting from cache reads										
implication	the l2_dbus_busy event counts only l2 read cycles.										
workaround	none identified										
											
title	incorrect sign may occur on x87 result due to indefinite qnan result from streaming simd extensions multiply										
problem	it is possible that a negative  sign bit may be incorrectly applied to the result of an    x87 floating-point operation if it is closely preceded by a streaming simd extensions (sse) multiply operation. in order for this erratum to occur, the streaming simd extensions multiply operation must result in an indefinite quiet not-a-number (qnan). operations such as multiplying zero by infinity will result in an indefinite qnan result.										
implication	if this erratum occurs, the result of an x87 floating-point instruction, which should be positive, will instead be negative.										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	deadlock										
problem	intel's 32-bit instruction set architecture (isa) utilizes most of the available op-code space; however some byte combinations remain undefined and are considered illegal instructions. intel processors detect the  attempted execution of illegal instructions and signal an exception. this exception is handled by operating system and/or application software.   under a complex set of internal and external conditions involving illegal instructions,  a deadlock may occur within the processor. the necessary conditions for  the  deadlock involve: execution of the illegal instruction. two-page table walks occur within a narrow timing window coincident with the illegal instruction.										
implication	the illegal instructions involved in this erratum are unusual and invalid byte combinations that are not useful to application software or operating systems. these combinations are not normally generated in the course of software programming, nor are such sequences known by intel to be generated in commercially available  software and tools. development tools (compilers, assemblers) do not generate this type of code sequence, and will normally flag such a sequence as an error. if this erratum occurs, the processor deadlock condition will occur and result in a system hang. code execution cannot continue without a system reset.										
workaround	none identified										
											
title	maskmovq instruction interaction with string operation may cause deadlock										
problem	under the following scenario, combined with a specific alignment of internal events, the processor may enter a deadlock condition: a store operation completes, leaving a write-combining (wc) buffer  partially filled. the target of a subsequent maskmovq instruction is split across a cache line. the data in (2) above results in a hit to the data in the wc buffer in (1).										
implication	if this erratum occurs, the processor deadlock condition will occur and result in a system hang. code execution cannot continue without a system reset.										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	movd, cvtsi2ss, or pinsrw following zeroing instruction can cause incorrect result										
problem	an incorrect result may be calculated after the following circumstances occur: a register has been zeroed with either a sub reg, reg instruction, or an xor reg, reg instruction. a value is moved with sign extension into the same register’s lower 16 bits; or a signed integer multiply is performed to the same register’s lower 16 bits.   the register is then copied to an mmx™ technology register using the movd, or converted to single precision floating-point and moved to an mmx technology register using the cvtsi2ss instruction prior to any other operations on the sign- extended value, or inserted into an mmx™ technology register using the pinsrw instruction.   specifically, the sign may be incorrectly extended into bits 16-31 of the mmx technology register. in the case of the pinsrw instruction, a non-zero value could be loaded into the mmx™ technology register. this erratum only affects the mmx™ technology register.   this erratum only occurs when the following three steps occur in the order shown. this erratum may occur with up to 63 (39 for pre-cpuid 0x6bx) intervening instructions that do not modify the sign-extended value between steps 2 and 3. xor eax,  eax or sub eax, eax  movsx ax, bl or movsx ax, byte ptr <memory address> or movsx ax, bx or movsx ax, word ptr <memory address> or imul bl (ax implicit, opcode f6 /5) or imul byte ptr <memory address> (ax implicit, opcode f6 /5) or imul ax, bx (opcode 0f af /r) or imul ax, word ptr <memory address> (opcode 0f af /r) or imul ax, bx, 16 (opcode 6b /r ib) or imul ax, word ptr <memory address>, 16 (opcode 6b /r ib) or imul ax, 8 (opcode 6b /r ib) or imul ax, bx, 1024 (opcode 69 /r iw) or imul ax, word ptr <memory address>, 1024 (opcode 69 /r iw) or imul ax, 1024 (opcode 69 /r iw) or cbw  movd mm0, eax or cvtsi2ss mm0, eax   note that the values for immediate byte/words are merely representative (i.e., 8, 16, 1024) and that any value in the range for the size is affected. also, note that this erratum may occur with “eax” replaced with any 32-bit general-purpose register, and “ax” with the corresponding 16-bit version of that replacement. “bl” or “bx” can be   replaced with any 8-bit or 16-bit general-purpose register. the cbw and imul (opcode f6 /5) instructions are specific to the eax register only.   in the above example, eax is forced to contain 0 by the xor or sub instructions. since the four types of the movsx or imul instructions and the cbw instruction only modify bits 15:8 of eax by sign extending the lower 8 bits of eax, bits 31:16 of eax should always contain 0. this implies that when movd or cvtsi2ss copies eax to mm0, bits 31:16 of mm0 should also be 0. in certain scenarios, bits 31:16 of mm0 are not 0, but are replicas of bit 15 (the 16th bit) of ax. this is noticeable when the value in ax after the movsx, imul or cbw instruction is negative (i.e., bit 15 of ax is a 1).   when ax is positive (bit 15 of ax is 0), movd or cvtsi2ss will produce the correct answer. if ax is negative (bit 15 of ax is 1), movd or cvtsi2ss may produce the right answer or the wrong answer, depending on the point in time when the movd or cvtsi2ss instruction is executed in relation to the movsx, imul or cbw instruction. the pinsrw instruction can fail to correctly load a zero when used with a partial register zeroing instruction (sub or xor): mov di, 0ffff8914h xor eax, eax add ax, di xor ah, ah pinsrw mm1, eax, 00h in this case, the programmer expects mm1 to contain 0014h in it’s least significant word. this erratum would cause mm1 to contain 8914h. the number of intervening instructions between steps 4 and 5 is the same as noted in the sign extension  example above between steps 2 and 3.										
implication	the effect of incorrect execution will vary from unnoticeable, due to the code  sequence discarding the incorrect bits, to an application failure.										
workaround	there are two possible workarounds for this erratum:										
											
title	flush# assertion following stpclk# may prevent cpu clocks from stopping										
problem	if flush# is  asserted after stpclk# is asserted, the  cache  flush operation will not occur until after stpclk# is de-asserted. furthermore, the pending  flush  will  prevent the processor from entering the sleep state, since the flush operation must complete prior to the processor entering the sleep state.										
implication	following slp# assertion, processor power dissipation may be higher than expected. furthermore, if the source to the processor’s input bus clock (bclk) is removed, normally resulting in a transition to the deep sleep state, the processor may shutdown improperly. the ensuing attempt to wake up the processor will result in unpredictable behavior and may cause the system to hang.										
workaround	for systems that use the flush# input signal and deep sleep state  of  the processor, ensure that flush# is not asserted while stpclk# is asserted.										
											
title	intermittent failure to assert ads# during processor power-on										
problem	under a system specific set of initial parametric conditions, a very small number of pentium® iii processors (cpuid 068xh) may be susceptible to entering an internal test mode during processor power-on. the symptom of this test mode is a failure to assert ads# during a processor power-on.										
implication	on susceptible platforms, when power is applied to the processor, there  is  a possibility that the processor will occasionally enter the test mode rather than initiate a system boot sequence.										
workaround											
											
title	floating-point exception condition may be deferred										
problem	a floating-point instruction that causes a pending floating-point exception (es=1) is normally signaled by the processor on the next waiting fp/mmx™ technology instruction. in the following set of circumstances, the exception may be delayed or  the fsw register may contain a wrong value: the excepting floating-point instruction is followed by an instruction that accesses memory across a page (4-kbyte) boundary or its access results in the update of a page table dirty/access bit. the memory accessing instruction is immediately followed by a waiting floating- point or mmx technology instruction. the waiting floating-point or mmx technology instruction retires during a one- cycle window that coincides with a sequence of internal events related to instruction cache line eviction.										
implication	the floating-point exception will not be signaled until the next waiting floating- point/mmx technology instruction. alternatively it may be signaled with the wrong  tos and condition code values. this erratum has not been observed in any commercial software applications.										
workaround	none identified										
											
title	thermtrip# may not be asserted as specified										
problem	thermtrip# is a signal on the pentium® iii processor that is asserted when the     core reaches a critical temperature during operation as detailed in the processor specification. the pentium® iii processor may not assert thermtrip# until a much higher temperature than the one specified is reached.										
implication	the thermtrip# feature is not functional on the pentium® iii processor. note that this erratum can only occur when the processor is running with a  tplate  temperature over the maximum specification of 75° c										
workaround	avoid operation of the pentium iii processor outside of the thermal specifications defined by the processor specifications.										
											
title	cache line reads may result in eviction of invalid data										
problem	a small window  of  time  exists in which internal timing  conditions in the  processor cache logic may result in the eviction of an l2 cache line marked in the invalid state.										
implication	there are three possible implications of this erratum: the processor may provide incorrect l2 cache line data by evicting an invalid line. a bnr# (block next request) stall may occur on the system bus. should a snoop request occur to the same cache line in a small window of time  the processor may incorrectly assert hitm#. it is then possible for an infinite snoop stall to occur should another processor respond (correctly) to the snoop request with hit#. in order for this infinite snoop stall to occur, at least three agents must be present, and the probability of occurrence increases with the number of processors. should 2 or 3 occur, the processor will eventually assert binit# (if enabled) with an mca error code indicating a rob time-out. at this point, the system requires a hard reset.										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	snoop probe during flush# could cause l2 to be left in shared state										
problem	during a l2 flush operation using the flush# pin, it is possible that a read request  from a bus agent or other processor to a valid line will leave the line in the shared state (s) instead of the invalid state (i) as expected after flush operation. before the flush operation is completed, another snoop request to invalidate the line from another agent or processor could be ignored, again leaving the line in the shared state.										
implication	current desktop and mid range server systems  have no mechanism to assert the  flush pin and hence are not affected by this erratum. a high-end server system that does not suppress snoop traffic before the assertion of the flush# pin may cause a line to be left in an incorrect cache state.										
workaround	affected  systems (those capable of asserting the flush# pin) should prevent   snoop activity on the front side bus until invalidation is completed after asserting flush#, or use a wbinvd instruction instead of asserting the flush# pin in order   to flush the cache.										
											
title	selector for the ltr/lldt register may get corrupted										
problem	the internal selector portion of the respective register (tr, ldtr) may get corrupted,  if during a small window of ltr or lldt system instruction execution, the following sequence of events occur: speculative write to a segment register that might follow the ltr or lldt instruction the read segment descriptor of ltr/lldt operation spans a page (4 kbytes) boundary; or causes a page fault										
implication	incorrect selector for ltr, lldt instruction could be used after a task switch.										
workaround	software can insert a serializing  instruction  between  the  ltr or lldt instruction and the segment register write.										
											
title	init does not clear global entries in the tlb										
problem	init may not flush a tlb entry when: the processor is in protected mode with paging enabled and the page global enable flag is set (pge bit of cr4 register) g bit for the page table entry is set tlb entry is present in tlb when init occurs										
implication	software  may encounter unexpected page fault or incorrect address translation due  to a tlb entry erroneously left in tlb after init.										
workaround	write to cr3, cr4  or  cr0  registers  before  writing  to memory early in bios code to clear all the global entries from tlb.										
											
title	vm bit will be cleared on a double fault handler										
problem	following a task switch to a double fault  handler  that  was  initiated  while  the processor was in virtual-8086 (vm86) mode, the vm bit will be incorrectly cleared in eflags.										
implication	when the os recovers from the double fault handler, the processor will no longer be  in vm86 mode										
workaround	none identified										
											
title	memory aliasing with inconsistent a and d bits may cause processor deadlock										
problem	in the event that software implements memory aliasing by having two page directory entries (pdes) point to a common page table entry (pte) and the accessed and dirty bits for the two pdes are allowed to become inconsistent the processor may become deadlocked										
implication	this erratum has not been observed with commercially available software										
workaround	software that needs to implement memory aliasing in this way should manage    the consistency of the accessed and dirty bits.										
											
title	use of memory aliasing with inconsistent memory type may cause system hang										
problem	software that implements memory aliasing by having more than one linear addresses mapped to the same physical page with different cache types may cause the system to hang. this would occur if one of the addresses is non-cacheable used in code segment and  the other a cacheable address.  if the cacheable address finds its way  in instruction cache, and non-cacheable address is fetched in ifu, the processor may invalidate the non-cacheable address from the fetch unit. any micro-architectural event that causes instruction restart will expect this instruction to still be in fetch unit and lack of it will cause system hang										
implication	this erratum has not been observed with commercially available software										
workaround	although it is  possible to have a single physical page mapped by two different   linear addresses with different memory types, intel has strongly discouraged this practice as it may lead to undefined results. software that needs to implement memory aliasing should manage the memory type consistency										
											
title	processor may report invalid tss fault instead of double fault during mode c paging										
problem	when an operating  system executes  a  task switch via a task state segment (tss)   the cr3 register is always updated from the new task tss. in the mode c paging, once the cr3 is changed the processor will attempt to load the pdptrs. if the cr3 from the target task tss or task switch handler tss is not valid then the new pdptr   will not be loaded. this will lead to the reporting of invalid tss fault instead of the expected double fault										
implication	operating systems that access an invalid tss may get invalid tss fault instead of a double fault.										
workaround	software needs to ensure any accessed tss is valid.										
											
title	machine check exception may occur when interleaving code between different memory types										
problem	a small window of opportunity  exists  where  code  fetches  interleaved  between  different memory types may cause a machine check exception. a complex set of micro-architectural boundary conditions is required to expose this window.										
implication	interleaved instruction fetches between different memory types may result in a machine check exception. the system may hang if machine check exceptions are disabled. intel has not observed the occurrence of this erratum while running commercially available applications or operating systems.										
workaround	software can avoid this erratum by placing a serializing instruction between code fetches between different memory types.										
											
title	wrong esp register values during a fault in vm86 mode										
problem	at the beginning of the iret instruction execution in vm86 mode, the lower 16 bits of the esp register are saved as the old stack value. when a fault occurs, these 16 bits are moved into the 32-bit esp, effectively clearing the upper 16 bits of the esp.										
implication	this erratum has not been observed to cause any problems with commercially available software.										
workaround	none identified										
											
title	apic icr write may cause interrupt not to be sent when icr delivery bit pending										
problem	if the apic icr (interrupt control register) is written with a new interrupt command  while the delivery status bit from a previous interrupt command is set to '1' (send pending), the interrupt message may not be sent out by the processor.										
implication	this erratum will cause an interrupt message not to be sent, potentially resulting in system hang.										
workaround	software  should always poll the  delivery status bit in the  apic  icr and ensure  that it is '0' (idle) before writing a new value to the icr.										
											
title	high temperature and low supply voltage operation may result in incorrect processor operation										
problem	when operating at the high temperature, low supply voltage corner of the processor specification, if there is a store pending in the processor’s fill buffer, and simultaneously a load operation misses the l1 cache but results in a hit to the l2 cache, then it is possible that incorrect data may be returned to satisfy the load operation.										
implication	when this erratum is encountered, unpredictable software behavior may occur. it can be seen from the table of affected steppings that this erratum is constrained to a single stepping and is only possible in processors operating at frequencies of 933mhz and above and is not present in all of those processors. application of the workaround will prevent occurrence of the erratum in all processors of that stepping.										
workaround	it is possible for bios code to contain a workaround for this erratum.										
											
title	during boundary scan, bclk not sampled high when slp# is asserted low										
problem	during boundary scan, bclk is not sampled high when slp# is asserted low.										
implication	boundary scan results may be incorrect when slp# is asserted low.										
workaround	do not use boundary scan when slp# is asserted low.										
											
title	incorrect assertion of thermtrip# signal										
problem	the internal control register bit responsible for operation of the thermtrip circuit functionality may power up in a non-initialized state. as a result, thermtrip# may  be incorrectly asserted during de-assertion of reset# at nominal operating temperatures. when thermtrip# is asserted as a result of this erratum, the processor may shut down internally and stop execution but in few cases continue to execute.										
implication	this issue can lead to intermittent system power-on boot failures.  the occurrence  and repeatability of failures is system dependent, however all systems  and  processors are susceptible to failure. in addition, the processor may fail to stop execution during the event of a valid thermtrip# assertion resulting in the potential for permanent processor damage										
workaround	to prevent the risk of power-on boot failures or catastrophic thermal failures, a platform workaround is required. the system must provide a rising edge on the tck signal during the power-on sequence that meets all of the following requirements:										
											
title	processor might not exit sleep state properly upon de-assertion of cpuslp# signal										
problem	if the  processor enters  a  sleep  state  upon assertion of cpuslp# signal,  and  if the core to system bus multiplier is an odd bus fraction, then the processor may not resume from the cpu sleep state upon the de-assertion of cpuslp# signal.										
implication	this erratum may result in a system hang during a resume from cpu sleep state.										
workaround	it is possible to workaround this in bios by not asserting cpuslp# for power management purposes										
											
title	the instruction fetch unit (ifu) may fetch instructions based upon stale cr3 data after a write to cr3 register										
problem	under a complex set of conditions, there exists a one-clock window following a write   to the cr3 register wherein it is possible for the itlb fill buffer to obtain a stale page translation based on the stale cr3 data. this stale translation will persist until the  next write to the cr3 register, the next page fault or execution of a certain class of instructions including cpuid or iretd with privilege level change.										
implication	the wrong page translation could be used leading to erroneous software behavior.										
workaround	operating  systems  that  are potentially affected can add a second write to the   cr3 register.										
											
title	under some complex conditions, the instructions in the shadow of a jmp far may be unintentionally executed and retired										
problem	if all of the following events happen in sequence it is possible for the system or  application to hang or to execute with incorrect data. the execution of an instruction, with an opcode that requires the processor to stall the issue of micro-instructions in the flow from the microcode sequence logic block to the instruction decode block. (a stallms condition) less than 63 (39 for pre-cpuid 0x6bx) micro-instructions later, the execution of a mispredictable branch instruction. (jcc, loopcc, ret near,  call near indirect, jmp ecx=0, or jmp near indirect)   the conditional branch in event (2) is mispredicted, and furthermore the mispredicted path of execution must result in either an itlb miss, or an  instruction cache miss. this needs to briefly stall the issue of micro-instructions again immediately after the conditional branch until that branch prediction is corrected by the jump execution block. (a 2nd stallms condition) along the correct path of execution, the next instruction must contain a 3rd stallms condition at a precisely aligned point in the execution of the instruction. ( clts, popss, lss, or mov to ss) a jmp far instruction must execute within the next 63 micro-instructions (39 pre- cpuid 0x6bx) the intervening micro-instructions must not have any events or faults. when the instruction from event (2) retires, the stallms condition within the event (5) instruction fails to operate correctly, and instructions in the shadow of the jmp  far instruction could be unintentionally executed.										
implication	occurrence of this erratum could lead to erroneous software behavior. intel has not identified any commercially available software which may encounter this condition; this erratum was discovered in a focused test environment. one of the four instructions that are required to trigger this erratum, clts, is a privileged instruction that is only executed by an operating system or driver code. the remaining three instructions, popss, lss, and mov to ss, are executed infrequently in modern 32-bit application code.										
workaround	none identified at this time										
											
title	processor does not flag #gp on non-zero write to certain msrs										
problem	when a non-zero write occurs to the upper 32 bits of sysenter_eip_msr or sysenter_esp_msr, the processor should indicate a general protection fault by flagging #gp. due to this erratum, the processor does not flag #gp.										
implication	the processor unexpectedly does not flag #gp on a non-zero write to the upper 32  bits of sysenter_eip_msr or sysenter_esp_msr. no known commercially  available operating system has been identified to be affected by this erratum.										
workaround	none identified.										
											
title	ifu/bsu deadlock may cause system hang										
problem	a lockable instruction with memory operand that spans across two pages may, given  some rare internal conditions, hang the system.										
implication	when this erratum occurs, the system may hang. intel has not observed this erratum with any commercially available software or system.										
workaround	lockable data should always be contained in a single page.										
											
title	rep movs operation in fast string mode continues in that mode when crossing into a page with a different memory type										
problem	a fast “rep movs” operation will continue to be handled in fast mode when the string operation crosses a page boundary into an uncacheable (uc) memory type. also if  the fast string operation crosses a page boundary into a wc memory region, the processor will not self snoop the wc memory region. this may eventually result in incorrect data for the wc portion of the operation if those cache lines were previously cached as wb (through aliasing) and modified.										
implication	string elements should be handled by the processor at the native operand size in uc memory. in the event that the wb to wc aliasing case occurs and incorrect data is written to memory, the end result would vary from benign to operating system or application failure. intel has not observed either aspects of this erratum in commercially available software.										
workaround	software operating within intel’s recommendation will not require wb and wc memory aliased to the same physical address.										
											
title	the fxsave, stos or movs instructions may cause a store ordering violation when data crosses a page with a uc memory type										
problem	if the data from an fxsave, stos or movs instruction crosses a page boundary from wb to uc memory type and this instruction is immediately followed by a second instruction that also issues a store to memory, the final data stores from both instructions may occur in the wrong order										
implication	the impact of this store ordering behavior may vary from normal software execution  to potential software failure. intel has not observed this erratum in commercially available software.										
workaround	fxsave,  stos or movs data must not cross page boundary from wb to uc  memory type.										
											
title	popf and popfd instructions that set the trap flag bit may cause unpredictable processor behavior										
problem	in some rare  cases, popf and popfd instructions that set the trap flag (tf) bit in    the eflags register (causing the processor to enter single-step mode) may cause unpredictable processor behavior.										
implication	single step operation is typically enabled during software debug activities, not during normal system operation										
workaround	there is no workaround for single step operation  in  commercially  available  software. for debug activities on custom software, the popf and popfd instructions could be immediately followed by a nop instruction to facilitate correct execution.										
											
title	code segment limit violation may occur on 4 gigabyte limit check										
problem	code segment limit violation  may occur on 4 gigabyte  limit check when the  code  stream wraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0x0.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	avoid code that wraps around segment limit.										
											
title	fst instruction with numeric and null segment exceptions may cause general protection faults to be missed and fp linear address (fla) mismatch										
problem	fst instruction combined with numeric and null segment exceptions may cause general protection faults to be missed and fp linear address (fla) mismatch.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	none identified.										
											
title	code segment (cs) is incorrect on smm handler when smbase is not aligned										
problem	with smbase being relocated to a non-aligned address, during smm entry the cs can be improperly updated which can lead to an incorrect smm handler.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	align smbase to 32k byte.										
											
title	page with pat (page attribute table) set to uswc (uncacheable speculative write combine) while associated mtrr (memory type range register) is uc (uncacheable) may consolidate to uc										
problem	a page  whose  pat memory type  is uswc  while the relevant mtrr memory type is  uc, the consolidated memory type may be treated as uc (rather than wc  as  specified in ia-32 intel® architecture software developer's manual).										
implication	when this erratum occurs, the memory page may be as uc (rather than wc). this may have a negative performance impact.										
workaround	none identified.										
											
title	under certain conditions ltr (load task register) instruction may result in system hang										
problem	an ltr instruction may result in a system hang if all the following conditions are met: invalid data selector of the tr (task register) resulting with either #gp (general protection fault) or #np (segment not present fault). gdt (global descriptor table) is not 8-bytes aligned. gdt (global descriptor table) is not 8-bytes aligned. data bp (breakpoint) is set on cache line containing the descriptor data.										
implication	this erratum may result in system hang if all conditions  have  been  met.  this erratum has not been observed in commercial operating systems or software. for performance reasons, gdt is typically aligned to 8-bytes.										
workaround	software should align gdt to 8-bytes.										
											
title	loading from memory type uswc (uncacheable speculative write combine) may get its data internally forwarded from a previous pending store										
problem	a load from memory type uswc  may  get  its  data  internally  forwarded  from  a pending store. as a result, the expected load may never be issued to the external  bus.										
implication	when this erratum occurs, a uswc load request may be satisfied without being observed on the external bus. there are no known usage models where this behavior results in any negative side-effects.										
workaround	do not use memory type uswc for memory that has read side effects.										
											
title	fxsave after fninit without an intervening fp (floating point) instruction may save uninitialized values for fdp (x87 fpu instruction operand (data) pointer offset) and fds (x87 fpu instruction operand (data) pointer selector)										
problem	an fxsave after fninit without an intervening fp instruction may save uninitialized values for fdp and fds.										
implication	when this erratum occurs, the values for fdp/fds in the fxsave structure may  appear to be random values. these values will be initialized by the first fp   instruction executed after the fxrstor that restore the saved floating point state. any fp instruction with memory operand will initialize fdp/fds. intel has  not observed this erratum with any commercially available software.										
workaround	after an finit, do not expect the  fxsave memory image  to be  correct, until at least one fp instruction with a memory operand has been executed.										
											
title	fstp (floating point store) instruction under certain conditions may result in erroneously setting a valid bit on an fp (floating point) stack register										
problem	an fstp instruction with an pde/pte (page directory entry/page table entry) a/d bit update followed by user mode access fault due to a code fetch to a page that has supervisor only access permission may result in erroneously setting a valid bit of an  fp stack register. the fp top of stack pointer is unchanged.										
implication	this erratum may cause an unexpected stack overflow										
workaround	user mode  code  should not count on being able to recover from illegal accesses   to memory regions protected with supervisor only access when using fp instructions.										
											
title	invalid entries in page-directory-pointer-table register  (pdptr) may cause general protection (#gp)  exception  if  the  reserved  bits are set to one										
problem	invalid entries in the page-directory-pointer-table register (pdptr) that have the reserved bits set to one may cause a general protection (#gp) exception.										
implication	intel has not observed this erratum with any commercially available software.										
workaround	do not set the reserved bits to one when pdptr entries are invalid.										
											
title	writing the local vector table (lvt) when an interrupt is pending may cause an unexpected interrupt										
problem	if  a  local  interrupt is pending  when the  lvt entry is written, an interrupt may be  taken on the new interrupt vector even if the mask bit is set.										
implication	an interrupt may immediately be generated with the new vector when a lvt entry is written, even if the new lvt entry has the mask bit set. if there is no interrupt service routine (isr) set up for that vector the system will gp fault. if the isr does not do an end of interrupt (eoi) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.										
workaround	any vector programmed into an lvt entry must have  an isr associated with it,  even if that vector was programmed as masked. this isr routine must do an eoi to										
											
title	the processor may report a #ts instead of a #gp fault										
problem	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss  exception) instead of a #gp fault (general protection exception).										
implication	operation systems that access a busy tss may get invalid tss fault instead of a #gp fault. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	a write to an apic register sometimes may appear to have not occurred										
problem	with respect to  the  retirement  of instructions, stores to the uncacheable memory-  based apic register space are handled in a non-synchronized way. for example if an instruction that masks the interrupt flag, e.g. cli, is executed soon after an uncacheable write to the task priority register (tpr) that lowers the apic priority,  the interrupt masking operation may take effect before the actual priority has been lowered. this may cause interrupts whose priority is lower than the initial tpr, but higher than the final tpr, to not be serviced until the interrupt enabled flag is finally set, i.e. by sti instruction. interrupts will remain pending and are not lost.										
implication	in this example the processor may allow interrupts to be accepted but may delay   their service.										
workaround	this non-synchronization can be  avoided  by issuing  an apic register read after   the apic register write. this will force the store to the apic register before any subsequent instructions are executed. no commercial operating system is known to  be impacted by this erratum..										
											
title	using 2m/4m pages when a20m# is asserted may result in  incorrect address translations										
problem	an external a20m# pin if enabled forces address bit 20 to be masked (forced to zero)  to emulates real-address mode address wraparound at 1 megabyte. however, if all of the following conditions are met, address bit 20 may not be masked. paging is enabled a linear address has bit 20 set the address references a large page a20m# is enabled										
implication	when a20m# is enabled and an address references a large page the resulting translated physical address may be incorrect. this erratum has not been observed with any commercially available operating system.										
workaround	operating systems should not allow a20m#  to  be  enabled  if the  masking of address bit 20 could be applied to an address that references a large page.  a20m#   is normally only used with the first megabyte of memory										
											
title	values for lbr/bts/btm will be incorrect after an exit from smm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering  their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect. note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not  be used.										
workaround	none identified.										
											
title	init does not clear global entries in the tlb										
problem	init may not flush a tlb entry when:   the processor is in protected mode with paging enabled and the page global enable flag is set (pge bit of cr4 register) g bit for the page table entry is set tlb entry is present in tlb when init occurs.										
implication	software  may encounter unexpected page fault or incorrect address translation due  to a tlb entry erroneously left in tlb after init.										
workaround	write to cr3, cr4 (setting bits pse, pge or pae) or cr0 (setting bits pg or pe) registers before writing to memory early in bios code to clear all the global entries from tlb.										
											
title	the bs flag in dr6 may be set for non-single-step #db exception										
problem	dr6 bs (single step, bit 14) flag may be incorrectly set when the tf (trap flag, bit 8) of the eflags register is set, and a #db (debug exception) occurs due to one of the following: dr7 gd (general detect, bit 13) being bit set; int1 instruction; code breakpoint the dr6 bs (single step, bit 14) flag may be incorrectly set.										
implication	the bs flag may be incorrectly set for non-single-step #db exception.										
workaround	none identified.										
											
title	fault on  enter  instruction  may  result  in  unexpected  values  on stack frame										
problem	the enter instruction is used to create  a  procedure  stack  frame.  due  to  this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e. residual stack data as a result of processing the fault).										
implication	data in the created stack frame may be altered following a fault on the enter instruction. please refer to "procedure calls  for block-structured languages" in ia- 32 intel® architecture software developer’s manual, vol. 1, basic architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3. faults are usually processed in ring 0 and stack switch occurs when   transferring  to ring 0.	intel has not observed this erratum on any commercially available software.									
workaround	none identified.										
											
title	unaligned accesses to paging structures may cause the processor to hang										
problem	when an unaligned access is performed on paging structure entries, accessing a portion of two different entries simultaneously, the processor may live lock.										
implication	when this erratum occurs, the processor may live lock causing a system hang.										
workaround	do not perform unaligned accesses on paging structure entries.										
											
title	invlpg operation for large (2m/4m) pages may be incomplete under certain conditions										
problem	the invlpg instruction may not completely invalidate translation look-aside buffer (tlb) entries for large pages (2m/4m) when both of the following conditions exist: address range of the page being invalidated spans several memory type range registers (mtrrs) with different memory types specified invlpg operation is preceded by a page assist event (page fault (#pf) or an access that results in either a or d bits being set in a page table entry (pte))										
implication	stale translations may remain valid in tlb after a pte update resulting in  unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure that the memory type specified in the mtrrs is the same    for the entire address range of the large page.										
											
title	page access bit may be set prior to signaling a code segment limit fault										
problem	if code segment limit is set close to the end of a code page, then due to this erratum   the memory page access bit (a bit) may be set for the subsequent page prior to general protection fault on code segment limit.										
implication	when this erratum occurs, a non-accessed page which is present in memory and follows a page that contains the code segment limit may be tagged as accessed										
workaround	erratum can be avoided by placing a guard page (non-present or non-executable page) as the last page of the segment or after the page that includes the code segment limit.										
											
title	eflags, cr0, cr4 and the exf4  signal  may  be  incorrect  after  shutdown										
problem	when the processor is going into shutdown due  to an rsm  inconsistency failure,  eflags, cr0 and cr4 may be incorrect. in addition the exf4 signal may still be asserted. this may be observed if the processor is taken out of shutdown by nmi#.										
implication	a processor that has been taken  out  of shutdown  may have an incorrect eflags, cr0 and cr4. in addition the exf4 signal may still be asserted.										
workaround	none identified										
											
title	performance  monitoring  event  fp_mmx_trans_to_mmx  may  not count some transitions										
problem	performance monitor  event  fp_mmx_trans_to_mmx  (event  cch,  umask  01h) counts transitions from x87 floating point (fp) to mmx™ instructions. due to this erratum, if only a small number of mmx instructions (including emms) are executed immediately after the last fp instruction, an fp to mmx transition may not  be counted.										
implication	the count value for performance monitoring event fp_mmx_trans_to_mmx may be lower than expected. the degree of undercounting is dependent on the occurrences   of the erratum condition while the counter is active. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	writing the local vector table (lvt) when an interrupt is pending may cause an unexpected interrupt										
problem	if a local interrupt is pending when the lvt entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.										
implication	an interrupt may immediately be generated with the new vector when a lvt entry is written, even if the new lvt entry has the mask bit set. if there is no interrupt service routine (isr) set up for that vector the system will gp fault. if the isr does not do an end of interrupt (eoi) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.										
workaround	any vector programmed into an lvt entry must have an isr associated with it, even if that vector was programmed as masked. this isr routine must do an eoi to clear any unexpected interrupts that may occur. the isr associated with the spurious vector does not generate an eoi, therefore the spurious vector should not be used when writing the lvt.										
											
title	lock# asserted during a special cycle shutdown transaction may unexpectedly deassert										
problem	during a processor shutdown transaction, when lock# is asserted and if a defer# is received during a snoop phase and the locked transaction is pipelined on the front side bus (fsb), lock# may unexpectedly deassert.										
implication	when this erratum occurs, the system may hang during shutdown. intel has not observed this erratum with any commercially available systems or software.										
workaround	none identified.										
											
title	address reported by machine-check architecture (mca) on single-bit l2 ecc errors may be incorrect										
problem	when correctable single-bit ecc errors occur in the l2 cache, the address is logged in the mca address register (mci_addr). under some scenarios, the address reported may be incorrect.										
implication	software should not rely on the value reported in mci_addr, for single-bit l2 ecc errors.										
workaround	none identified.										
											
title	exception record (ler) msrverw/verr/lsl/lar instructions may unexpectedly update the last exception record (ler) msr										
problem	the ler msr may be unexpectedly updated, if the resultant value of the zero flag (zf) is zero after executing the following instructions. verr (zf=0 indicates unsuccessful segment read verification) verw (zf=0 indicates unsuccessful segment write verification) lar (zf=0 indicates unsuccessful access rights load) lsl (zf=0 indicates unsuccessful segment limit load)										
implication	the value of the ler msr may be inaccurate if verw/verr/lsl/lar instructions are executed after the occurrence of an exception.										
workaround	software exception handlers that rely on the ler msr value should read the ler msr before executing verw/verr/lsl/lar instructions.										
											
title	dr3 address match on movd/movq/movntq memory store instruction may incorrectly increment performance monitoring count for saturating simd instructions retired (event cfh)										
problem	performance monitoring for event cfh normally increments on saturating simd instruction retired. regardless of dr7 programming, if the linear address of a retiring memory store movd/movq/movntq instruction executed matches the address in dr3, the cfh counter may be incorrectly incremented.										
implication	the value observed for performance monitoring count for saturating simd instructions retired may be too high. the size of the error is dependent on the number of occurrences of the conditions described above, while the counter is active.										
workaround											
											
title	sysret may incorrectly clear rf (resume flag) in the rflags register										
problem	in normal operation, sysret will restore the value of rflags from r11 (the value previously saved upon execution of the syscall instruction). due to this erratum, the rflags.rf bit will be unconditionally cleared after execution of the sysret instruction.										
implication	the sysret instruction can not be used if the rf flag needs to be set after returning from a system call. intel has not observed this erratum with any commercially available software.										
workaround	use the iret instruction to return from a system call, if rf flag has to be set after the return.										
											
title	general protection fault (#gp) for instructions greater than 15 bytes may be preempted										
problem	when the processor encounters an instruction that is greater than 15 bytes in length, a #gp is signaled when the instruction is decoded. under some circumstances, the #gp fault may be preempted by another lower priority fault (for example, page fault (#pf)). however, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #gp fault will occur.										
implication	software may observe a lower-priority fault occurring before or in lieu of a #gp fault. instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.										
workaround	none identified.										
											
title	pending x87 fpu exceptions (#mf) following sti may be serviced before higher priority interrupts.										
problem	interrupts that are pending prior to the execution of the sti (set interrupt flag) instruction are serviced immediately after the sti instruction is executed. because of this erratum, if following sti, an instruction that triggers a #mf is executed while stpclk#, enhanced intel speedstep® technology transitions or thermal monitor 1 events occur, the pending #mf may be serviced before higher priority interrupts.										
implication	software may observe #mf being serviced before higher priority interrupts.										
workaround	none identified.										
											
title	the processor may report a #ts instead of a #gp fault										
problem	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss exception) instead of a #gp fault (general protection exception).										
implication	operation systems that access a busy tss may get invalid tss fault instead of a #gp fault. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	a write to an apic register sometimes may appear to have not occurred										
problem	with respect to the retirement of instructions, stores to the uncacheable memory- based apic register space are handled in a non-synchronized way. for example if an instruction that masks the interrupt flag, for example. cli, is executed soon after an uncacheable write to the task priority register (tpr) that lowers the apic priority, the interrupt masking operation may take effect before the actual priority has been lowered. this may cause interrupts whose priority is lower than the initial tpr, but higher than the final tpr, to not be serviced until the interrupt enabled flag is finally set, that is. by sti instruction. interrupts will remain pending and are not lost.										
implication	in this example the processor may allow interrupts to be accepted but may delay their service.										
workaround	this non-synchronization can be avoided by issuing an apic register read after the apic register write. this will force the store to the apic register before any subsequent instructions are executed. no commercial operating system is known to be impacted by this erratum.										
											
title	programming the digital thermal sensor (dts) threshold may cause unexpected thermal interrupts										
problem	software can enable dts thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. when programming dts value, the previous dts threshold may be crossed. this generates an unexpected thermal interrupt.										
implication	software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold.										
workaround	in the acpi/os implement a workaround by temporarily disabling the dts threshold interrupt before updating the dts threshold value.										
											
title	count value for performance-monitoring counter pmh_page_walk may be incorrect										
problem	performance-monitoring counter pmh_page_walk is used to count the number of page walks resulting from data translation look-aside buffer (dtlb) and instruction translation look-aside (itlb) misses. under certain conditions, this counter may be incorrect.										
implication	there may be small errors in the accuracy of the counter.										
workaround	none identified.										
											
title	ler msrs may be incorrectly updated										
problem	the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh) may contain incorrect values after any of the following: either stpclk#, nmi (non-maskable interrupt), or external interrupts cmp or test instructions with an uncacheable memory operand followed by a conditional jump. sti/pop ss/mov ss instructions followed by cmp or test instructions and then by a conditional jump.										
implication	when the conditions for this erratum occur, the value of the ler msrs may be incorrectly updated.										
workaround	none identified.										
											
title	performance monitoring events for retired instructions (c0h) may not be accurate										
problem	the inst_retired performance monitor may miscount retired instructions as follows: repeat string and repeat i/o operations are not counted when a hardware interrupt is received during or after the last iteration of the repeat flow. vmlaunch and vmresume instructions are not counted. hlt and mwait instructions are not counted. the following instructions, if executed during hlt or mwait events, are also not counted: rsm from a c-state smi during an mwait instruction. rsm from an smi during a hlt instruction.										
implication	there may be a smaller than expected value in the inst_retired performance monitoring counter. the extent to which this value is smaller than expected is determined by the frequency of the above cases.										
workaround	none identified.										
											
title	performance monitoring event for number of reference cycles when the processor is not halted (3ch) does not count according to the specification										
problem	the cpu_clk_unhalted performance monitor with mask 1 counts bus clock cycles instead of counting the core clock cycles at the maximum possible ratio. the maximum possible ratio is computed by dividing the maximum possible core frequency by the bus frequency.										
implication	the cpu_clk_unhalted performance monitor with mask 1 counts a value lower than expected. the value is lower by exactly one multiple of the maximum possible ratio.										
workaround	multiply the performance monitor value by the maximum possible ratio.										
											
title	using 2m/4m pages when a20m# is asserted may result in incorrect address translations										
problem	an external a20m# pin if enabled forces address bit 20 to be masked (forced to zero) to emulates real-address mode address wraparound at 1 megabyte. however, if all of the following conditions are met, address bit 20 may not be masked: paging is enabled a linear address has bit 20 set the address references a large page a20m# is enabled										
implication	when a20m# is enabled and an address references a large page the resulting translated physical address may be incorrect. this erratum has not been observed with any commercially available operating system.										
workaround	operating systems should not allow a20m# to be enabled if the masking of address bit 20 could be applied to an address that references a large page. a20m# is normally only used with the first megabyte of memory.										
											
title	writing shared unaligned data that crosses a cache line without proper semaphores or barriers may expose a memory ordering issue										
problem	software which is written so that multiple agents can modify the same shared unaligned memory location at the same time may experience a memory ordering issue if multiple loads access this shared data shortly thereafter. exposure to this problem requires the use of a data write which spans a cache line boundary.										
implication	this erratum may cause loads to be observed out of order. intel has not observed this erratum with any commercially available software or system.										
workaround	software should ensure at least one of the following is true when modifying shared data by multiple agents:										
											
title	code segment limit violation may occur on 4-gigabyte limit check										
problem	code segment limit violation may occur on 4-gigabyte limit check when the code stream wraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0x0.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	avoid code that wraps around segment limit.										
											
title	fp inexact-result exception flag may not be set										
problem	when the result of a floating-point operation is not exactly representable in the destination format (1/3 in binary form, for example), an inexact-result (precision) exception occurs. when this occurs, the pe bit (bit 5 of the fpu status word) is normally set by the processor. under certain rare conditions, this bit may not be set when this rounding occurs. however, other actions taken by the processor (invoking the software exception handler if the exception is unmasked) are not affected. this erratum can only occur if one of the following fst instructions is one or two instructions after the floating-point operation which causes the precision exception: fst m32real fst m64real fstp m32real fstp m64real fstp m80real fist m16int fist m32int fistp m16int fistp m32int fistp m64int fisttp m16int fisttp m32int fisttp m64int  note: even if this combination of instructions is encountered, there is also a dependency on the internal pipelining and execution state of both instructions in the processor.										
implication	inexact-result exceptions are commonly masked or ignored by applications, as it happens frequently, and produces a rounded result acceptable to most applications. the pe bit of the fpu status word may not always be set upon receiving an inexact- result exception. thus, if these exceptions are unmasked, a floating-point error exception handler may not recognize that a precision exception occurred. note that this is a "sticky" bit, i.e., once set by an inexact-result condition, it remains set until cleared by software.										
workaround	this condition can be avoided by inserting either three nops or three non-floating-point non-jcc instructions between the two floating-point instructions.										
											
title	global pages in the data translation look-aside buffer (dtlb) may not be flushed by rsm instruction before restoring the architectural state from smram										
problem	the resume from system management mode (rsm) instruction does not flush global pages from the data translation look-aside buffer (dtlb) prior to reloading the saved architectural state.										
implication	if smm turns on paging with global paging enabled and then maps any of linear addresses of smram using global pages, rsm load may load data from the wrong location.										
workaround	do not use global pages in system management mode.										
											
title	sequential code fetch to non-canonical address may have nondeterministic results										
problem	if code sequentially executes off the end of the positive canonical address space (falling through from address 00007fffffffffff to non- canonical address 0000800000000000), under some circumstances the code fetch will be converted to a canonical fetch at address ffff800000000000.										
implication	due to this erratum, the processor may transfer control to an unintended address. the result of fetching code at that address is unpredictable and may include an unexpected trap or fault, or execution of the instructions found there.										
workaround	if the last page of the positive canonical address space is not allocated for code (4k page at 00007ffffffff000 or 2m page at 00007fffffe00000) then the problem cannot occur.										
											
title	vmcall to activate dual-monitor treatment of smis and smm ignores reserved bit settings in vm-exit control field										
problem	processors supporting intel® virtualization technology can execute vmcall from within the virtual machine monitor (vmm) to activate dual-monitor treatment of smis and smm. due to this erratum, if reserved bits are set to values inconsistent with vmx capability msrs, vmcall may not vmfail.										
implication	vmcall executed to activate dual-monitor treatment of smis and smm may not vmfail due to incorrect reserved bit settings in vm-exit control field.										
workaround	software should ensure that all vmcs reserved bits are set to values consistent with vmx capability msrs.										
											
title	rep movs/stos executing with fast strings enabled and crossing page boundaries with inconsistent memory types may use an incorrect data size or lead to memory-ordering violations.										
problem	under certain conditions as described in the intel® 64 and ia-32 architectures software developer’s manual, section out-of-order stores for string operations in pentium 4, intel xeon, and p6 family processors, the processor performs rep movs or rep stos as fast strings. due to this erratum fast string rep movs/rep stos instructions that cross page boundaries from wb/wc memory types to uc/wp/wt memory types, may start using an incorrect data size or may observe memory ordering violations.										
implication	upon crossing the page boundary the following may occur, dependent on the new page memory type: uc the data size of each write will now always be 8 bytes, as opposed to the original data size. wp the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. wt there may be a memory ordering violation.										
workaround	software should avoid crossing page boundaries from wb or wc memory type to uc, wp or wt memory type within a single rep movs or rep stos instruction that will execute with fast strings enabled.										
											
title	some bus performance monitoring events may not count local events under certain conditions										
problem	the following bus transaction performance monitor events are supposed to count all local transactions: bus_trans_ io (event: 6ch) – will not count i/o level reads resulting from package resolved c-state bus_trans_any (event: 70h) – will not count stop-grants										
implication	the count values for the affected events may be lower than expected. the degree of under count depends on the occurrence of erratum conditions while the affected events are active.										
workaround	none identified.										
											
title	premature execution of a load operation prior to exception handler invocation										
problem	if any of the below circumstances occur it is possible that the load portion of the instruction is executed before the exception handler is entered. if an instruction that performs a memory load causes a code segment limit violation. if a waiting x87 floating-point (fp) instruction or mmx™ technology instruction that performs a memory load has a floating-point exception pending. if an mmx or sse/sse2/sse3/ssse3 extensions (sse) instruction that performs a memory load and has either cr0.em=1 (emulation bit set), or a floating-point top-of-stack (fp tos) not equal to 0, or a dna exception pending.										
implication	in normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. if the target of the load is to uncached memory that has a system side-effect. particularly, while cr0.ts [bit 3] is set, a movd/movq with mmx/xmm register operands may issue a memory load before getting the dna exception.										
workaround	code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory.										
											
title	general protection (#gp) fault may not be signaled on data segment limit violation above 4-g limit										
problem	in 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4-g limit (0ffffffffh) may not signal a #gp fault.										
implication	when such memory accesses occur in 32-bit mode, the system may not issue a #gp fault.										
workaround	software should ensure that memory accesses in 32-bit mode do not occur above the 4- g limit (0ffffffffh).										
											
title	eip may be incorrect after shutdown in ia-32e mode										
problem	when the processor is going into shutdown state the upper 32 bits of the instruction pointer may be incorrect. this may be observed if the processor is taken out of shutdown state by nmi#.										
implication	a processor that has been taken out of the shutdown state may have an incorrect eip. the only software which would be affected is diagnostic software that relies on a valid eip.										
workaround	none identified.										
											
title	#gp fault is not generated on writing ia32_misc_enable [34] when execute disable is not supported										
problem	a #gp fault is not generated on writing to ia32_misc_enable [34] bit in a processor which does not support execute disable functionality.										
implication	writing to ia32_misc_enable [34] bit is silently ignored without generating a fault.										
workaround	none identified.										
											
title	(e)cx may get incorrectly updated when performing fast string rep movs or fast string rep stos with large data structures										
problem	when performing fast string rep movs or rep stos commands with data structures [(e)cx*data size] larger than the supported address size structure (64 kb for 16-bit address size and 4 gb for 32-bit address size) some addresses may be processed more than once. after an amount of data greater than or equal to the address size structure has been processed, external events (such as interrupts) will cause the (e)cx registers to be increment by a value that corresponds to 64 kb for 16-bit address size and 4 gb for 32-bit address size.										
implication	(e)cx may contain an incorrect count which may cause some of the movs or stos operations to re-execute. intel has not observed this erratum with any commercially available software.										
workaround	do not use values in (e)cx that when multiplied by the data size, give values larger than the address space size (64 kb for 16-bit address size and 4 gb for 32-bit address size).										
											
title	performance monitoring events for retired loads (cbh) and instructions retired (c0h) may not be accurate										
problem	the following events may be counted as instructions that contain a load by the mem_load_retired performance monitor events and may be counted as loads by the inst_retired (mask 01h) performance monitor event: prefetch instructions x87 exceptions on fst* and fbstp instructions breakpoint matches on loads, stores, and i/o instructions stores which update the a and d bits stores that split across a cache line vmx transitions any instruction fetch that misses in the itlb										
implication	the mem_load_retired and inst_retired (mask 01h) performance monitor events may count a value higher than expected. the extent to which the values are higher than expected is determined by the frequency of the above events.										
workaround	none identified.										
											
title	upper 32 bits of 'from' address reported through btms or btss may be incorrect										
problem	when a far transfer switches the processor from 32-bit mode to ia-32e mode, the upper 32 bits of the 'from' (source) addresses reported through the btms (branch trace messages) or btss (branch trace stores) may be incorrect.										
implication	the upper 32 bits of the 'from' address debug information reported through btms or btss may be incorrect during this transition.										
workaround	none identified.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the intel® 64 and ia- 32 architectures software developer’s manual volume 3: system programming guide, including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	in order to avoid this erratum, programmers should use the xmc synchronization algorithm as detailed in the intel® 64 and ia-32 architectures software developer’s manual volume 3: system programming guide, section: handling self- and cross- modifying code.										
											
title	msrs actual frequency clock count (ia32_aperf) or maximum frequency clock count (ia32_mperf) may contain incorrect data after a machine check exception (mce)										
problem	when an mce occurs during execution of a rdmsr instruction for msrs actual frequency clock count (ia32_aperf) or maximum frequency clock count (ia32_mperf), the current and subsequent rdmsr instructions for these msrs may contain incorrect data.										
implication	after an mce event, accesses to the ia32_aperf and ia32_mperf msrs may return incorrect data. a subsequent reset will clear this condition.										
workaround	none identified.										
											
title	incorrect address computed for last byte of fxsave/fxrstor image leads to partial memory update										
problem	a partial memory state save of the 512-byte fxsave image or a partial memory state restore of the fxrstor image may occur if a memory address exceeds the 64kb limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4gb limit while the processor is operating in 32-bit mode.										
implication	fxsave/fxrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.										
workaround	software should avoid memory accesses that wrap around the respective 16-bit and 32- bit mode memory limits.										
											
title	split locked stores may not trigger the monitoring hardware										
problem	logical processors normally resume program execution following the mwait, when another logical processor performs a write access to a wb cacheable address within the address range used to perform the monitor operation. due to this erratum, a logical processor may not resume execution until the next targeted interrupt event or o/s timer tick following a locked store that spans across cache lines within the monitored address range.										
implication	the logical processor that executed the mwait instruction may not resume execution until the next targeted interrupt event or o/s timer tick in the case where the monitored address is written by a locked store which is split across cache lines.										
workaround	do not use locked stores that span cache lines in the monitored address range.										
											
title	rep cmps/scas operations may terminate early in 64-bit mode when rcx >= 0x100000000										
problem	rep cmps (compare string) and scas (scan string) instructions in 64-bit mode may terminate before the count in rcx reaches zero if the initial value of rcx is greater than or equal to 0x100000000.										
implication	early termination of rep cmps/scas operation may be observed and rflags may be incorrectly updated.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	fxsave/fxrstor instructions which store to the end of the segment and cause a wrap to a misaligned base address (alignment <= 0x10h) may cause fpu instruction or operand pointer corruption										
problem	if a fxsave/fxrstor instruction stores to the end of the segment causing a wrap to a misaligned base address (alignment <= 0x10h), and one of the following conditions is satisfied: 32-bit addressing, obtained by using address-size override, when in 64-bit mode 16-bit addressing in legacy or compatibility mode.  then, depending on the wrap-around point, one of the below saved values may be corrupted: fpu instruction pointer offset fpu instruction pointer selector fpu operand pointer selector fpu operand pointer offset										
implication	this erratum could cause fpu instruction or operand pointer corruption and may lead to unexpected operations in the floating point exception handler.										
workaround	avoid segment base misalignment and address wrap-around at the segment boundary.										
											
title	prefetchh instruction execution under some conditions may lead to processor livelock										
problem	prefetchh instruction execution after a split load and dependent upon ongoing store operations may lead to processor livelock.										
implication	due to this erratum, the processor may livelock.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	prefetchh instructions may not be executed when alignment check (ac) is enabled										
problem	prefetcht0, prefetcht1, prefetcht2 and prefetchnta instructions may not be executed when alignment check is enabled.										
implication	prefetchh instructions may not perform the data prefetch if alignment check is enabled.										
workaround	clear the ac flag (bit 18) in the eflags register and/or the am bit (bit 18) of control register cr0 to disable alignment checking.										
											
title	upper 32 bits of the fpu data (operand) pointer in the fxsave memory image may be unexpectedly all 1's after fxsave										
problem	the upper 32 bits of the fpu data (operand) pointer may incorrectly be set to all 1's instead of the expected value of all 0's in the fxsave memory image if all of the following conditions are true: the processor is in 64-bit mode. the last floating point operation was in compatibility mode bit 31 of the fpu data (operand) pointer is set. an fxsave instruction is executed										
implication	software depending on the full fpu data (operand) pointer may behave unpredictably.										
workaround	none identified.										
											
title	concurrent multi-processor writes to non-dirty page may result in unpredictable behavior										
problem	when a logical processor writes to a non-dirty page, and another logical-processor either writes to the same non-dirty page or explicitly sets the dirty bit in the corresponding page table entry, complex interaction with internal processor activity may cause unpredictable system behavior.										
implication	this erratum may result in unpredictable system behavior and hang.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	performance monitor idle_during_div (18h) count may not be accurate										
problem	performance monitoring events that count the number of cycles the divider is busy and no other execution unit operation or load operation is in progress may not be accurate.										
implication	the counter may reflect a value higher or lower than the actual number of events.										
workaround	none identified.										
											
title	values for lbr/bts/btm will be incorrect after an exit from smm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect.  note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.										
workaround	none identified.										
											
title	shutdown condition may disable non-bootstrap processors										
problem	when a logical processor encounters an error resulting in shutdown, non-bootstrap processors in the package may be unexpectedly disabled.										
implication	non-bootstrap logical processors in the package that have not observed the error condition may be disabled and may not respond to init#, smi#, nmi#, sipi or other events.										
workaround	when this erratum occurs, reset# must be asserted to restore multi-core functionality.										
											
title	syscall immediately after changing eflags.tf may not behave according to the new eflags.tf										
problem	if a syscall instruction follows immediately after eflags.tf was updated and ia32_fmask.tf (bit 8) is cleared, then under certain circumstances syscall may behave according to the previous eflags.tf.										
implication	when the problem occurs, syscall may generate an unexpected debug exception, or may skip an expected debug exception.										
workaround	mask eflags.tf by setting ia32_fmask.tf (bit 8).										
											
title	code segment limit/canonical faults on rsm may be serviced before higher priority interrupts/exceptions and may push the wrong address onto the stack										
problem	normally, when the processor encounters a segment limit or canonical fault due to code execution, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. due to this erratum, if rsm (resume from system management mode) returns to execution flow that results in a code segment limit or canonical fault, the #gp fault may be serviced before a higher priority interrupt or exception (e.g. nmi (non-maskable interrupt), debug break(#db), machine check (#mc), etc.). if the rsm attempts to return to a non- canonical address, the address pushed onto the stack for this #gp fault may not match the non-canonical address that caused the fault.										
implication	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	vm bit is cleared on second fault handled by task switch from virtual- 8086 (vm86)										
problem	following a task switch to any fault handler that was initiated while the processor was in vm86 mode, if there is an additional fault while servicing the original task switch then the vm bit will be incorrectly cleared in eflags, data segments will not be pushed and the processor will not return to the correct mode upon completion of the second fault handler via iret.										
implication	when the os recovers from the second fault handler, the processor will no longer be in vm86 mode. normally, operating systems should prevent interrupt task switches from faulting, thus the scenario should not occur under normal circumstances.										
workaround	none identified.										
											
title	ia32_fmask is reset during an init										
problem	ia32_fmask msr (0xc0000084) is reset during init.										
implication	if an init takes place after ia32_fmask is programmed, the processor will overwrite the value back to the default value.										
workaround	operating system software should initialize ia32_fmask after init.										
											
title	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception										
problem	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.										
implication	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software, or system.										
workaround	as recommended in the intel® 64 and ia-32 architectures software developer's manual, the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.										
											
title	last branch records (lbr) updates may be incorrect after a task switch										
problem	a task-state segment (tss) task switch may incorrectly set the lbr_from value to the lbr_to value.										
implication	the lbr_from will have the incorrect address of the branch instruction.										
workaround	none identified.										
											
title	io_smi indication in smram state save area may be set incorrectly										
problem	the io_smi bit in smram's location 7fa4h is set to "1" by the cpu to indicate a system management interrupt (smi) occurred as the result of executing an instruction that reads from an i/o port. due to this erratum, the io_smi bit may be incorrectly set by: a non-i/o instruction. smi is pending while a lower priority event interrupts. a rep i/o read. an i/o read that redirects to mwait. in systems supporting intel® virtualization technology a fault in the middle of an io operation that causes a vm exit										
implication	smm handlers may get false io_smi indication.										
workaround	the smm handler has to evaluate the saved context to determine if the smi was triggered by an instruction that read from an i/o port. the smm handler must not restart an i/o instruction if the platform has not been configured to generate a synchronous smi for the recorded i/o port address.										
											
title	init does not clear global entries in the tlb										
problem	init may not flush a tlb entry when: the processor is in protected mode with paging enabled and the page global enable flag is set (pge bit of cr4 register). g bit for the page table entry is set. tlb entry is present in tlb when init occurs.										
implication	software may encounter unexpected page fault or incorrect address translation due to a tlb entry erroneously left in tlb after init.										
workaround	write to cr3, cr4 (setting bits pse, pge or pae) or cr0 (setting bits pg or pe) registers before writing to memory early in bios code to clear all the global entries from tlb.										
											
title	using memory type aliasing with memory types wb/wt may lead to unpredictable behavior										
problem	memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory type. memory type aliasing with the memory types wb and wt may cause the processor to perform incorrect operations leading to unpredictable behavior.										
implication	software that uses aliasing of wb and wt memory types may observe unpredictable behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	update of read/write (r/w) or user/supervisor (u/s) or present (p) bits without tlb shootdown may cause unexpected processor behavior										
problem	updating a page table entry by changing r/w, u/s or p bits without tlb shootdown (as defined by the 4 step procedure in "propagation of page table and page directory entry changes to multiple processors" in volume 3a of the intel® 64 and ia-32 architectures software developer’s manual), in conjunction with a complex sequence of internal processor micro-architectural events, may lead to unexpected processor behavior.										
implication	this erratum may lead to livelock, shutdown or other unexpected processor behavior. intel has not observed this erratum with any commercially available system.										
workaround	none identified.										
											
title	bts message may be lost when the stpclk# signal is active										
problem	stpclk# is asserted to enable the processor to enter a low-power state. under some circumstances, when stpclk# becomes active, the bts (branch trace store) message may be either lost and not written or written with corrupted branch address to the debug store area.										
implication	bts messages may be lost or be corrupted in the presence of stpclk# assertions.										
workaround	none identified.										
											
title	mov to/from debug registers causes debug exception										
problem	when in v86 mode, if a mov instruction is executed to/from a debug register, a general-protection exception (#gp) should be generated. however, in the case when the general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.										
implication	with debug-register protection enabled (that is, the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception will be generated instead of the expected general-protection fault.										
workaround	in general, operating systems do not set the gd bit when they are in v86 mode. the gd bit is generally set and used by debuggers. the debug exception handler should check that the exception did not occur in v86 mode before continuing. if the exception did occur in v86 mode, the exception may be directed to the general-protection exception handler.										
											
title	eflags discrepancy on a page fault after a multiprocessor tlb shootdown										
problem	this erratum may occur when the processor executes one of the following read- modify-write arithmetic instructions and a page fault occurs during the store of the memory operand: add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd. in this case, the eflags value pushed onto the stack of the page fault handler may reflect the status of the register after the instruction would have completed execution rather than before it. the following conditions are required for the store to generate a page fault and call the operating system page fault handler: the store address entry must be evicted from the dtlb by speculative loads from other instructions that hit the same way of the dtlb before the store has completed. dtlb eviction requires at least three-load operations that have linear address bits 15:12 equal to each other and address bits 31:16 different from each other in close physical proximity to the arithmetic operation. the page table entry for the store address must have its permissions tightened during the very small window of time between the dtlb eviction and execution of the store. examples of page permission tightening include from present to not present or from read/write to read only, etc. 3. another processor, without corresponding synchronization and tlb flush, must cause the permission change.										
implication	this scenario may only occur on a multiprocessor platform running an operating system that performs “lazy” tlb shootdowns. the memory image of the eflags register on the page fault handler’s stack prematurely contains the final arithmetic flag values although the instruction has not yet completed. intel has not identified any operating systems that inspect the arithmetic portion of the eflags register during a page fault nor observed this erratum in laboratory testing of software applications.										
workaround	no workaround is needed upon normal restart of the instruction, since this erratum is transparent to the faulting code and results in correct instruction behavior. operating systems may ensure that no processor is currently accessing a page that is scheduled to have its page permissions tightened or have a page fault handler that ignores any incorrect state.										
											
title	lbr, bts, btm may report a wrong address when an exception/interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/interrupt.										
workaround	none identified.										
											
title	a thermal interrupt is not generated when the current temperature is invalid										
problem	when the dts (digital thermal sensor) crosses one of its programmed thresholds it generates an interrupt and logs the event (ia32_therm_status msr (019ch) bits [9, 7]). due to this erratum, if the dts reaches an invalid temperature (as indicated ia32_therm_status msr bit[31]) it does not generate an interrupt even if one of the programmed thresholds is crossed and the corresponding log bits become set.										
implication	when the temperature reaches an invalid temperature the cpu does not generate a thermal interrupt even if a programmed threshold is crossed.										
workaround	none identified.										
											
title	cmpsb, lodsb, or scasb in 64-bit mode with count greater or equal to 248 may terminate early										
problem	in 64-bit mode cmpsb, lodsb, or scasb executed with a repeat prefix and count greater than or equal to 248 may terminate early. early termination may result in one of the following. the last iteration not being executed signaling of a canonical limit fault (#gp) on the last iteration										
implication	while in 64-bit mode, with count greater or equal to 248, repeat string operations cmpsb, lodsb or scasb may terminate without completing the last iteration. intel has not observed this erratum with any commercially available software.										
workaround	do not use repeated string operations with rcx greater than or equal to 248.										
											
title	returning to real mode from smm with eflags.vm set may result in unpredictable system behavior										
problem	returning back from smm mode into real mode while eflags.vm is set in smram may result in unpredictable system behavior.										
implication	if smm software changes the values of the eflags.vm in smram, it may result in unpredictable system behavior. intel has not observed this behavior in commercially available software.										
workaround	smm software should not change the value of eflags.vm in smram.										
											
title	vmlaunch/vmresume may not fail when vmcs is programmed to cause vm exit to return to a different mode										
problem	vmlaunch/vmresume instructions may not fail if the value of the “host address- space size” vm-exit control differs from the setting of ia32_efer.lma.										
implication	programming the vmcs to allow the monitor to be in different modes prior to vmlaunch/vmresume and after vm-exit may result in undefined behavior										
workaround	software should ensure that "host address-space size" vm-exit control has the same value as ia32_efer.lma at the time of vmlaunch/vmresume.										
											
title	iret under certain conditions may cause an unexpected alignment check exception										
problem	in ia-32e mode, it is possible to get an alignment check exception (#ac) on the iret instruction even though alignment checks were disabled at the start of the iret. this can only occur if the iret instruction is returning from cpl3 code to cpl3 code. irets from cpl0/1/2 are not affected. this erratum can occur if the eflags value on the stack has the ac flag set, and the interrupt handler's stack is misaligned. in ia-32e mode, rsp is aligned to a 16-byte boundary before pushing the stack frame.										
implication	in ia-32e mode, under the conditions given above, an iret can get a #ac even if alignment checks are disabled at the start of the iret. this erratum can only be observed with a software generated stack frame.										
workaround	software should not generate misaligned stack frames for use with iret.										
											
title	performance monitoring event fp_assist may not be accurate    fadd and fmul instructions with a nan(not a number) operand and a memory operand fdiv instruction with zero operand value in memory										
problem	in addition, an assist event may be counted when daz (denormals-are-zeros) and ftz (flush-to-zero) flags are turned on even though no actual assist occurs.										
implication	the counter value for the performance monitoring event fp_assist (11h) may be larger than expected. the size of the error is dependent on the number of occurrences of the above conditions while the event is active.										
workaround	none identified.										
											
title	cpl-qualified bts may report incorrect branch-from instruction address										
problem	cpl (current privilege level)-qualified bts (branch trace store) may report incorrect branch-from instruction address under the following conditions: either bts_off_os [9] or bts_off_usr [10] is selected in ia32_debugctlc msr (1d9h). privilege-level transitions occur between cpl > 0 and cpl 0 or vice versa.										
implication	due to this erratum, the from address reported by bts may be incorrect for the described conditions.										
workaround	none identified										
											
title	pebs does not always differentiate between cpl-qualified events										
problem	performance monitoring counter configured to sample pebs (precise event based sampling) events at a certain privilege level may count samples at the wrong privilege level.										
implication	performance monitoring counter may be higher than expected for cpl-qualified events.										
workaround	do not use performance monitoring counters for precise event sampling when the precise event is dependent on the cpl value.										
											
title	pmi may be delayed to next pebs event										
problem	after a pebs (precise event-based sampling) event, the pebs index is compared with the pebs threshold, and the index is incremented with every event. if pebs index is equal to the pebs threshold, a pmi (performance monitoring interrupt) should be issued. due to this erratum, the pmi may be delayed by one pebs event.										
implication	debug store interrupt service routines may observe delay of pmi occurrence by one pebs event.										
workaround	none identified.										
											
title	pebs buffer overflow status will not be indicated unless ia32_debugctl[12] is set										
problem	ia32_perf_global_status msr (38eh) bit [62] when set, indicates that a pebs (precise event-based sampling) overflow has occurred and a pmi (performance monitor interrupt) has been sent. due to this erratum, this bit is not set unless ia32_debugctl msr (1d9h) bit [12] (which stops all performance monitor counters upon a pmi) is also set.										
implication	due to this erratum, ia32_perf_global_status [62] will not signal that a pmi was generated due to a pebs overflow unless ia32_debugctl [12] is set.										
workaround	it is possible for the software to set ia32_debugctl [12] to avoid this erratum.										
											
title	the bs flag in dr6 may be set for non-single-step #db exception										
problem	dr6 bs (single step, bit 14) flag may be incorrectly set when the tf (trap flag, bit 8) of the eflags register is set, and a #db (debug exception) occurs due to one of the following: dr7 gd (general detect, bit 13) being bit set int1 instruction; code breakpoint										
implication	the bs flag may be incorrectly set for non-single-step #db exception.										
workaround	none identified.										
											
title	an asynchronous mce during a far transfer may corrupt esp										
problem	if an asynchronous machine check occurs during an interrupt, call through gate, far ret or iret and in the presence of certain internal conditions, esp may be corrupted.										
implication	if the mce (machine check exception) handler is called without a stack switch, then a triple fault will occur due to the corrupted stack pointer, resulting in a processor shutdown. if the mce is called with a stack switch, for example when the cpl (current privilege level) was changed or when going through an interrupt task gate, then the corrupted esp will be saved on the stack or in the tss (task state segment), and will not be used.										
workaround	use an interrupt task gate for the machine check handler.										
											
title	in single-stepping on branches mode, the bs bit in the pending- debug-exceptions field of the guest state area will be incorrectly set by vm-exit on a mov to cr8 instruction										
problem	in a system supporting intel virtualization technology, the bs bit (bit 14 of the pending-debug-exceptions field) in the guest state area will be incorrectly set when all of the following conditions occur:  the processor is running in vmx non-root as a 64 bit mode guest; the “cr8-load existing” vm-execution control is 0 and the “use tpr shadow” vmexecution is 1. both btf (single-step on branches, bit 1) of the ia32_debugctl msr (1d9h) register and the tf (trap flag, bit 8) of the rflags register are set. “mov cr8, reg” attempts to program a tpr (task priority register) value that is below the tpr threshold and causes a vm-exit.										
implication	a virtual-machine will sample the bs bit and will incorrectly inject a single-step trap to the guest.										
workaround	a virtual-machine monitor must manually disregard the bs bit in the guest state area in case of a vm-exit due to a tpr value below the tpr threshold.										
											
title	b0-b3 bits in dr6 may not be properly cleared after code breakpoint										
problem	b0-b3 bits (breakpoint conditions detect flags, bits [3:0]) in dr6 may not be properly cleared when the following sequence happens: pop instruction to ss (stack segment) selector. next instruction is fp (floating point) that gets fp assist followed by code breakpoint.										
implication	b0-b3 bits in dr6 may not be properly cleared.										
workaround	none identified.										
											
title	btm/bts branch-from instruction address may be incorrect for software interrupts										
problem	when btm (branch trace message) or bts (branch trace store) is enabled, a software interrupt may result in the overwriting of btm/bts branch-from instruction address by the lbr (last branch record) branch-from instruction address.										
implication	a btm/bts branch-from instruction address may get corrupted for software interrupts.										
workaround	none identified.										
											
title	rep store instructions in a specific situation may cause the processor to hang										
problem	during a series of rep (repeat) store instructions a store may try to dispatch to memory prior to the actual completion of the instruction. this behavior depends on the execution order of the instructions, the timing of a speculative jump and the timing of an uncacheable memory store. all types of rep store instructions are affected by this erratum.										
implication	when this erratum occurs, the processor may live lock and/or result in a system hang.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	performance monitor sse retired instructions may return incorrect values										
problem	the simd_inst_retired (event: c7h) is used to track retired sse instructions. due to this erratum, the processor may also count other types of instructions resulting in values higher than the number of actual retired sse instructions.										
implication	the event monitor instruction simd_inst_retired may report count higher than expected.										
workaround	none identified.										
											
title	performance monitoring events for l1 and l2 miss may not be accurate										
problem	performance monitoring events 0cbh with an event mask value of 02h or 08h (mem_load_retired.l1_line_miss or mem_load_retired.l2_line_miss) may under count the cache miss events.										
implication	these performance monitoring events may show a count which is lower than expected; the amount by which the count is lower is dependent on other conditions occurring on the same load that missed the cache.										
workaround	none identified.										
											
title	store to wt memory data may be seen in wrong order by two subsequent loads										
problem	when data of store to wt memory is used by two subsequent loads of one thread and another thread performs cacheable write to the same address the first load may get the data from external memory or l2 written by another core, while the second load will get the data straight from the wt store.										
implication	software that uses wb to wt memory aliasing may violate proper store ordering.										
workaround	do not use wb to wt aliasing.										
											
title	a mov instruction from cr8 register with 16-bit operand size will leave bits 63:16 of the destination register unmodified										
problem	moves to/from control registers are supposed to ignore rew.w and the 66h (operand size) prefix. in systems supporting intel virtualization technology, when the processor is operating in vmx non-root operation and “use tpr shadow” vm-execution control is set to 1, a mov instruction from cr8 with a 16 bit operand size (rex.w =0 and 66h prefix) will only store 16 bits and leave bits 63:16 at the destination register unmodified, instead of storing zeros in them.										
implication	intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	debug register may contain incorrect information on a movss or popss instruction followed by sysret										
problem	in ia-32e mode, if a movss or popss instruction with a debug breakpoint is followed by the sysret instruction; incorrect information may exist in the debug status register (dr6).										
implication	when debugging or when developing debuggers, this behavior should be noted. this erratum does not occur under normal usage of the movss or popss instructions (that is, following them with a mov esp instruction).										
workaround	do not attempt to put a breakpoint on movss and popss instructions that are followed by a sysret.										
											
title	single step interrupts with floating point exception pending may be mishandled										
problem	in certain circumstances, when a floating point exception (#mf) is pending during single-step execution, processing of the single-step debug exception (#db) may be mishandled.										
implication	when this erratum occurs, #db will be incorrectly handled as follows: #db is signaled before the pending higher priority #mf (interrupt 16) #db is generated twice on the same instruction										
workaround	none identified										
											
title	non-temporal data store may be observed in wrong program order										
problem	when non-temporal data is accessed by multiple read operations in one thread while another thread performs a cacheable write operation to the same address, the data stored may be observed in wrong program order (i.e., later load operations may read older data).										
implication	software that uses non-temporal data without proper serialization before accessing the non-temporal data may observe data in wrong program order.										
workaround	software that conforms to the intel® 64 and ia-32 architecture software developer's manual, volume 3a, section “buffering of write combining memory locations” will operate correctly.										
											
title	fault on enter instruction may result in unexpected values on stack frame										
problem	the enter instruction is used to create a procedure stack frame. due to this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (i.e., residual stack data as a result of processing the fault).										
implication	data in the created stack frame may be altered following a fault on the enter instruction. please refer to "procedure calls for block-structured languages" in the intel® 64 and ia-32 architectures software developer’s manual, vol. 1, basic architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3. faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. intel has not observed this erratum on any commercially-available software.										
workaround	none identified.										
											
title	cpuid reports architectural performance monitoring version 2 is supported, when only version 1 capabilities are available										
problem	cpuid leaf 0ah reports the architectural performance monitoring version that is available in eax[7:0]. due to this erratum cpuid reports the supported version as 2 instead of 1.										
implication	software will observe an incorrect version number in cpuid.0ah.eax [7:0] in comparison to which features are actually supported.										
workaround	software should use the recommended enumeration mechanism described in the architectural performance monitoring section of the intel® 64 and ia-32 architecture software developer's manual, volume 3: system programming guide.										
											
title	unaligned accesses to paging structures may cause the processor to hang										
problem	when an unaligned access is performed on paging structure entries, accessing a portion of two different entries simultaneously, the processor may live lock.										
implication	when this erratum occurs, the processor may live lock causing a system hang.										
workaround	do not perform unaligned accesses on paging structure entries.										
											
title	microcode updates performed during vmx non-root operation could result in unexpected behavior										
problem	when intel® virtualization technology is enabled, microcode updates are allowed only during vmx root operations. attempts to apply microcode updates while in vmx non- root operation should be silently ignored. due to this erratum, the processor may allow microcode updates during vmx non-root operations if not explicitly prevented by the host software.										
implication	microcode updates performed in non-root operation may result in unexpected system behavior.										
workaround	host software should intercept and prevent loads to ia32_bios_updt_trig msr (79h) during vmx non-root operations. there are two mechanism that can be used (1) enabling msr access protection in the vm-execution controls or (2) enabling selective msr protection of ia32_bios_updt_trig msr.										
											
title	invlpg operation for large (2m/4m) pages may be incomplete under certain conditions										
problem	the invlpg instruction may not completely invalidate translation look-aside buffer (tlb) entries for large pages (2-m/4-m) when both of the following conditions exist: address range of the page being invalidated spans several memory type range registers (mtrrs) with different memory types specified. invlpg operation is preceded by a page assist event (page fault (#pf) or an access that results in either a or d bits being set in a page table entry (pte)										
implication	stale translations may remain valid in tlb after a pte update resulting in unpredictable system behavior. intel has not observed this erratum with any commercially available software										
workaround	software should ensure that the memory type specified in the mtrrs is the same for the entire address range of the large page.										
											
title	page access bit may be set prior to signaling a code segment limit fault										
problem	if code segment limit is set close to the end of a code page, then due to this erratum the memory page access bit (a bit) may be set for the subsequent page prior to general protection fault on code segment limit.										
implication	when this erratum occurs, a non-accessed page present in memory following a page that contains the code segment limit may be tagged as accessed										
workaround	non-present or non-executable page can be placed after the limit of the code segment to prevent this erratum.										
											
title	update of attribute bits on page directories without immediate tlb shootdown may cause unexpected processor behavior										
problem	updating a page directory entry (or page map level 4 table entry or page directory pointer table entry in ia-32e mode) by changing r/w, u/s or p bits without immediate tlb shootdown (as described by the 4 step procedure in "propagation of page table and page directory entry changes to multiple processors" in volume 3a of the intel® 64 and ia-32 architectures software developer’s manual), in conjunction with a complex sequence of internal processor micro-architectural events, may lead to unexpected processor behavior.										
implication	this erratum may lead to livelock, shutdown or other unexpected processor behavior. intel has not observed this erratum with any commercially available system.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	invalid instructions may lead to unexpected behavior										
problem	invalid instructions due to undefined opcodes or instructions exceeding the maximum instruction length (due to redundant prefixes placed before the instruction) may lead, under complex circumstances, to unexpected behavior.										
implication	the processor may behave unexpectedly due to invalid instructions. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	eflags, cr0, cr4 and the exf4 signal may be incorrect after shutdown										
problem	when the processor is going into shutdown due to an rsm inconsistency failure, eflags, cr0 and cr4 may be incorrect. in addition the exf4 signal may still be asserted. this may be observed if the processor is taken out of shutdown by nmi#.										
implication	a processor that has been taken out of shutdown may have an incorrect eflags, cr0 and cr4. in addition the exf4 signal may still be asserted.										
workaround	none identified.										
											
title	performance monitoring counter macro_insts.decoded may not count some decoded instructions										
problem	macro_insts.decoded performance monitoring counter (event 0aah, umask 01h) counts the number of macro instructions decoded, but not necessarily retired. the event is undercounted when the decoded instructions are a complete loop iteration that is decoded in one cycle and the loop is streamed by the lsd (loop stream detector), as described in the optimizing the front end section of the intel® 64 and ia-32 architectures optimization reference manual.										
implication	the count value returned by the performance monitoring counter macro_inst.decoded may be lower than expected. the degree of undercounting is dependent on the occurrence of loop iterations that are decoded in one cycle and whether the loop is streamed by the lsd while the counter is active.										
workaround	none identified.										
											
title	the stack may be incorrect as a result of vip/vif check on sysexit and sysret										
problem	3. both the vif (virtual interrupt flag) and vip (virtual interrupt pending) flags of the eflags register are set										
implication	if this erratum occurs the stack size may be incorrect, consequently this may result in unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	performance monitoring event simd_uop_type_exec.mul is counted incorrectly for pmuludq instruction										
problem	performance monitoring event simd_uop_type_exec.mul (event select 0b3h, umask 01h) counts the number of simd packed multiply micro-ops executed. the count for pmuludq micro-ops might be lower than expected. no other instruction is affected.										
implication	the count value returned by the performance monitoring event simd_uop_type_exec.mul may be lower than expected. the degree of undercount depends on actual occurrences of pmuludq instructions, while the counter is active.										
workaround	none identified.										
											
title	storage of pebs record delayed following execution of mov ss or sti										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflow of the counter results in storage of a pebs record in the pebs buffer. the information in the pebs record represents the state of the next instruction to be executed following the counter overflow. due to this erratum, if the counter overflow occurs after execution of either mov ss or sti, storage of the pebs record is delayed by one instruction.										
implication	when this erratum occurs, software may observe storage of the pebs record being delayed by one instruction following execution of mov ss or sti. the state information in the pebs record will also reflect the one instruction delay.										
workaround	none identified.										
											
title	updating code page directory attributes without tlb invalidation may result in improper handling of code #pf   the target linear address corresponds to the modified pde the pte (page table entry) for the target linear address has an a (accessed) bit that is clear										
problem	one of the following simultaneous exception conditions is present following the code transition code #db and code #pf code segment limit violation #gp and code #pf										
implication	software may observe either incorrect processing of code #pf before code segment limit violation #gp or processing of code #pf in lieu of code #db.										
workaround	none identified.										
											
title	performance monitoring event cpu_clk_unhalted.ref may not count clock cycles according to the processors operating frequency										
problem	performance counter msr_perf_fixed_ctr2 (msr 30bh) that counts cpu_clk_unhalted.ref clocks should count these clock cycles at a constant rate that is determined by the maximum resolved boot frequency, as programmed by bios. due to this erratum, the rate is instead set by the maximum core-clock to bus- clock ratio of the processor, as indicated by hardware.										
implication	no functional impact as a result of this erratum. if the maximum resolved boot frequency as programmed by bios is different from the frequency implied by the maximum core-clock to bus-clock ratio of the processor as indicated by hardware, then the following effects may be observed:										
workaround	performance monitoring event cpu_clk_unhalted.ref will count at a rate different than the tsc (time stamp counter)										
											
title	store ordering may be incorrect between wc and wp memory types										
problem	according to intel® 64 and ia-32 architectures software developer's manual, volume 3a, methods of caching available, wp (write protected) stores should drain the wc (write combining) buffers in the same way as uc (uncacheable) memory type stores do. due to this erratum, wp stores may not drain the wc buffers.										
implication	memory ordering may be violated between wc and wp stores.										
workaround	none identified										
											
title	(e)cx may get incorrectly updated when performing fast string rep stos with large data structures										
problem	when performing fast string rep stos commands with data structures [(e)cx*data size] larger than the supported address size structure (64k for 16-bit address size and 4g for 32-bit address size) some addresses may be processed more than once. after an amount of data greater than or equal to the address size structure has been processed, external events (such as interrupts) will cause the (e)cx registers to be incremented by a value that corresponds to 64k bytes for 16 bit address size and 4g bytes for 32 bit address size.										
implication	(e)cx may contain an incorrect count which may cause some of the stos operations to re-execute. intel has not observed this erratum with any commercially available software.										
workaround	do not use values in (e)cx that when multiplied by the data size, give values larger than the address space size (64k for 16-bit address size and 4g for 32-bit address size).										
											
title	performance monitoring event br_inst_retired may count cpuid instructions as branches										
problem	performance monitoring event br_inst_retired (c4h) counts retired branch instructions. due to this erratum, two of its sub-events mistakenly count for cpuid instructions as well. those sub events are: br_inst_retired.pred_not_taken (umask 01h) and br_inst_retired.any (umask 00h).										
implication	the count value returned by the performance monitoring event br_inst_retired.pred_not_taken or br_inst_retired.any may be higher than expected. the extent of over counting depends on the occurrence of cpuid instructions, while the counter is active.										
workaround	none identified.										
											
title	performance monitoring event misalign_mem_ref may over count										
problem	performance monitoring event misalign_mem_ref (05h) is used to count the number of memory accesses that cross an 8-byte boundary and are blocked until retirement. due to this erratum, the performance monitoring event misalign_mem_ref also counts other memory accesses.										
implication	the performance monitoring event misalign_mem_ref may over count. the extent of the over counting depends on the number of memory accesses retiring while the counter is active.										
workaround	none identified										
											
title	a rep stos/movs to a monitor/mwait address range may prevent triggering of the monitoring hardware										
problem	the monitor instruction is used to arm the address monitoring hardware for the subsequent mwait instruction. the hardware is triggered on subsequent memory store operations to the monitored address range. due to this erratum, rep stos/movs fast string operations to the monitored address range may prevent the actual triggering store to be propagated to the monitoring hardware.										
implication	a logical processor executing an mwait instruction may not immediately continue program execution if a rep stos/movs targets the monitored address range.										
workaround	software can avoid this erratum by not using rep stos/movs store operations within the monitored address range.										
											
title	false level one data cache parity machine-check exceptions may be signaled										
problem	executing an instruction stream containing invalid instructions/data may generate a false level one data cache parity machine-check exception.										
implication	the false level one data cache parity machine-check exception is reported as an uncorrected machine-check error. an uncorrected machine-check error is treated as a fatal exception by the operating system and may cause a shutdown and/or reboot.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a memory access may get a wrong memory type following a #gp due to wrmsr to an mtrr mask										
problem	the tlb (translation lookaside buffer) may indicate a wrong memory type on a memory access to a large page (2m/4m byte) following the recovery from a #gp (general protection fault) due to a wrmsr to one of the ia32_mtrr_physmaskn msrs with reserved bits set.										
implication	when this erratum occurs, a memory access may get an incorrect memory type leading to unexpected system operation. as an example, an access to a memory mapped i/o device may be incorrectly marked as cacheable, become cached, and never make it to the i/o device. intel has not observed this erratum with any commercially available software.										
workaround	software should not attempt to set reserved bits of ia32_mtrr_physmaskn msrs.										
											
title	pmi while lbr freeze enabled may result in old/out-of-date lbr information										
problem	when precise event-based sampling (pebs) is configured with performance monitoring interrupt (pmi) on pebs buffer overflow enabled and last branch record (lbr) freeze on pmi enabled by setting freeze_lbrs_on_pmi flag (bit 11) to 1 in ia32_debugctl (msr 1d9h), the lbr stack is frozen upon the occurrence of a hardware pmi request. due to this erratum, the lbr freeze may occur too soon (i.e. before the hardware pmi request).										
implication	following a pmi occurrence, the pmi handler may observe old/out-of-date lbr information that does not describe the last few branches before the pebs sample that triggered the pmi.										
workaround	none identified										
											
title	overlap of an intel® vt apic access page in a guest with the ds save area may lead to unpredictable behavior										
problem	logging of a branch record or a pebs (precise-event-based-sampling) record to the ds (debug store) save area that overlaps with the apic access page may lead to unpredictable behavior.										
implication	guest software configured to log branch records or pebs records cannot specify the ds (debug store) save area within the apic-access page. under any expected usage model this type of overlap is not expected to exist. one should be aware of the fact that the specified ds address is of linear form while the apic access page is of a physical form. any solution that wishes to avoid this condition will need to comprehend the linear-to-physical translation of the ds related address pointers with respect to the mapping of the physical apic access page to avoid such an overlap. under normal circumstances for correctly written software, such an overlap is not expected to exist. intel has not observed this erratum with any commercially available software.										
workaround	for a fully comprehensive workaround, the vmm should not allow the logging of branch or pebs records while guest software is running if the "virtualize apic accesses" vm- execution control is 1.										
											
title	vtpr write access during event delivery may cause an apic-access vm exit										
problem	vtpr write accesses should not cause apic-access vm exits but instead should cause data to be written to the virtual-apic page. due to this erratum, a vtpr write access during event delivery may cause an apic-access vm exit with no data being written to the virtual-apic page.										
implication	vtpr accesses are accesses to offset 80h on the apic-access page. vtpr write accesses can occur during event delivery when pushing data on the stack. because event delivery performs multiple stack pushes, an event delivery that includes a vtpr write access will also include at least one other write to the apic-access page. that other write will cause an apic-access vm exit. thus, even in the presence of this erratum, any event delivery that includes a vtpr write access will cause an apic- access vm exit. the only difference with respect to correct behavior will be with regard to page offset saved in the exit qualification by the apic-access vm exit. a vmm should be able to emulate the event delivery correctly even with the incorrect offset.										
workaround	the vmm should emulate any event delivery that causes an apic-access vm exit in the same way regardless of the offset saved in the exit qualification.										
											
title	bist failure after reset										
problem	the processor may show an erroneous bist (built-in self test) result in bit [17] of eax register when coming out of reset.										
implication	when this erratum occurs, an erroneous bist failure will be reported in eax bit [17]. this failure can be ignored since it is not accurate.										
workaround	it is possible for bios to workaround this erratum by masking off bit [17] of the eax register after coming out of reset.										
											
title	performance monitoring event fp_mmx_trans_to_mmx may not count some transitions										
problem	performance monitor event fp_mmx_trans_to_mmx (event cch, umask 01h) counts transitions from x87 floating point (fp) to mmx™ instructions. due to this erratum, if only a small number of mmx instructions (including emms) are executed immediately after the last fp instruction, a fp to mmx transition may not be counted.										
implication	the count value for performance monitoring event fp_mmx_trans_to_mmx may be lower than expected. the degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	instruction fetch may cause a livelock during snoops of the l1 data cache										
problem	a livelock may be observed in rare conditions when instruction fetch causes multiple level one data cache snoops.										
implication	due to this erratum, a livelock may occur. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	use of memory aliasing with inconsistent memory type may cause a system hang or a machine check exception										
problem	software that implements memory aliasing by having more than one linear addresses mapped to the same physical page with different cache types may cause the system to hang or to report a machine check exception (mce). this would occur if one of the addresses is non-cacheable and used in a code segment and the other is a cacheable address. if the cacheable address finds its way into the instruction cache, and the non-cacheable address is fetched in the ifu, the processor may invalidate the non- cacheable address from the fetch unit. any micro-architectural event that causes instruction restart will be expecting this instruction to still be in the fetch unit and lack of it will cause a system hang or an mce.										
implication	this erratum has not been observed with commercially available software.										
workaround	although it is possible to have a single physical page mapped by two different linear addresses with different memory types, intel has strongly discouraged this practice as it may lead to undefined results. software that needs to implement memory aliasing should manage the memory type consistency										
											
title	a wb store following a rep stos/movs or fxsave may lead to memory-ordering violations										
problem	under certain conditions, as described in the software developers manual section "out-of-order stores for string operations in pentium 4, intel xeon, and p6 family processors", the processor may perform rep movs or rep stos as write combining stores (referred to as “fast strings”) for optimal performance. fxsave may also be internally implemented using write combining stores. due to this erratum, stores of a wb (write back) memory type to a cache line previously written by a preceding fast string/fxsave instruction may be observed before string/fxsave stores.										
implication	a write-back store may be observed before a previous string or fxsave related store. intel has not observed this erratum with any commercially available software.										
workaround	software desiring strict ordering of string/fxsave operations relative to subsequent write-back stores should add an mfence or sfence instruction between the string/fxsave operation and following store-order sensitive code such as that used for synchronization.										
											
title	vm exit with exit reason “tpr below threshold” can cause the blocking by mov/pop ss and blocking by sti bits to be cleared in the guest interruptibility-state field										
problem	as specified in section, “vm exits induced by the tpr shadow”, in the intel® 64 and ia-32 architectures software developer’s manual, volume 3b, a vm exit occurs immediately after any vm entry performed with the “use tpr shadow", "activate secondary controls”, and “virtualize apic accesses” vm-execution controls all set to 1 and with the value of the tpr shadow (bits 7:4 in byte 80h of the virtual-apic page) less than the tpr-threshold vm-execution control field. due to this erratum, such a vm exit will clear bit 0 (blocking by sti) and bit 1 (blocking by mov/pop ss) of the interruptibility-state field of the guest-state area of the vmcs (bit 0 - blocking by sti and bit 1 - blocking by mov/pop ss should be left unmodified).										
implication	since the sti, mov ss, and pop ss instructions cannot modify the tpr shadow, bits 1:0 of the interruptibility-state field will usually be zero before any vm entry meeting the preconditions of this erratum; behavior is correct in this case. however, if vmm software raises the value of the tpr-threshold vm-execution control field above that of the tpr shadow while either of those bits is 1, incorrect behavior may result. this may lead to vmm software prematurely injecting an interrupt into a guest. intel has not observed this erratum with any commercially available software.										
workaround	vmm software raising the value of the tpr-threshold vm-execution control field should compare it to the tpr shadow. if the threshold value is higher, software should not perform a vm entry; instead, it could perform the actions that it would normally take in response to a vm exit with exit reason “tpr below threshold”.										
											
title	using memory type aliasing with cacheable and wc memory types may lead to memory ordering violations										
problem	memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory types. memory type aliasing with a cacheable memory type and wc (write combining) may cause the processor to perform incorrect operations leading to memory ordering violations for wc operations.										
implication	software that uses aliasing between cacheable and wc memory types may observe memory ordering errors within wc memory operations. intel has not observed this erratum with any commercially available software.										
workaround	none identified. intel does not support the use of cacheable and wc memory type aliasing, and wc operations are defined as weakly ordered.										
											
title	rsm instruction execution under certain conditions may cause processor hang or unexpected instruction execution results										
problem	rsm instruction execution, under certain conditions triggered by a complex sequence of internal processor micro-architectural events, may lead to processor hang, or unexpected instruction execution results.										
implication	in the above sequence, the processor may live lock or hang, or rsm instruction may restart the interrupted processor context through a nondeterministic eip offset in the code segment, resulting in unexpected instruction execution, unexpected exceptions or system hang. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum. please contact your intel sales representative for availability.										
											
title	nmis may not be blocked by a vm-entry failure										
problem	the intel® 64 and ia-32 architectures software developer’s manual volume 3b: system programming guide, part 2 specifies that, following a vm-entry failure during or after loading guest state, “the state of blocking by nmi is what it was before vm entry.” if non-maskable interrupts (nmis) are blocked and the “virtual nmis” vm- execution control set to 1, this erratum may result in nmis not being blocked after a vm-entry failure during or after loading guest state.										
implication	vm-entry failures that cause nmis to become unblocked may cause the processor to deliver an nmi to software that is not prepared for it.										
workaround	vmm software should configure the virtual-machine control structure (vmcs) so that vm- entry failures do not occur.										
											
title	benign exception after a double fault may not cause a triple fault shutdown										
problem	according to the intel® 64 and ia-32 architectures software developer’s manual, volume 3a, exception and interrupt reference, if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. however due to this erratum, only contributory exceptions and page faults will cause a triple fault shutdown, whereas a benign exception may not.										
implication	if a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	ia32_mc1_status msr bit[60] does not reflect machine check error reporting enable correctly										
problem	ia32_mc1_status msr (405h) bit[60] (en- error enabled) is supposed to indicate whether the enable bit in the ia32_mc1_ctl msr (404h) was set at the time of the last update to the ia32_mc1_status msr. due to this erratum, ia32_mc1_status msr bit[60] instead reports the current value of the ia32_mc1_ctl msr enable bit.										
implication	ia32_mc1_status msr bit [60] may not reflect the correct state of the enable bit in the ia32_mc1_ctl msr at the time of the last update.										
workaround	none identified.										
											
title	corruption of cs segment register during rsm while transitioning from real mode to protected mode										
problem	during the transition from real mode to protected mode, if an smi (system management interrupt) occurs between the mov to cr0 that sets pe (protection enable, bit 0) and the first far jmp, the subsequent rsm (resume from system management mode) may cause the lower two bits of cs segment register to be corrupted.										
implication	the corruption of the bottom two bits of the cs segment register will have no impact unless software explicitly examines the cs segment register between enabling protected mode and the first far jmp. intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, part 1, in the section titled "switching to protected mode" recommends the far jmp immediately follows the write to cr0 to enable protected mode. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	fp data operand pointer may be incorrectly calculated after an fp access which wraps a 4-gbyte boundary in code that uses 32-bit address size in 64-bit mode										
problem	the fp (floating point) data operand pointer is the effective address of the operand associated with the last non-control fp instruction executed by the processor. if an 80-bit fp access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-gbyte boundary and the fp environment is subsequently saved, the value contained in the fp data operand pointer may be incorrect.										
implication	due to this erratum, the fp data operand pointer may be incorrect. wrapping an 80- bit fp load around a 4-gbyte boundary in this way is not a normal programming practice. intel has not observed this erratum with any commercially available software.										
workaround	if the fp data operand pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit fp accesses are wrapped around a 4-gbyte boundary.										
											
title											
problem	under an unlikely and complex sequence of conditions in 64-bit mode, a register ip- relative instruction result may be incorrect.										
implication	a register ip-relative instruction result may be incorrect and could cause software to read from or write to an incorrect memory location. this may result in an unexpected page fault or unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	vm exit due to virtual apic-access may clear rf   erratum affecting only intel® core™2 duo mobile processors on mobile intel® 965 express chipset family										
problem	rf (resume flag), bit 16 of the eflags/rflags register, is used to restart instruction execution without getting an instruction breakpoint on the instruction following a debug breakpoint exception. due to this erratum, in a system supporting intel® virtualization technology, when a vm exit occurs due to virtual apic-access (advanced programmable interrupt controller-access) the eflags/rflags saved in the vmcs (virtual-machine control structure) may contain an rf value of 0.										
implication	when this erratum occurs, following a vm exit due to a virtual apic-access, the processor may unintentionally break on the subsequent instruction after vm entry.										
workaround	none identified.										
											
title	vmcall failure due to corrupt mseg location may cause vm exit to load the machine state incorrectly										
problem	in systems supporting intel virtualization technology, if a vmcall failure occurs due to a corrupt monitor segment (mseg), subsequent vm exits may load machine state incorrectly.										
implication	occurrence of this erratum may result in a vmx abort.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	fixed function performance counters msr_perf_fixed_ctr1(30ah) and msr_perf_fixed_ctr2(30bh) are note cleared when the processor is reset										
problem	the fixed function performance counters that count the number of core cycles and reference cycles when the core is not in a halt state are not cleared when the processor is reset.										
implication	the msr_perf_fixed_ctr1 and msr_perf_fixed_ctr2 counters may contain unexpected values after reset.										
workaround	bios can workaround this erratum by clearing the counters at processor initialization time.										
											
title	multi-core processors configured for single core operation may not be able to enter intel® enhanced deeper sleep										
problem	bios may contain the option to disable cmp (core multiple processing). disabling cmp configures a processor for single core operation. due to this erratum, a multi-core processor operating with cmp disabled may not be able to enter intel® enhanced deeper sleep if a sipi (start-up inter-processor interrupt) is sent to the disabled processor.										
implication	when this erratum occurs, the processor may not be able to enter the intel® enhanced deeper sleep and therefore may consume more power than expected. intel has not observed this erratum with any commercially available system or software.										
workaround	none identified										
											
title	vtpr access may lead to system hang										
problem	the logical processor may hang if an instruction performs a vtpr access and the next instruction to be executed is located on a different code page.										
implication	software running vmx non-root operation may cause a logical processor to hang if the virtual-machine monitor (vmm) sets both the “use tpr shadow” and “virtualize apic accesses” vm-execution controls.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	activation of intel® adaptive thermal monitor while intel® dynamic front side bus frequency switching is active may lead to an incorrect operating point frequency										
problem	intel adaptive thermal monitor has the ability to use multiple frequency/voltage operating points to cool the processor while maintaining a high level of performance. if intel dynamic front side bus frequency switching is active, activation of the intel adaptive thermal monitor may transition the processor to the correct operating point voltage, but not frequency. this may occur if: 1.) the software/os requests to go to a higher performance enhanced intel speedstep® technology operating point during the thermal monitor activation period. 2.) an entry into c4 state or intel enhanced deeper sleep interrupts the transition between the intel dynamic front side bus frequency switching frequency and the targeted thermal monitor operating point frequency.										
implication	if this erratum occurs, the intel dynamic front side bus frequency switching operating point frequency will be observed along with the intel adaptive thermal monitor operating point voltage. the performance state status register (ia32_perf_sts) will reflect this intermediate performance state. there is no functional impact; the eventual voltage/frequency selection is a valid operating point. de-activation of the intel adaptive thermal monitor will result in the processor transitioning to the expected enhanced intel speedstep technology operating point.										
workaround	none identified										
											
title	gigabit ethernet controller aux1 pin cannot be used for ieee-1588* v2 clock synchronization										
problem	the gigabit ethernet (gigabit ethernet) controller’s software defined pin aux1, when used as the ieee-1588 v2 auxiliary device connection for external clock synchronization, may miss incoming pulses.										
implication	use of the gigabit ethernet aux1 pin may cause incorrect external clock synchronization.										
workaround	use the gigabit ethernet controller’s software defined pin aux0 as the ieee-1588 v2 auxiliary device connection for external clock synchronization.										
											
title	sata transmit signal voltage levels may exceed specification value										
problem	the sata transmit buffers have been designed to maximize performance including a variety of routing scenarios. as a result, the sata transmit levels may exceed the maximum motherboard transmit (tx) connector and the device receive (rx) connector voltage specifications as defined in section 7.2.1 of the serial ata specification for both sata gen1 (1.5 gb/s) and gen2 (3 gb/s) speeds.										
implication	intel has not observed this erratum to negatively impact the operation of any commercially available system.										
workaround	none identified.										
											
title	disabling one uart disables both uarts										
problem	disabling one uart (universal asynchronous receiver transmitter) by setting bit 0 or bit 1 in the uart_cont register (bus 0; device 31; function 0; offset 80h) will incorrectly disable both uarts.										
implication	if either uart is disabled during active uart operations, a loss of serial communication results.										
workaround	do not disable the unused uart.										
											
title	usb full-speed traffic may be lost										
problem	if a usb full-speed transaction is started near the end of a micro-frame, the soc may receive more than 189 bytes for the next micro-frame.										
implication	if the soc receives more than 189 bytes for a micro-frame, an nyet (no response yet) handshake packet error will be sent to the software and the transfer will be lost.										
workaround	none identified. usb driver recovery protocol may be applied to cause the transfer to be retried.										
											
title	virtual wire mode b will result in a system hang										
problem	when the local apic is configured for virtual wire mode b, the system may hang. the local apic supports 8259 virtual wire a and symmetric interrupt modes.										
implication	the 8259 virtual wire b mode external interrupts will be ignored leading the system to hang.										
workaround	do not use the 8259 virtual mode b mode when using the 8259 to deliver interrupts.										
											
title	pcie* may experience link width degradation during power up										
problem	the pcie receiver circuits may violate zrx-high-imp-dcpos as defined in section 4.3.4.5 of the pci express base specification, revision 3.0. this applies to the 2.5 gb/s and the 5 gb/s transfer rates.										
implication	the attached pcie device may falsely detect a receiver during power up resulting in link width degradation.										
workaround	a bios code change has been identified and may be implemented as workaround for this erratum.										
											
title	pcie root ports may incorrectly indicate crs software visibility support										
problem	the pcie root port rootcap.crssv (bus 0; device 1-4; function 0; offset 5eh; bit 0) field indicates that the root port is capable of returning crs (configuration request retry status) completion status to software. due to this erratum, the default value of this bit is set to 1, incorrectly indicating that crs is supported.										
implication	due to this erratum, the software that expects the crs completion status may not function as expected.										
workaround	a bios code change has been identified and may be implemented as workaround for this erratum.										
											
title	pcie ports may log a receiver overflow error on an unexpected completion										
problem	upon receipt of an unexpected completion, the pcie root port (bus 0; device 1-4; function 0) may log a receiver overflow error in addition to an unexpected completion error.										
implication	due to this erratum, a receiver overflow error may be logged incorrectly. if receiver overflow errors are configured to be fatal errors, this may result in a system hang.										
workaround	to avoid a hang, it is possible to configure receiver overflow errors to be non-fatal errors.										
											
title	the platform smbus device incorrectly advertises a 32-byte bar size										
problem	during bios enumeration, the legacy smbus controller indicates a 32 bytes bar size while the design allocation size is 2kb.										
implication	when this erratum occurs, accessing the smbus controller bar region may result in a device conflict.										
workaround	a bios code change has been identified and may be implemented as workaround for this erratum.										
											
title	processor may hang if gigabit ethernet controller’s eeprom is not properly configured or absent										
problem	systems may fail to boot if the processor’s gigabit ethernet controller’s associated configuration eeprom is not properly configured or has not been installed on the platform.										
implication	systems that do not properly place and configure the gigabit ethernet controller’s eeprom may hang.										
workaround	a bios code change has been identified and may be implemented as workaround for this erratum.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	a page fault may not be generated when the ps bit is set to 1 in a pml4e or pdpte										
problem	the processors supporting the intel® 64 architecture, the ps bit (page size bit 7) is reserved in pml4es and pdptes. if the translation of the linear address of a memory access encounters a pml4e or a pdpte with ps set to 1, a page fault should occur. due to this erratum, ps of such an entry is ignored and no page fault will occur due to its being set.										
implication	software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.										
workaround	software should not set bit 7 in any pml4e or pdpte that has present bit (bit 0) set to “1”.										
											
title	cs limit violations may not be detected after vm entry										
problem	the processor may fail to detect a cs limit violation on fetching the first instruction after vm entry if the first byte of that instruction is outside the cs limit but the last byte of the instruction is inside the limit.										
implication	the processor may erroneously execute an instruction that should have caused a general protection exception.										
workaround	when a vmm emulates a branch instruction it should inject a general protection exception if the instruction target eip is beyond the cs limit.										
											
title	ia32_debugctl.freeze_perfmon_on_pmi is incorrectly cleared by smi										
problem	freeze_perfmon_on_pmi (bit 12) in the ia32_debugctl msr (1d9h) is erroneously cleared during delivery of an smi (system-management interrupt).										
implication	as a result of this erratum, the performance monitoring counters will continue to count after a pmi occurs in smm (system-management mode).										
workaround	none identified.										
											
title	pebs record eventingip field may be incorrect after cs.base change										
problem	due to this erratum a pebs (precise event base sampling) record generated after an operation which changes cs.base may contain an incorrect address in the eventingip field.										
implication	software attempting to identify the instruction which caused the pebs event may identify the incorrect instruction when non-zero cs.base is supported and cs.base is changed. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	some performance counter overflows may not be logged in ia32_perf_global_status when freeze_perfmon_on_pmi is   enabled										
problem	when enabled, freeze_perfmon_on_pmi bit 12 in ia32_debugctl msr (1d9h) freezes pmcs (performance monitoring counters) on a pmi (performance monitoring interrupt) request by clearing the ia32_perf_global_ctrl msr (38fh). due to this erratum, when freeze_perfmon_on_pmi is enabled and two or more pmcs overflow within a small window of time and pmi is requested, then subsequent pmc overflows may not be logged in ia32_perf_global_status msr (38eh).										
implication	on a pmi, subsequent pmc overflows may not be logged in ia32_perf_global_status msr.										
workaround	re-enabling the pmcs in ia32_perf_global_ctrl will log the overflows that were not previously logged in ia32_perf_global_status.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of movntdqa that loads from wc (write combining) memory may appear to pass an earlier locked instruction to a different cache line.										
implication	software that expects a lock to fence subsequent movntdqa instructions may not operate properly. if the software does not rely on locked instructions to fence the subsequent execution of movntdqa then this erratum does not apply.										
workaround	software that requires a locked instruction to fence subsequent executions of movntdqa should insert an lfence instruction before the first execution of movntdqa following the locked instruction. if there is already a fencing or serializing instruction between the locked instruction and the movntdqa, then an additional lfence is not necessary.										
											
title	performance monitor instructions retired event may not count consistently										
problem	performance monitor instructions retired (event c0h; umask 00h) and the instruction retired fixed counter (ia32_fixed_ctr0 msr (309h)) are used to track the number of instructions retired. due to this erratum, certain situations may cause the counter(s) to increment when no instruction has retired or to not increment when specific instructions have retired.										
implication	a performance counter counting instructions retired may over or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor or system bus master writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction prior to execution of the new code is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case, the phrase “unexpected or unpredictable execution behavior” encompasses the generation of most of the exceptions listed in the intel architecture software developer's manual volume 3: system programming guide including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf, the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	in order to avoid this erratum, programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3: system programming guide, section: handling self- and cross-modifying code.										
											
title	redirection of rsm to probe mode may not generate an lbr record										
problem	a redirection of the rsm instruction to probe mode may not generate the lbr (last branch record) record that would have been generated by a non-redirected rsm instruction.										
implication	the lbr stack may be missing a record when redirection of rsm to probe mode is used. the lbr stack will still properly describe the code flow of non-smm code.										
workaround	none identified.										
											
title	usb ehci rmh port disabled due to device initiated remote wake										
problem	during resume from global suspend, the rmh controller may not send sof soon enough to prevent a device from entering suspend again. a collision on the port may occur if a device initiated remote wake occurs before the rmh controller sends sof.  note:	intel has only observed this issue when two usb devices on the same rmh controller send remote wake within 30 ms window while rmh controller is resuming from global suspend.									
implication	the rmh host controller may detect the collision as babble and disable the port. workaround intel recommends system software to check bit 3 (port enable/disable change)										
workaround											
											
title	ag3e pin strap value may not affect power sequencing										
problem	ag3e (after g3 enable) pin strap is correctly written to the gen_pmcon1.ag3e register bit (bus 0; device 31; function 0; offset 44h; bit 0) after a power-on but may not be correctly utilized during power-on sequencing.										
implication	due to this erratum, the soc may proceed to s0 without waiting for a wake event when ag3e is asserted.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie* ports may not detect a 100mhz toggle for compliance mode switching										
problem	the default behavior of the soc pcie electrical idle detection circuit does not guarantee detection of 100mhz toggling signal as recommended by the implementation note in pcie 3.0 base specification section 4.2.6.2.2.										
implication	the soc may not cycle through all of the transmitter defined settings while under pcie compliance load board test.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie* elasticity buffer errors may be detected when not in config/l0 ltssm states										
problem	pcie elasticity buffer errors may be observed by the ltssm (link training status state machine) outside of the config/l0 states.										
implication	due to this erratum, receiver errors may be logged in the pcie errcorsts.re (bus 0; device 1-4; function 0; offset 110h; bit 0) and, as a consequence, possibly signaled to the os.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	a spurious pcie* data parity error is logged										
problem	a pcie root port may incorrectly determine a tlp (transaction layer packet) is poisoned and logs an error in the pcists.dpe field (bus 0; devices 1-4; function 0; offset 06h, bit 15) and, if the associated pcicmd.per field (bus 0; devices 1-4; function 0; offset 04h, bit 6) is set, the pcists.mdpe (bus 0; devices: 1-4; function: 0; offset 06h, bit 8) field.										
implication	spurious errors may be logged in the pci status register but no poison tlp is received or sent. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	none identified.										
											
title	interrupt may be lost if i/o apic is programmed in edge mode										
problem	an interrupt programmed in the i/o apic to be triggered by a rising edge may be lost if the irq line is deasserted prior to the interrupt delivery to the core.										
implication	the interrupt will not be serviced. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	none identified.										
											
title	pcie* link l1 exit may result in a system hang										
problem	a processor pcie link may hang while exiting the l1 link power state.										
implication	due to this erratum, the system may hang during a pcie l1 power state transition.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	internal errors may not be escalated to the rcec										
problem	a masked unsupported request error occurring simultaneously with a detected internal parity or unexpected completion error within the pcie* root complex may prevent the escalation of internally detected errors to the rcec (root complex event collector) for interrupt generation.										
implication	when this erratum occurs, the soc may hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	disabling gigabit ethernet controller function 0 may lead to unexpected system behavior										
problem	when the gigabit ethernet controller function 0 is disabled, that function should be replaced by a dummy function. due to this erratum, the dummy function’s address space is not compatible with the processor system fabric.										
implication	if the gigabit ethernet controller’s dummy function is enabled, the dummy function may be the target of requests intended for different devices, leading to unexpected system behavior.										
workaround	none identified. the gigabit ethernet controller function 0 must remain enabled when the controller is enabled.										
											
title	smbus controller may detect spurious parity errors										
problem	if the address of the last data byte transferred (i.e., buffer base address + length - 1) in an smbus master transaction modulo 16 is inclusively between 0 and 7, the smbus controller may spuriously detect a parity error.										
implication	if the smbus controller detects a data parity error then the transaction is discarded, the controller stops processing master transactions, mctrl.ss (smbus 2.0 master control register; base: smtbar; offset: 108h; bit: 0) is cleared, error status field errsts.irdpe (smbus 2.0 error status register; base: smtbar; offset: 018h; bit: 9) is set, and error status field erruncsts.ptlpe (smbus 2.0 uncorrectable error status register; bus: 0; device: 13h; function: 0; offset: 104h; bit: 12) is set. in some configurations, other error registers may be set and the tlp may be logged. this error does not cause a hang in the smbus controller.										
workaround	for master transactions subject to this erratum, the device driver should ensure the data buffer is zero-filled to the next 16 byte boundary before initiating the transaction.										
											
title											
problem	interrupts that target a logical processor whose local apic is either in the process of being hardware disabled by clearing by bit 11 in the ia32_apic_base_msr or software disabled by clearing bit 8 in the spurious-interrupt vector register at offset 0f0h from the apic base are neither delivered nor discarded.										
implication	when this erratum occurs, the processor may hang.										
workaround	none identified. software must follow the recommendation that all interrupt sources that target an apic must be masked or changed to no longer target the apic before the apic is disabled.										
											
title	dts reading is incorrect below -27°c										
problem	the dts (digital thermal sensor) cannot report a value below -27°c for skus c2308 and c2508.										
implication	core dts readings will report a value of 0xff (-27°c) for temperatures of -27°c and lower. for uncore dts, instead of being limited to -27°c, the dts’s ttr register (sideband port 0x4, offset 0xb1) will report an overflow and the dts temperature will wrap around to a positive temperature. thermal policies for high temperature events are not affected.										
workaround	none identified.										
											
title											
problem	the pcu (platform control unit) in soc may not be able to process concurrent accesses to the gpio registers. due to this erratum, read instructions may return 0xffffffff and write instructions may be dropped.										
implication	multiple drivers concurrently accessing gpio registers may result in unpredictable system behavior.										
workaround	gpio drivers should not access gpio registers concurrently. each driver should acquire a global lock before accessing the gpio register, and then release the lock after the access is completed.										
											
title	processor may fail to discard pcie* flow control initialization packets while in dl_active state										
problem	after pcie flow control initialization completes successfully, the link enters the dl_active state and additional flow control initialization packets should not be received. due to this erratum, the processor may fail to discard flow control initialization packets inadvertently received while in dl_active state.										
implication	receipt of initfc2 dllps after link partner enters dl_active state may lead to unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	none identified.										
											
title	gigabit ethernet controller may not be functional after booting the system from mechanical off										
problem	during boot, the gigabit ethernet controller loads a configuration image. due to this erratum, when booting from acpi state g3 (mechanical off) with wake-on-lan support disabled, the configuration image may not load correctly leading to non- functional gigabit ethernet interfaces.										
implication	the gigabit ethernet subsystem may not be functional when booting from mechanical off. a subsequent cold reset from soft off (acpi state g2/s5) will not exhibit this erratum.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	attempts to clear performance counter overflow bits may not succeed										
problem	an msr write which sets ia32_perf_global_ovf_ctrl msr (390h) bits 1 and/or 0 may not clear the corresponding bit(s) of ia32_perf_global_status msr (38eh) if neither ia32_pmc0 nor ia32_pmc1 are enabled at the time of the msr write and at least one of the fixed-function performance counters is enabled.										
implication	software will not be able to rely on writes to this msr to clear the overflow indication of the general-purpose performance counters.										
workaround	software can avoid this erratum by disabling all fixed-function performance counters before writing to ia32_perf_global_ovf_ctrl msr.										
											
title											
problem	on an smi (system-management interrupt), the processor stores the rip of the next instruction in smram (system-management ram). due to this erratum, an smi that occurs while the processor is in 64-bit mode with a non-zero value in the cs segment base may result in an incorrect rip being stored in smram.										
implication	when this erratum occurs, the rip stored in smram will be incorrect and the rsm instruction will resume from that incorrect rip, resulting in unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	machine check status overflow bit may not be set										
problem	the over (error overflow) indication in bit [62] of the ia32_mc0_status msr (401h) may not be set if ia32_mc0_status.mcacod (bits [15:0]) held a value of 0x3 (external error) when a second machine check occurred in the mc0 bank. additionally, the over indication may not be set if the second machine check has an mcacod value of 0x810, 0x820 or 0x410, regardless of the first error.										
implication	software may not be notified that an overflow of mc0 bank occurred.										
workaround	none identified.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is  set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	top swap mechanism may become incorrectly configured										
problem	writing the general control register may cause the top swap mechanism to become incorrectly configured, resulting in unreliable boot behavior.										
implication	due to this erratum, boot behavior may become unreliable which may impact system availability.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	tlb entries may not be invalidated properly when bit 8 is set in ept paging-structure entries										
problem	the invvpid and mov to cr3 instructions may fail to invalidate tlb entries that were created using ept paging-structure entries in which bit 8 was set.										
implication	the affected tlb entries may be incorrectly shared across linear-address spaces, possibly leading to unpredictable guest behavior.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	boundary scan chain is not functional in two skus										
problem	the boundary scan chain is not functional in c2308 and c2508 series processors.										
implication	due to this erratum, boundary scan testing will give erroneous results.										
workaround	none identified.										
											
title	rdtsc values may not be unique										
problem	rdtsc instructions executed in close proximity may return the same value at high cpu frequencies.										
implication	software that relies upon rdtsc values being strictly increasing may not operate properly.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	cpuid instruction leaf 0ah may return an unexpected value										
problem	when a cpuid instruction is executed with eax = 0ah (architectural performance monitoring leaf), the value returned in edx may incorrectly set bit 14. cpuid leaf 0ah edx bit 14 is reserved and should be zero.										
implication	when this erratum occurs, the processor will report an incorrect value in edx.										
workaround	none identified.										
											
title	uncorrectable memory ecc errors may be improperly logged										
problem	in some cases, an uncorrectable memory ecc error is not logged in ia32_mc5_status, but instead is logged in ia32_mc0_status msr (401h).										
implication	in some cases it may not be possible to identify uncorrectable memory ecc errors.										
workaround	none identified.										
											
title	soft strap disabling of sata 2 or sata 3 breaks the boundary scan chain										
problem	the boundary scan chain is not functional if soft straps are configured to disable sata 2 and/or sata 3.										
implication	when this erratum occurs, boundary scan testing will give erroneous results.										
workaround	sata 2 disable and sata 3 disable soft straps must be 0 when boundary scan is used.										
											
title	vm exits during execution of intn in virtual-8086 mode with virtual- mode extensions may save rflags incorrectly										
problem	an apic-access vm exit or a vm exit due to an ept (extended page table) violation or an ept misconfiguration that occurs during execution of the intn instruction in virtual- 8086 mode (eflags.vm = 1) with virtual-mode extensions (cr4.vme = 1) may save an incorrect value for rflags in the guest-state area of the vmcs.										
implication	this erratum may cause a virtual-machine monitor to handle the vm exit incorrectly, may cause a subsequent vm entry to fail, or may cause incorrect operation of guest software.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	clearing ia32_mc0_ctl[5] may prevent machine check notification										
problem	clearing bit 5 of a logical processor’s ia32_mc0_ctl msr (400h) may incorrectly block notifying other logical processors of any local machine check.										
implication	the system may not react as expected to a machine check exception when ia32_mc0_ctl[5] is 0.										
workaround	none identified.										
											
title	usb 2.0 device may not be detected at system power-on										
problem	certain internal conditions may cause one or more usb ports to fail at system power- on.										
implication	when this erratum occurs, a usb device attached to the affected port will not function. in addition, the os may report problems with the usb port.										
workaround	a bios code change has been identified and may be implemented as workaround for this erratum.										
											
title	lpc clock control using the lpc_clkrun# may not behave as expected										
problem	the lpc_clkrun# pin should be an input/open drain output signal as stated for the clkrun# signal in section 2 of the intel low pin count (lpc) interface specification, revision 1.1. due to this erratum, if the signal is configured to be an output signal, the buffer may drive an active high level.										
implication	the soc may prevent a peripheral device from successfully requesting the lpc clock.										
workaround	none identified.										
											
title	pmi may be pended when pmi lvt mask bit set										
problem	if a performance counter overflow or pebs (precise event based sampling) record generation is unable to trigger a pmi (performance monitoring interrupt) due to the pmi lvt (local vector table) entry’s mask bit being set, the pmi should be dropped. due to this erratum, the pmi may instead be pended and may be taken after the pmi lvt entry mask bit is cleared.										
implication	an unexpected pmi may occur.										
workaround	none identified										
											
title	performance monitoring counter overflows may not be reflected in ia32_perf_global_status										
problem	when an overflow indication in ia32_perf_global_status msr (38eh) is cleared via either the logging of a pebs (precise event based sampling) record or an msr write to ia32_perf_global_ovf_ctrl msr (390h), a simultaneous counter overflow may not set its corresponding overflow bit.										
implication	when this erratum occurs, a counter overflow will not be logged in ia32_perf_global_status, although it may still pend a performance monitoring interrupt.										
workaround	none identified.										
											
title	malformed ipv6 extension headers may result in lan device hang										
problem	certain malformed ipv6 extension headers are not processed correctly.										
implication	due to this erratum, the lan device may behave unpredictably.										
workaround	intel® ethernet software release version 20.2 and above contains a workaround for this erratum.										
											
title	system may experience inability to boot or may cease operation										
problem	the soc lpc_clkout0 and/or lpc_clkout1 signals (low pin count bus clock outputs) may stop functioning.										
implication	if the lpc clock(s) stop functioning the system will no longer be able to boot.										
workaround	a platform level change has been identified and may be implemented as a workaround for this erratum.										
											
title	accessing unimplemented isp mmio space may cause a system hang										
problem	access to unimplemented isp (image signal processor) registers should result in a software error. due to this erratum, the transaction may not complete.										
implication	when this erratum occurs, the system may hang.										
workaround	do not access unimplemented isp mmio space.										
											
title	quad word transactions in violation of programming model may result in system hang										
problem	quad word (64 bit data) transactions to access two adjacent 32-bit registers of soc internal devices may cause system hang.										
implication	due to this erratum, violations of a device programming model may result in a hang instead of a fatal target abort / completer abort error. software written in compliance to correct programming model will not be affected.										
workaround	software must be written and compiled in compliance to correct programming model.										
											
title	gpio registers do not support 8 or 16 bit transactions										
problem	due to this erratum, only aligned dword accesses to gpio registers function correctly. this erratum applies to gpio registers whether in mmio space or io space.										
implication	gpio register transactions using byte or word accesses or unaligned dword accesses will not work correctly.										
workaround	always use aligned 32 bit transactions when accessing gpio registers.										
											
title	csi interface may not correct certain single bit errors										
problem	the csi (camera serial interface) ecc (error correcting code) implementation may not correctly handle single-bit errors in the ecc field and may incorrectly flag as double-bit errors.										
implication	due to this erratum, some single-bit errors may be treated as double-bit errors. intel has not observed this erratum with any commercially available software or system.										
workaround	none identified.										
											
title	ulpi bus marginality for usb device mode										
problem	usb device mode is supported by the soc via the ulpi (utmi+ low pin interface) bus. the ulpi bus may exhibit read timing marginalities resulting in a hold time violation.										
implication	due to this erratum, the soc ulpi reads may be unreliable.										
workaround	none identified.										
											
title	anomalies in usb xhci pme enable and pme status										
problem	the pme_en (bit 8) and pme_status (bit 15) in xhci’s pci pmcsr (bus 0, device 20, function 0, offset 0x74) do not comply with the pci specification.										
implication	if a standard bus driver model for this register is applied, wake issues and system slowness may happen.										
workaround	use intel-provided bios asl code or refer to intel-provided xhci driver reference code.										
											
title	emmc asynchronous abort may cause a hang										
problem	use of an asynchronous abort command to recover from an emmc transfer error or use of a high priority interrupt stop_transmission command may result in a hang.										
implication	using asynchronous abort command may cause a hang. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	the emmc driver should use high priority interrupt send_status mode per jedec standard emmc, version 4.5. a minimum wait time of 128us between getting an error interrupt and issuing a software reset will avoid this erratum.										
											
title	usb xhci superspeed packet with invalid type field issue										
problem	if the encoding for the “type” field for a superspeed packet is set to a reserved value and the encoding for the “subtype” field is set to “ack”, the xhci may accept the packet as a valid acknowledgement transaction packet instead of ignoring the packet. note: the usb 3.0 specification requires that a device never set any defined fields to reserved values.										
implication	system implication is dependent on the misbehaving device and may result in anomalous system behavior. note: this issue has only been observed in a synthetic test environment with a synthetic device.										
workaround	none identified										
											
title	usb xhci behavior with three consecutive failed u3 entry attempts										
problem	the xhci does not transition to the ss.inactive usb 3.0 ltssm (link training and status state machine) state after a superspeed device fails to enter u3 upon three consecutive attempts. note: the usb 3.0 specification requires a superspeed device to enter u3 when directed.										
implication	the xhci will continue to try to initiate u3. the implication is driver and operating system dependent.										
workaround	none identified										
											
title	sd host controller incorrectly reports supporting of suspend/ resume feature										
problem	sdio, sd card, and emmc controllers should not indicate the support of optional suspend/resume feature documented in the sd host controller standard specification version 3.0. due to this erratum, the default value in the capabilities register (offset 040h) incorrectly indicates to the software that this feature is supported.										
implication	if software utilizes the suspend/resume feature, data may not be correctly transferred between memory and sd device.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	sd host controller error status registers may be incorrectly set										
problem	this erratum impacts sdio, sd card, and emmc sd host controllers. auto cmd error status register (offset 03ch, bits [7:1]) may be incorrectly set for software-issued commands (for example: cmd13) that generate errors when issued close to the transmission of an auto cmd12 command. in addition, the error interrupt status register bits (offset 032h) are similarly affected.										
implication	software may not be able to interpret sd host controller error status.										
workaround	software should follow the same error recovery flow whenever an error status bit is set. alternatively, don’t use software-issued commands which have auto cmd12 enabled.										
											
title	sd host controller registers are not cleared by software reset										
problem	this erratum impacts sdio, sd card, and emmc sd host controllers. when software reset is asserted, registers such as sdma system address / argument 2 (offset 00h) in sd host controller are not cleared, failing to comply with the sd host controller specification 3.0.										
implication	intel has not observed this erratum to impact any commercially available software.										
workaround	driver is expected to reprogram these registers before issuing a new command.										
											
title	timing specification violation on sd card interface										
problem	sd card interface io circuitry is not optimized for platform conditions during operation at 3.3 v.										
implication	due to this erratum, there is an increased risk of a transfer error.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	sd card controller does not disable clock during card power down										
problem	the clock and power control of the sd card controller are not linked. therefore, the sd card controller does not automatically disable the sd card clock when the sd card power is disabled.										
implication	when an sd card is inserted into the system and powered off, the clock to the sd card will continue to be driven. although this behavior is common, it is a violation of the sd card spec 3.0.										
workaround	to address this problem, the sd card clock should be enabled/disabled in conjunction with sd card power.										
											
title	reset sequence may take longer than expected when acg is enabled in sd and sdio controllers										
problem	when acg (auto clock gating) is enabled in sd and sdio controllers, the reset sequence may take longer than expected, possibly resulting in a software timeout.										
implication	due to this erratum, a longer response time may be observed after a software-initiated controller reset.										
workaround	a bios workaround has been identified. please refer to latest version of “bay trail–m/d soc bios writers guide.”										
											
title	xhci port assigned highest slotid when resuming from sx issue										
problem	if a device is attached while the platform is in s3 or s4 and the device is assigned the highest assignable slot id upon resume, the xhci may attempt to access an unassigned main memory address.										
implication	accessing unassigned main memory address may cause a system software timeout leading to possible system hang.										
workaround	system sw can detect the timeout and perform a host controller reset prior to avoid a system hang.										
											
title	lfps detect threshold										
problem	the usb 3.0 host and device controllers’ lfps (low frequency periodic signal) detect threshold is higher than the usb 3.0 specification maximum of 300 mv.										
implication	the usb 3.0 host and device controllers may not recognize lfps from superspeed devices transmitting at the minimum low power peak-to-peak differential voltage (400 mv) as defined by usb 3.0 specification for the optional capability for low-power swing mode. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	set latency tolerance value command completion event issue										
problem	the xhci controller does not return a value of ‘0’ for slot id in the command completion event trb (transfer request block) for a set latency tolerance value command. note: this violates the command completion event trb description in section 6.4.2.2 of the extensible host controller interface for universal serial bus (xhci) specification, revision 1.0.										
implication	there are no known functional failures due to this issue. note: set latency tolerance value command is specific to the controller and not the slot. software knows which command was issued and which fields are valid to check for the event. note: xhci cv compliance test suite: test td4.10: set latency tolerance value command test may issue a warning.										
workaround	none identified										
											
title	xhci data packet header and payload mismatch error condition										
problem	if a superspeed device sends a dph (data packet header) to the xhci with a data length field that specifies less data than is actually sent in the dpp (data packet payload), the xhci will accept the packet instead of discarding the packet as invalid. note: the usb 3.0 specification requires a device to send a dpp matching the amount of data specified by the dph.										
implication	the amount of data specified in the dph will be accepted by the xhci and the remaining data will be discarded and may result in anomalous system behavior. note: this issue has only been observed in a synthetic test environment with a synthetic device.										
workaround	none identified										
											
title	usb xhci max packet size and transfer descriptor length mismatch										
problem	the xhci may incorrectly handle a request from a low-speed or full-speed device when all the following conditions are true: the sum of the packet fragments equals the length specified by the td (transfer descriptor) the td length is less than the mps (max packet size) for the device the last packet received in the transfer is “0” or babble bytes										
implication	the xhci will halt the endpoint if all the above conditions are met. all functions associated with the endpoint will stop functioning until the device is unplugged and reinserted.										
workaround	none identified										
											
title	usb ehci rmh port disabled due to device initiated remote wake										
problem	during resume from global suspend, the rmh controller may not send sof soon enough to prevent a device from entering suspend again. a collision on the port may occur if a device initiated remote wake occurs before the rmh controller sends sof. note: intel has only observed this issue when two usb devices on the same rmh controller send remote wake within 30 ms window while rmh controller is resuming from global suspend										
implication	the rmh host controller may detect the collision as babble and disable the port.										
workaround	intel recommends system software to check bit 3 (port enable/disable change) together with bit 7 (suspend) of port n status and control portc registers when determining which port(s) have initiated remote wake. intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	usb ehci isoch in transfer error issue										
problem	if a usb full-speed inbound isochronous transaction with a packet length 190 bytes or greater is started near the end of a microframe the soc may see more than 189 bytes in the next microframe.										
implication	if the soc sees more than 189 bytes for a microframe an error will be sent to software and the isochronous transfer will be lost. if a single data packet is lost no perceptible impact for the end user is expected. note: intel has only observed the issue in a synthetic test environment where precise control of packet scheduling is available, and has not observed this failure in its compatibility validation testing. isochronous traffic is periodic and cannot be retried thus it is considered good practice for software to schedule isochronous transactions to start at the beginning of a microframe. known software solutions follow this practice. to sensitize the system to the issue additional traffic such as other isochronous transactions or retries of asynchronous transactions would be required to push the inbound isochronous transaction to the end of the microframe.										
workaround	intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	usb ehci babble detected with sw overscheduling										
problem	if software violates usb periodic scheduling rules for full-speed isochronous traffic by overscheduling, the rmh may not handle the error condition properly and return a completion split with more data than the length expected.										
implication	if the rmh returns more data than expected, the endpoint will detect packet babble for that transaction and the packet will be dropped. since overscheduling occurred to create the error condition, the packet would be dropped regardless of rmh behavior. if a single isochronous data packet is lost, no perceptible impact to the end user is expected. note: usb software overscheduling occurs when the amount of data scheduled for a microframe exceeds the maximum budget. this is an error condition that violates the usb periodic scheduling rule. note: this failure has only been recreated synthetically with usb software intentionally overscheduling traffic to hit the error condition.										
workaround	intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	usb ehci full-/low-speed eop issue										
problem	if the eop of the last packet in a usb isochronous split transaction (transaction >189 bytes) is dropped or delayed 3 ms or longer the following may occur: if there are no other pending low-speed or full-speed transactions the rmh will not send sof, or keep-alive. devices connected to the rmh will interpret this condition as idle and will enter suspend. if there is other pending low-speed or full-speed transactions, the rmh will drop the isochronous transaction and resume normal operation.										
implication	if there are no other transactions pending, the rmh is unaware a device has entered suspend and may start sending a transaction without waking the device. the implication is device dependent, but a device may stall and require a reset to resume functionality. if there are other transactions present, only the initial isochronous transaction may be lost. the loss of a single isochronous transaction may not result in end user perceptible impact. note: intel has only observed this failure when using software that does not comply with the usb specification and violates the hardware isochronous scheduling threshold by terminating transactions that are already in progress.										
workaround	intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	usb ehci asynchronous retries prioritized over periodic transfers										
problem	the integrated usb rmh incorrectly prioritizes full-speed and low-speed asynchronous retries over dispatchable periodic transfers.										
implication	periodic transfers may be delayed or aborted. if the asynchronous retry latency causes the periodic transfer to be aborted, the impact varies depending on the nature of periodic transfer: if a periodic interrupt transfer is aborted, the data may be recovered by the next instance of the interrupt or the data could be dropped. if a periodic isochronous transfer is aborted, the data will be dropped. a single dropped periodic transaction should not be noticeable by end user.										
workaround	intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	usb ehci fs/ls incorrect number of retries										
problem	a usb low-speed transaction may be retried more than three times, and a usb full- speed transaction may be retried less than three times if all of the following conditions are met: a usb low-speed transaction with errors or the first retry of the transaction occurs near the end of a microframe, and there is not enough time to complete another retry of the low-speed transaction in the same microframe. there is pending usb full-speed traffic and there is enough time left in the microframe to complete one or more attempts of the full-speed transaction. both the low-speed and full-speed transactions must be asynchronous (bulk/ control) and must have the same direction either in or out. note: per the usb ehci specification a transaction with errors should be attempted a maximum of three times if it continues to fail.										
implication	for low-speed transactions the extra retry(s) allow a transaction additional chance(s) to recover regardless of if the full-speed transaction has errors or not. if the full-speed transactions also have errors, the soc may retry the transaction fewer times than required, stalling the device prematurely. once stalled, the implication is software dependent, but the device may be reset by software.										
workaround	intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	usb ehci rmh think time issue										
problem	the usb rmh think time may exceed its declared value in the rmh hub descriptor register of 8 full-speed bit times.										
implication	if the usb driver fully subscribes a usb microframe, ls/fs transactions may exceed the microframe boundary. note: no functional failures have been observed.										
workaround	intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	usb ehci full-/low-speed device removal issue										
problem	if two or more usb full-/low-speed devices are connected to the ehci usb controller, the devices are not suspended, and one device is removed, one or more of the devices remaining in the system may be affected by the disconnect.										
implication	the implication is device dependent. a device may experience a delayed transaction, stall and be recovered via software, or stall and require a reset such as a hot plug to resume normal functionality.										
workaround	intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	a page fault may not be generated when the ps bit is set to “1” in a pml4e or pdpte										
problem	on processors supporting intel® 64 architecture the ps bit (page size bit 7) is reserved in pml4es and pdptes. if the translation of the linear address of a memory access encounters a pml4e or a pdpte with ps set to 1 a page fault should occur. due to this erratum, ps of such an entry is ignored and no page fault will occur due to its being set.										
implication	software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.										
workaround	software should not set bit 7 in any pml4e or pdpte that has present bit (bit 0) set to “1”.										
											
title	cs limit violations may not be detected after vm entry										
problem	the processor may fail to detect a cs limit violation on fetching the first instruction after vm entry if the first byte of that instruction is outside the cs limit but the last byte of the instruction is inside the limit.										
implication	the processor may erroneously execute an instruction that should have caused a general protection exception.										
workaround	when a vmm emulates a branch instruction it should inject a general protection exception if the instruction’s target eip is beyond the cs limit.										
											
title	ia32_debugctl.freeze_perfmon_on_pmi is incorrectly cleared by smi										
problem	freeze_perfmon_on_pmi (bit 12) in the ia32_debugctl msr (1d9h) is erroneously cleared during delivery of an smi (system-management interrupt).										
implication	as a result of this erratum the performance monitoring counters will continue to count after a pmi occurs in smm (system-management mode).										
workaround	none identified.										
											
title	pebs record eventingip field may be incorrect after cs.base change										
problem	due to this erratum a pebs (precise event base sampling) record generated after an operation which changes cs.base may contain an incorrect address in the eventingip field.										
implication	software attempting to identify the instruction which caused the pebs event may identify the incorrect instruction when non-zero cs.base is supported and cs.base is changed. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	enabled										
problem	when enabled, freeze_perfmon_on_pmi bit 12 in ia32_debugctl msr (1d9h) freezes pmcs (performance monitoring counters) on a pmi (performance monitoring interrupt) request by clearing the ia32_perf_global_ctrl msr (38fh). due to this erratum, when freeze_perfmon_on_pmi is enabled and two or more pmcs overflow within a small window of time and pmi is requested, then subsequent pmc overflows may not be logged in ia32_perf_global_status msr (38eh).										
implication	on a pmi, subsequent pmc overflows may not be logged in ia32_perf_global_status msr.										
workaround	re-enabling the pmcs in ia32_perf_global_ctrl will log the overflows that were not previously logged in ia32_perf_global_status.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of movntdqa that loads from wc (write combining) memory may appear to pass an earlier locked instruction to a different cache line.										
implication	software that expects a lock to fence subsequent movntdqa instructions may not operate properly. if the software does not rely on locked instructions to fence the subsequent execution of movntdqa then this erratum does not apply.										
workaround	software that requires a locked instruction to fence subsequent executions of movntdqa should insert an lfence instruction before the first execution of movntdqa following the locked instruction. if there is already fencing or serializing instruction between the locked instruction and the movntdqa, then an additional lfence is not necessary.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor or system bus master writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction prior to execution of the new code is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the intel architecture software developer's manual volume 3: system programming guide including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	in order to avoid this erratum programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3: system programming guide section: handling self- and cross-modifying code.										
											
title	sdio host controller does not control the sdio bus power										
problem	the sd bus power bit in power control register (bus 0; device 17; function 0; offset 029h) is not connected to any soc io pin that can reset the sdio bus power. due to this erratum, sdio device power-on-reset cannot be controlled by power control register. sdio controller may fail to comply with sd host controller specification version 3.00.										
implication	sdio devices may not be powered up and initialized correctly.										
workaround	software should be configured to use a gpio pin on the platform to enable or disable the sdio bus power. please refer to intel atom® processor e3800 product family soc external design specification (eds) document.										
											
title	usb hsic ports incorrectly reported as removable										
problem	the dr (device removable) bit in the portsc registers of the two usb hsic ports incorrectly indicates that devices on these ports may be removed.										
implication	software that relies solely on the state of dr bits will consider fixed devices to be removable. this may lead the software to improper actions (e.g. requesting the user remove a fixed device).										
workaround	in conjunction with the dr bits, software should use bios-configured acpi tables and factor in the connectable field of the usb port capabilities object when determining whether a port is removable.										
											
title	multiple threads that access the isp concurrently may lead to a system hang										
problem	the isp (image signal processor) may not be able to process concurrent accesses.										
implication	if multiple software threads access the isp concurrently, it may lead to system hang during video recording, still image capture or preview modes.										
workaround	avoid using multiple threads that may concurrently access the isp. the intel-provided drivers implement this workaround.										
											
title	premature asynchronous interrupt enabling may lead to loss of sdio wifi functionality										
problem	setting the sdio controller’s host control 2 register asynchronous interrupt enable (bus 0; device 17; function 0; offset 03eh, bit 14) to ‘1’ before the signal voltage switch sequence completion may result in sdio card initialization failure.										
implication	sdio card initialization failure may lead to software time out and loss of wifi device functionality. currently released common operating system drivers do not use asynchronous interrupt mode.										
workaround	the sdio driver should either use sdio synchronous interrupt mode or enable sdio asynchronous interrupt mode after the sdio card signal voltage switch sequence completes.										
											
title											
problem	if software modifies a paging structure entry while the processor is using the entry for linear address translation, the processor may erroneously use the old value of the entry to form a translation in a tlb (or an entry in a paging structure cache) and then update the entry’s new value to set the accessed flag or dirty flag. this will occur only if both the old and new values of the entry result in valid translations.										
implication	incorrect behavior may occur with algorithms that atomically check that the accessed flag or the dirty flag of a paging structure entry is clear and modify other parts of that paging structure entry in a manner that results in a different valid translation.										
workaround	affected algorithms must ensure that appropriate tlb invalidation is done before assuming that future accesses do not use translations based on the old value of the paging structure entry.										
											
title	certain emmc host controller registers are not cleared by software reset										
problem	due to this erratum, when an emmc host controller software reset is requested by setting bit 0 of the software reset register (offset 2fh), the command response register (offset 10h) and adma error status register (offset 54h) are not cleared. this does not comply with the sd host controller specification 3.0.										
implication	intel has not observed this erratum to impact any commercially available software.										
workaround	software should not read these registers until a response is received from the emmc device.										
											
title	lpe audio output not available on hdmi when hdaudio controller is disabled										
problem	when lpe (low power engine) audio is active, the hdaudio controller can be disabled. due to this erratum, the lpe audio is dependent on hdaudio controller being enabled.										
implication	hdmi will not output any audio when the hdaudio controller is disabled, and thus, will not play lpe audio where the lpe audio controller is selected by bios.										
workaround	the hdaudio controller should be enabled by soft-strap. bios should not disable it during the boot flow. please refer to latest version of “valleyview – i soc bios writers guide”.										
											
title	usb device mode controller may not successfully switch to high speed data rate										
problem	the usb device mode controller may initiate speed change to high speed data rate immediately following a reset of a discrete ulpi (utmi+ low pin interface) compliant phy (physical layer) device.										
implication	some ulpi-compliant phys may not recognize the usb device mode controller speed change and thus may not be able to support usb high speed operation.										
workaround	none identified. contact intel technical support for information on supported phy.										
											
title	usb device mode controller response time may exceed the specification										
problem	the usb ulpi specification allocates 112 bit times for the usb device mode controller to respond to requests. due to this erratum, the soc’s device mode controller may exceed this specification.										
implication	usb response time may exceed specifications in configurations with maximal total usb cable length, resulting in communication failure.										
workaround	limit the total cable length used to connect to the host to less than 24m to compensate for the additional controller response time.										
											
title	usb device mode controller may not enter the ss.inactive state										
problem	when operating at superspeed rates, the pending_hp_timer is used to detect lost or corrupted acknowledgements. the usb3.0 specification requires a usb port to transition to the ss.inactive state on the fourth consecutive timeout. due to this erratum, the usb device mode controller in device mode will continue to enter recovery state and not enter the ss.inactive state.										
implication	this behavior does not comply with the usb3.0 specification. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	usb ehci full-/low-speed port reset or clear tt buffer request										
problem	one or more full-/low-speed usb devices on the same rmh controller may be affected if the devices are not suspended and either (a) software issues a port reset or (b) software issues a clear tt buffer request to a port executing a split full-/low-speed asynchronous out command. the small window of exposure for full-speed device is around 1.5 microseconds and around 12 microseconds for a low-speed device.										
implication	the affected port may stall or receive stale data for a newly arrived split transfer occurring at the time of the port reset or clear tt buffer request. note: note: this issue has only been observed in a synthetic test environment.										
workaround	intel recommends the use of the usb xhci controller which is not affected by this erratum.										
											
title	usb device mode controller lfps transmission period does not meet usb3.0 specification										
problem	upon usb device mode controller superspeed u1 (low-power state) exit, the lfps (low-frequency periodic signaling) signal may be transmitted for less than the 600ns required by usb3.0 specification.										
implication	in case of concurrent u1 exit by both sides of the usb link, there may be insufficient lfps duration to ensure the exit is successful. in cases where u1 exit does not succeed, host software will typically initiate link recovery. intel has not observed this erratum with any commercially available systems.										
workaround	none identified.										
											
title	performance monitor instructions retired event may not count consistently										
problem	performance monitor instructions retired (event c0h; umask 00h) and the instruction retired fixed counter (ia32_fixed_ctr0 msr (309h)) are used to track the number of instructions retired. due to this erratum, certain situations may cause the counter(s) to increment when no instruction has retired or to not increment when specific instructions have retired.										
implication	a performance counter counting instructions retired may over or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	mtf vm exit may be delayed following a vm entry that injects a software interrupt										
problem	if the “monitor trap flag” vm-execution control is 1 and vm entry is performing event injection, an mtf vm exit should be delivered immediately after the vm entry. due to this erratum, delivery of the mtf vm exit may be delayed by one instruction if the event being injected is a software interrupt and if the guest state being loaded has rflags.vm = cr4.vme = 1. in this case, the mtf vm exit is delivered following the first instruction of the software interrupt handler.										
implication	software using the monitor trap flag to trace guest execution may fail to get a notifying vm exit after injecting a software interrupt. intel has not observed this erratum with any commercially available system.										
workaround	none identified. an affected virtual-machine monitor could emulate delivery of the software interrupt before vm entry.										
											
title	lbr stack and performance counter freeze on pmi may not function correctly										
problem	when freeze_lbrs_on_pmi flag (bit 11) in ia32_debugctl msr (1d9h) is set, the lbr (last branch record) stack is frozen on a hardware pmi (performance monitoring interrupt) request. when freeze_perfmon_on_pmi flag (bit 12) in ia32_debugctl msr is set, a pmi request clears each of the enable fields of the ia32_perf_global_ctrl msr (38fh) to disable counters. due to this erratum, when freeze_lbrs_on_pmi and/or freeze_perfmon_on_pmi is set in ia32_debugctl msr and the local apic is disabled or the pmi lvt is masked, the lbr stack and/or performance counters freeze on pmi may not function correctly.										
implication	performance monitoring software may not function properly if the lbr stack and performance counters freeze on pmi do not operate as expected. intel has not observed this erratum to impact any commercially available system.										
workaround	none identified.										
											
title	certain mipi csi sensors may not operate correctly at low clock frequencies										
problem	mipi (mobile industry processor interface) csi (camera serial interface) dphy may drop packets if the mipi csi clock frequency is below 80mhz and if camera sensor uses ths-exit less than 200ns.										
implication	intel has observed this erratum on systems using specific vga sensors which operate at 80 mhz or lower and has ths-exit less than 200ns.										
workaround	do not operate sensor below 80mhz mipi csi clock with ths-exit less than 200ns.										
											
title	usb legacy support smi not available from xhci controller										
problem	smis are routed using the pmc (power management controller) smi_sts and smi_en registers. however, the usb smi enable (usb_smi_en) and usb status (usb_sts) fields only reflect smis for the ehci usb controller. smis triggered by the xhci controller’s usblegctlsts mechanism are not available.										
implication	bios is unable to receive smi interrupts from the xhci controller. bios mechanisms such as legacy keyboard emulation for pre-os environments will be impacted.										
workaround	use the ehci controller for legacy keyboard emulation that requires legacy usb smi support by bios.										
											
title	sd card uhs-i mode is not fully supported										
problem	the sd card specification rev 3.01 addendum 1 specifies a relaxed ncrc (number of clocks to cyclic redundancy check) timing specification for uhs-i (ddr50) mode. due to this erratum, the sd host controller is not fully compatible with this relaxed timing specification.										
implication	using uhs-i mode with sd devices that rely upon relaxed ncrc may cause sd host commands to fail to complete, resulting in device access failures.										
workaround	hs mode may be used in place of uhs-i. bios and driver workarounds have been identified.										
											
title	usb xhci may execute a stale transfer request block (trb)										
problem	when a usb 3.0 or usb 2.0 hub with numerous active full-speed (fs) or low-speed (ls) periodic endpoints attached is removed and then reconnected to an usb xhci port, the xhci controller may fail to fully refresh its cache of trb records. the controller may read and execute a stale trb and place a pointer to it in a transfer event trb.										
implication	in some cases, the xhci controller may read de-allocated memory pointed to by a trb of a disabled slot. the xhci controller may also place a pointer to that memory in the event ring, causing the xhci driver to access that memory and process its contents, resulting in system hang, failure to enumerate devices, or other anomalous system behavior. note: this issue has only been observed in a stress test environment.										
workaround	none identified.										
											
title	hd audio recording and playback may glitch or stop										
problem	under certain conditions generally involving extended simultaneous video and hd audio playback and/or recording, glitches, distortion, or persistent muting of the audio stream may occur due to improper processing of input stream data or response packets.										
implication	due to this erratum, media device operation may not be reliable.										
workaround	a bios workaround has been identified to minimize the effect of this erratum. please refer to the bay trail – m/d soc bios writers guide or later. the 3rd party codec driver should minimize hd audio device command traffic.										
											
title	soc pcie ltssm may not enter detect within 20 ms										
problem	the pcie specification requires the ltssm to enter detect within 20 ms of the end of fundamental reset. due to this erratum, the soc may violate this specification.										
implication	intel has not observed this erratum to impact operation of any commercially available add-in card.										
workaround	none identified.										
											
title	sata signal voltage level violation										
problem	sata transmit buffers have been designed to maximize performance and robustness over a variety of routing scenarios. as a result, the sata transmit signaling voltage levels may exceed the maximum motherboard tx connector and device rx connector voltage specifications as defined in section 7.2.2.3 of the serial ata specification, rev 3.1. this issue applies to gen 1 (1.5 gb/s) and gen 2 (3 gb/s).										
implication	none known.										
workaround	none identified.										
											
title	pcie root ports unsupported request completion										
problem	the pcie root ports may return an unsupported request (ur) completion with an incorrect lower address field in response to a memory read if any of the following occur: bus master enable is disabled in the pcie root port’s command register (pcicmd bit 2 =0) address type (at) field of the transaction layer packet (tlp) header is non-zero the requested upstream address falls within the memory range claimed by the secondary side of the bridge requester id with bus number of 0										
implication	the ur completion with an incorrect lower address field may be handled as a malformed tlp causing the requestor to send an err_nonfatal or err_fatal message.										
workaround	none identified.										
											
title	vga max luminance voltage may exceed vesa limits										
problem	the max luminance voltage on the vga video outputs may range from 640 mv to 810mv (the vesa specification range is 665 mv to 770mv) with linearity (inl/dnl) of up to ±3 lsb (the vesa linearity specification is ±1 lsb).										
implication	intel has not observed any functional issues due to this erratum.										
workaround	none identified.										
											
title	sd card initialization sequence may fail when acg is enabled in sd controller										
problem	when acg (auto clock gating) is enabled in sd controller, sdclk may get turned off before voltage switch sequence is complete, possibly resulting in an initialization failure.										
implication	intel has not observed this erratum to impact any commercially available software or system.										
workaround	a bios code change has been identified. please refer to the latest version of “intel atom™ processor e3800 product family series based soc, bios writer's guide”.										
											
title	reset sequence may not complete under certain conditions										
problem	under certain conditions, the soc may not complete initialization either during a reset issued while the system is running or from the g3 (mechanically off) global system state.										
implication	when this erratum occurs, the soc will detect an initialization problem and halt the initialization sequence prior to normal operation, leading to a system hang. the system will subsequently require a power cycle via the system power button.										
workaround	for the erratum occurring during reset while the system is running, a firmware code change has been identified which significantly reduces the likelihood of this erratum after the initial reset at power on. for the erratum occurring while powering up from g3:										
											
title	multiple drivers that access the gpio registers concurrently may result in unpredictable system behavior										
problem	the pcu (platform control unit) in soc may not be able to process concurrent accesses to the gpio registers. due to this erratum, read instructions may return 0xffffffff and write instructions may be dropped.										
implication	multiple drivers concurrently accessing gpio registers may result in unpredictable system behavior.										
workaround	gpio drivers should not access gpio registers concurrently. each driver should acquire a global lock before accessing the gpio register, and then release the lock after the access is completed. the intel-provided drivers implement this workaround.										
											
title	boot may not complete when smi occurs during boot										
problem	during boot, the system should be able to handle smis (system management interrupt). due to this erratum, boot may not complete when smi occurs during boot.										
implication	if the system receives an smi during boot, the boot may not complete.										
workaround	a bios workaround has been identified. please refer to version 1.1 or later of “intel atom™ processor e3800 product family soc, bios writer's guide”.										
											
title	interrupts that target an apic that is being disabled may result in a system hang										
problem	interrupts that target a logical processor whose local apic is either in the process of being hardware disabled by clearing bit 11 in the ia32_apic_base_msr or software disabled by clearing bit 8 in the spurious-interrupt vector register at offset 0f0h from the apic base are neither delivered nor discarded.										
implication	when this erratum occurs, the processor may hang.										
workaround	none identified. software must follow the recommendation that all interrupt sources that target an apic must be masked or changed to no longer target the apic, and that any interrupts targeting the apic be quashed, before the apic is disabled.										
											
title	corrected or uncorrected l2 cache machine check errors may log incorrect address in ia32_mci_addr										
problem	for l2 cache errors with ia32_mci_status.mcacod (bits [15:0]) value 0000_0001_0000_1010b, the address reported in ia32_mci_addr msr may not be the address that caused the machine check.										
implication	due to this erratum, the address reported in ia32_mci_addr may be incorrect.										
workaround	none identified.										
											
title	write-1-clear bits in pmc registers may be unexpectedly cleared										
problem	due to this erratum, writing certain pmc (power management controller) registers with 8-bit, 16-bit, or non-naturally aligned 32-bit transfers may cause write-1-clear bits in adjacent fields to be unexpectedly cleared. the affected registers are: prsts, vlv_pm_sts, gen_pmcon1, s0ix_wake_sts, pm1_sts_en, gpe0a_sts, smi_sts, alt_gpio_smi, uprwc, tco_sts.										
implication	write-1-clear bits are typically used to report interrupt-type events to software. inadvertent clearing of these bits may prevent software from detecting events. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	the affected registers should be written with naturally aligned 32-bit transfers. when the destination field is narrower than 32 bits, adjacent field(s) within the naturally aligned 32-bit boundary must also be written.										
											
title	port reset on usb2 port0 and port1 may cause a reset on hsic port0 and port1 respectively										
problem	hsic port0 - port1 are dedicated to hsic devices, while usb port0 – port3 can be used for usb devices. due to this erratum, a traffic interrupt is caused on hsic port0 or hsic port1 when a port reset is issued by the driver on usb2 host port0 or usb2 host port1 respectively.										
implication	when this erratum occurs, the traffic interruption on hsic port0 or port1 will result in a transaction error being reported by the hsic host controller to the driver. the driver in response will re-enumerate the hsic device causing it to reset.										
workaround	configure usb and hsic ports such that usb port0 in usb2 host mode is not used simultaneously with hsic port0, and usb port1 in usb2 host mode is not used simultaneously with hsic port1.										
											
title	frequency reported by cpuid instruction may not match published frequency										
problem	when the cpuid instruction is executed with eax = 80000002h, 80000003h, and 80000004h, the frequency reported in the brand string may be truncated while the published frequency is rounded. for example, a processor with a frequency of 1.4999ghz may be reported as 1.49ghz in the brand string instead of the published frequency of 1.5ghz.										
implication	certain intel atom® processor e3800 product family processors may report in brand string a frequency lower than the published frequency.										
workaround	none identified.										
											
title	some usb controller capability registers may be invalid after s3 resume										
problem	the contents of several usb xhci host capability registers may be invalid after an s3 resume. registers impacted by this erratum are hccparams, hcsparams1, hcparams3, usb2_phy_pmc, usb_pgc, and xltp_ltv1.										
implication	software that depends on the contents of the named registers may not behave as expected, possibly leading to a usb driver failure or a system hang.										
workaround	a bios workaround has been identified. please refer to the latest version of the bios spec update and memory reference code.										
											
title	machine check status overflow bit may not be set										
problem	the over (error overflow) indication in bit [62] of the ia32_mc0_status msr (401h) may not be set if ia32_mc0_status.mcacod (bits [15:0]) held a value of 0x3 (external error) when a second machine check occurred in the mc0 bank. additionally, the over indication may not be set if the second machine check has an mcacod value of 0x810, 0x820 or 0x410, regardless of the first error.										
implication	software may not be notified that an overflow of mc0 bank occurred.										
workaround	none identified.										
											
title	attempts to clear performance counter overflow bits may not succeed										
problem	an msr write which sets ia32_perf_global_ovf_ctrl msr (390h) bits 1 and/or 0 may not clear the corresponding bit(s) of ia32_perf_global_status msr (38eh) if neither ia32_pmc0 nor ia32_pmc1 are enabled at the time of the msr write and at least one of the fixed-function performance counters is enabled.										
implication	software will not be able to rely on writes to this msr to clear the overflow indication of the general-purpose performance counters.										
workaround	software can avoid this erratum by disabling all fixed-function performance counters before writing to ia32_perf_global_ovf_ctrl msr.										
											
title	smi in 64 bit mode may store an incorrect rip to smram when cs has a non-zero base										
problem	on an smi (system-management interrupt), the processor stores the rip of the next instruction in smram (system-management ram). due to this erratum, an smi that occurs while the processor is in 64-bit mode with a non-zero value in the cs segment base may result in an incorrect rip being stored in smram.										
implication	when this erratum occurs, the rip stored in smram will be incorrect and the rsm instruction will resume from that incorrect rip, resulting in unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	top swap mechanism may become incorrectly configured										
problem	writing the general control register may cause the top swap mechanism to become incorrectly configured, resulting in unreliable boot behavior.										
implication	due to this erratum, boot behavior may become unreliable which may impact system availability.										
workaround	n/a										
											
title	certain peripheral i/o controllers may hang after an unexpectedly long latency memory transaction										
problem	when an emmc (embedded multimedia card), lpe (low power engine), xdci (usb device mode controller), sdio (secure digital input output), or sd (secure digital) controller memory transaction encounters an unexpectedly long latency, this may cause the controller to hang.										
implication	when this erratum occurs, the peripheral i/o controller will hang.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	disabling sdio or sdcard may lead to a system hang										
problem	if bios disables either the sdio or the sdcard (but not both) and follows the recommended sequence of placing the disabled controller in d3, the remaining enabled controller may stop functioning and hang the system. if bios doesn’t put the disabled controller in d3, the enabled controller will operate normally but entry to the s0ix low- power state is blocked.										
implication	when this erratum occurs, the sdio or the sdcard stops functioning and may hang the system.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	ulpi bus marginality for usb device mode										
problem	usb device mode is supported by the soc via the ulpi (utmi+ low pin interface) bus. the ulpi bus may exhibit read timing marginalities resulting in a hold time violation.										
implication	due to this erratum, the soc ulpi reads may be unreliable.										
workaround	none identified.										
											
title	tlb entries may not be invalidated properly when bit 8 is set in ept paging-structure entries										
problem	ept (extended page tables) translates guest-physical addresses to physical addresses using ept paging structures. bit 8 of each ept paging-structure entry is available to software and should be ignored by the processor. due to this erratum, the invvpid and mov to cr3 instructions may fail to invalidate tlb entries that were created using ept paging-structure entries in which bit 8 was set.										
implication	the affected tlb entries may be incorrectly shared across linear-address spaces, possibly leading to unpredictable guest behavior.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	cpuid instruction leaf 0ah may return an unexpected value										
problem	when a cpuid instruction is executed with eax = 0ah (architectural performance monitoring leaf), the value returned in edx may incorrectly set bit 14. cpuid leaf 0ah edx bit 14 is reserved and should be zero.										
implication	when this erratum occurs, the processor will report an incorrect value edx.										
workaround	none identified.										
											
title	video and/or audio artifact may occur when changing frequencies										
problem	when changing the processor frequency, the soc may fail to update the usb descriptor prior to xhci consuming the descriptor when in isoc mode.										
implication	when this erratum occurs, videos or audio artifacts may occur.										
workaround	it is possible for the firmware to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	usb device may not be detected at system power-on										
problem	certain internal conditions may cause the d-signal of one or more usb ports to get stuck at +3.3v during system power-on										
implication	when this erratum occurs, a usb device attached to the affected port will not function. in addition, the os may report problems with the usb port. this erratum may not affect all socs and has been observed only on platforms that ramp the 1.8v sustain rail (v1p8a) before ramping the 3.3v sustain rail (v3p3a).										
workaround	a bios workaround has been identified. refer to usb 2.0 device lost during system cold boot - technical advisory, document# 556192.										
											
title	vm exits during execution of intn in virtual-8086 mode with virtual- mode extensions may save rflags incorrectly										
problem	an apic-access vm exit or a vm exit due to an ept (extended page table) violation or an ept misconfiguration that occurs during execution of the intn instruction in virtual- 8086 mode (eflags.vm = 1) with virtual-mode extensions (cr4.vme = 1) may save an incorrect value for rflags in the guest-state area of the vmcs.										
implication	this erratum may cause a virtual-machine monitor to handle the vm exit incorrectly, may cause a subsequent vm entry to fail, or may cause incorrect operation of guest software.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	clearing ia32_mc0_ctl[5] may prevent machine check notification										
problem	clearing bit 5 of a logical processor’s ia32_mc0_ctl msr (400h) may incorrectly block notifying other logical processors of any local machine check.										
implication	the system may not react as expected to a machine check exception when ia32_mc0_ctl[5] is 0.										
workaround	none identified.										
											
title	system may unexpectedly reboot after shutdown										
problem	certain internal conditions may cause the system to reboot immediately after a shutdown.										
implication	a user shutdown request may not result in the system reaching a power-off condition.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	unusual waveform on sata gen1 (1.5 gbps) during window loading										
problem	abnormal idle waveform (666ps) observed intermittently during boot time (before window logon screen) on sata_tx signal under gen 1 speed mode.										
implication	intel has not observed this erratum to impact any sata gen1 functional features.										
workaround	non identified.										
											
title	system may experience inability to boot or may cease operation										
problem	under certain conditions where activity is high for several years the lpc, usb (low speed and full speed) and sd card circuitry may stop functioning in the outer years of use.										
implication	lpc circuitry that stops functioning may cause operation to cease or inability to boot. sd card or usb circuitry that stops functioning may cause sd cards to be unrecognized or low speed or full speed usb devices to not function. intel has only observed this behavior in simulation. designs that implement the lpc interface at the 1.8v signal voltage are not affected by the lpc part of this erratum.										
workaround	firmware code changes for lpc circuitry and mitigations for sd card & usb circuitry have been identified and may be implemented for this erratum.										
											
title	lpc clock control using the ilb_lpc_clkrun# signal may not behave as expected										
problem	the ilb_lpc_clkrun# pin should be an input/open drain output signal as stated for the clkrun# signal in section 2 of the intel low pin count (lpc) interface specification, revision 1.1. due to this erratum, if the signal is configured to be an output signal, the buffer may drive an active high level.										
implication	the processor may prevent a peripheral device from successfully requesting the lpc clock.										
workaround	none identified.										
											
title	xhci host controller reset may cause a system hang										
problem	xhci host controller may not respond following system software setting (bit 1='1') the. host controller reset (hcrst) of the usb command register (xhcibar+80h).										
implication	caterr# may occur resulting in a system hang.										
workaround	a 1 ms delay is necessary following system software setting (bit 1='1') host controller reset (hcrst) of the usb command register (xhcibar+80h).										
											
title	shutdown may occur when memory subsystem signals a machine check exception										
problem	a machine check error signaled by the memory subsystem may cause the processor to enter shut down state instead of delivering a machine check exception (#mc).										
implication	the processor may enter shut down state instead of delivering #mc, though the ia32_mci_status registers are correctly updated and persist through warm reset.										
workaround	it is possible for bios to contain a workaround for this issue										
											
title	ia32_debugctl.freeze_perfmon_on_pmi is incorrectly cleared by smi										
problem	freeze_perfmon_on_pmi (bit 12) in the ia32_debugctl msr (1d9h) is erroneously cleared during delivery of an smi (system-management interrupt).										
implication	as a result of this erratum the performance monitoring counters will continue to count after a pmi occurs in smm (system-management mode).										
workaround	none identified.										
											
title	redirection of rsm to probe mode may not generate an lbr record										
problem	a redirection of the rsm instruction to probe mode may not generate the lbr (last branch record) record that would have been generated by a non-redirected rsm instruction.										
implication	the lbr stack may be missing a record when redirection of rsm to probe mode is used. the lbr stack will still properly describe the code flow of non-smm code.										
workaround	none identified.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor or system bus master writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction prior to execution of the new code is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the intel architecture software developer's manual volume 3: system programming guide including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	in order to avoid this erratum programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3: system programming guide section: handling self- and cross-modifying code.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures errata										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	a page fault may not be generated when the ps bit is set to “1” in a pml4e or pdpte										
problem	on processors supporting intel® 64 architecture the ps bit (page size bit 7) is reserved in pml4es and pdptes. if the translation of the linear address of a memory access encounters a pml4e or a pdpte with ps set to 1 a page fault should occur. due to this erratum, ps of such an entry is ignored and no page fault will occur due to its being set.										
implication	software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.										
workaround	software should not set bit 7 in any pml4e or pdpte that has present bit (bit 0) set to “1”.										
											
title	some performance counter overflows may not be logged in ia32_perf_global_status when freeze_perfmon_on_pmi is enabled										
problem	when enabled, freeze_perfmon_on_pmi bit 12 in ia32_debugctl msr (1d9h) freezes pmcs (performance monitoring counters) on a pmi (performance monitoring interrupt) request by clearing the ia32_perf_global_ctrl msr (38fh). due to this erratum, when freeze_perfmon_on_pmi is enabled and two or more pmcs overflow within a small window of time and pmi is requested, then subsequent pmc overflows may not be logged in ia32_perf_global_status msr (38eh).										
implication	on a pmi, subsequent pmc overflows may not be logged in ia32_perf_global_status msr.										
workaround	re-enabling the pmcs in ia32_perf_global_ctrl will log the overflows that were not previously logged in ia32_perf_global_status.										
											
title	cs limit violations may not be detected after vm entry errata										
problem	the processor may fail to detect a cs limit violation on fetching the first instruction after vm entry if the first byte of that instruction is outside the cs limit but the last byte of the instruction is inside the limit.										
implication	the processor may erroneously execute an instruction that should have caused a general protection exception.										
workaround	when a vmm emulates a branch instruction it should inject a general protection exception if the instruction’s target eip is beyond the cs limit.										
											
title	pebs record eventingip field may be incorrect after cs.base change										
problem	due to this erratum a pebs (precise event base sampling) record generated after an operation which changes cs.base may contain an incorrect address in the eventingip field.										
implication	software attempting to identify the instruction which caused the pebs event may identify the incorrect instruction when non-zero cs.base is supported and cs.base is changed. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of movntdqa that loads from wc (write combining) memory may appear to pass an earlier locked instruction to a different cache line.										
implication	software that expects a lock to fence subsequent movntdqa instructions may not operate properly. if the software does not rely on locked instructions to fence the subsequent execution of movntdqa then this erratum does not apply.										
workaround	software that requires a locked instruction to fence subsequent executions of movntdqa should insert an lfence instruction before the first execution of movntdqa following the locked instruction. if there is already a fencing or serializing instruction between the locked instruction and the movntdqa, then an additional lfence is not necessary.										
											
title	performance monitor instructions retired event may not count consistently										
problem	performance monitor instructions retired (event c0h; umask 00h) and the instruction retired fixed counter (ia32_fixed_ctr0 msr (309h)) are used to track the number of instructions retired. due to this erratum, certain situations may cause the counter(s) to increment when no instruction has retired or to not increment when specific instructions have retired. errata										
implication	a performance counter counting instructions retired may over or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	lbr stack and performance counter freeze on pmi may not function correctly										
problem	when freeze_lbrs_on_pmi flag (bit 11) in ia32_debugctl msr (1d9h) is set, the lbr (last branch record) stack is frozen on a hardware pmi (performance monitoring interrupt) request. when freeze_perfmon_on_pmi flag (bit 12) in ia32_debugctl msr is set, a pmi request clears each of the enable fields of the ia32_perf_global_ctrl msr (38fh) to disable counters. due to this erratum, when freeze_lbrs_on_pmi and/or freeze_perfmon_on_pmi is set in ia32_debugctl msr and the local apic is disabled or the pmi lvt is masked, the lbr stack and/or performance counters freeze on pmi may not function correctly.										
implication	performance monitoring software may not function properly if the lbr stack and performance counters freeze on pmi do not operate as expected. intel has not observed this erratum to impact any commercially available system.										
workaround	none identified.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	machine check status overflow bit may not be set										
problem	the over (error overflow) indication in bit [62] of the ia32_mc0_status msr (401h) may not be set if ia32_mc0_status.mcacod (bits [15:0]) held a value of 0x3 (external error) when a second machine check occurred in the mc0 bank. additionally, the over indication may not be set if the second machine check has an mcacod value of 0x810, 0x820 or 0x410, regardless of the first error. errata										
implication	software may not be notified that an overflow of mc0 bank occurred.										
workaround	none identified.										
											
title	rtit trace may contain fup.far packet with incorrect address										
problem	the fup.far (flow update packet for far transfer) generated by rtit (real time instruction trace) on a far transfer instruction should contain the linear address of the first byte of the next sequential instruction after the far transfer instruction. due to this erratum, far transfer instructions with more than 3 prefixes may incorrectly include an address between the first byte of the far transfer instruction and the last byte of the far transfer instruction.										
implication	the rtit trace decoder may incorrectly decode the trace due to an incorrect address in the fup packet.										
workaround	the rtit trace decoder can identify a fup.far in the middle of a far transfer instruction and treat that fup.far as if it was coming from the first byte of the following sequential instruction.										
											
title	rtit may delay the psb by one packet										
problem	after an rtit (real time instruction trace) packet that exceeds the limit specified by pkt_mask in rtit_packet_count (msr 77ch) bits [17:16], the psb (packet stream boundary) packet should be sent immediately. due to this erratum, the psb packet may be delayed by one packet.										
implication	the psb packet may be delayed by one packet.										
workaround	none identified.										
											
title	rtit tracestop condition detected during buffer overflow may not clear traceactive										
problem	if an rtit (real time instruction trace) tracestop condition is detected while rtit_status.buffer_overflow msr (769h) bit 3 is set, the processor may not clear rtit_ctl.traceactive msr (768h) bit 13, and tracing will continue after the overflow resolves. such a case will be evident if the tracestop packet is inserted before overflow is resolved, as indicated by the fup.buffovf (flow update packet for buffer overflow) packet.										
implication	the rtit trace will continue tracing beyond the intended stop point.										
workaround	none identified.										
											
title	rtit fup.buffovf packet may be incorrectly followed by a tip packet errata										
problem	when rtit (real time instruction trace) suffers an internal buffer overflow, packet generation stops temporarily, after which a fup.buffovf (flow update packet for buffer overflow) is sent to indicate the lip that follows the instruction upon which tracing resumes. in some cases, however, this packet will be immediately followed by a fup.tip (flow update packet for target ip) which was generated by a branch instruction that executed during the overflow. the ip payload of this fup.tip will be the lip of the instruction upon which tracing resumes.										
implication	the spurious fup.tip packet may cause the rtit trace decoder to fail.										
workaround	the rtit trace decoder should ignore any fup.tip packet that immediately follows a fup.buffovf whose ip matches the ip payload of the fup.buffovf.										
											
title	rtit cyc packet payload values may be off by 1 cycle										
problem	when rtit (real time instruction trace) is enabled with rtit_ctl.cyc_acc msr (768h) bit 1 set to 1, all cyc (cycle count) packets have a payload value that is one less than the number of cycles that have actually passed. note that for cyc packets with a payload value of 0, the correct value may be 0 or 1.										
implication	the trace decoder will produce inaccurate performance data when using cyc packets to track software performance.										
workaround	as a partial workaround, the trace decoder should add 1 to the payload value of any cyc packet with a non-zero payload.										
											
title	the soc may not detect a battery charger or may fail to connect to a usb host										
problem	during power-on, when the soc is used in device mode instead of host mode, the usb d+/d- line may have a 2 µsec glitch to 3.3 v.										
implication	due to this erratum, the platform may not detect a battery charger (and hence not charge the battery) or the soc may not successfully connect to an attached usb host.										
workaround	power the soc on before connecting to its usb port. alternatively, manually disconnecting and re-connecting the usb cable restores operation after the erratum has occurred.										
											
title	rgb666 pixel format display panel may not operate as expected										
problem	due to this erratum, the rgb666 format support on the soc has restrictions on the horizontal resolution. for single link mipi* dsi (display serial interface), the horizontal resolution must be evenly divisible by 4. for dual link mipi dsi, one-half the horizontal resolution plus the overlapping pixels must be evenly divisible by 4. errata										
implication	due to this erratum, the rgb666 panel may not operate as expected.										
workaround	for dual link panels with overlap, choose the overlap so that one-half the horizontal resolution plus the overlapping pixels is evenly divisible by 4. for single link panels the horizontal resolution must be evenly divisible by 4.										
											
title	lpddr3 tinit0 duration may be longer than specification requirement										
problem	jedec standard jesd209-3 requires a maximum power ramp duration tinit0 of 20ms. due to this erratum, the soc may not comply with the tinit0 specification.										
implication	intel has not observed this erratum to impact the functionality or performance of any commercially available lpddr3 parts. intel has obtained waivers from vendors who provide commonly used lpddr3 dram parts.										
workaround	none identified.										
											
title	hdmi and dvi displays may flicker or blank out when using certain pixel frequencies										
problem	due to this erratum, hdmi (high-definition multimedia interface) and dvi (digital visual interface) ports may send data out at an incorrect rate, that is different than the one requested when using certain pixel frequencies.										
implication	when this erratum occurs, panels may flicker or blank out. the impacted pixel frequencies are: 218.25mhz, 218.70mhz, 220.50mhz, 221.20mhz, 229.50mhz, 233.793mhz and 234.00mhz.										
workaround	select a video mode that does not use an affected pixel frequency.										
											
title	mipi* dsi interface timing marginality										
problem	mipi d-phy specification v1.1 section 9.1.1 requires minimum tr (rise time) and tf (fall time) of 150ps for data rates of less than 1gbps. due to this erratum, the soc may exhibit rise time and fall time marginality on a mipi dsi interface with an 80 ohm or 100 ohm impedance.										
implication	emi compliance tests on a mipi dsi interface with one of the listed impedance values may not pass. intel has not observed any functional, performance, or regulatory failures resulting from this erratum.										
workaround	none identified.										
											
title	xhci usb2.0 split-transactions error counter reset issue errata										
problem	the xhci controller may not reset its split transaction error counter if a high-speed usb hub propagates a mal-formed bit from a low-speed or full-speed usb device exhibiting non-usb specification compliant signal quality.										
implication	the implication is device dependent. full speed and low speed devices behind the hub may be re-enumerated and may cause a device to not function as expected.										
workaround	software driver can be modified to workaround this erratum.										
											
title	popcnt instruction may take longer to execute than expected										
problem	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.										
implication	software using the popcnt instruction may experience lower performance than expected.										
workaround	none identified.										
											
title	lpss uart not fully compatible with 16550 uart										
problem	stick parity bit, lcr[5], (line control register, hsuart0_bar0, offset 0ch; bit [5] for hsuart0 and hsuart1_bar0, offset 0ch; bit [5] for hsuart1) does not follow the 16550 specified behavior, instead the parity bit is always logic 0.										
implication	lpss (low power sub-system) uarts are not fully 16550 compatible and may cause an error when connected to a uart device that requires the stick parity feature.										
workaround	do not use stick parity mode of uart.										
											
title	accessing undocumented unimplemented mmio space may cause a system hang										
problem	access to undocumented unimplemented mmio space should result in a software error. due to this erratum, an access to undocumented unimplemented mmio space may not complete.										
implication	when this erratum occurs, the system may hang.										
workaround	do not access to undocumented unimplemented mmio space.										
											
title	usb xhci controller may not re-enter d3 state after a usb wake event errata										
problem	after processing a usb wake event, the usb xhci controller may not reenter d3 state.										
implication	when this erratum occurs, the affected usb xhci controller may not recognize subsequent usb wake events. when this erratum occurs, pme status bit [15] of register power management control/status (pm_cs) (bus 0; device 20; function 20; offset 74h) remains at 1.										
workaround	the software driver should set pmctrl[28] (bus 0; device 14; function 0; offset 80a4h) after the xhci controller enters d0 state following an exit from d3 state.										
											
title	sd card / sdio controller preset_value does not change transfer frequency										
problem	the preset_value (cmd12_err_stat_host_ctrl_2 csr at bus 0; device 18; function 0; mmio offset 3ch, bit 31) does not change the sd card/ sdio bus transfer frequency as required by the sd host controller standard specification version 3.0.										
implication	drivers that attempt to utilize preset_value may not obtain the maximum transfer rate of an attached uhs sd card or sdio bus.										
workaround	software should set the uhs_mode field (bits [18:16] of the cmd12_err_stat_host_ctrl_2 csr) before setting the preset_value bit to reach the maximum transfer rate.										
											
title	soc may experience an incorrect pixel alpha component in the render target										
problem	under certain complex 3d render pipeline conditions, the graphics subsystem may experience an incorrect pixel alpha component in the render target.										
implication	due to this erratum the graphics subsystem may experience an incorrect pixel alpha component in the render target. this erratum has not been observed with the commercial applications tested.										
workaround	applications can be written to avoid the conditions necessary for this erratum to occur.										
											
title	some rtit packets following psb may be sent out of order or dropped										
problem	when a complex micro-architectural condition occurs concurrently with the generation of a rtit (real-time instruction trace) psb (packet stream boundary) packet, the packets that immediately follow the psb could precede or overwrite some older packets. this erratum applies to no more than 21 packets immediately following the psb. errata										
implication	the rtit packet output immediately following a psb may not accurately reflect software behavior, and may result in an rtit decoder error.										
workaround	none identified.										
											
title	xhci controller usb debug port disconnect issue										
problem	usb 3.0 debug port may hang when removing the usb debug device. note: this issue has only been observed infrequently during usb debug connector unplug events										
implication	the port will not function and require a platform reset to recover.										
workaround	none identified.										
											
title	cursor movements towards the edges of pipe-c display may cause unpredictable display behavior										
problem	moving the cursor rapidly towards the edges of the display connected to pipe-c may result in loss of display, display flickering, or other display artifact requiring a display pipe restart.										
implication	when this erratum occurs, cursor movements can affect the display image.										
workaround	intel has identified a driver workaround for this erratum.										
											
title	multiple drivers that access the gpio registers concurrently may result in unpredictable system behavior										
problem	the pcu (platform control unit) in soc may not be able to process concurrent accesses to the gpio registers. due to this sighting, read instructions may return 0xffffffff and write instructions may be dropped.										
implication	multiple drivers concurrently accessing gpio registers may result in unpredictable system behavior.										
workaround	it is possible for the driver to contain a workaround for this erratum.										
											
title	usb device mode may not be functional when connected to usb 1.x										
problem	device mode may not be functional when connected to usb 1.x host or hub.										
implication	due to this erratum, the soc in device mode may be unable to connect to usb 1.x host or hub. errata										
workaround	none identified.										
											
title	disabling pwm[1:0] signals may not work										
problem	clearing pwm_enable field (bit 31) in pwmctrl registers (bus 0; device 30; function 1,2; offset 10h) should disable pwm (pulse width modulation) output. however, due to this erratum, the pwm[1:0] signals may remain enabled after clearing pwm_enable under certain conditions.										
implication	hardware connected to the pwm signals may not behave as expected.										
workaround	intel has identified pwm driver workaround for this erratum. the driver should write all ‘0’s to pwm_base_unit field (bits 23:8) of pwmctrl register, followed by setting pwm_sw_update to ‘1’ before clearing pwm_enable field.										
											
title	leakage from v1p05a to v1p8a power rail at power on										
problem	at power on, leakage from the v1p05a power rail to the v1p8a power rail may result in raising the v1p8a rail to about 400mv prior to that rail being powered.										
implication	intel has not observed this erratum to impact the operation of any commercially available platform.										
workaround	none identified.										
											
title	protocol speed id count (psic) field incorrect value										
problem	the protocol speed id count (psic) field incorrectly reports a value of 3. psic should report 6 indicating ssic support.										
implication	if software utilizes psic, it may incorrectly determine ssic is not supported. additionally xhci cv td 1.09 protocol speed id test fails. intel has obtained a usb- if waiver for this erratum.										
workaround	none identified.										
											
title	xhci host initiated lpm l1 may cause a hang errata										
problem	if usb 2.0 device supports hardware lpm and causes the host to initiate l1, then the host may inadvertently generate a transaction error during the hardware lpm entry process.										
implication	the host will automatically re-enumerate the device repeatedly, resulting in a soft hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	usb 2.0 ports may not function after power-on										
problem	usb 2.0 ports may not function after the system is powered on.										
implication	when this erratum occurs, usb 2.0 devices that functioned prior to powering off the system are inaccessible after a subsequent power-on. this erratum does not impact usb 3.0 ports.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	pmi may be pended when pmi lvt mask bit set										
problem	if a performance counter overflow or pebs (precise event based sampling) record generation is unable to trigger a pmi (performance monitoring interrupt) due to the pmi lvt (local vector table) entry’s mask bit being set, the pmi should be dropped. due to this erratum, the pmi may instead be pended and may be taken after the pmi lvt entry mask bit is cleared.										
implication	an unexpected pmi may occur.										
workaround	none identified.										
											
title	performance monitoring counter overflows may not be reflected in ia32_perf_global_status										
problem	when an overflow indication in ia32_perf_global_status msr (38eh) is cleared via either the logging of a pebs (precise event based sampling) record or an msr write to ia32_perf_global_ovf_ctrl msr (390h), a simultaneous counter overflow may not set its corresponding overflow bit.										
implication	when this erratum occurs, a counter overflow will not be logged in ia32_perf_global_status, although it may still pend a performance monitoring interrupt.										
workaround	none identified.										
											
title	system may exhibit slow boot or shutdown during cold boot										
problem	some systems may hang shortly after a cold reset. this will lead to timeout and a warm reset which causes the boot to take an additional 5 seconds. if global reset is not implemented as specified by the platform design guide, the warm reset may lead to a system shutdown.										
implication	occasionally, some systems may experience a slower cold boot due to the boot process involving a warm reset. if those systems do not properly implement global reset, they may shutdown instead of completing the boot.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	processor may not wake from c6 or deeper sleep state										
problem	the processor may not wake after a sleep state entered with mwait target c-state of c6 and sub c-state of 2 or a target c-state deeper than c6 is requested.										
implication	when this erratum occurs, the system may hang.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	lpc serr generation can not be independently disabled										
problem	lpc serr# events are incorrectly propagated to trigger the nmi interrupt when the see field of the pcie_reg_command register (bus 0; device 31; function 0; offset 4h) is cleared. this erratum only affects systems with attached lpc devices that signal serr# events.										
implication	serr for lpc cannot be disabled using pcie_reg_command see bit. serr# is used on the lpc bus to carry the legacy isa iochk# parity error indication.										
workaround	none identified. software can clear nsc (nmi status and control) msr (bus 0; device 31; function 0; offset 61h) sne field to disable serr for both nmi and lpc.										
											
title	incorrect detection of usb lfps may lead to usb 3.0 link errors										
problem	the usb 3.0 host controller may incorrectly detect lfps (low frequency periodic signal) on certain soc parts.										
implication	when this erratum occurs, the usb 3.0 host controller may not enumerate the link or may encounter unrecoverable errors during operation.										
workaround	a bios workaround has been identified and may be implemented as a workaround for this erratum.										
											
title	usb high speed links may disconnect when subject to eft events										
problem	when subjected to eft (electric fast transient) events, the xhci host controller usb 2.0 interface may not meet ce certification requirements according to iec 61000-4-4 connected to a usb device with an unshielded cable on a usb2 root port.										
implication	when this erratum occurs, the usb high speed device may be falsely disconnected. this will result in failure of the iec 61000-4-4 eft test.										
workaround	none identified.										
											
title	system may hang when ddr dynamic self-refresh is enabled										
problem	the system may hang when ddr dynamic self-refresh is enabled.										
implication	when this erratum occurs, the system hangs. a cold reset is required to recover the system.										
workaround	a bios workaround has been identified.										
											
title	usb3 phy may become unreliable on certain soc parts										
problem	when the system enters s0i3 sleep state, the contents of usb3 phy configuration registers may change sometimes.										
implication	due to this erratum, the usb3 device connected to the port may not be detected or the port may downgrade to usb2 speed.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	xhci host controller reset may lead to a system hang										
problem	an access to xhci configuration space within 1ms of setting the xhci hcrst (host controller reset) bit of the usb command register (xhcibar, offset 80h, bit [1]) or a second setting of the hcrst bit within 120ms may cause the xhci host controller to fail to respond.										
implication	due to this erratum, the system may hang.										
workaround	software must not access xhci configuration space within 1ms or set hcrst bit within 120ms of setting the hcrst bit.										
											
title	system may experience inability to boot or may cease operation errata										
problem	under certain conditions where s0ix is not implemented and activity is high for several years the lpc, rtc and sd card may stop functioning in the outer years of use.										
implication	lpc and rtc circuitry that stops functioning may cause operation to cease or inability to boot. sd card that stops functioning may cause sd cards to be unrecognized. intel has only observed this behavior in simulation. designs that implement the lpc interface at the 1.8v signal voltage are not affected by the lpc part of this erratum. designs implementing s0ix are not affected by this issue.										
workaround	firmware code changes for lpc and rtc circuitry and mitigations for sd card circuitry have been identified and may be implemented for this erratum.										
											
title	split access to apic-access page may access virtual-apic page										
problem	a read from the apic-access page that splits a cacheline boundary should cause an apic-access vm exit. due to this erratum, the processor may redirect such accesses to the virtual-apic page without causing an apic-access vm exit.										
implication	guest software that attempts to access its apic with a cacheline split may not be properly virtualized.										
workaround	none identified.										
											
title	pebs record eventingip field may be incorrect after cs.base change										
problem	due to this erratum, a pebs (precise event base sampling) record generated after an operation that changes the cs.base may contain an incorrect address in the eventingip field.										
implication	software attempting to identify the instruction that caused the pebs event may report an incorrect instruction when non-zero cs.base is supported and cs.base is changed. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	performance monitor instructions retired event may not count consistently										
problem	performance monitor instructions retired (event c0h; umask 00h) and the instruction retired fixed counter (ia32_fixed_ctr0 msr (309h)) are used to track the number of instructions retired. due to this erratum, certain situations may cause the counter(s) to increment when no instruction has retired or to not increment when specific instructions have retired.										
implication	a performance counter counting instructions retired may over or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	smram state-save area above the 4gb boundary may cause unpredictable system behavior										
problem	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, errata subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	ensure that the smram state-save area is located entirely below the 4gb address boundary.										
											
title	popcnt instruction may take longer to execute than expected										
problem	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.										
implication	software using the popcnt instruction may experience lower performance than expected.										
workaround	none identified.										
											
title	apic-access vm exit may occur instead of smap #pf										
problem	a supervisor-mode data access through a user-mode page should cause a #pf if cr4.smap (supervisor-mode access prevention) is 1 and eflags.ac is 0. due to this erratum, a guest supervisor mode access to the apic-access page may cause an apic-access vm exit instead of a #pf due to smap.										
implication	a guest may miss an smap violation if it maps its apic through a user-mode page. intel has not observed this erratum with any commercially available software.										
workaround	guest software should not map their apic to a user mode page and attempt to access it from supervisor mode.										
											
title	some performance counter overflows may not be logged in ia32_perf_global_status when freeze_perfmon_on_pmi is enabled										
problem	when enabled, freeze_perfmon_on_pmi bit 12 in ia32_debugctl msr (1d9h) freezes pmcs (performance monitoring counters) on a pmi (performance monitoring interrupt) request by setting ctr_frz bit 49 in ia32_perf_global_status msr (38eh). due to this erratum, if freeze_perfmon_on_pmi is enabled, pmc overflows that occur within a few cycles of a pmi being pended may not be logged in ia32_perf_global_status msr.										
implication	a performance counter may overflow but not set the overflow bit in ia32_perf_global_status msr.										
workaround	re-enabling the pmcs in ia32_perf_global_ctrl will log the overflows that were not previously logged in ia32_perf_global_status										
											
title	performance monitoring offcore_response1 event may improperly count l2 evictions										
problem	due to this erratum, a performance monitoring counter configured to count offcore_response1 (event b7h, umask 02h) uses msr_offcore_rsp0.corewb (msr 1a6h, bit 3) instead of the expected msr_offcore_rsp1.corewb (msr 1a7h, bit 3).										
implication	a performance monitoring counter using the offcore_response1 event will not count l2 evictions as expected when the corewb value is not the same in msr_offcore_rsp1 and in msr_offcore_rsp0.										
workaround	none identified.										
											
title	debug exception may not be generated on memory read spanning a cacheline boundary										
problem	a debug exception should be generated on a read which accesses an address specified by a breakpoint address register (dr0-dr3) and its lenn field (in dr7) configured to monitor data reads. due to this erratum, under complex micro architectural conditions the processor may not trigger a debug exception on a memory read that spans a cacheline boundary.										
implication	when this erratum occurs, a debugger is not notified of a read that matches a data breakpoint.										
workaround	none identified.										
											
title	intel® pt cr3 filtering compares bits [11:5] of cr3 and ia32_rtit_cr3_match outside of pae paging mode										
problem	cr3[11:5] are used to locate the page-directory-pointer table only in pae paging mode. when using intel pt (processor trace), those bits of cr3 are compared to ia32_rtit_cr3_match (msr 572h) when ia32_rtit_ctl.cr3filter (msr 570h bit 7) is set, independent of paging mode.										
implication	any value written to the ignored cr3[11:5] bits which can only be non-zero outside of pae paging mode must also be written to ia32_rtit_cr3_match[11:5] in order to result in a cr3 filtering match.										
workaround	none identified.										
											
title	intel® pt ovf packet may be followed by tip.pgd packet										
problem	if intel pt (processor trace) encounters an internal buffer overflow and generates an ovf (overflow) packet just as ia32_rtit_ctl (msr 570h) bit 0 (traceen) is cleared, errata or during a far transfer that causes ia32_rtit_status.contexten[1] (msr 571h) to be cleared, the ovf may be followed by a tip.pgd (target instruction pointer - packet generation disable) packet.										
implication	the intel pt decoder may not expect a tip.pgd to follow an ovf which could cause a decoder error.										
workaround	the intel pt decoder should ignore a tip.pgd that immediately follows ovf.										
											
title	intel® pt ovf may be followed by an unexpected fup packet										
problem	certain intel pt (processor trace) packets, including fups (flow update packets), should be issued only between tip.pge (target ip packet - packet generation enable) and tip.pgd (target ip packet - packet generation disable) packets. when outside a tip.pge/tip.pgd pair, as a result of ia32_rtit_status.filteren[0] (msr 571h) being cleared, an ovf (overflow) packet may be unexpectedly followed by a fup.										
implication	the intel pt decoder may incorrectly assume that tracing is enabled and resume decoding from the fup ip.										
workaround	the intel pt decoder may opt to scan ahead for other packets to confirm whether packeten is set.										
											
title	performance monitoring corewb offcore response event may overcount										
problem	an l2 eviction may affect the offcore_rsp1 and offcore_rsp2 events configured to count corewb when the eviction is caused by an access made by a different core sharing the l2 cache.										
implication	the offcore response events may overcount when configured to count corewb occurrence.										
workaround	none identified.										
											
title	fbstp may update fop/fip/fdp/fsw before exception or vm exit										
problem	due to this erratum, a fbstp whose memory access causes an exception (e.g. #pf or #gp) or vm exit (e.g. ept violation), may unexpectedly update fop, fip, fdp, fsw.ie or fsw.pe. fsw.es is not affected by this erratum.										
implication	an x87 exception handler that executes an fbstp but relies on the fp exception state being unchanged after taking a memory exception may not behave as expected. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	pebs record may be generated when counters frozen errata										
problem	when performance monitoring counters are frozen due to ia32_perf_global_status.ctr_frz msr (38eh, bit 59) being set, a pebs (processor event based sampling) record may still be generated for counter 0 when the event specified by ia32_perfevtsel0 msr (186h) occurs.										
implication	an unexpected pebs record may cause performance analysis software to behave unexpectedly.										
workaround	none identified.										
											
title	ia32_perf_global_inuse [62] may be set										
problem	ia32_perf_global_inuse msr (392h) bit 62 is reserved. however, due to this erratum, it may sometimes be read as 1.										
implication	a read of ia32_perf_global_inuse msr may see bit 62 set in the result.										
workaround	none identified.										
											
title	sata interface may not loopback patterns in bist-l mode										
problem	in certain bist-l tx compliance test setups on sata interface, the first 10b in the mftp (mid frequency test pattern), i.e. 333h, inserted by j-bert has disparity mismatch with the previous 10b, i.e. 363h, of previous hftp (high frequency test pattern) block. 333h has negative beginning disparity while 363h has positive ending disparity. when soc detects disparity mismatch, it does not re-compute the running disparity based on the received 333h.										
implication	due to this erratum, sata interface may not correctly loopback patterns in bist-l mode. this erratum does not impact bist-t compliance mode.										
workaround	while using bist-l loopback mode for sata tx compliance testing, if a disparity error is encountered in subsequent mftp block after receiving bist-l fis and hftp block, insert a non-align primitive to correct back the disparity error at the beginning of mftp pattern.										
											
title	using 32-bit addressing mode with sd/emmc controller may lead to unpredictable system behavior										
problem	sd/emmc dma transfers using 32-bit addressing mode may lead to unpredictable system behavior.										
implication	due to this erratum, unpredictable system behavior may occur.										
workaround	sd/emmc software should use the 64-bit addressing mode with the 96-bit descriptor format.										
											
title	vdd2 cannot operate at 1.35v										
problem	vdd2 power rail cannot operate at 1.35v.										
implication	due to this erratum, merging vdd2 and vddq platform rails at 1.35v is not supported. this erratum does not impact the ability to merge vdd2 and vddq rails at 1.24v.										
workaround	none identified.										
											
title	sata host controller does not pass certain compliance tests										
problem	the soc sata host controller oob (out of band) host responses, oob transmit gap, and oob transmit burst length do not pass serial ata interoperability program revision 1.4.3, unified test document version 1.01 tests oob-03[a/b], oob-05, and oob-06[a/b].										
implication	intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	certain mca events may incorrectly set overflow bit										
problem	a single machine check event may incorrectly set over (bit 62) of ia32_mc4_status (msr 411h). the affected mca events are unsupported idi opcode (mcacod 0x0408, mscod 0x0000), wbmto* access to mmio (mcacod 0x0408, mcacod 0x0003) and clflush to mmio (mcacod 0x0408, mcacod 0x0004).										
implication	software analyzing system machine check error logs may incorrectly think that multiple errors have occurred. intel has not observed this erratum impacting commercially available systems.										
workaround	none identified.										
											
title	the shadow register for ddr3l mr2 is 10 bits wide instead of 11 bits										
problem	the shadow register for ddr3l mr2 (d_cr_tqoffset.mr_value) is only 10 bits whereas the mr2 register in dram devices is 11 bits.										
implication	at self-refresh entry, the memory controller writes the shadow mr2 register to the dram appending 0 for the 11th bit.										
workaround	if a design needs to set mr2’s 11th bit, bios should set d_cr_tqctl.srten = 0 at mchbar offset 0x1a50 (multicast address) and write 1 to bit 7 of mr2 inside the dram to enable self-refresh extended temperature mode all the time.										
											
title	hd audio recording may experience a glitch while opening or closing audio streams										
problem	setting crstb (bit 0 at intel hd audio base address + 8) to zero when opening and closing audio streams may result in audio glitches.										
implication	due to this erratum, audio glitches may occur while opening or closing audio streams.										
workaround	avoid setting crstb (bit 0 at intel hd audio base address + 8) to zero unless entering d3 for system suspend or unless asserting platform reset for reboot.										
											
title	xhci host initiated lpm l1 may cause a hang										
problem	if usb 2.0 device supports hardware lpm (low power mode) and causes the host to initiate l1, then the host may inadvertently generate a transaction error during the hardware lpm entry process.										
implication	the host will automatically re-enumerate the device repeatedly, resulting in a soft hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	usb device controller incorrectly interprets u3 wakeup for warm reset										
problem	xhci violates usb 3 specification for tu3wakeupretrydelay, which dictates time to initiate the u3 wakeup lfps handshake signaling after an unsuccessful lfps handshake. xhci employs 12us for tu3wakeupretrydelay instead of 100ms [as defined per spec].										
implication	device may incorrectly interpret the lfps asserted [due to the short tu3wakeupretrydelay time] for duration greater than tresetdelay. if resume fails on the host side, this will be detected as a warm reset from xhci and transition into rx.detect ltssm state. due to this erratum, the device may fail to respond to xhci- initiated u3 wakeup request.										
workaround	none identified.										
											
title	spi flash transaction failure with software sequencing										
problem	invalid instruction fields on flash invalid instructions registers (flill - fcbah + 004h; flill1 - fcbah + 008h) in flash descriptor contains opcodes that flash controller should protect against. spi flash transactions will fail unless non-zero op- code is written to the invalid instruction fields. errata										
implication	due to this erratum, spi flash will not function with software sequencing if zero op- code is written to invalid instruction fields in flash descriptor data structure of the image.										
workaround	program invalid instruction fields in flash descriptor with non-zero op-code. hence, all illegal instructions and pre-opcode locations will have to be programmed with op- codes in the flash descriptor.										
											
title	usb 2.0 timing responsiveness degradation										
problem	usb specification requires 1ms resume reflection time from platform to the device indicating usb resume/wake. due to this erratum, soc implementation violates the usb2 timing specification.										
implication	when this erratum occurs, usb devices that are sensitive to this timing specification may cease to function or re-enumerate upon waking from suspend.										
workaround	none identified.										
											
title	d3 entry or d3 exit may fail for certain integrated pcie functions										
problem	due to this erratum, the soc may fail to correctly execute the d3 entry flow or the d3 exit flow for certain integrated pcie functions.										
implication	if the affected pci device fails to correctly enter d3, the soc may not enter s0ix low power states. if the affected pci device fails to correctly exit d3, the device will not function.										
workaround	to work around the d3 entry issue, software can implement an acpi _ps3 method to verify pmcsr (bits 1:0) indicates the device has entered d3. if the device has not entered d3, the d3 entry steps should be repeated. to work around the d3 exit issue, software can issue a read to any device register prior to programming any dma transfers.										
											
title	pm1_sts_en.wak_sts gets set during s0										
problem	pm1_sts_en.wak_sts (offset 0h, bit 15) is supposed to be set to '1' only upon exit from a valid sleep state. due to this erratum, this bit gets set to '1' by a valid and enabled wake source during s0 and s0ix.										
implication	sci (system control interrupt) os flows from pm1_sts_en or gpe0*_sts (b: 0, d: 13, f: 1, offset 20h/24h/28h/2ch) that also read pm1_sts_en.wak_sts may not operate as expected.										
workaround	the platform should either use an alternate gpe (general purpose event) to route the sci or the os should ignore wak_sts in s0.										
											
title	a store instruction may not wake up mwait errata										
problem	one use of the monitor/mwait instruction pair is to allow a logical processor to wait in a sleep state until a store to the armed address range occurs. due to this erratum, stores to the armed address range may not trigger mwait to resume execution.										
implication	the logical processor that executed the mwait instruction may not resume execution until it receives an interrupt. software that does not rely on stores to the armed address range to wake a logical processor from an mwait sleep state is not affected by this erratum.										
workaround	software needs to use interrupts to wake processors from mwait-induced sleep states.										
											
title	de-asserting bme bit may cause system hang										
problem	if the bme (bus master enable) bit in the isp (image signal processor) device 3 pci configuration space is de-asserted while the camera device is processing an image, the system may hang.										
implication	when this erratum occurs, the system may become non-responsive. intel has not observed this erratum to impact commercially available software.										
workaround	do not de-assert bme while the camera is active.										
											
title	storage controllers may not be power gated										
problem	when disabled or placed in d3 state by bios, the sd card and sdio storage controllers may not be power gated unless this is done prior to the emmc controller being disabled or placed in d3 state.										
implication	due to this erratum, storage controllers may not be power gated. this erratum does not apply to skus without emmc controllers.										
workaround	bios should ensure the sd card and sdio controllers are disabled before disabling the emmc controller or putting it into d3.										
											
title	reading an intel® trace hub register after a write to an undefined register may fail										
problem	reading an intel th (trace hub) register (bus 0; device 0; function 2; offset is register specific) may fail after attempting to write an undefined intel th register location (undefined locations are those not documented in the intel trace hub developer’s manual).										
implication	when this erratum occurs, reading a defined intel th register returns all zeroes regardless of its actual values. errata										
workaround	software should not attempt to write to undefined intel th register locations.										
											
title	deasserting pcicmd_pcists.bme before stopping isp camera driver may lead to a system hang										
problem	if pcicmd_pcists.bme (bus configured by bios: device: 3; function: 0; offset: 4h; bit 2) is de-asserted without first stopping the isp camera driver, the system may hang.										
implication	if the pcicmd_pcists.bme register bit in the isp is de-asserted, while the isp (image signal processor) is processing a data stream, the system may hang.										
workaround	software should not de-assert bme without first stopping the isp camera driver.										
											
title	certain invalidation wait descriptors may cause vt-d to hang										
problem	an inv_wait_dsc (invalidation wait descriptor) with if=0 (do not generate an interrupt on completion) and sw=0 (do not write status-word on completion) will prevent vt-d from processing subsequent commands.										
implication	when this erratum occurs, subsequent commands submitted to the invalidation queue will not be processed.										
workaround	ensure all inv_wait_dsc have the if bit and/or the sw bit set to ’1’.										
											
title	certain vt-d svm registers are writeable										
problem	vt-d engines that do not advertise svm (shared virtual memory) capability should treat the 32-bit registers at vtdbar offsets 0xdc, 0xe0, 0xe4, 0xe8 and 0xec as reserved and read-only. due to this erratum, these registers are writeable.										
implication	writing the listed registers does not affect the operation of the soc.										
workaround	none identified.										
											
title	changing vt-d event interrupt configuration control registers may not behave as expected										
problem	due to this erratum, the sequence used to change vt-d event interrupt service routine configuration for fault events and for invalidation events may not work as expected. specifically, reading one of the associated configuration registers does not serialize vt-d event interrupts. as a result, vt-d event interrupts that were issued using the previous interrupt service configuration may be delivered after software has observed the interrupt service configuration to be updated. errata										
implication	vt-d event interrupts using stale configuration information may be lost or cause unexpected behavior. intel has not observed this erratum to impact commercially available software.										
workaround	reading a vt-d event control register twice achieves the intended interrupt serialization.										
											
title	soc may not meet the vol(max) specification for thermtrip_n										
problem	under certain platform configurations and conditions, when the soc asserts thermtrip_n, it may not meet the vol(max) specification.										
implication	when this erratum occurs, the platform may not detect the assertion of thermtrip_n. this may, in turn, prevent the power-button override capability from resetting the platform placing the platform in a non-responsive state requiring the platform to go to g3 (completely drained battery needed) in order to reboot.										
workaround	a platform design change has been identified as a workaround for this erratum.										
											
title	intermittent caterr may occur when back to back host controller reset is performed										
problem	the xhci host controller may fail to respond, due to an internal race condition, if consecutive xhci host controller resets are performed.										
implication	a processor caterr may occurs during long duration reboot testing or s4/s5 cycling tests.										
workaround	software should add a 120ms delay in between consecutive xhci host controller resets.										
											
title	discrete tpm may not be accessible through fast spi bus										
problem	accesses to a tpm device attached on fast spi bus will not succeed unless a flash device is also attached on fast spi bus.										
implication	due to this erratum, the system is not able to communicate with a tpm device attached to the fast spi bus by itself. the integrated tpm (intel platform trust technology) is not affected by this erratum. any tpm attached to the lpc bus is not affected by this erratum.										
workaround	none identified.										
											
title	usb xhci controller may not re-enter a d3 state after a usb wake event errata										
problem	after processing a usb 3.0 wake event, the usb xhci controller may not re-enter d3 state.										
implication	when the failure occurs, the system will not enter an sx state.										
workaround	software should clear bit 8 pme enable (pme_en) of pm_cs--power management control/status register (usb xhci-d21:f0: offset 74h) after the controller enters d0 state following an exit from d3.										
											
title	updating or disabling xhci controller driver may prevent entering s0ix										
problem	updating or disabling xhci controller driver will disable xhci rtd3 power gating preventing the soc from entering s0ix sleep states.										
implication	due to this erratum, the soc does not enter s0ix until the driver is updated/re- enabled following a system reboot.										
workaround	none identified.										
											
title	intel® trace hub pti pattern generator may stop working when width is changed while enabled										
problem	intel th (trace hub) pti (parallel trace interface) pattern generator feature is used to test the connectivity between pti port and trace capture hardware. due to this erratum, once enabled the pattern generator may hang if the width is decreased.										
implication	intel th's pattern generator feature stops working when users decrease the width.										
workaround	intel th's pti pattern generator width should be reconfigured only after an intel® trace hub soft reset. intel® trace hub soft reset can be done by setting npkdsc.flr bit to '1'.										
											
title	sthcap1.rtitcnt field value does not correctly indicate the number of channels supported										
problem	the rtitcnt field (bits[19:16]) of the sthcap1 csr (offset 04004h from mtb_bar) does not indicate the correct number of channels supported by intel® trace hub for intel® processor trace.										
implication	the rtitcnt field value cannot be used.										
workaround	the correct number of channels can be obtained from soc datasheet.										
											
title	camera device does not issue an msi when intx is enabled errata										
problem	when both msi (message signaled interrupts) and legacy intx are enabled by the camera device, intx is asserted rather than issuing the msi, in violation of the pci local bus specification.										
implication	due to this erratum, camera device interrupts can be lost leading to device failure.										
workaround	the camera device must disable legacy intx by setting bit 10 of pcicmd (bus 0; device 3; function 0; offset 04h) before msi is enabled.										
											
title	system may experience inability to boot or may cease operation										
problem	under certain conditions where activity is high for several years the lpc, rtc, sd card and gpio termination circuitry may stop functioning in the outer years of use.										
implication	lpc and rtc circuitry that stops functioning may cause operation to cease or inability to boot. sd card that stops functioning may cause sd cards to be unrecognized. intel has only observed this behavior in simulation. designs that implement the lpc interface at the 1.8v signal voltage are not affected by the lpc part of this erratum. gpio circuitry implications are platform implementation specific and may result in unexpected behavior.										
workaround	firmware updates for lpc, rtc circuitry and gpio termination have been identified. mitigations for sd card circuitry and gpio termination have been identified and may be implemented for this erratum.										
											
title	gpio registers do not support 8 or 16 bit transactions										
problem	due to this erratum, only aligned dword accesses to gpio registers function correctly. this erratum applies to gpio registers whether in mmio space or io space.										
implication	gpio register transactions using byte or word accesses or unaligned dword accesses will not work correctly.										
workaround	always use aligned 32 bit transactions when accessing gpio registers.										
											
title	quad word transactions in violation of programming model may result in system hang										
problem	quad word (64 bit data) transactions to access two adjacent 32 bit registers of soc internal devices that do not support such transactions may cause system hang.										
implication	due to this erratum, violations of a device programming model may result in a hang instead of a fatal target abort / completer abort error. software written in compliance to correct programming model will not be affected.										
workaround	software must be written and compiled in compliance to correct programming model.										
											
title	soc pcie ltssm may not enter detect within 20 ms										
problem	the pcie specification requires the ltssm (link training and status state machine) to enter detect within 20 ms of the end of fundamental reset. due to this erratum, the soc may violate this specification.										
implication	intel has not observed this erratum to impact operation of any commercially available add-in card. workaround none identified.										
workaround											
											
title	lfps detect threshold										
problem	the usb 3.0 host and device controllers’ lfps (low frequency periodic signal) detect threshold is higher than the usb 3.0 specification maximum of 300 mv.										
implication	the usb 3.0 host and device controllers may not recognize lfps from superspeed devices transmitting at the minimum low power peak-to-peak differential voltage (400 mv) as defined by usb 3.0 specification for the optional capability for low-power swing mode. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	set latency tolerance value command completion event issue										
problem	the xhci controller does not return a value of ‘0’ for slot id in the command completion event trb (transfer request block) for a set latency tolerance value command. note: this violates the command completion event trb description in section 6.4.2.2 of the extensible host controller interface for universal serial bus (xhci) specification, revision 1.0.										
implication	there are no known functional failures due to this issue. note: set latency tolerance value command is specific to the controller and not the slot. software knows which command was issued and which fields are valid to check for the event. note: xhci cv compliance test suite: test td4.10: set latency tolerance value command test may issue a warning.										
workaround	none identified.										
											
title	sata signal voltage level violation										
problem	sata transmit buffers have been designed to maximize performance and robustness over a variety of routing scenarios. as a result, the sata transmit signaling voltage levels may exceed the maximum motherboard tx connector and device rx connector voltage specifications as defined in section 7.2.2.3 of the serial ata specification, rev 3.1. this issue applies to gen 1 (1.5 gb/s) and gen 2 (3gb/s).										
implication	none known.										
workaround	none identified.										
											
title	anomalies in usb xhci pme enable and pme status										
problem	the pme_en (bit 8) and pme_status (bit 15) in xhci’s pci pmcsr (bus 0, device 20, function 0, offset 0x74) do not comply with the pci specification.										
implication	if a standard bus driver model for this register is applied, wake issues and system slowness may happen.										
workaround	none identified										
											
title	xhci port assigned highest slotid when resuming from sx issue										
problem	if a device is attached while the platform is in s3 or s4 and the device is assigned the highest assignable slot id upon resume, the xhci may attempt to access an unassigned main memory address.										
implication	accessing unassigned main memory address may cause a system software timeout leading to possible system hang.										
workaround	system sw can detect the timeout and perform a host controller reset prior to avoid a system hang.										
											
title	xhci data packet header and payload mismatch error condition										
problem	if a superspeed device sends a dph (data packet header) to the xhci with a data length field that specifies less data than is actually sent in the rsm (data packet payload), the xhci will accept the packet instead of discarding the packet as invalid. note: the usb 3.0 specification requires a device to send a dpp matching the amount of data specified by the dph.										
implication	the amount of data specified in the dph will be accepted by the xhci and the remaining data will be discarded and may result in anomalous system behavior.										
workaround	none identified.										
											
title	usb xhci superspeed packet with invalid type field issue										
problem	if the encoding for the “type” field for a superspeed packet is set to a reserved value and the encoding for the “subtype” field is set to “ack”, the xhci may accept the packet as a valid acknowledgement transaction packet instead of ignoring the packet. note: the usb 3.0 specification requires that a device never set any defined fields to reserved values.										
implication	system implication is dependent on the misbehaving device and may result in anomalous system behavior.										
workaround	none identified.										
											
title	usb xhci behavior with three consecutive failed u3 entry attempts										
problem	the xhci does not transition to the ss.inactive usb 3.0 ltssm (link training and status state machine) state after a superspeed device fails to enter u3 upon three consecutive attempts. note: the usb 3.0 specification requires a superspeed device to enter u3 when directed.										
implication	the xhci will continue to try to initiate u3. the implication is driver and operating system dependent.										
workaround	none identified.										
											
title	usb xhci max packet size and transfer descriptor length mismatch										
problem	the xhci may incorrectly handle a request from a low-speed or full-speed device when all the following conditions are true: the sum of the packet fragments equals the length specified by the td (transfer descriptor). the td length is less than the mps (max packet size) for the device. the last packet received in the transfer is “0” or babble bytes.										
implication	the xhci will halt the endpoint if all the above conditions are met. all functions associated with the endpoint will stop functioning until the device is unplugged and reinserted.										
workaround	none identified.										
											
title	pcie* root ports unsupported request completion										
problem	the pcie* root ports may return an unsupported request (ur) completion with an incorrect lower address field in response to a memory read if any of the following occur: bus master enable is disabled in the pcie root port’s command register (pcicmd bit 2 =0). address type (at) field of the transaction layer packet (tlp) header is non-zero. the requested upstream address falls within the memory range claimed by the secondary side of the bridge. requester id with bus number of 0.										
implication	the ur completion with an incorrect lower address field may be handled as a malformed tlp causing the requestor to send an err_nonfatal or err_fatal message.										
workaround	none identified.										
											
title	usb ehci rmh port disabled due to device initiated remote wake										
problem	during resume from global suspend, the rmh controller may not send sof soon enough to prevent a device from entering suspend again. a collision on the port may occur if a device initiated remote wake occurs before the rmh controller sends sof. note: intel has only observed this issue when two usb devices on the same rmh controller send remote wake within 30 ms window while rmh controller is resuming from global suspend.										
implication	the rmh host controller may detect the collision as babble and disable the port.										
workaround	intel recommends system software to check bit 3 (port enable/disable change) together with bit 7 (suspend) of port n status and control portc registers when determining which port(s) have initiated remote wake. intel recommends the use of the usb xhci controller, which is not affected by this erratum.										
											
title	smbus hold time										
problem	the smbus data hold time may be less than the 300 ns minimum defined by the bay trail-d/m soc (system on chip) external design specification (eds).										
implication	there are no known functional failures due to this issue.										
workaround	none identified.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	cs limit violations may not be detected after vm entry										
problem	the processor may fail to detect a cs limit violation on fetching the first instruction after vm entry if the first byte of that instruction is outside the cs limit but the last byte of the instruction is inside the limit.										
implication	the processor may erroneously execute an instruction that should have caused a general protection exception.										
workaround	when a vmm emulates a branch instruction it should inject a general protection exception if the instruction’s target eip is beyond the cs limit.										
											
title	ia32_debugctl.freeze_perfmon_on_pmi is incorrectly cleared by smi										
problem	freeze_perfmon_on_pmi (bit 12) in the ia32_debugctl msr (1d9h) is erroneously cleared during delivery of an smi (system-management interrupt).										
implication	as a result of this erratum the performance monitoring counters will continue to count after a pmi occurs in smm (system-management mode).										
workaround	none identified.										
											
title	pebs record eventingip field may be incorrect after cs.base change										
problem	due to this erratum a pebs (precise event base sampling) record generated after an operation which changes cs.base may contain an incorrect address in the eventingip field.										
implication	software attempting to identify the instruction which caused the pebs event may identify the incorrect instruction when non-zero cs.base is supported and cs.base is changed. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	some performance counter overflows may not be logged in ia32_perf_global_status when freeze_perfmon_on_pmi is enabled										
problem	when enabled, freeze_perfmon_on_pmi bit 12 in ia32_debugctl msr (1d9h) freezes pmcs (performance monitoring counters) on a pmi (performance monitoring interrupt) request by clearing the ia32_perf_global_ctrl msr (38fh). due to this erratum, when freeze_perfmon_on_pmi is enabled and two or more pmcs overflow within a small window of time and pmi is requested, then subsequent pmc overflows may not be logged in ia32_perf_global_status msr (38eh).										
implication	on a pmi, subsequent pmc overflows may not be logged in ia32_perf_global_status msr.										
workaround	re-enabling the pmcs in ia32_perf_global_ctrl will log the overflows that were not previously logged in ia32_perf_global_status.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of movntdqa that loads from wc (write combining) memory may appear to pass an earlier locked instruction to a different cache line.										
implication	software that expects a lock to fence subsequent movntdqa instructions may not operate properly. if the software does not rely on locked instructions to fence the subsequent execution of movntdqa then this erratum does not apply.										
workaround	software that requires a locked instruction to fence subsequent executions of movntdqa should insert an lfence instruction before the first execution of movntdqa following the locked instruction. if there is already fencing or serializing instruction between the locked instruction and the movntdqa, then an additional lfence is not necessary.										
											
title	performance monitor instructions retired event may not count consistently										
problem	performance monitor instructions retired (event c0h; umask 00h) and the instruction retired fixed counter (ia32_fixed_ctr0 msr (309h)) are used to track the number of instructions retired. due to this erratum, certain situations may cause the counter(s) to increment when no instruction has retired or to not increment when specific instructions have retired.										
implication	a performance counter counting instructions retired may over or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor or system bus master writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction prior to execution of the new code is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the intel architecture software developer's manual volume 3: system programming guide including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	to avoid this erratum, programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3: system programming guide section: handling self- and cross-modifying code.										
											
title	usb hsic ports incorrectly reported as removable										
problem	the dr (device removable) bit in the portsc registers of the two usb hsic ports incorrectly indicates that devices on these ports may be removed.										
implication	software that relies solely on the state of dr bits will consider fixed devices to be removable. this may lead the software to improper actions (for example, requesting the user remove a fixed device).										
workaround	in conjunction with the dr bits, software should use bios-configured acpi tables and factor in the connectable field of the usb port capabilities object when determining whether a port is removable.										
											
title	paging structure entry may be used before accessed and dirty flags are updated										
problem	if software modifies a paging structure entry while the processor is using the entry for linear address translation, the processor may erroneously use the old value of the entry to form a translation in a translation lookaside buffer (tlb) (or an entry in a paging structure cache) and then update the entry’s new value to set the accessed flag or dirty flag. this will occur only if both the old and new values of the entry result in valid translations.										
implication	incorrect behavior may occur with algorithms that atomically check that the accessed flag or the dirty flag of a paging structure entry is clear and modify other parts of that paging structure entry in a manner that results in a different valid translation.										
workaround	affected algorithms must ensure that appropriate tlb invalidation is done before assuming that future accesses do not use translations based on the old value of the paging structure entry.										
											
title	vga max luminance voltage may exceed vesa limits										
problem	the max luminance voltage on the vga video outputs may range from 640 mv to 810mv (the vesa specification range is 665 mv to 770mv) with linearity (inl/dnl) of up to ±3 lsb (the vesa linearity specification is ±1 lsb).										
implication	intel has not observed any functional issues due to this erratum.										
workaround	none identified.										
											
title	sd host controller incorrectly reports supporting of suspend/resume feature										
problem	sdio, sd card, and emmc controllers should not indicate the support of optional suspend/ resume feature documented in the sd host controller standard specification version 3.0. due to this erratum, the default value in the capabilities register (offset 040h) incorrectly indicates to the software that this feature is supported.										
implication	if software utilizes the suspend/resume feature, data may not be correctly transferred between memory and sd device.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	sd host controller error status registers may be incorrectly set										
problem	this erratum impacts sdio, sd card, and emmc sd host controllers. auto cmd error status register (offset 03ch, bits [7:1]) may be incorrectly set for software-issued commands (for example: cmd13) that generate errors when issued close to the transmission of an auto cmd12 command. in addition, the error interrupt status register bits (offset 032h) are similarly affected.										
implication	software may not be able to interpret sd host controller error status.										
workaround	software should follow the same error recovery flow whenever an error status bit is set.										
											
title	sd host controller registers are not cleared by software reset										
problem	this erratum impacts sdio, sd card, and emmc sd host controllers. when software reset is asserted, registers such as sdma system address / argument 2 (offset 00h) in sd host controller are not cleared, failing to comply with the sd host controller specification 3.0.										
implication	intel has not observed this erratum to impact any commercially available software. workaround driver is expected to reprogram these registers before issuing a new command.										
workaround											
											
title	emmc asynchronous abort may cause a hang										
problem	use of an asynchronous abort command to recover from an emmc transfer error or use of a high priority interrupt stop_transmission command may result in a hang.										
implication	using asynchronous abort command may cause a hang. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	the emmc driver should use high priority interrupt send_status mode per jedec standard emmc, version 4.5. a minimum wait time of 128us between getting an error interrupt and issuing a software reset will avoid this erratum.										
											
title	timing specification violation on sd card interface										
problem	sd card interface i/o circuitry is not optimized for platform conditions during operation at 3.3v. implication due to this erratum, there is an increased risk of a transfer error.										
implication											
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	sd card controller does not disable clock during card power down										
problem	the clock and power control of the sd card controller are not linked. therefore, the sd card controller does not automatically disable the sd card clock when the sd card power is disabled.										
implication	when an sd card is inserted into the system and powered off, the clock to the sd card will continue to be driven. although this behavior is common, it is a violation of the sd card spec 3.0.										
workaround	to address this problem, the sd card clock should be enabled/disabled in conjunction with sd card power.										
											
title	reset sequence may take longer than expected when acg is enabled in sd and sdio controllers										
problem	when acg (auto clock gating) is enabled in sd and sdio controllers, the reset sequence may take longer than expected, possibly resulting in a software timeout.										
implication	due to this erratum, a longer response time may be observed after software initiates reset.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	sdio host controller does not control the sdio bus power										
problem	the sd bus power bit in power control register (bus 0; device 17; function 0; offset 029h) is not connected to any soc io pin that can reset the sdio bus power. due to this erratum, sdio device power-on-reset cannot be controlled by power control register. sdio controller may fail to comply with sd host controller specification version 3.00.										
implication	sdio devices may not be powered up and initialized correctly.										
workaround	a gpio pin must be implemented on the platform to control the sdio bus power. gpio pin can be asserted/de-asserted from asl methods in firmware.										
											
title	premature asynchronous interrupt enabling may lead to loss of sdio wi-fi functionality										
problem	setting the sdio controller’s host control 2 register asynchronous interrupt enable (bus 0; device 17; function 0; offset 03eh, bit 14) to ‘1’ before the signal voltage switch sequence completion may result in sdio card initialization failure.										
implication	sdio card initialization failure may lead to software time out and loss of wifi device functionality. currently released common operating system drivers do not use asynchronous interrupt mode.										
workaround	the sdio driver should either use sdio synchronous interrupt mode or enable sdio asynchronous interrupt mode after the sdio card signal voltage switch sequence completes.										
											
title	mtf vm exit may be delayed following a vm entry that injects a software interrupt										
problem	if the “monitor trap flag” vm-execution control is 1 and vm entry is performing event injection, an mtf vm exit should be delivered immediately after the vm entry. due to this erratum, delivery of the mtf vm exit may be delayed by one instruction if the event being injected is a software interrupt and if the guest state being loaded has rflags.vm = cr4.vme = 1. in this case, the mtf vm exit is delivered following the first instruction of the software interrupt handler.										
implication	software using the monitor trap flag to trace guest execution may fail to get a notifying vm exit after injecting a software interrupt. intel has not observed this erratum with any commercially available system.										
workaround	none identified. an affected virtual-machine monitor could emulate delivery of the software interrupt before vm entry.										
											
title	lbr stack and performance counter freeze on pmi may not function correctly										
problem	when freeze_lbrs_on_pmi flag (bit 11) in ia32_debugctl msr (1d9h) is set, the lbr (last branch record) stack is frozen on a hardware pmi (performance monitoring interrupt) request. when freeze_perfmon_on_pmi flag (bit 12) in ia32_debugctl msr is set, a pmi request clears each of the enable fields of the ia32_perf_global_ctrl msr (38fh) to disable counters. due to this erratum, when freeze_lbrs_on_pmi and/or freeze_perfmon_on_pmi is set in ia32_debugctl msr and the local apic is disabled or the pmi lvt is masked, the lbr stack and/or performance counters freeze on pmi may not function correctly.										
implication	performance monitoring software may not function properly if the lbr stack and performance counters freeze on pmi do not operate as expected. intel has not observed this erratum to impact any commercially available system.										
workaround	none identified.										
											
title	usb legacy support smi not available from xhci controller										
problem	smis are routed using the pmc (power management controller) smi_sts and smi_en registers. however, the usb smi enable (usb_smi_en) and usb status (usb_sts) fields only reflect smis for the ehci usb controller. smis triggered by the xhci controller’s usblegctlsts mechanism are not available.										
implication	bios is unable to receive smi interrupts from the xhci controller. bios mechanisms such as legacy keyboard emulation for pre-os environments will be impacted.										
workaround	use the ehci controller for legacy keyboard emulation that require legacy usb smi support by bios.										
											
title	sd card uhs-i mode is not fully supported										
problem	the sd card specification rev 3.01 addendum 1 specifies a relaxed ncrc (number of clocks to cyclic redundancy check) timing specification for uhs-i (ddr50) mode. due to this erratum, the sd host controller is not fully compatible with this relaxed timing specification.										
implication	using uhs-i mode with sd devices that rely upon relaxed ncrc may cause sd host commands to fail to complete, resulting in device access failures.										
workaround	bios and driver code changes have been identified and may be implemented as a workaround for this erratum.										
											
title	hd audio recording and playback may glitch or stop										
problem	under certain conditions generally involving extended simultaneous video and hd audio playback and/or recording, glitches, distortion, or persistent muting of the audio stream may occur due to improper processing of input stream data or response packets.										
implication	due to this erratum, media device operation may not be reliable.										
workaround	a bios code change has been identified and may be implemented to minimize the effect of this erratum. the 3rd party codec driver should minimize hd audio device command traffic.										
											
title	usb xhci may execute a stale transfer request block (trb)										
problem	when a usb 3.0 or usb 2.0 hub with numerous active full-speed (fs) or low-speed (ls) periodic endpoints attached is removed and then reconnected to an usb xhci port, the xhci controller may fail to fully refresh its cache of trb records. the controller may read and execute a stale trb and place a pointer to it in a transfer event trb.										
implication	in some cases, the xhci controller may read de-allocated memory pointed to by a trb of a disabled slot. the xhci controller may also place a pointer to that memory in the event ring, causing the xhci driver to access that memory and process its contents, resulting in system hang, failure to enumerate devices, or other anomalous system behavior.										
workaround	none identified.										
											
title											
problem	when the cpuid instruction is executed with eax = 80000002h, 80000003h, and 80000004h, the frequency reported in the brand string may be truncated while the published frequency is rounded. for example a processor with a frequency of 2.166667ghz may be reported as 2.16ghz in the brand string instead of the published frequency of 2.17ghz										
implication	intel® pentium® processor n3000 and j2000 series, and intel® celeron® n2000, j1700, j1800, and j1900 series processors may report in the brand string a frequency lower than the published frequency.										
workaround	none identified.										
											
title	reset sequence may not complete under certain conditions										
problem	under certain conditions, the soc may not complete initialization either during a reset issued while the system is running or from the g3 (mechanically off) global system state.										
implication	when this erratum occurs, the soc will detect an initialization problem and halt the initialization sequence prior to normal operation, leading to a system hang. the system will subsequently require a power cycle via the system power button.										
workaround	for the erratum occurring during reset while the system is running, a firmware code change has been identified which significantly reduces the likelihood of this erratum after the initial reset at power on.										
											
title	multiple drivers that access the gpio registers concurrently may result in unpredictable system behavior										
problem	the pcu (platform control unit) in soc may not be able to process concurrent accesses to the gpio registers. due to this erratum, read instructions may return 0xffffffff and write instructions may be dropped.										
implication	multiple drivers concurrently accessing gpio registers may result in unpredictable system behavior.										
workaround	gpio drivers should not access gpio registers concurrently. each driver should acquire a global lock before accessing the gpio register, and then release the lock after the access is completed. the intel-provided drivers implement this workaround.										
											
title	boot may not complete when smi occurs during boot										
problem	during boot, the system should be able to handle smis (system management interrupt). due to this erratum, boot may not complete when smi occurs during boot.										
implication	if the system receives an smi during boot, the boot may not complete.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	interrupts that target an apic that is being disabled may result in a system hang										
problem	interrupts that target a logical processor whose local apic is either in the process of being hardware disabled by clearing bit 11 in the ia32_apic_base_msr or software disabled by clearing bit 8 in the spurious-interrupt vector register at offset 0f0h from the apic base are neither delivered nor discarded.										
implication	when this erratum occurs, the processor may hang.										
workaround	none identified. software must follow the recommendation that all interrupt sources that target an apic must be masked or changed to no longer target the apic, and that any interrupts targeting the apic be quashed, before the apic is disabled.										
											
title											
problem	for l2 cache errors with ia32_mci_status.mcacod (bits [15:0]) value 0000_0001_0000_1010b, the address reported in ia32_mci_addr msr may not be the address that caused the machine check.										
implication	due to this erratum, the address reported in ia32_mci_addr may be incorrect.										
workaround	none identified.										
											
title	some usb controller capability registers may be invalid after s3 resume										
problem	the contents of several usb xhci host capability registers may be invalid after an s3 resume. registers impacted by this erratum are hccparams, hcsparams1, hcparams3, usb2_phy_pmc, usb_pgc, and xltp_ltv1.										
implication	software that depends on the contents of the named registers may not behave as expected, possibly leading to a usb driver failure or a system hang.										
workaround	a bios workaround has been identified.										
											
title	top swap mechanism may become incorrectly configured										
problem	writing the general control register may cause the top swap mechanism to become incorrectly configured, resulting in unreliable boot behavior.										
implication	due to this erratum, boot behavior may become unreliable which may impact system availability.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	certain peripheral i/o controllers may hang after an unexpectedly long latency memory transaction										
problem	when an emmc (embedded multimedia card), lpe (low power engine), xdci (usb device mode controller), sdio (secure digital input output), or sd (secure digital) controller memory transaction encounters an unexpectedly long latency, this may cause the controller to hang.										
implication	when this erratum occurs, the peripheral i/o controller will hang.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	disabling sdio or sdcard may lead to a system hang										
problem	if bios disables either the sdio or the sdcard (but not both) and follows the recommended sequence of placing the disabled controller in d3, the remaining enabled controller may stop functioning and hang the system. if bios doesn’t put the disabled controller in d3, the enabled controller will operate normally but entry to the s0ix low-power state is blocked.										
implication	when this erratum occurs, the sdio or the sdcard stops functioning and may hang the system. workaround it is possible for the firmware to contain a workaround for this erratum.										
workaround											
											
title	video and/or audio artifact may occur when changing frequencies										
problem	when changing the processor frequency, the soc may fail to update the usb descriptor prior to xhci consuming the descriptor when in isoc mode.										
implication	when this erratum occurs, video or audio artifacts may occur.										
workaround	it is possible for firmware to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	usb device may not be detected at system power-on										
problem	certain internal conditions may cause the d- signal of one or more usb ports to get stuck at +3.3v during system power-on.										
implication	when this erratum occurs, a usb device attached to the affected port will not function. in addition, the os may report problems with the usb port. this erratum may not affect all socs and has been observed only on platforms that ramp the 1.8v sustain rail (v1p8a) before ramping the 3.3v sustain rail (v3p3a).										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	vm exits during execution of intn in virtual-8086 mode with virtual-mode extensions may save rflags incorrectly										
problem	an apic-access vm exit or a vm exit due to an ept (extended page table) violation or an ept misconfiguration that occurs during execution of the intn instruction in virtual-8086 mode (eflags.vm = 1) with virtual-mode extensions (cr4.vme = 1) may save an incorrect value for rflags in the guest-state area of the vmcs.										
implication	this erratum may cause a virtual-machine monitor to handle the vm exit incorrectly, may cause a subsequent vm entry to fail, or may cause incorrect operation of guest software.										
workaround	it is possible for the firmware to contain a workaround for this erratum.										
											
title	lpe audio playback may result in system hang										
problem	extended audio playback with the lpe (low power engine) may result in a system hang if the soc concurrently enters c6 or deeper sleep states.										
implication	the system may hang when this erratum occurs.										
workaround	it is possible for the driver to contain a workaround for this erratum.										
											
title	lpc serr generation can not be independently disabled										
problem	lpc serr# events are incorrectly propagated to trigger the nmi interrupt when the see field of the pcie_reg_command register (bus 0; device 31; function 0; offset 4h) is cleared. this erratum only affects systems with attached lpc devices that signal serr# events.										
implication	serr for lpc cannot be disabled using pcie_reg_command see bit. serr# is used on the lpc bus to carry the legacy isa iochk# parity error indication.										
workaround	none identified. software can clear nsc (nmi status and control) msr (bus 0; device 31; function 0; offset 61h) sne field to disable serr for both nmi and lpc.										
											
title	some rtit packets following psb may be sent out of order or dropped										
problem	when a complex micro-architectural condition occurs concurrently with the generation of a rtit (real-time instruction trace) psb (packet stream boundary) packet, the packets that immediately follow the psb could precede or overwrite some older packets. this erratum applies to no more than 21 packets immediately following the psb.										
implication	the rtit packet output immediately following a psb may not accurately reflect software behavior, and may result in an rtit decoder error.										
workaround	none identified.										
											
title	accessing unimplemented isp mmio space may cause a system hang										
problem	access to unimplemented isp (image signal processor) registers should result in a software error. due to this erratum, the transaction may not complete.										
implication	when this erratum occurs, the system may hang.										
workaround	do not access unimplemented isp mmio space.										
											
title	rtit trace may contain fup.far packet with incorrect address										
problem	the fup.far (flow update packet for far transfer) generated by rtit (real time instruction trace) on a far transfer instruction should contain the linear address of the first byte of the next sequential instruction after the far transfer instruction. due to this erratum, far transfer instructions with more than 3 prefixes may incorrectly include an address between the first byte of the far transfer instruction and the last byte of the far transfer instruction.										
implication	the rtit trace decoder may incorrectly decode the trace due to an incorrect address in the fup packet.										
workaround	the rtit trace decoder can identify a fup.far in the middle of a far transfer instruction and treat that fup.far as if it was coming from the first byte of the following sequential instruction.										
											
title	rtit may delay the psb by one packet										
problem	after an rtit (real time instruction trace) packet that exceeds the limit specified by pkt_mask in rtit_packet_count (msr 77ch) bits [17:16], the psb (packet stream boundary) packet should be sent immediately. due to this erratum, the psb packet may delayed by one packet.										
implication	the psb packet may be delayed by one packet.										
workaround	none identified.										
											
title	rtit tracestop condition detected during buffer overflow may not clear traceactive										
problem	if an rtit (real time instruction trace) tracestop condition is detected while rtit_status.buffer_overflow msr (769h) bit 3 is set, the processor may not clear rtit_ctl.traceactive msr (768h) bit 13, and tracing will continue after the overflow resolves. such a case will be evident if the tracestop packet is inserted before overflow is resolved, as indicated by the fup.buffovf (flow update packet for buffer overflow) packet.										
implication	the rtit trace will continue tracing beyond the intended stop point.										
workaround	none identified.										
											
title	rtit fup.buffovf packet may be incorrectly followed by a tip packet										
problem	when rtit (real time instruction trace) suffers an internal buffer overflow, packet generation stops temporarily, after which a fup.buffovf (flow update packet for buffer overflow) is sent to indicate the lip that follows the instruction upon which tracing resumes. in some cases, however, this packet will be immediately followed by a fup.tip (flow update packet for target ip) which was generated by a branch instruction that executed during the overflow. the ip payload of this fup.tip will be the lip of the instruction upon which tracing resumes.										
implication	the spurious fup.tip packet may cause the rtit trace decoder to fail.										
workaround	the rtit trace decoder should ignore any fup.tip packet that immediately follows a fup.buffovf whose ip matches the ip payload of the fup.buffovf.										
											
title	rtit cyc packet payload values may be off by 1 cycle										
problem	when rtit (real time instruction trace) is enabled with rtit_ctl.cyc_acc msr (768h) bit 1 set to 1, all cyc (cycle count) packets have a payload value that is one less than the number of cycles that have actually passed. note that for cyc packets with a payload value of 0, the correct value may be 0 or 1.										
implication	the trace decoder will produce inaccurate performance data when using cyc packets to track software performance.										
workaround	as a partial workaround, the trace decoder should add 1 to the payload value of any cyc packet with a non-zero payload.										
											
title	first mtc packet after rtit enable may be incorrect										
problem	when rtit (real time instruction trace) is enabled, indicated by triggeren in bit 2 of the rtit_status msr (769h) transitioning from 0 to 1, the first mtc (mini time counter) packet may be sent at the wrong time.										
implication	the rtit trace decoder will make incorrect assumptions about the tsc value based on an asynchronous mtc packet.										
workaround	the rtit trace decoder should ignore the first mtc that follows trace enabling										
											
title	performance monitoring counter overflows may not be reflected in ia32_perf_global_status										
problem	when an overflow indication in ia32_perf_global_status msr (38eh) is cleared via either the logging of a pebs (precise event based sampling) record or an msr write to ia32_perf_global_ovf_ctrl msr (390h), a simultaneous counter overflow may not set its corresponding overflow bit.										
implication	when this erratum occurs, a counter overflow will not be logged in ia32_perf_global_status, although it may still pend a performance monitoring interrupt.										
workaround	none identified.										
											
title	xhci host controller reset may cause a system hang										
problem	xhci host controller may not respond following system software setting (bit 1='1') the host controller reset (hcrst) of the usb command register (xhcibar+80h).										
implication	caterr# may occur resulting in a system hang.										
workaround	a 1ms delay is necessary following system software setting (bit 1='1') host controller reset (hcrst) of the usb command register (xhcibar+80h).										
											
title	pmi may be pended when pmi lvt mask bit set										
problem	if a performance counter overflow or precise event based sampling (pebs) record generation is unable to trigger a performance monitoring interrupt (pmi) due to the pmi local vector table (lvt) entry's mask bit being set, the pmi should be dropped. due to this erratum, the pmi may instead be pended and may be taken after the pmi lvt entry mask bit is cleared.										
implication	an unexpected pmi may occur.										
workaround	none identified.										
											
title	eflags discrepancy on page fault after translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault. this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without a page fault.										
workaround	if the page fault handler inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	invlpg operation for large (2m/4m) pages may be incomplete under certain conditions										
problem	the invlpg instruction may not completely invalidate translation look-aside buffer (tlb) entries for large pages (2m/4m) when both of the following conditions exist: "address range of the page being invalidated spans several memory type range registers (mtrrs) with different memory types specified "invlpg operation is preceded by a page assist event (page fault (#pf) or an access that results in either a or d bits being set in a page table entry (pte)).										
implication	stale translations may remain valid in tlb after a pte update resulting in unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure that the memory type specified in the mtrrs is the same for the entire address range of the large page.										
											
title	store to wt memory data may be seen in wrong order by two subsequent loads										
problem	when data of store to wt memory is used by two subsequent loads of one thread and another thread performs cacheable write to the same address the first load may get the data from external memory or l2 written by another core, while the second load will get the data straight from the wt store.										
implication	software that uses wb to wt memory aliasing may violate proper store ordering.										
workaround	do not use wb to wt aliasing.										
											
title	non-temporal data store may be observed in wrong program order										
problem	when non-temporal data is accessed by multiple read operations in one thread while another thread performs a cacheable write operation to the same address, the data stored may be observed in wrong program order (i.e. later load operations may read older data).										
implication	software that uses non-temporal data without proper serialization before accessing the non-temporal data may observe data in wrong program order.										
workaround	software that conforms to the intel® 64 and ia-32 architectures software developer's manual, volume 3a, section "buffering of write combining memory locations" will operate correctly.										
											
title	page access bit may be set prior to signaling a code segment limit fault										
problem	if code segment limit is set close to the end of a code page, then due to this erratum the memory page access bit (a bit) may be set for the subsequent page prior to general protection fault on code segment limit.										
implication	when this erratum occurs, a non-accessed page which is present in memory and follows a page that contains the code segment limit may be tagged as accessed.										
workaround	erratum can be avoided by placing a guard page (non-present or non-executable page) as the last page of the segment or after the page that includes the code segment limit.										
											
title	updating code page directory attributes without tlb invalidation may result in improper handling of code #pf										
problem	code #pf (page fault exception) is normally handled in lower priority order relative to both code #db (debug exception) and code segment limit violation #gp (general protection fault). due to this erratum, code #pf may be handled incorrectly, if all of the following conditions are met: a pde (page directory entry) is modified without invalidating the corresponding tlb (translation look-aside buffer) entry code execution transitions to a different code page such that both the target linear address corresponds to the modified pde the pte (page table entry) for the target linear address has an a (accessed) bit that is clear one of the following simultaneous exception conditions is present following the code transition code #db and code #pf code segment limit violation #gp and code #pf										
implication	software may observe either incorrect processing of code #pf before code segment limit violation #gp or processing of code #pf in lieu of code #db.										
workaround	none identified.										
											
title	storage of pebs record delayed following execution of mov ss or sti										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflow of the counter results in storage of a pebs record in the pebs buffer. the information in the pebs record represents the state of the next instruction to be executed following the counter overflow. due to this erratum, if the counter overflow occurs after execution of either mov ss or sti, storage of the pebs record is delayed by one instruction.										
implication	when this erratum occurs, software may observe storage of the pebs record being delayed by one instruction following execution of mov ss or sti. the state information in the pebs record will also reflect the one instruction delay.										
workaround	none identified.										
											
title	performance monitoring event fp_mmx_trans_to_mmx may not count some transitions										
problem	performance monitor event fp_mmx_trans_to_mmx (event cch, umask 01h) counts transitions from x87 floating point (fp) to mmx™ instructions. due to this erratum, if only a small number of mmx instructions (including emms) are executed immediately after the last fp instruction, a fp to mmx transition may not be counted.										
implication	the count value for performance monitoring event fp_mmx_trans_to_mmx may be lower than expected. the degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	a rep stos/movs to a monitor/mwait address range may prevent triggering of the monitoring hardware										
problem	the monitor instruction is used to arm the address monitoring hardware for the subsequent mwait instruction. the hardware is triggered on subsequent memory store operations to the monitored address range. due to this erratum, rep stos/movs fast string operations to the monitored address range may prevent the actual triggering store to be propagated to the monitoring hardware.										
implication	a logical processor executing an mwait instruction may not immediately continue program execution if a rep stos/movs targets the monitored address range.										
workaround	software can avoid this erratum by not using rep stos/movs store operations within the monitored address range.										
											
title	performance monitoring event misalign_mem_ref may over count										
problem	performance monitoring event misalign_mem_ref (05h) is used to count the number of memory accesses that cross an 8-byte boundary and are blocked until retirement. due to this erratum, the performance monitoring event misalign_mem_ref also counts other memory accesses.										
implication	the performance monitoring event misalign_mem_ref may over count. the extent of the over counting depends on the number of memory accesses retiring while the counter is active.										
workaround	none identified.										
											
title	the processor may report a #ts instead of a #gp fault										
problem	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss exception) instead of a #gp fault (general protection exception).										
implication	operation systems that access a busy tss may get invalid tss fault instead of a #gp fault. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	code segment limit violation may occur on 4 gigabyte limit check										
problem	code segment limit violation may occur on 4 gigabyte limit check when the code stream wraps around in a way that one instruction ends at the last byte of the segment and the next instruction begins at 0x0.										
implication	this is a rare condition that may result in a system hang. intel has not observed this erratum with any commercially available software, or system.										
workaround	avoid code that wraps around segment limit.										
											
title	a write to an apic register sometimes may appear to have not occurred										
problem	with respect to the retirement of instructions, stores to the uncacheable memory- based apic register space are handled in a non-synchronized way. for example if an instruction that masks the interrupt flag, for example, cli is executed soon after an uncacheable write to the task priority register (tpr) that lowers the apic priority, the interrupt masking operation may take effect before the actual priority has been lowered. this may cause interrupts whose priority is lower than the initial tpr, but higher than the final tpr, to not be serviced until the interrupt enabled flag is finally set, that is, by sti instruction. interrupts will remain pending and are not lost.										
implication	in this example the processor may allow interrupts to be accepted but may delay their service.										
workaround	this non-synchronization can be avoided by issuing an apic register read after the apic register write. this will force the store to the apic register before any subsequent instructions are executed. no commercial operating system is known to be impacted by this erratum.										
											
title	last branch records (lbr) updates may be incorrect after a task switch										
problem	a task-state segment (tss) task switch may incorrectly set the lbr_from value to the lbr_to value.										
implication	the lbr_from will have the incorrect address of the branch instruction. workaround none identified.										
workaround											
											
title	rep movs/stos executing with fast strings enabled and crossing page boundaries with inconsistent memory types may use an incorrect data size or lead to memory-ordering violations										
problem	under certain conditions as described in the software developers manual section "out- of-order stores for string operations in pentium 4, intel xeon, and p6 family processors" the processor performs rep movs or rep stos as fast strings. due to this erratum fast string rep movs/rep stos instructions that cross page boundaries from wb/wc memory types to uc/wp/wt memory types, may start using an incorrect data size or may observe memory ordering violations.										
implication	upon crossing the page boundary the following may occur, dependent on the new page memory type: uc the data size of each write will now always be 8 bytes, as opposed to the original data size. wp the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. wt there may be a memory ordering violation.										
workaround	software should avoid crossing page boundaries from wb or wc memory type to uc, wp or wt memory type within a single rep movs or rep stos instruction that will execute with fast strings enabled.										
											
title	upper 32 bits of 'from' address reported through btms or btss may be incorrect										
problem	when a far transfer switches the processor from 32-bit mode to ia-32e mode, the upper 32 bits of the 'from' (source) addresses reported through the btms (branch trace messages) or btss (branch trace stores) may be incorrect.										
implication	the upper 32 bits of the 'from' address debug information reported through btms or btss may be incorrect during this transition.										
workaround	none identified.										
											
title	address reported by machine-check architecture (mca) on single-bit l2 ecc errors may be incorrect										
problem	when correctable single-bit ecc errors occur in the l2 cache, the address is logged in the mca address register (mci_addr). under some scenarios, the address reported may be incorrect.										
implication	software should not rely on the value reported in mci_addr, for single-bit l2 ecc errors.										
workaround	none identified.										
											
title	code segment limit/canonical faults on rsm may be serviced before higher priority interrupts/exceptions and may push the wrong address onto the stack										
problem	normally, when the processor encounters a segment limit or canonical fault due to code execution, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. due to this erratum, if rsm (resume from system management mode) returns to execution flow that results in a code segment limit or canonical fault, the #gp fault may be serviced before a higher priority interrupt or exception (e.g. nmi (non-maskable interrupt), debug break(#db), machine check (#mc), etc.). if the rsm attempts to return to a non-canonical address, the address pushed onto the stack for this #gp fault may not match the non-canonical address that caused the fault.										
implication	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	store ordering may be incorrect between wc and wp memory type										
problem	according to intel® 64 and ia-32 intel architecture software developer's manual, volume 3a "methods of caching available", wp (write protected) stores should drain the wc (write combining) buffers in the same way as uc (uncacheable) memory type stores do. due to this erratum, wp stores may not drain the wc buffers.										
implication	memory ordering may be violated between wc and wp stores.										
workaround	none identified.										
											
title	eflags, cr0, cr4 and the exf4 signal may be incorrect after shutdown										
problem	when the processor is going into shutdown due to an rsm inconsistency failure, eflags, cr0 and cr4 may be incorrect. in addition the exf4 signal may still be asserted. this may be observed if the processor is taken out of shutdown by nmi#.										
implication	a processor that has been taken out of shutdown may have an incorrect eflags, cr0 and cr4. in addition the exf4 signal may still be asserted.										
workaround	none identified.										
											
title	premature execution of a load operation prior to exception handler invocation										
problem	if any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. if an instruction that performs a memory load causes a code segment limit violation. if a waiting x87 floating-point (fp) instruction or mmx™ technology (mmx) instruction that performs a memory load has a floating-point exception pending. if an mmx or sse/sse2/sse3/ssse3 extensions (sse) instruction that performs a memory load and has either cr0.em=1 (emulation bit set), or a floating-point top- of-stack (fp tos) not equal to 0, or a dna exception pending.										
implication	in normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. if the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the side- effect. particularly, while cr0.ts [bit 3] is set, a movd/movq with mmx/xmm register operands may issue a memory load before getting the dna exception.										
workaround	code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory.										
											
title	performance monitoring events for retired instructions (c0h) may not be accurate										
problem	the inst_retired performance monitor may miscount retired instructions as follows: repeat string and repeat i/o operations are not counted when a hardware interrupt is received during or after the last iteration of the repeat flow. vmlaunch and vmresume instructions are not counted. hlt and mwait instructions are not counted. the following instructions, if executed during hlt or mwait events, are also not counted: rsm from a c-state smi during an mwait instruction. rsm from an smi during a hlt instruction.										
implication	there may be a smaller than expected value in the inst_retired performance monitoring counter. the extent to which this value is smaller than expected is determined by the frequency of the above cases.										
workaround	none identified.										
											
title	returning to real mode from smm with eflags.vm set may result in unpredictable system behavior										
problem	returning back from smm mode into real mode while eflags.vm is set in smram may result in unpredictable system behavior.										
implication	if smm software changes the values of the eflags.vm in smram, it may result in unpredictable system behavior. intel has not observed this behavior in commercially available software.										
workaround	smm software should not change the value of eflags.vm in smram.										
											
title	writing the local vector table (lvt) when an interrupt is pending may cause an unexpected interrupt										
problem	if a local interrupt is pending when the lvt entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.										
implication	an interrupt may immediately be generated with the new vector when a lvt entry is written, even if the new lvt entry has the mask bit set. if there is no interrupt service routine (isr) set up for that vector the system will gp fault. if the isr does not do an end of interrupt (eoi) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.										
workaround	any vector programmed into an lvt entry must have an isr associated with it, even if that vector was programmed as masked. this isr routine must do an eoi to clear any unexpected interrupts that may occur. the isr associated with the spurious vector does not generate an eoi, therefore the spurious vector should not be used when writing the lvt.										
											
title	pending x87 fpu exceptions (#mf) following sti may be serviced before higher priority interrupts										
problem	interrupts that are pending prior to the execution of the sti (set interrupt flag) instruction are normally serviced immediately after the instruction following the sti. an exception to this is if the following instruction triggers a #mf. in this situation, the interrupt should be serviced before the #mf. because of this erratum, if following sti, an instruction that triggers a #mf is executed while stpclk#, enhanced intel speedstep® technology transitions or thermal monitor events occur, the pending #mf may be serviced before higher priority interrupts.										
implication	software may observe #mf being serviced before higher priority interrupts. workaround none identified.										
workaround											
											
title	verw/verr/lsl/lar instructions may unexpectedly update the last exception record (ler) msr										
problem	the ler msr may be unexpectedly updated, if the resultant value of the zero flag (zf) is zero after executing the following instructions verr (zf=0 indicates unsuccessful segment read verification) verw (zf=0 indicates unsuccessful segment write verification) lar (zf=0 indicates unsuccessful access rights load) lsl (zf=0 indicates unsuccessful segment limit load)										
implication	the value of the ler msr may be inaccurate if verw/verr/lsl/lar instructions are executed after the occurrence of an exception.										
workaround	software exception handlers that rely on the ler msr value should read the ler msr before executing verw/verr/lsl/lar instructions.										
											
title	init does not clear global entries in the tlb										
problem	init may not flush a tlb entry when: the processor is in protected mode with paging enabled and the page global enable flag is set (pge bit of cr4 register) g bit for the page table entry is set tlb entry is present in tlb when init occurs										
implication	software may encounter unexpected page fault or incorrect address translation due to a tlb entry erroneously left in tlb after init.										
workaround	write to cr3, cr4 (setting bits pse, pge or pae) or cr0 (setting bits pg or pe) registers before writing to memory early in bios code to clear all the global entries from tlb.										
											
title	programming the digital thermal sensor (dts) threshold may cause unexpected thermal interrupts										
problem	software can enable dts thermal interrupts by programming the thermal threshold and setting the respective thermal interrupt enable bit. when programming dts value, the previous dts threshold may be crossed. this will generate an unexpected thermal interrupt.										
implication	software may observe an unexpected thermal interrupt occur after reprogramming the thermal threshold.										
workaround	in the acpi/os implement a workaround by temporarily disabling the dts threshold interrupt before updating the dts threshold value.										
											
title	writing shared unaligned data that crosses a cache line without proper semaphores or barriers may expose a memory ordering issue										
problem	software which is written so that multiple agents can modify the same shared unaligned memory location at the same time may experience a memory ordering issue if multiple loads access this shared data shortly thereafter. exposure to this problem requires the use of a data write which spans a cache line boundary.										
implication	this erratum may cause loads to be observed out of order. intel has not observed this erratum with any commercially available software or system.										
workaround	software should ensure at least one of the following is true when modifying shared data by multiple agents:										
											
title											
problem	in 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4g limit (0ffffffffh) may not signal a #gp fault.										
implication	when such memory accesses occur in 32-bit mode, the system may not issue a #gp fault.										
workaround	software should ensure that memory accesses in 32-bit mode do not occur above the 4g limit (0ffffffffh).										
											
title	an asynchronous mce during a far transfer may corrupt esp										
problem	if an asynchronous machine check occurs during an interrupt, call through gate, far ret or iret and in the presence of certain internal conditions, esp may be corrupted.										
implication	if the mce (machine check exception) handler is called without a stack switch, then a triple fault will occur due to the corrupted stack pointer, resulting in a processor shutdown. if the mce is called with a stack switch, e.g. when the cpl (current privilege level) was changed or when going through an interrupt task gate, then the corrupted esp will be saved on the new stack or in the tss (task state segment), and will not be used.										
workaround	use an interrupt task gate for the machine check handler.										
											
title	cpuid reports architectural performance monitoring version 2 is supported, when only version 1 capabilities are available										
problem	cpuid leaf 0ah reports the architectural performance monitoring version that is available in eax[7:0]. due to this erratum cpuid reports the supported version as 2 instead of 1.										
implication	software will observe an incorrect version number in cpuid.0ah.eax [7:0] in comparison to which features are actually supported.										
workaround	software should use the recommended enumeration mechanism described in the architectural performance monitoring section of the intel® 64 and ia-32 architectures software developer's manual, volume 3: system programming guide.										
											
title	b0-b3 bits in dr6 may not be properly cleared after code breakpoint										
problem	b0-b3 bits (breakpoint conditions detect flags, bits [3:0]) in dr6 may not be properly cleared when the following sequence happens: pop instruction to ss (stack segment) selector; next instruction is fp (floating point) that gets fp assist followed by code breakpoint.										
implication	b0-b3 bits in dr6 may not be properly cleared.										
workaround	none identified.										
											
title	an xtpr update transaction cycle, if enabled, may be issued to the fsb after the processor has issued a stop-grant special cycle										
problem	according to the fsb (front side bus) protocol specification, no fsb cycles should be issued by the processor once a stop-grant special cycle has been issued to the bus. if xtpr update transactions are enabled by clearing the ia32_misc_enables[bit 23] at the time of stop-clock assertion, an xtpr update transaction cycle may be issued to the fsb after the processor has issued a stop grant acknowledge transaction.										
implication	when this erratum occurs in systems using c-states c2 (stop-grant state) and higher the result could be a system hang.										
workaround	bios must leave the xtpr update transactions disabled (default).										
											
title	performance monitoring event ia32_fixed_ctr2 may not function properly when max ratio is a non-integer core-to-bus ratio										
problem	performance counter ia32_fixed_ctr2 (msr 30bh) event counts cpu reference clocks when the core is not in a halt state. this event is not affected by core frequency changes (e.g., p states, tm2 transitions) but counts at the same frequency as the time-stamp counter ia32_time_stamp_counter (msr 10h). due to this erratum, the ia32_fixed_ctr2 will not function properly when the non-integer core-to-bus ratio multiplier feature is used and when a non-zero value is written to ia32_ fixed_ctr2. non-integer core-to-bus ratio enables additional operating frequencies. this feature can be detected by ia32_platform_id (msr 17h) bit [23].										
implication	the performance monitoring event ia32_fixed_ctr2 may result in an inaccurate count when the non-integer core-to-bus multiplier feature is used.										
workaround	if writing to ia32_fixed_ctr2 and using a non-integer core-to-bus ratio multiplier, always write a zero.										
											
title	instruction fetch may cause a livelock during snoops of the l1 data cache										
problem	a livelock may be observed in rare conditions when instruction fetch causes multiple level one data cache snoops.										
implication	due to this erratum, a livelock may occur. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	use of memory aliasing with inconsistent memory type may cause a system hang or a machine check exception										
problem	software that implements memory aliasing by having more than one linear addresses mapped to the same physical page with different cache types may cause the system to hang or to report a machine check exception (mce). this would occur if one of the addresses is non-cacheable and used in a code segment and the other is a cacheable address. if the cacheable address finds its way into the instruction cache, and the non- cacheable address is fetched in the ifu, the processor may invalidate the non- cacheable address from the fetch unit. any microarchitectural event that causes instruction restart will be expecting this instruction to still be in the fetch unit and lack of it will cause a system hang or an mce.										
implication	this erratum has not been observed with commercially available software.										
workaround	although it is possible to have a single physical page mapped by two different linear addresses with different memory types, intel has strongly discouraged this practice as it may lead to undefined results. software that needs to implement memory aliasing should manage the memory type consistency.										
											
title	a wb store following a rep stos/movs or fxsave may lead to memory-ordering violations										
problem	under certain conditions, as described in the software developers manual section "out- of-order stores for string operations in pentium 4, intel xeon, and p6 family processors", the processor may perform rep movs or rep stos as write combining stores (referred to as "fast strings") for optimal performance. fxsave may also be internally implemented using write combining stores. due to this erratum, stores of a wb (write back) memory type to a cache line previously written by a preceding fast string/fxsave instruction may be observed before string/fxsave stores.										
implication	a write-back store may be observed before a previous string or fxsave related store. intel has not observed this erratum with any commercially available software.										
workaround	software desiring strict ordering of string/fxsave operations relative to subsequent write-back stores should add an mfence or sfence instruction between the string/ fxsave operation and following store-order sensitive code such as that used for synchronization.										
											
title	vm exit with exit reason "tpr below threshold" can cause the blocking by mov/pop ss and blocking by sti bits to be cleared in the guest interruptability-state field										
problem	as specified in section, "vm exits induced by the tpr shadow", in the intel® 64 and ia-32 architectures software developer's manual, volume 3b, a vm exit occurs immediately after any vm entry performed with the "use tpr shadow", "activate secondary controls", and "virtualize apic accesses" vm-execution controls all set to 1 and with the value of the tpr shadow (bits 7:4 in byte 80h of the virtual-apic page) less than the tpr-threshold vm-execution control field. due to this erratum, such a vm exit will clear bit 0 (blocking by sti) and bit 1 (blocking by mov/pop ss) of the interruptability-state field of the guest-state area of the vmcs (bit 0 - blocking by sti and bit 1 - blocking by mov/pop ss should be left unmodified).										
implication	since the sti, mov ss, and pop ss instructions cannot modify the tpr shadow, bits 1:0 of the interruptability-state field will usually be zero before any vm entry meeting the preconditions of this erratum; behavior is correct in this case. however, if vmm software raises the value of the tpr-threshold vm-execution control field above that of the tpr shadow while either of those bits is 1, incorrect behavior may result. this may lead to vmm software prematurely injecting an interrupt into a guest. intel has not observed this erratum with any commercially available software.										
workaround	vmm software raising the value of the tpr-threshold vm-execution control field should compare it to the tpr shadow. if the threshold value is higher, software should not perform a vm entry; instead, it could perform the actions that it would normally take in response to a vm exit with exit reason "tpr below threshold".										
											
title	using memory type aliasing with cacheable and wc memory types may lead to memory ordering violations										
problem	memory type aliasing occurs when a single physical page is mapped to two or more different linear addresses, each with different memory types. memory type aliasing with a cacheable memory type and wc (write combining) may cause the processor to perform incorrect operations leading to memory ordering violations for wc operations.										
implication	software that uses aliasing between cacheable and wc memory types may observe memory ordering errors within wc memory operations. intel has not observed this erratum with any commercially available software.										
workaround	none identified. intel does not support the use of cacheable and wc memory type aliasing, and wc operations are defined as weakly ordered.										
											
title	vm exit caused by a sipi results in zero being saved to the guest rip field in the vmcs										
problem	if a logical processor is in vmx non-root operation and in the wait-for-sipi state, an occurrence of a start-up ipi (sipi) causes a vm exit. due to this erratum, such vm exits always save zero into the rip field of the guest-state area of the virtual-machine control structure (vmcs) instead of the value of rip before the sipi was received.										
implication	in the absence of virtualization, a sipi received by a logical processor in the wait-for- sipi state results in the logical processor starting execution from the vector sent in the sipi regardless of the value of rip before the sipi was received. a virtual-machine monitor (vmm) responding to a sipi-induced vm exit can emulate this behavior because the sipi vector is saved in the lower 8 bits of the exit qualification field in the vmcs. such a vmm should be unaffected by this erratum. a vmm that does not emulate this behavior may need to recover the old value of rip through alternative means. intel has not observed this erratum with any commercially available software.										
workaround	vmm software that may respond to sipi-induced vm exits by resuming the interrupt guest context without emulating the non-virtualized sipi response should (1) save from the vmcs (using vmread) the value of rip before any vm entry to the wait-for sipi state; and (2) restore to the vmcs (using vmwrite) that value before the next vm entry that resumes the guest in any state other than wait-for-sipi.										
											
title	nmis may not be blocked by a vm-entry failure										
problem	the intel® 64 and ia-32 architectures software developer's manual volume 3b: system programming guide, part 2 specifies that, following a vm-entry failure during or after loading guest state, "the state of blocking by nmi is what it was before vm entry." if non-maskable interrupts (nmis) are blocked and the "virtual nmis" vm-execution control set to 1, this erratum may result in nmis not being blocked after a vm-entry failure during or after loading guest state.										
implication	vm-entry failures that cause nmis to become unblocked may cause the processor to deliver an nmi to software that is not prepared for it.										
workaround	vmm software should configure the virtual-machine control structure (vmcs) so that vm-entry failures do not occur.										
											
title	partial streaming load instruction sequence may cause the processor to hang										
problem	under some rare conditions, when multiple streaming load instructions (movntdqa) are mixed with non-streaming loads that split across cache lines, the processor may hang.										
implication	under the scenario described above, the processor may hang. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum. however, streaming behavior may be re-enabled by setting bit 5 to 1 of the msr at address 0x21 for software development or testing purposes. if this bit is changed, then a read- modify-write should be performed to preserve other bits of this msr. when the streaming behavior is enabled and using streaming load instructions, always consume a full cache line worth of data and/or avoid mixing them with non-streaming memory references. if streaming loads are used to read partial cache lines, and mixed with non- streaming memory references, use fences to isolate the streaming load operations from non-streaming memory operations.										
											
title	self/cross modifying code may not be detected or may cause a machine check exception										
problem	if instructions from at least three different ways in the same instruction cache set exist in the pipeline combined with some rare internal state, self-modifying code (smc) or cross-modifying code may not be detected and/or handled.										
implication	an instruction that should be overwritten by another instruction while in the processor pipeline may not be detected/modified, and could retire without detection. alternatively the instruction may cause a machine check exception. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	data tlb eviction condition in the middle of a cacheline split load operation may cause the processor to hang										
problem	if the tlb translation gets evicted while completing a cacheline split load operation, under rare scenarios the processor may hang.										
implication	the cacheline split load operation may not be able to complete normally, and the machine may hang and generate machine check exception. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	update of read/write (r/w) or user/supervisor (u/s) or present (p) bits without tlb shootdown may cause unexpected processor behavior										
problem	updating a page table entry by changing r/w, u/s or p bits, even when transitioning these bits from 0 to 1, without keeping the affected linear address range coherent with all tlb (translation lookaside buffers) and paging-structures caches in the processor, in conjunction with a complex sequence of internal processor microarchitectural events and store operations, may lead to unexpected processor behavior.										
implication	this erratum may lead to livelock, shutdown or other unexpected processor behavior. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	rsm instruction execution under certain conditions may cause processor hang or unexpected instruction execution results										
problem											
implication	in the above sequence, the processor may live lock or hang, or rsm instruction may restart the interrupted processor context through a nondeterministic eip offset in the code segment, resulting in unexpected instruction execution, unexpected exceptions or system hang. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	benign exception after a double fault may not cause a triple fault shutdown										
problem	according to the intel® 64 and ia-32 architectures software developer's manual, volume 3a, "exception and interrupt reference", if another exception occurs while attempting to call the double-fault handler, the processor enters shutdown mode. due to this erratum, any benign faults while attempting to call double-fault handler will not cause a shutdown. however contributory exceptions and page faults will continue to cause a triple fault shutdown.										
implication	if a benign exception occurs while attempting to call the double-fault handler, the processor may hang or may handle the benign exception. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	ler msrs may be incorrectly updated										
problem	the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh) may contain incorrect values after any of the following: either stpclk#, nmi (nonmaskable interrupt) or external interrupts cmp or test instructions with an uncacheable memory operand followed by a conditional jump sti/pop ss/mov ss instructions followed by cmp or test instructions and then by a conditional jump										
implication	when the conditions for this erratum occur, the value of the ler msrs may be incorrectly updated.										
workaround	none identified.										
											
title	short nested loops that span multiple 16-byte boundaries may cause a machine check exception or a system hang										
problem	under a rare set of timing conditions and address alignment of instructions in a short nested loop sequence, software that contains multiple conditional jump instructions and spans multiple 16-byte boundaries, may cause a machine check exception or a system hang.										
implication	due to this erratum, a machine check exception or a system hang may occur. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	ia32_mc1_status msr bit[60] does not reflect machine check error reporting enable correctly										
problem	ia32_mc1_status msr (405h) bit[60] (en- error enabled) is supposed to indicate whether the enable bit in the ia32_mc1_ctl msr (404h) was set at the time of the last update to the ia32_mc1_status msr. due to this erratum, ia32_mc1_status msr bit[60] instead reports the current value of the ia32_mc1_ctl msr enable bit.										
implication	ia32_mc1_status msr bit [60] may not reflect the correct state of the enable bit in the ia32_mc1_ctl msr at the time of the last update.										
workaround	none identified.										
											
title	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception										
problem	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.										
implication	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software, or system.										
workaround	as recommended in the ia-32 intel® architecture software developer’s manual, the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.										
											
title	a vm exit due to a fault while delivering a software interrupt may save incorrect data into the vmcs										
problem	if a fault occurs during delivery of a software interrupt (intn) in virtual-8086 mode when virtual mode extensions are in effect and that fault causes a vm exit, incorrect data may be saved into the vmcs. specifically, information about the software interrupt may not be reported in the idt-vectoring information field. in addition, the interruptability-state field may indicate blocking by sti or by mov ss if such blocking were in effect before execution of the intn instruction or before execution of the vm- entry instruction that injected the software interrupt.										
implication	in general, vmm software that follows the guidelines given in the section “handling vm exits due to exceptions” of intel® 64 and ia-32 architectures software developer’s manual volume 3b: system programming guide should not be affected. if the erratum improperly causes indication of blocking by sti or by mov ss, the ability of a vmm to inject an interrupt may be delayed by one instruction.										
workaround	vmm software should follow the guidelines given in the section “handling vm exits due to exceptions” of intel® 64 and ia-32 architectures software developer’s manual volume 3b: system programming guide.										
											
title	a vm exit occurring in ia-32e mode may not produce a vmx abort when expected										
problem	if a vm exit occurs while the processor is in ia-32e mode and the “host address-space size” vm-exit control is 0, a vmx abort should occur. due to this erratum, the expected vmx aborts may not occur and instead the vm exit will occur normally. the conditions required to observe this erratum are a vm entry that returns from smm with the “ia- 32e guest” vm-entry control set to 1 in the smm vmcs and the “host address-space size” vm-exit control cleared to 0 in the executive vmcs.										
implication	a vm exit will occur when a vmx abort was expected.										
workaround	an smm vmm should always set the “ia-32e guest” vm-entry control in the smm vmcs to be the value that was in the lma bit (ia32_efer.lma.lma[bit 10]) in the ia32_efer msr (c0000080h) at the time of the last smm vm exit. if this guideline is followed, that value will be 1 only if the “host address-space size” vm-exit control is 1 in the executive vmcs.										
											
title	vm entry may fail when attempting to set ia32_debugctl.freeze_while_smm_en										
problem	if bit 14 (freeze_while_smm_en) is set in the ia32_debugctl field in the guest- state area of the vmcs, vm entry may fail as described in section “vm-entry failures during or after loading guest state” of intel® 64 and ia-32 architectures software developer’s manual volume 3b: system programming guide, part 2. (the exit reason will be 80000021h and the exit qualification will be zero.) note that the freeze_while_smm_en bit in the guest ia32_debugctl field may be set due to a vmwrite to that field or due to a vm exit that occurs while ia32_debugctl.freeze_while_smm_en=1										
implication	a vmm will not be able to properly virtualize a guest using the freeze_while_smm feature.										
workaround	it is possible for the bios to contain a workaround for this erratum. alternatively, the following software workaround may be used. if a vmm wants to use the freeze_while_smm feature, it can configure an entry in the vm-entry msr-load area for the ia32_debugctl msr (1d9h); the value in the entry should set the freeze_while_smm_en bit. in addition, the vmm should use vmwrite to clear the freeze_while_smm_en bit in the guest ia32_debugctl field before every vm entry. (it is necessary to do this before every vm entry because each vm exit will save that bit as 1.) this workaround prevents the vm-entry failure and sets the freeze_while_smm_en bit in the ia32_debugctl msr.										
											
title	vm entry may use wrong address to access virtual-apic page										
problem	when xfeature_enabled_mask register (xcr0) bit 1 (sse) is 1, a vm entry executed with the "use tpr shadow" vm-execution control set to 1 may use the wrong address to access data on the virtual-apic page.										
implication	an affected vm entry may exhibit the following behaviors: (1) it may use wrong areas of the virtual-apic page to determine whether vm entry fails or whether it induces a vm exit due to the tpr threshold; or (2) it may clear wrong areas of the virtual-apic page.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	init incorrectly resets ia32_lstar msr										
problem	in response to an init reset initiated either via the init# pin or an ipi (inter processor interrupt), the processor should leave msr values unchanged. due to this erratum ia32_lstar msr (c0000082h), which is used by the ia32e syscall instruction, is being cleared by an init reset.										
implication	if software programs a value in ia32_lstar to be used by the syscall instruction and the processor subsequently receives an init reset, the syscall instructions will not behave as intended. intel has not observed this erratum in any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	cpuid instruction may return incorrect brand string										
problem	when a cpuid instruction is executed with eax = 8000_0002h, 8000_0003h, or 8000_0004h, the returned eax, ebx, ecx, and/or edx values may be incorrect.										
implication	when this erratum occurs, the processor may report an incorrect brand string. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	global instruction tlb entries may not be invalidated on a vm exit or vm entry										
problem	if a vmm is using global page entries (cr4.pge is enabled and any present page- directories or page-table entries are marked global), then on a vm entry, the instruction tlb (translation lookaside buffer) entries caching global page translations of the vmm may not be invalidated. in addition, if a guest is using global page entries, then on a vm exit, the instruction tlb entries caching global page translations of the guest may not be invalidated.										
implication	stale global instruction linear to physical page translations may be used by a vmm after a vm exit or a guest after a vm entry.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	xrstor instruction may cause extra memory reads										
problem	an xrstor instruction will cause non-speculative accesses to xsave memory area locations containing the fcw/fsw and fop/ftw floating point registers even though the 64-bit restore mask specified in the edx:eax register pair does not indicate to restore the x87 fpu state.										
implication	page faults, data breakpoint triggers, etc. may occur due to the unexpected non- speculative accesses to these memory locations.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling peci via the peci_ctl msr does not enable peci and may corrupt the cpuid feature flags										
problem	writing peci_ctl msr (platform environment control interface control register) will not update the peci_ctl msr (5a0h), instead it may corrupt the cpuid feature flags.										
implication	due to this erratum, peci (platform environment control interface) will not be enabled as expected by the software. in addition, due to this erratum, processor features reported in ecx following execution of leaf 1 of cpuid (eax=1) may be masked. software utilizing cpuid leaf 1 to verify processor capabilities may not work as intended.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	corruption of cs segment register during rsm while transitioning from real mode to protected mode										
problem	during the transition from real mode to protected mode, if an smi (system management interrupt) occurs between the mov to cr0 that sets pe (protection enable, bit 0) and the first far jmp, the subsequent rsm (resume from system management mode) may cause the lower two bits of cs segment register to be corrupted.										
implication	the corruption of the bottom two bits of the cs segment register will have no impact unless software explicitly examines the cs segment register between enabling protected mode and the first far jmp. intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, part 1, in the section titled "switching to protected mode" recommends the far jmp immediately follows the write to cr0 to enable protected mode. intel has not observed this erratum with any commercially available software.										
workaround	none identified										
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified										
											
title	the xrstor instruction may fail to cause a general-protection exception										
problem	the xfeature_enabled_mask register (xcr0) bits [63:9] are reserved and must be 0; consequently, the xrstor instruction should cause a general-protection exception if any of the corresponding bits in the xstate_bv field in the header of the xsave/ xrstor area is set to 1. due to this erratum, a logical processor may fail to cause such an exception if one or more of these reserved bits are set to 1.										
implication	software may not operate correctly if it relies on the xrstor instruction to cause a general-protection exception when any of the bits [63:9] in the xstate_bv field in the header of the xsave/xrstor area is set to 1.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the xsave instruction may erroneously modify reserved bits in the xstate_bv field										
problem	bits 63:2 of the header.xstate_bv are reserved and must be 0. due to this erratum, the xsave instruction may erroneously modify one or more of these bits.										
implication	if one of bits 63:2 of the xstate_bv field in the header of the xsave/xrstor area had been 1 and was then cleared by the xsave instruction, a subsequent execution of xrstor may not generate the #gp (general-protection exception) that would have occurred in the absence of this erratum. alternatively, if one of those bits had been 0 and was then set by the xsave instruction, a subsequent execution of xrstor may generate a #gp that would not have occurred in the absence of this erratum.										
workaround	it is possible for the bios to contain a partial workaround for this erratum that prevents xsave from setting header.xstate_bv reserved bits. to ensure compatibility with future processors, software should not set any xstate_bv reserved bits when configuring the header of the xsave/xrstor save area.										
											
title	store ordering violation when using xsave										
problem	the store operations done as part of the xsave instruction may cause a store ordering violation with older store operations. the store operations done to save the processor context in the xsave instruction flow, when xsave is used to store only the sse context, may appear to execute before the completion of older store operations.										
implication	execution of the stores in xsave, when xsave is used to store sse context only, may not follow program order and may execute before older stores. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	memory ordering violation with stores/loads crossing a cacheline boundary										
problem	when two logical processors are accessing the same data that is crossing a cacheline boundary without serialization, with a specific set of processor internal conditions, it is possible to have an ordering violation between memory store and load operations.										
implication	due to this erratum, proper load store ordering may not be followed when multiple logical processors are accessing the same data that crosses a cacheline boundary without serialization.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	b0-b3 bits in dr6 for non-enabled breakpoints may be incorrectly set										
problem	some of the b0-b3 bits (breakpoint conditions detect flags, bits [3:0]) in dr6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: mov or pop instruction to ss (stack segment) selector; next instruction is fp (floating point) that gets fp assist another instruction after the fp instruction completes successfully a breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in b0-b3 after the breakpoint occurs in step 4.										
implication	due to this erratum, b0-b3 bits in dr6 may be incorrectly set for non-enabled breakpoints.										
workaround	software should not execute a floating point instruction directly after a mov ss or pop ss instruction.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor, or system bus master, writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction, prior to execution of the new code, is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case, the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the intel® architecture software developer's manual volume 3: system programming guide, including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	in order to avoid this erratum, programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3: system programming guide, section: handling self- and cross-modifying code.										
											
title	a page fault may not be generated when the ps bit is set to “1” in a pml4e or pdpte										
problem	on processors supporting intel® 64 architecture, the ps bit (page size, bit 7) is reserved in pml4es and pdptes. if the translation of the linear address of a memory access encounters a pml4e or a pdpte with ps set to 1, a page fault should occur. due to this erratum, ps of such an entry is ignored and no page fault will occur due to its being set.										
implication	software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.										
workaround	software should not set bit 7 in any pml4e or pdpte that has present bit (bit 0) set to “1”.										
											
title	vm exits due to “nmi-window exiting” may be delayed by one instruction										
problem	if vm entry is executed with the “nmi-window exiting” vm-execution control set to 1, a vm exit with exit reason “nmi window” should occur before execution of any instruction if there is no virtual-nmi blocking, no blocking of events by mov ss, and no blocking of events by sti. if vm entry is made with no virtual-nmi blocking but with blocking of events by either mov ss or sti, such a vm exit should occur after execution of one instruction in vmx non-root operation. due to this erratum, the vm exit may be delayed by one additional instruction.										
implication	vmm software using “nmi-window exiting” for nmi virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual nmi, which is virtually asynchronous. the erratum may affect vmms relying on deterministic delivery of the affected vm exits.										
workaround	none identified.										
											
title	a 64-bit register ip-relative instruction may return unexpected results										
problem	under an unlikely and complex sequence of conditions in 64-bit mode, a register ip- relative instruction result may be incorrect.										
implication	a register ip-relative instruction result may be incorrect and could cause software to read from or write to an incorrect memory location. this may result in an unexpected page fault or unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	local apic timer may stop counting during transitions into c1e or enhanced intel speedstep® technology event										
problem	a transition into c1e or enhanced intel speedstep technology event may cause the local apic timer to stop counting and not generate an apic timer interrupt.										
implication	due to this erratum, the system may report incorrect apic timer data and may result in the apic timer interrupt not being generated and subsequent system hang. intel has observed this erratum on a small number of l54xx components.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	the processor may report a #ts instead of a #gp fault										
problem	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss exception) instead of a #gp fault (general protection exception).										
implication	operation systems that access a busy tss may get invalid tss fault instead of a #gp fault. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	rep movs/stos executing with fast strings enabled and crossing page boundaries with inconsistent memory types may use an incorrect data size or lead to memory-ordering violations										
problem	under certain conditions as described in the software developers manual section "out- of-order stores for string operations in pentium 4, intel xeon, and p6 family processors" the processor performs rep movs or rep stos as fast strings. due to this erratum fast string rep movs/rep stos instructions that cross page boundaries from wb/wc memory types to uc/wp/wt memory types, may start using an incorrect data size or may observe memory ordering violations.										
implication	upon crossing the page boundary the following may occur, dependent on the new page memory type: uc the data size of each write will now always be 8 bytes, as opposed to the original data size. wp the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. wt there may be a memory ordering violation.										
workaround	software should avoid crossing page boundaries from wb or wc memory type to uc, wp or wt memory type within a single rep movs or rep stos instruction that will execute with fast strings enabled.										
											
title	code segment limit/canonical faults on rsm may be serviced before higher priority interrupts/exceptions and may push the wrong address onto the stack										
problem	normally, when the processor encounters a segment limit or canonical fault due to code execution, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. due to this erratum, if rsm (resume from system management mode) returns to execution flow that results in a code segment limit or canonical fault, the #gp fault may be serviced before a higher priority interrupt or exception (for example, nmi (non-maskable interrupt), debug break(#db), machine check (#mc), and so forth). if the rsm attempts to return to a non-canonical address, the address pushed onto the stack for this #gp fault may not match the non-canonical address that caused the fault.										
implication	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	performance monitor sse retired instructions may return incorrect values										
problem	performance monitoring counter simd_inst_retired (event: c7h) is used to track retired sse instructions. due to this erratum, the processor may also count other types of instructions resulting in higher than expected values.										
implication	performance monitoring counter simd_inst_retired may report count higher than expected.										
workaround	none identified.										
											
title	premature execution of a load operation prior to exception handler invocation										
problem	if any of the below circumstances occur, it is possible that the load portion of the instruction will have executed before the exception handler is entered. if an instruction that performs a memory load causes a code segment limit violation. if a waiting x87 floating-point (fp) instruction or mmx™ technology (mmx) instruction that performs a memory load has a floating-point exception pending. if an mmx or sse/sse2/sse3/ssse3 extensions (sse) instruction that performs a memory load and has either cr0.em=1 (emulation bit set), or a floating-point top- of-stack (fp tos) not equal to 0, or a dna exception pending.										
implication	in normal code execution where the target of the load operation is to write back memory there is no impact from the load being prematurely executed, or from the restart and subsequent re-execution of that instruction by the exception handler. if the target of the load is to uncached memory that has a system side-effect, restarting the instruction may cause unexpected system behavior due to the repetition of the side- effect. particularly, while cr0.ts [bit 3] is set, a movd/movq with mmx/xmm register operands may issue a memory load before getting the dna exception.										
workaround	code which performs loads from memory that has side-effects can effectively workaround this behavior by using simple integer-based load instructions when accessing side-effect memory and by ensuring that all code is written such that a code segment limit violation cannot occur as a part of reading from side-effect memory.										
											
title	mov to/from debug registers causes debug exception										
problem	when in v86 mode, if a mov instruction is executed to/from a debug registers, a general-protection exception (#gp) should be generated. however, in the case when the general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.										
implication	with debug-register protection enabled (i.e., the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception will be generated instead of the expected general-protection fault.										
workaround	in general, operating systems do not set the gd bit when they are in v86 mode. the gd bit is generally set and used by debuggers. the debug exception handler should check that the exception did not occur in v86 mode before continuing. if the exception did occur in v86 mode, the exception may be directed to the general-protection exception handler.										
											
title	incorrect address computed for last byte of fxsave/fxrstor image leads to partial memory update										
problem	a partial memory state save of the 512-byte fxsave image or a partial memory state restore of the fxrstor image may occur if a memory address exceeds the 64 kb limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4 gb limit while the processor is operating in 32-bit mode.										
implication	fxsave/fxrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.										
workaround	software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits.										
											
title	values for lbr/bts/btm will be incorrect after an exit from smm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect. note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.										
workaround	none identified										
											
title	single step interrupts with floating point exception pending may be mishandled										
problem	in certain circumstances, when a floating point exception (#mf) is pending during single-step execution, processing of the single-step debug exception (#db) may be mishandled.										
implication	when this erratum occurs, #db will be incorrectly handled as follows: #db is signaled before the pending higher priority #mf (interrupt 16) #db is generated twice on the same instruction										
workaround	none identified.										
											
title	fault on enter instruction may result in unexpected values on stack frame										
problem	the enter instruction is used to create a procedure stack frame. due to this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (that is, residual stack data as a result of processing the fault).										
implication	data in the created stack frame may be altered following a fault on the enter instruction. please refer to "procedure calls for block-structured languages" in intel® 64 and ia-32 architectures software developer's manual, volume 1: basic architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3. faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	general protection fault (#gp) for instructions greater than 15 bytes may be preempted										
problem	when the processor encounters an instruction that is greater than 15 bytes in length, a #gp is signaled when the instruction is decoded. under some circumstances, the #gp fault may be preempted by another lower priority fault (for example, page fault (#pf)). however, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #gp fault will occur.										
implication	software may observe a lower-priority fault occurring before or in lieu of a #gp fault. instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.										
workaround	none identified.										
											
title	general protection (#gp) fault may not be signaled on data segment limit violation above 4-g limit										
problem	in 32-bit mode, memory accesses to flat data segments (base = 00000000h) that occur above the 4g limit (0ffffffffh) may not signal a #gp fault.										
implication	when such memory accesses occur in 32-bit mode, the system may not issue a #gp fault.										
workaround	software should ensure that memory accesses in 32-bit mode do not occur above the 4g limit (0ffffffffh).										
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1's. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	debug exception flags dr6.b0-b3 flags may be incorrect for disabled breakpoints										
problem	when a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (dr7.g0-g3 and dr7.l0-l3), the dr6.b0-b3 flags may be incorrect.										
implication	the debug exception dr6.b0-b3 flags may be incorrect for the load if the corresponding breakpoint enable flag in dr7 is disabled.										
workaround	none identified.										
											
title	corruption of cs segment register during rsm while transitioning from real mode to protected mode										
problem	during the transition from real mode to protected mode, if an smi (system management interrupt) occurs between the mov to cr0 that sets pe (protection enable, bit 0) and the first far jmp, the subsequent rsm (resume from system management mode) may cause the lower two bits of cs segment register to be corrupted.										
implication	the corruption of the bottom two bits of the cs segment register will have no impact unless software explicitly examines the cs segment register between enabling protected mode and the first far jmp. intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, part 1, in the section titled "switching to protected mode" recommends the far jmp immediately follows the write to cr0 to enable protected mode. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	a vm exit on mwait may incorrectly report the monitoring hardware as armed										
problem	a processor write to the address range armed by the monitor instruction may not immediately trigger the monitoring hardware. consequently, a vm exit on a later mwait may incorrectly report the monitoring hardware as armed, when it should be reported as unarmed due to the write occurring prior to the mwait.										
implication	if a write to the range armed by the monitor instruction occurs between the monitor and the mwait, the mwait instruction may start executing before the monitoring hardware is triggered. if the mwait instruction causes a vm exit, this could cause its exit qualification to incorrectly report 0x1. in the recommended usage model for monitor/mwait, there is no write to the range armed by the monitor instruction between the monitor and the mwait.										
workaround	software should never write to the address range armed by the monitor instruction between the monitor and the subsequent mwait.										
											
title	performance monitor event segment_reg_loads counts inaccurately										
problem	the performance monitor event segment_reg_loads (event 06h) counts instructions that load new values into segment registers. the value of the count may be inaccurate.										
implication	the performance monitor event segment_reg_loads may reflect a count higher or lower than the actual number of events.										
workaround	none identified.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	improper parity error signaled in the iq following reset when a code breakpoint is set on a #gp instruction										
problem	while coming out of cold reset or exiting from c6, if the processor encounters an instruction longer than 15 bytes (which causes a #gp) and a code breakpoint is enabled on that instruction, an iq (instruction queue) parity error may be incorrectly logged resulting in an mce (machine check exception).										
implication	when this erratum occurs, an mce may be incorrectly signaled.										
workaround	none identified.										
											
title	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception										
problem	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.										
implication	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software or system.										
workaround	as recommended in the intel® 64 and ia-32 intel® architectures software developer’s manual, the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.										
											
title	ia32_mperf counter stops counting during on-demand tm1										
problem	according to the intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, the ratio of ia32_mperf (msr e7h) to ia32_aperf (msr e8h) should reflect actual performance while tm1 or on-demand throttling is activated. due to this erratum, ia32_mperf msr stops counting while tm1 or on-demand throttling is activated, and the ratio of the two will indicate higher processor performance than actual.										
implication	the incorrect ratio of ia32_aperf/ia32_mperf can mislead software p-state (performance state) management algorithms under the conditions described above. it is possible for the operating system to observe higher processor utilization than actual, which could lead the os into raising the p-state. during tm1 activation, the os p-state request is irrelevant and while on-demand throttling is enabled, it is expected that the os will not be changing the p-state. this erratum should result in no practical implication to software.										
workaround	none identified.										
											
title	intel® quickpath memory controller may hang due to uncorrectable ecc errors occurring on both channels in mirror channel mode										
problem	if an uncorrectable ecc error or parity error occurs on the mirrored channel before an uncorrectable ecc error or parity error on the other channel can be resolved, the intel quickpath memory controller will hang without an uncorrectable ecc or parity error being logged.										
implication	the processor may hang and not report the error when uncorrectable ecc or parity errors occur in close proximity on both channels in a mirrored channel pair. no uncorrectable ecc or parity error will be logged in the machine check banks.										
workaround	none identified.										
											
title	simultaneous correctable ecc errors on different memory channels with patrol scrubbing enabled may result in incorrect information being logged										
problem	when a correctable patrol scrub ecc error occurs simultaneously with a correctable system read ecc error on different memory channels, ia32_mci_status and ia32_mci_misc should log the system read error. due to this erratum ia32_mci_misc may incorrectly contain the patrol scrub error information and the ia32_mci_addr may not be correct.										
implication	ia32_mci_misc and ia32_mci_status information may be inconsistent. ia32_mci_addr may be incorrect.										
workaround	none identified.										
											
title	the memory controller tthrot_opref timings may be violated during self refresh entry										
problem	during self refresh entry, the memory controller may issue more refreshes than permitted by tthrot_opref (bits 29:19 in mc_channel_{0,1,2}_refresh_timing csr).										
implication	the intention of tthrot_opref is to limit current. since current supply conditions near self refresh entry are not critical, there is no measurable impact due to this erratum.										
workaround	none identified.										
											
title	synchronous reset of ia32_aperf/ia32_mperf counters on overflow does not work										
problem	when either the ia32_mperf or ia32_aperf msr (e7h, e8h) increments to its maximum value of 0xffff_ffff_ffff_ffff, both msrs are supposed to synchronously reset to 0x0 on the next clock. this synchronous reset does not work. instead, both msrs increment and overflow independently.										
implication	software can not rely on synchronous reset of the ia32_aperf/ia32_mperf registers.										
workaround	none identified.										
											
title	writing the local vector table (lvt) when an interrupt is pending may cause an unexpected interrupt										
problem	if a local interrupt is pending when the lvt entry is written, an interrupt may be taken on the new interrupt vector even if the mask bit is set.										
implication	an interrupt may immediately be generated with the new vector when a lvt entry is written, even if the new lvt entry has the mask bit set. if there is no interrupt service routine (isr) set up for that vector the system will gp fault. if the isr does not do an end of interrupt (eoi) the bit for the vector will be left set in the in-service register and mask all interrupts at the same or lower priority.										
workaround	any vector programmed into an lvt entry must have an isr associated with it, even if that vector was programmed as masked. this isr routine must do an eoi to clear any unexpected interrupts that may occur. the isr associated with the spurious vector does not generate an eoi, therefore the spurious vector should not be used when writing the lvt.										
											
title	faulting mmx instruction may incorrectly update x87 fpu tag word										
problem	under a specific set of conditions, mmx stores (movd, movq, movntq, maskmovq) which cause memory access faults (#gp, #ss, #pf, or #ac), may incorrectly update the x87 fpu tag word register. this erratum will occur when the following additional conditions are also met. the mmx store instruction must be the first mmx instruction to operate on x87 fpu state (that is, the x87 fp tag word is not already set to 0x0000). for movd, movq, movntq stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to maskmovq).										
implication	if the erratum conditions are met, the x87 fpu tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.										
workaround	none identified.										
											
title	xapic timer may decrement too quickly following an automatic reload while in periodic mode										
problem	when the xapic timer is automatically reloaded by counting down to zero in periodic mode, the xapic timer may slip in its synchronization with the external clock. the xapic timer may be shortened by up to one xapic timer tick.										
implication	when the xapic timer is automatically reloaded by counting down to zero in periodic mode, the xapic timer may slip in its synchronization with the external clock. the xapic timer may be shortened by up to one xapic timer tick.										
workaround	none identified.										
											
title											
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	b0-b3 bits in dr6 for non-enabled breakpoints may be incorrectly set										
problem	some of the b0-b3 bits (breakpoint conditions detect flags, bits [3:0]) in dr6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: mov or pop instruction to ss (stack segment) selector; next instruction is fp (floating point) that gets fp assist another instruction after the fp instruction completes successfully a breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in b0-b3 after the breakpoint occurs in step 4.										
implication	due to this erratum, b0-b3 bits in dr6 may be incorrectly set for non-enabled breakpoints.										
workaround	software should not execute a floating point instruction directly after a mov ss or pop ss instruction.										
											
title	core c6 may clear previously logged tlb errors										
problem	following an exit from core c6, previously logged tlb (translation lookaside buffer) errors in ia32_mci_status may be cleared.										
implication	due to this erratum, tlb errors logged in the associated machine check bank prior to core c6 entry may be cleared. provided machine check exceptions are enabled, the machine check exception handler can log any uncorrectable tlb errors prior to core c6 entry. the tlb marks all detected errors as uncorrectable.										
workaround	as long as machine check exceptions are enabled, the machine check exception handler can log the tlb error prior to core c6 entry. this will ensure the error is logged before it is cleared.										
											
title	changing the memory type for an in-use page translation may lead to memory-ordering violations										
problem	under complex micro-architectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.										
implication	memory ordering may be violated. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure pages are not being actively used before requesting their memory type be changed.										
											
title	a string instruction that re-maps a page may encounter an unexpected page fault an unexpected page fault (#pf) may occur for a page under the following conditions: the paging structures initially specify a valid translation for the page. software modifies the paging structures so that there is no valid translation for the page (for example, by clearing to 0 the present bit in one of the paging-structure entries used to translate the page). an iteration of a string instruction modifies the paging structures so that the translation is again a valid translation for the page (e.g., by setting to 1 the bit that was cleared earlier). a later iteration of the same string instruction loads from a linear address on the page.										
problem	software did not invalidate tlb entries for the page between the first modification of the paging structures and the string instruction. in this case, the load in the later iteration may cause a page fault that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page).										
implication	software may see an unexpected page fault that indicates that there is no translation for the page. intel has not observed this erratum with any commercially available software or system.										
workaround	software should not update the paging structures with a string instruction that accesses pages mapped the modified paging structures.										
											
title	infinite stream of interrupts may occur if an extint delivery mode interrupt is received while all cores in c6										
problem	if all logical processors in a core are in c6, an extint delivery mode interrupt is pending in the xapic and interrupts are blocked with eflags.if=0, the interrupt will be processed after c6 wakeup and after interrupts are re-enabled (eflags.if=1). however, the pending interrupt event will not be cleared.										
implication	due to this erratum, an infinite stream of interrupts will occur on the core servicing the external interrupt. intel has not observed this erratum with any commercially available software/system.										
workaround	none identified.										
											
title	two xapic timer event interrupts may unexpectedly occur										
problem	if an xapic timer event is enabled and while counting down the current count reaches 1 at the same time that the processor thread begins a transition to a low power c- state, the xapic may generate two interrupts instead of the expected one when the processor returns to c0.										
implication	due to this erratum, two interrupts may unexpectedly be generated by an xapic timer event.										
workaround	none identified.										
											
title	eoi transaction may not be sent if software enters core c6 during an interrupt service routine										
problem	if core c6 is entered after the start of an interrupt service routine but before a write to the apic eoi (end of interrupt) register, and the core is woken up by an event other than a fixed interrupt source the core may drop the eoi transaction the next time apic eoi register is written and further interrupts from the same or lower priority level will be blocked.										
implication	eoi transactions and interrupts may be blocked when core c6 is used during interrupt service routines. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	freeze_while_smm does not prevent event from pending pebs during smm										
problem	in general, a pebs record should be generated on the first count of the event after the counter has overflowed. however, ia32_debugctl_msr.freeze_while_smm (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if a performance counter overflowed before an smi a pebs record has not yet been generated because another count of the event has not occurred the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.										
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.										
workaround	none identified.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	dr6 may contain incorrect information when the first instruction after a mov ss,r/m or pop ss is a store										
problem	normally, each instruction clears the changes in dr6 (debug status register) caused by the previous instruction. however, the instruction following a mov ss,r/m (mov to the stack segment selector) or pop ss (pop stack segment selector) instruction will not clear the changes in dr6 because data breakpoints are not taken immediately after a mov ss,r/m or pop ss instruction. due to this erratum, any dr6 changes caused by a mov ss,r/m or pop ss instruction may be cleared if the following instruction is a store.										
implication	when this erratum occurs, incorrect information may exist in dr6. this erratum will not be observed under normal usage of the mov ss,r/m or pop ss instructions (that is, following them with an instruction that writes [e/r]sp). when debugging or when developing debuggers, this behavior should be noted.										
workaround	none identified.										
											
title	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang										
problem	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).										
implication	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.										
workaround	none identified.										
											
title	ia32_perf_global_ctrl msr may be incorrectly initialized										
problem	the ia32_perf_global_ctrl msr (38fh) bits [34:32] may be incorrectly set to 7h after reset; the correct value should be 0h.										
implication	the ia32_perf_global_ctrl msr bits [34:32] may be incorrect after reset (en_fixed_ctr{0, 1, 2} may be enabled).										
workaround	none identified.										
											
title	ecc errors can not be injected on back-to-back writes										
problem	ecc errors should be injected on every write that matches the address set in the mc_channel_{0,1,2}_addr_match csrs. due to this erratum if there are two back- to-back writes that match mc_channel_{0,1,2}_addr_match, the 2nd write will not have the error injected.										
implication	the 2nd back-to-back write that matches mc_channel_{0,1,2}_addr_match will not have the ecc error properly injected. setting mc_channel_{0,1,2}_addr_match to a specific address will reduce the chance of being impacted by this erratum.										
workaround	only injecting errors to specific address should reduce the chance on being impacted by this erratum.										
											
title	performance monitor counter mem_inst_retired.stores may count higher than expected										
problem	performance monitoring counter mem_inst_retired.stores (event: 0bh, umask: 02h) is used to track retired instructions which contain a store operation. due to this erratum, the processor may also count other types of instructions including wrmsr and mfence.										
implication	performance monitoring counter mem_inst_retired.stores may report counts higher than expected.										
workaround	none identified.										
											
title	sleeping cores may not be woken up on logical cluster mode broadcast ipi using destination field instead of shorthand										
problem	if software sends a logical cluster broadcast ipi using a destination shorthand of 00b (no shorthand) and writes the cluster portion of the destination field of the interrupt command register to all ones while not using all 1s in the mask portion of the destination field, target cores in a sleep state that are identified by the mask portion of the destination field may not be woken up. this erratum does not occur if the destination shorthand is set to 10b (all including self) or 11b (all excluding self).										
implication	when this erratum occurs, cores which are in a sleep state may not wake up to handle the broadcast ipi. intel has not observed this erratum with any commercially available software.										
workaround	use destination shorthand of 10b or 11b to send broadcast ipis.										
											
title	faulting executions of fxrstor may update state inconsistently										
problem	the state updated by a faulting fxrstor instruction may vary from one execution to another.										
implication	software that relies on x87 state or sse state following a faulting execution of fxrstor may behave inconsistently.										
workaround	software handling a fault on an execution of fxrstor can compensate for execution variability by correcting the cause of the fault and executing fxrstor again.										
											
title	failing dimm id may be incorrect in the 2dpc configuration when mirroring is enabled										
problem	when redundancy is lost in the 2dpc (2 dimms per channel) configuration, mc_smi_spare_dimm_error_status csr bits [13:12] (redundancy_loss_failing_dimm) may indicate the incorrect failing dimm id. the 2dpc configuration is indicated when mc_channel_{0,1}_dimm_init_params csr bit [24] (three_dimms_present) is 0.										
implication	the failing dimm id may be reported incorrectly in the 2dpc configuration when mirroring is enabled. the 3dpc configuration is not affected.										
workaround	only use the value in bit [13] to determine the failing dimm id in the non-3pdc configurations when mirroring is enabled. this workaround will show correct results for both the 1dpc and 2dpc configurations.										
											
title	issueonce bit in mc_scrub_control register does not work correctly										
problem	when issueonce (bit [25]) in the mc_scrub_control register (device 3, function 2, offset 4ch) is set, the memory controller should issue one patrol scrub. due to this erratum, scrubbing requests continue to be issued.										
implication	issueonce bit in mc_scrub_control register does not work correctly. workaround none identified.										
workaround											
											
title	memory aliasing of code pages may cause unpredictable system behavior										
problem	the type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. specifically, if one code page is mapped by one logical processor as write-back and by another as uncacheable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.										
implication	the type of memory aliasing contributing to this erratum is the case where two different logical processors have the same code page mapped with two different memory types. specifically, if one code page is mapped by one logical processor as write-back and by another as uncacheable and certain instruction fetch timing conditions occur, the system may experience unpredictable behavior.										
workaround	code pages should not be mapped with uncacheable and cacheable memory types at the same time.										
											
title	performance monitor counters may count incorrectly										
problem	under certain circumstances, a general purpose performance counter, ia32_pmc0-4 (c1h – c4h), may count at core frequency or not count at all instead of counting the programmed event.										
implication	the performance monitor counter ia32_pmcx may not properly count the programmed event. due to the requirements of the workaround there may be an interruption in the counting of a previously programmed event during the programming of a new event.										
workaround	before programming the performance event select registers, ia32_perfevtselx msr (186h – 189h), the internal monitoring hardware must be cleared. this is accomplished by first disabling, saving valid events and clearing from the select registers, then programming three event values 0x4300d2, 0x4300b1 and 0x4300b5 into the ia32_perfevtselx msrs, and finally continuing with new event programming and restoring previous programming if necessary. each performance counter, ia32_pmcx, must have its corresponding ia32_prefevtselx msr programmed with at least one of the event values and must be enabled in ia32_perf_global_ctrl msr (38fh) bits [3:0]. all three values must be written to either the same or different ia32_perfevtselx msrs before programming the performance counters. note that the performance counter will not increment when its ia32_perfevtselx msr has a value of 0x4300d2, 0x4300b1 or 0x4300b5 because those values have a zero umask field (bits [15:8]).										
											
title	memory thermal throttling may not work as expected in lockstep channel mode										
problem	thermal throttling on a channel that is in lockstep mode affects all channels in order to maintain lockstep requirements. if throttling parameters are modified at different times during runtime, throttling on one channel is likely to be out of phase with throttling on other channels. throttling which is out of phase will result in more throttling than anticipated. if the throttling duty cycle exceeds 50%, certain phase relationships can result in persistent memory traffic blockage.										
implication	runtime modification of throttling parameters may result in a system hang. workaround since thermal throttling on one channel affects all channels while in lockstep mode,										
workaround											
											
title	simultaneous accesses to the processor via jtag and peci may cause unexpected behavior										
problem	jtag commands that are executed at the same time as a peci (platform environment control interface) access may cause unexpected behavior. in addition the peci command may take longer to complete or may not complete.										
implication	the processor could be left in an unexpected state and any software or firmware doing peci writes may time out.										
workaround	ensure that peci commands are not executed while using jtag.										
											
title	performance monitor event offcore_response_0 (b7h) does not count nt stores to local dram correctly										
problem	when a ia32_perfevtselx msr is programmed to count the offcore_response_0 event (event:b7h), selections in the offcore_rsp_0 msr (1a6h) determine what is counted. the following two selections do not provide accurate counts when counting nt (non-temporal) stores: offcore_rsp_0 msr bit [14] is set to 1 (local_dram) and bit [7] is set to 1 (other): nt stores to local dram are not counted when they should have been. offcore_rsp_0 msr bit [9] is set to (other_core_hit_snoop) and bit [7] is set to 1 (other): nt stores to local dram are counted when they should not have been.										
implication	the counter for the offcore_response_0 event may be incorrect for nt stores. workaround none identified.										
workaround											
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	system may hang if mc_channel_{0,1,2}_mc_dimm_init_cmd.do_zqcl commands are not issued in increasing populated ddr3 rank order										
problem	zqcl commands are used during initialization to calibrate ddr3 termination. a zqcl command can be issued by writing 1 to the mc_channel_{0,1,2}_mc_dimm_init_cmd.do_zqcl (device 4,5,6, function 0, offset 15, bit[15]) field and it targets the ddr3 rank specified in the rank field (bits[7:5]) of the same register. if the zqcl commands are not issued in increasing populated rank order then zq calibration may not complete, causing the system to hang.										
implication	due to this erratum the system may hang if writes to the mc_channel_{0,1,2}_mc_dimm_init_cmd.do_zqcl field are not in increasing populated ddr3 rank order.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	package c3/c6 transitions when memory 2x refresh is enabled may result in a system hang										
problem	if asr_present (mc_channel_{0,1,2}_refresh_throttle_sup port csr function 0, offset 68h, bit [0], auto self refresh present) is clear which indicates that high temperature operation is not supported on the dram, the memory controller will not enter self-refresh if software has ref_2x_now (bit 4 of the mc_closed_loop csr, function 3, offset 84h) set. this scenario may cause the system to hang during c3/c6 entry.										
implication	failure to enter self-refresh can delay c3/c6 power state transitions to the point that a system hang may result with caterr being asserted. ref_2x_now is used to double the refresh rate when the dram is operating in extended temperature range. the asr_present was intended to allow low power self refresh with dram that does not support automatic self refresh.										
workaround	it is possible for intel provided bios reference code to contain a workaround for this erratum. please refer to the latest version of the bios memory reference code and release notes.										
											
title											
problem	when back-to-back uncorrected machine check errors occur that would both be logged in the ia32_mc3_status msr (40ch), the ia32_mc3_status.mscod (bits [31:16]) field may reflect the status of the most recent error and not the first error. the rest of the ia32_mc3_status msr contains the information from the first error.										
implication	software should not rely on the value of ia32_mc3_status.mscod if ia32_mc3_status.over (bit [62]) is set.										
workaround	none identified.										
											
title	corrected errors with a yellow error indication may be overwritten by other corrected errors										
problem	a corrected cache hierarchy data or tag error that is reported with ia32_mci_status.mcacod (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one) and a yellow threshold-based error status indication (bits [54:53] equal to 10b) may be overwritten by a corrected error with a no tracking indication (00b) or green indication (01b).										
implication	corrected errors with a yellow threshold-based error status indication may be overwritten by a corrected error without a yellow indication.										
workaround	none identified.										
											
title	performance monitor events dcache_cache_ld and dcache_cache_st may overcount										
problem	the performance monitor events dcache_cache_ld (event 40h) and dcache_cache_st (event 41h) count cacheable loads and stores that hit the l1 cache. due to this erratum, in addition to counting the completed loads and stores, the counter will incorrectly count speculative loads and stores that were aborted prior to completion.										
implication	the performance monitor events dcache_cache_ld and dcache_cache_st may reflect a count higher than the actual number of events.										
workaround	none identified.										
											
title	performance monitor events instr_retired and mem_inst_retired may count inaccurately										
problem	the performance monitor event instr_retired (event c0h) should count the number of instructions retired, and mem_inst_ retired (event 0bh) should count the number of load or store instructions retired. however, due to this erratum, they may undercount.										
implication	the performance monitor event instr_retired and mem_inst_retired may reflect a count lower than the actual number of events.										
workaround	none identified.										
											
title	a page fault may not be generated when the ps bit is set to "1" in a pml4e or pdpte										
problem	on processors supporting intel® 64 architecture, the ps bit (page size, bit 7) is reserved in pml4es and pdptes. if the translation of the linear address of a memory access encounters a pml4e or a pdpte with ps set to 1, a page fault should occur. due to this erratum, ps of such an entry is ignored and no page fault will occur due to its being set.										
implication	software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.										
workaround	software should not set bit 7 in any pml4e or pdpte that has present bit (bit 0) set to "1".										
											
title	uncacheable access to a monitored address range may prevent future triggering of the monitor hardware										
problem	it is possible that an address range which is being monitored via the monitor instruction could be written without triggering the monitor hardware. a read from the monitored address range which is issued as uncacheable (for example having the cr0.cd bit set) may prevent subsequent writes from triggering the monitor hardware. a write to the monitored address range which is issued as uncacheable, may not trigger the monitor hardware and may prevent subsequent writes from triggering the monitor hardware.										
implication	the mwait instruction will not exit the optimized power state and resume program flow if the monitor hardware is not triggered.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® interconnect bist (intel® ibist) results may be additionally reported after a getsec[wakeup] or init-sipi sequence										
problem	bist results should only be reported in eax the first time a logical processor wakes up from the wait-for-sipi state. due to this erratum, intel® interconnect bist (intel® ibist) intel results may be additionally reported after init-sipi sequences and when waking up rlp’s from the senter sleep state using the getsec[wakeiup] command.										
implication	an init-sipi sequence may show a non-zero value in eax upon wakeup when a zero value is expected. rlp’s waking up for the senter sleep state using the getsec[wakeup] command may show a different value in eax upon wakeup than before going into the senter sleep state.										
workaround	if necessary software may save the value in eax prior to launching into the secure environment and restore upon wakeup and/or clear eax after the init-sipi sequence.										
											
title	pending x87 fpu exceptions (#mf) may be signaled earlier than expected										
problem	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executed while enhanced intel speedstep® technology transitions, intel® turbo boost technology transitions, or thermal monitor events occur, the pending #mf may be signaled before pending interrupts are serviced.										
implication	software may be observed #mf being-signaled before pending interrupts are serviced. workaround none identified.										
workaround											
											
title	vm exits due to “nmi-window exiting” may be delayed by one instruction										
problem	if vm entry is executed with the “nmi-window exiting” vm-execution control set to 1, a vm exit with exit reason “nmi window” should occur before execution of any instruction if there is no virtual-nmi blocking, no blocking of events by mov ss, and not blocking of events by str. if vm entry is made with no virtual-nmi blocking but with blocking of events by either mov ss or sti, such a vm exit should occur after execution of one instruction in vmx non-root operation. due to this erratum, the vm exit may be delayed by one additional instruction.										
implication	vmm software using “nmi-window exiting” for nmi virutalization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual nmi, which is virtually asynchronous. the erratum may affect vmms relying on deterministic delivery of the affected vm exits.										
workaround	none identified.										
											
title	multiple performance monitor interrupts are possible on overflow of ia32_fixed_ctr2										
problem	when multiple performance counters are set to generate interrupts on an overflow and more than one counter overflows at the same time, only one interrupt should be generated. however, if one of the counters set to generate an interrupt on overflow is the ia32_fixed_ctr2 (msr 30bh) counter, multiple interrupts may be generated when the ia32_fixed_ctr2 overflows at the same time as any of the other performance counters.										
implication	multiple counter overflow interrupts may be unexpectedly generated. workaround none identified.										
workaround											
											
title	c-state autodemotion may be too aggressive under certain configurations and workloads										
problem	the c-state autodemotion feature allows the processor to make intelligent power and performance tradeoffs regarding the os-requested c-state. under certain operating system and workload specific conditions, the c-state auto-demotion feature may be overly aggressive in demoting os c-sate requests to a c-sate with higher power and lower exit latency.										
implication	this aggressive demotion can result in higher platform power under idle conditions.										
workaround	none identified										
											
title	lbrs may not be initialized during power-on reset of the processor										
problem	if a second reset is initiated during the power-on processor reset cycle, the lbrs (last branch records) may not be properly initialized.										
implication	due to this erratum, debug software may not be able to rely on the lbrs out of power- on reset.										
workaround	ensure that the processor has completed its power-on reset cycle prior to initiating a second reset.										
											
title	multiple performance monitor interrupts are possible on overflow of fixed counter 0										
problem	the processor can be configured to issue a pmi (performance monitor interrupt) upon overflow of the ia32_fixed_ctr0 msr (309h). a single pmi should be observed on overflow of ia32_fixed_ctr0, however multiple pmis are observed when this erratum occurs. this erratum only occurs when ia32_fixed_ctr0 overflows and the processor and counter are configured as follows: intel hyper-threading technology is enabled ia32_fixed_ctr0 local and global controls are enabled ia32_fixed_ctr0 is set to count events only on its own thread (ia32_fixed_ctr_ctrl msr (38dh) bits[2] = ‘0) pmis are enabled on ia32_fixed_ctr0 (ia32_fixed_ctr_ctrl msr bit[3] = ‘1) freeze_on_pmi feature is enabled (ia32_debugctl msr (1d9h) bit[12] = ‘1)										
implication	when this erratum occurs there may be multiple pmis observed when ia32_fixed_ctr0 overflows.										
workaround	disable the freeze_perfmon_on_pmi feature in ia32_debugctl msr (1d9h) bit[12].										
											
title	vm exits due to lidr/lgdt/sidt/sgdt do not report correct operand size										
problem	when a vm exit occurs due to a lidt, lgdt, sidt, or sgdt instruction with a 32-bit operand, bit 11 of the vm-exit instruction information field should be set to 1. due to this erratum, this bit is instead cleared to 0 (indicating a 16-bit operand).										
implication	virtual-machine monitors cannot rely on bit 11 of the vm-exit instruction information field to determine the operand size of the instruction causing the vm exit.										
workaround	virtual-machine monitor software may decode the instruction to determine operand size.										
											
title	performance monitoring events store_blocks.not_sta and store_blocks.sta may not count events correctly										
problem	performance monitor events store_blocks.not_sta and store_blocks.sta should only increment the count when a load is blocked by a store. due to this erratum, the count will be incremented whenever a load hits a store, whether it is blocked or can forward. in addition this event does not count for specific threads correctly.										
implication	if intel hyper-threading technology is disabled, the performance monitor events store_blocks.not_sta and store_blocks.sta may indicate a higher occurrence of loads blocked by stores than have actually occurred. if intel hyper-threading technology is enabled, the counts of loads blocked by stores may be unpredictable and they could be higher or lower than the correct count.										
workaround	none identified.										
											
title	storage of pebs record delayed following execution of mov ss or sti										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflow of the counter results in storage of a pebs record in the pebs buffer. the information in the pebs record represents the state of the next instruction to be executed following the counter overflow. due to this erratum, if the counter overflow occurs after execution of either mov ss or sti, storage of the pebs record is delayed by one instruction.										
implication	when this erratum occurs, software may observe storage of the pebs record being delayed by one instruction following execution of mov ss or sti. the state information in the pebs record will also reflect the one instruction delay.										
workaround	none identified.										
											
title	performance monitoring event fp_mmx_trans_to_mmx may not count some transitions										
problem	performance monitor event fp_mmx_trans_to_mms (event cch, umask 01h) counts transitions from x87 floating point (fp) to mmxtm instructions. due to this erratum, if only a small number of mmx instructions (including emms) are executed immediately after the last fp instruction, a fp to mmx transition may not be counted.										
implication	the count value for performance monitoring event fp_mmx_trans_to_mmx may be lower than expected. the degree of undercounting is dependent on the occurrences of the erratum condition while the counter is active. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	the peci bus may be tri-stated after system reset										
problem	during power-up, the processor may improperly assert the peci (platform environment control interface) pin. this condition is cleared as soon as bus clock starts toggling. however, if the peci host (also referred to as the master or originator) incorrectly determines this asserted state as another peci host initiating a transaction, it may release control of the bus resulting in a permanent tri-state condition.										
implication	due to this erratum, the peci host may incorrectly determine that it is not the bus master and consequently peci commands initiated by the peci software layer may receive incorrect/invalid responses.										
workaround	to workaround this erratum the peci host should pull the peci bus low to initiate a peci transaction.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title	apic timer ccr may report 0 in periodic mode										
problem	in periodic mode the apic timer ccr (current-count register) is supposed to be automatically reloaded from the initial-count register when the count reaches 0, consequently software would never be able to observe a value of 0. due to this erratum, software may read 0 from the ccr when the timer has counted down and is in the process of re-arming.										
implication	due to this erratum, an unexpected value of 0 may be read from the apic timer ccr when in periodic mode.										
workaround	none identified.										
											
title	lbr, btm or bts records may have incorrect branch from information after an intel enhanced speedstep technology transition, t-states, c1e, or adaptive thermal throttling										
problem	the “form” address associated with the lbr (last branch record), btm (branch trace message) or bts (branch trace store) may be incorrect for the first branch after an enchanced intel® speedstep technology transition, t-states, c1e (c1 enhanced), or adaptive thermal throttling.										
implication	when the lbrs, btm or bts are enabled, some records may have incorrect branch “from” addresses for the first branch after an enchanced intel speedstep technology transition, t-states, c1e, or adaptive thermal throttling.										
workaround	none identified.										
											
title	pebs records not created for fp-assists events										
problem	when a performance monitor counter is configured to count fp_assists (event: f7h) and to trigger pebs (precise event based sampling), the processor does not create a pebs record when the counter overflows.										
implication	fp_assists events cannot be used for pebs.										
workaround	none identified.										
											
title	msr_turbo_ratio_limit msr may return intel® turbo boost technology core ratio multipliers for non-existent core configurations										
problem	msr_turbo_ratio_limit msr (1adh) is designed to describe the maximum intel turbo boost technology potential of the processor. on some processors, a non-zero intel turbo boost technology value will be returned for non-existent core configurations.										
implication	due to this erratum, software using the msr_turbo_ratio_limit msr to report intel turbo boost technology processor capabilities may report erroneous results.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	l1 cache uncorrected errors may be recorded as correctable in 16k mode										
problem	when the l1 cache is operating in 16k redundant parity mode and a parity error occurs on both halves of the duplicated cache on the same cacheline, an uncorrectable error should be logged. due to this erratum, the uncorrectable error will be recorded as correctable, however a machine check exception will be appropriately taken in this case.										
implication	due to this erratum, the ia32_mci_status.uc bit will incorrectly contain a value of 0 indicating a correctable error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	extra apic timer interrupt may occur during a write to the divide configuration register										
problem	if the apic timer divide configuration register (offset 03e0h) is written at the same time that the apic timer current count register (offset 0390h) reads 1h, it is possible that the apic timer will deliver two interrupts.										
implication	due to this erratum, two interrupts may unexpectedly be generated by an apic timer event.										
workaround	software should reprogram the divide configuration register only when the apic timer interrupt is disarmed.										
											
title	peci reads of machine check msrs in the processor core may not function correctly										
problem	peci reads which target machine check msrs in the processor core may either be directed to a different core than intended or report that the data is not available.										
implication	peci reads of machine check msrs in the processor core may return incorrect data or incorrectly report that data is not available for the requested core.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the combination of a page-split lock access and data accesses that are split across cacheline boundaries may lead to processor livelock										
problem	under certain complex microarchitectural conditions, the simultaneous occurrence of a page-split lock and several data accesses that are split cacheline boundaries may lead to processor livelock.										
implication	due to this erratum, a livelock may occur that can only be terminated by a processor reset. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	package c6 transitions may cause memory bit errors to be observed										
problem	during package c6 transitions, internal signaling noise may cause the ddrx_cke signal to become asserted during self-refresh. these assertions may result in memory bit errors upon exiting from the package c6 state. due to this erratum the ddrx_cke signals can be driven during times in which the ddr3 jedec specification requires that they are idle.										
implication	ddrx_cke signals can be driven during package c6 memory self-refresh creating an invalid memory dram state. a system hang, memory ecc errors or unpredictable system behavior may occur when exiting the package c6 state.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	fp data operand pointer may be incorrectly calculated after an fp access which wraps a 4-gbyte boundary in code that uses 32-bit address size in 64-bit mode										
problem	the fp (floating point) data operand pointer is the effective address of the operand associated with the last non-control fp instruction executed by the processor. if an 80- bit fp access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-gbyte boundary and the fp environment is subsequently saved, the value contained in the fp data operand pointer may be incorrect.										
implication	due to this erratum, the fp data operand pointer may be incorrect. wrapping an 80-bit fp load around a 4-gbyte boundary in this way is not a normal programming practice. intel has not observed this erratum with any commercially available software.										
workaround	if the fp data operand pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit fp accesses are wrapped around a 4-gbyte boundary.										
											
title	fp data operand pointer may be incorrectly calculated after an fp access which wraps a 64-kbyte boundary in 16-bit code										
problem	the fp (floating point) data operand pointer is the effective address of the operand associated with the last non-control fp instruction executed by the processor. if an 80- bit fp access (load or store) occurs in a 16-bit mode other than protected mode (in which case the access will produce a segment limit violation), the memory access wrap a 64-kbyte boundary, and the fp environment is subsequently saved, the value contained in the fp data operand pointer may be incorrect.										
implication	due to this erratum, the fp data operand pointer may be incorrect. wrapping an 80-bit fp load around a segment boundary in this way is not a normal programming practice. intel has not observed this erratum with any commercially available software.										
workaround	if the fp data operand pointer is used in an operating system which may run 16-bit fp code, care must be taken to ensure that no 80-bit fp access are wrapped around a 64- kbyte boundary.										
											
title	spurious prochot# assertion during warm reset may hang the processor										
problem	the processor may hang if there is a spurious prochot# pin assertion during a warm reset. the hang may occur even if the minimum hold time specification for prochot# is not met or voltage regulator based throttling is not enabled.										
implication	due to this erratum the processor may hang if there is any spurious assertion of the prochot# pin during a warm reset.										
workaround	it is possible of the bios to contain a workaround for this erratum, to be used in conjunction with a bios modification.										
											
title	tsc values when observed cross-socket may be out of sync after a warm reset										
problem	in a two socket platform with package c6 enabled, the tsc (time stamp counter) cross-socket values should remain synchronous if the conditions specified in the processor ac timing waveforms section of the intel® xeon 5600 series emts (electrical mechanical and thermal specifications) are met. due to this erratum the tsc may become out of sync between the processor packages after a warm reset even if the reset# de-assertion requirements are met.										
implication	certain software applications that rely on hardware based tsc cross-socket synchronization may not function correctly.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	changes to reserved bits for some non-architectural msr’s may cause unpredictable system behavior										
problem	under normal circumstances, an operation fails if it attempts to modify a reserved bit of a model-specific register (msr). due to this erratum and for some non-architectural msrs, such an attempt may cause unpredictable system behavior.										
implication	unpredictable system behavior may occur if software attempts to modify reserved bits of some non-architectural msrs. (note that documentation of the wrmsr instruction states that “undefined or reserved bits in an msr should be set to values previously read.”)										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	persistent stream of correctable memory ecc errors may result in unexpected behavior										
problem	when demand and/or patrol scrub are enabled along with write major mode, and a persistent stream of correctable memory ecc errors occurs, the processor may exhibit unexpected behavior.										
implication	a system hang or unpredictable system behavior might be observed due to this erratum. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the intel provided memory reference code to contain a workaround for this erratum. the workaround disables write major mode when demand and/or patrol scrub are enabled, which eliminates the potential for this erratum to occur.										
											
title	io_smi indication in smram state save area may be lost										
problem	the io_smi bit (bit 0) in the io state field at smram offset 7fa4h is set to “1” by the processor to indicate a system management interrupt (smi) is either taken immediately after a successful i/o instruction or is taken after a successful iteration of a rep i/o instruction. due to this erratum, the setting of the io_smi bit may be lost. this may happen under a complex set of internal conditions with intel® hyper- threading technology enabled and has not been observed with commercially available software.										
implication	due to this erratum, smi handlers may not be able to identify the occurrence of i/o smis.										
workaround	none identified.										
											
title	failing dimm id may be incorrect when mirroring is enabled										
problem	when redundancy is lost in mirroring mode, the failing dimms cannot be identified correctly if mc_smi_spare_dimm_error_status csr bits [13:12] (redundancy_loss_failing_dimm) are 00b.										
implication	when the bits [13:12] in the mc_smi_spare_dimm_error_status csr are 00b, the failing dimm may not be correctly identified.										
workaround	none identified.										
											
title	peci reads to machine check registers may return unexpected data										
problem	if bios disables one or more cores by writing to the csr_desired_cores (device 0; function 0; offset 80h), peci (platform environment control interface) reads to machine check registers may receive data from a core which was not the intended target of the read or may receive unexpected data.										
implication	when one or more cores are disabled by the bios, peci commands to read machine check registers may return incorrect data and/or behave in an unpredictable manner.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	fsw may be corrupted if an x87 store instruction causes a page fault in vmx non-root operation										
problem	the x87 fsw (fpu status word) may be corrupted if execution of a floating-point store instruction (fst, fstp, fist, fistp, fisttp) causes a page fault in vmx non-root operation.										
implication	this erratum may result in unexpected behavior of software that uses x87 fpu instructions.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	sensitivity in clocking circuitry may result in unpredictable system behavior										
problem	on a subset of processors the clocking circuitry may be sensitive to fluctuations in vtt voltage during stressful testing and/or operating conditions and may result in unpredictable system behavior.										
implication	this erratum may result in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	accesses to a vmcs may not operate correctly if cr0.cd is set on any logical processor of a core										
problem	the vmx (virtual-machine extensions) are controlled by the vmcs (virtual-machine control structure). if cr0.cd is set on any logical processor of a core, operations using the vmcs may not function correctly. such operations include the vmread and vmwrite instructions as well as vm entries and vm exits.										
implication	if cr0.cd is set on either logical processor in a core, the vmwrite instruction may not correctly update the vmcs and the vmread instruction may not return correct data. vm entries may not load state properly and may not establish vmx controls properly. vm exits may not save or load state properly.										
workaround	vmms (virtual-machine monitors) should ensure that cr0.cd is clear on all logical processors of a core before entering vmx operation on any logical processor. software should not set cr0.cd on a logical processor if any logical processor of the same core is in vmx operation. vmm software should prevent guest software from setting cr0.cd by setting bit 30 in the cr0 guest/host mask field in every vmcs.										
											
title											
problem	hardware prefetches that miss the l1 data cache but cannot be processed immediately due to resource conflicts will count and then retry. this may lead to incorrectly incrementing the l1d_prefetch.miss (event 4eh, umask 02h) event multiple times for a single miss.										
implication	the count reported by the l1d_prefetch.miss event may be higher than expected. workaround none identified.										
workaround											
											
title	parallel vmx entries and exits the dtlb is not flushed										
problem	the dtlb physicals are left intact, however, the physicals needs to be flushed to ensure proper smrr operation.										
implication	the dtlb physicals may contain smm addresses even after exiting smm.										
workaround	software using smm transfer monitor should insure that the dtlb is flushed prior to parallel entries and exits.										
											
title	vm exit may incorrectly clear ia32_perf_global_ctrl [34:32]										
problem	if the “load ia32_perf_global_ctrl” vm-exit control is 1, a vm exit should load the ia32_perf_global_ctrl msr (38fh) from the ia32_perf_global_ctrl field in the guest-state area of the vmcs. due to this erratum, such a vm exit may instead clear bits 34:32 of the msr, loading only bits 31:0 from the vmcs.										
implication	all fixed-function performance counters will be disabled after an affected vm exit, even if the vm exit should have enabled them based on the ia32_perf_global_ctrl field in the guest-state area of the vmcs.										
workaround	a vm monitor that wants the fixed-function performance counters to be enabled after a vm exit may do one of two things: (1) clear the “load ia32_perf_global_ctrl” vm- exit control; or (2) include an entry for the ia32_perf_global_ctrl msr in the vm- exit msr-load list.										
											
title											
problem	section “checks on guest non-register state” of volume 3b specifies consistency checks that vm entry should perform for bit 14 (bs, indicating a pending single-step exception) of the pending debug exception field in guest-state area of the vmcs. these checks enforce the consistency of that bit with other fields in the guest-state area. due to this erratum, vm entry may fail to perform these checks.										
implication	a logical processor may enter vmx non-root operation with a pending single-step debug exception that not consistent other register state; this may result in unexpected behavior. intel has not observed this erratum with any commercially available software.										
workaround	when using vmwrite to write to a field in the guest-state area, software should ensure that the value written is consistent with the state of other guest-state fields.										
											
title	package c6 transitions may result in single and multi-bit memory errors										
problem	on a subset of processors, during package c6 transitions, internal circuit marginality may cause ddr3 jedec specification violations. these violations may result in control and data signal errors upon exiting from package c6 state.										
implication	certain memory control signals may be incorrectly driven during package c6 memory self-refresh. this can create an invalid memory dram state, system hang, reboot, memory ecc errors or unpredictable system behavior. for systems with ecc memory, correctable/uncorrectable ecc errors may be logged in the ia32_mc8_status msr (421h) with the uncorrectable errors resulting in a machine check exception.										
workaround	it is possible for the bios to contain a workaround for this erratum. please refer to , intel® xeon® processor 5600 series microcode update guide for further details.										
											
title	execution of vmptrld may corrupt memory if current-vmcs pointer is invalid										
problem	if the vmclear instruction is executed with a pointer to the current-vmcs (virtual- machine control structure), the current-vmcs pointer becomes invalid as expected. a subsequent execution of the vmptrld (load pointer to virtual-machine control structure) instruction may erroneously overwrite the four bytes at physical address 0000008fh.										
implication	due to this erratum, the four bytes in system memory at physical address 0000008fh may be corrupted.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	perfmon overflow status can not be cleared after certain conditions have occurred										
problem	under very specific timing conditions, if software tries to disable a perfmon counter through msr ia32_perf_global_ctrl (0x38f) or through the per-counter event- select (e.g. msr 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in msr ia32_perf_global_stat (0x38e) may be left set with no way for software to clear it.										
implication	due to this erratum, software may be unable to clear the perfmon counter overflow status indication.										
workaround	software may avoid this erratum by clearing the perfmon counter value prior to disabling it and then clearing the overflow status indication bit.										
											
title	an unexpected page fault or ept violation may occur after anotherlogical processor creates a valid translation for a page										
problem	an unexpected page fault (#pf) or ept violation may occur for a page under the following conditions: the paging structures initially specify no valid translation for the page. software on one logical processor modifies the paging structures so thatthere is a valid translation for the page (e.g., by setting to 1 the present bitin one of the paging-structure entries used to translate the page). software on another logical processor observes this modification (e.g., byaccessing a linear address on the page or by reading the modified paging structure entry and seeing value 1 for the present bit). shortly thereafter, software on that other logical processor performs astore to a linear address on the page. in this case, the store may cause a page fault or ept violation that indicates that there is no translation for the page (e.g., with bit 0 clear in thepage-fault error code, indicating that the fault was caused by a not- present page). intel has not observed this erratum with any commercially available software.										
implication	an unexpected page fault may be reported. there are no other side effects due to this erratum.										
workaround	system software can be constructed to tolerate these unexpected page faults. see section “propagation of paging-structure changes to multiple processors” of volume 3a of ia-32 intel® architecture software developer's manual, for recommendations for software treatment of asynchronous paging-structure updates.										
											
title	l1 data cache errors may be logged with level set to 1 instead of 0										
problem	when an l1 data cache error is logged in ia32_mci_status[15:0], which is the mca error code field, with a cache error type of the format 0000 0001 rrrr ttll, the ll field may be incorrectly encoded as 01b instead of 00b.										
implication	an error in the l1 data cache may report the same ll value as the l2 cache. software should not assume that an ll value of 01b is the l2 cache.										
workaround	none identified.										
											
title	executing the getsec instruction while throttling may result in a processor hang										
problem	if the processor throttles due to either high temperature thermal conditions or due to an explicit operating system throttling request (tt1) while executing getsec[senter] or getsec[sexit] instructions, then under certain circumstances, the processor may hang. intel has not been observed this erratum with any commercially available software.										
implication	possible hang during execution of getsec instruction.										
workaround	none identified.										
											
title	perfmon event load_hit_pre.sw_prefetch may overcount										
problem	perfmon event load_hit_pre.sw_prefetch (event 4ch, umask 01h) should count load instructions hitting an ongoing software cache fill request initiated by a preceding software prefetch instruction. due to this erratum, this event may also count when there is a preceding ongoing cache fill request initiated by a locking instruction.										
implication	perfmon event load_hit_pre.sw_prefetch may overcount.										
workaround	none identified.										
											
title	successive fixed counter overflows may be discarded										
problem	under specific internal conditions, when using freeze perfmon on pmi feature (bit 12 in ia32_debugctl.freeze_perfmon_on_pmi, msr 1d9h), if two or more perfmon fixed counters overflow very closely to each other, the overflow may be mishandled for some of them. this means that the counter's overflow status bit (in msr_perf_global_status, msr 38eh) may not be updated properly; additionally, pmi interrupt may be missed if software programs a counter in sampling-mode (pmi bit is set on counter configuration).										
implication	successive fixed counter overflows may be discarded when freeze perfmon on pmi is used.										
workaround											
											
title	#gp may be signaled when invalid vex prefix precedes conditional branch instructions										
problem	when a 2-byte opcode of a conditional branch (opcodes 0f8xh, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid vex prefix, it may sometimes signal a #gp fault (illegal instruction length > 15-bytes) instead of a #ud (illegal opcode) fault.										
implication	due to this erratum, #gp fault instead of a #ud may be signaled on an illegal instruction.										
workaround	none identified.										
											
title	a logical processor may wake from shutdown state when branch- trace messages or branch-trace stores are enabled										
problem	normally, a logical processor that entered the shutdown state will remain in that state until a break event (nmi, smi, init) occurs. due to this erratum, if cr4.mce (machine check enable) is 0 and a branch-trace message or branch-trace store is pending at the time of a machine check, the processor may not remain in shutdown state. in addition, if the processor was in vmx non-root operation when it improperly woke from shutdown state, a subsequent vm exit may save a value of 2 into the activity-state field in the vmcs (indicating shutdown) even though the vm exit did not occur while in shutdown state.										
implication	this erratum may result in unexpected system behavior. if a vm exit saved a value of 2 into the activity-state field in the vmcs, the next vm entry will take the processor to shutdown state.										
workaround	software should ensure that cr4.mce is set whenever ia32_debugctl msr (60eh) tr bit [6] is set.										
											
title	task switch to a tss with an inaccessible ldtr descriptor may cause unexpected faults										
problem	a task switch may load the ldtr (local descriptor table register) with an incorrect segment descriptor if the ldt (local descriptor table) segment selector in the new tss specifies an inaccessible location in the gdt (global descriptor table).										
implication	future accesses to the ldt may result in unpredictable system behavior.										
workaround	operating system code should ensure that segment selectors used during task switches to the gdt specify offsets within the limit of the gdt and that the gdt is fully paged into memory.										
											
title	package c6 exit with memory in self-refresh when using ddr3 rdimm memory may lead to a system hang										
problem	when using ddr3 rdimm memory and exiting from the c6 low power state with memory in self-refresh the cs (chip select) signals may remain in tri-state during tstab (clk stabilization time) thus violating the jedec standard: definition of the sste32882 registering clock driver with parity and quad chip selects for ddr3 rdimm applications. as detailed in the jedec specification the cs signals should transition from tri-state to high to exit the clock stopped power down mode.										
implication	when this erratum occurs the processor may hang.										
workaround	none identified.										
											
title	.mcip bit not checked on senter or enteraccs										
problem	when an ilp (initiating logical processor) executes getsec with either the senter or enteraccs leaf function, the processor should check the mcip (machine check in progress) bit in the ia32_mcg_status msr (17ah) to determine if any machine check exception is being processed. if a machine check is in progress the ilp should generate a general protection exception. due to this erratum, the general protection exception is not generated.										
implication	if getsec is executed with either the senter or enteraccs leaf function, and a machine check exception is being processed, ilp will enter an authenticated execution mode instead of generating a general protection exception.										
workaround	none identified.										
											
title	unexpected load may occur on execution of certain opcodes										
problem	if software executes an instruction with an opcode of the form 66 0f 38 8x (where x is in the range 0 to 6), the processor may unexpectedly perform a load operation (the data loaded is not used). the load occurs even if the instruction causes a vm exit or a fault (including an invalid-opcode exception). if the vmxon instruction has been executed successfully, the load is from the physical address in the vmxon pointer plus 408h; otherwise, it is from physical address 407h. the affected opcodes include the invept and invvpid instructions as well as five invalid opcodes.										
implication	this erratum may cause incorrect side effects if the load accesses a memory-mapped i/o device. intel has not observed this erratum with any commercially available system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	successive fixed counter overflows may be discarded										
problem	under specific internal conditions, when using freeze perfmon on pmi feature (bit 12 in ia32_debugctl.freeze_perfmon_on_pmi, msr 1d9h), if two or more perfmon fixed counters overflow very closely to each other, the overflow may be mishandled for some of them. this means that the counter's overflow status bit (in msr_perf_global_status, msr 38eh) may not be updated properly; additionally, pmi interrupt may be missed if software programs a counter in sampling-mode (pmi bit is set on counter configuration).										
implication	successive fixed counter overflows may be discarded when freeze perfmon on pmi is used.										
workaround	software can avoid this by:										
											
title	vm exits due to “nmi-window exiting” may not occur following a vm entry to the shutdown state										
problem	if vm entry is made with the “virtual nmis” and “nmi-window exiting”, vm-execution controls set to 1, and if there is no virtual-nmi blocking after vm entry, a vm exit with exit reason “nmi window” should occur immediately after vm entry unless the vm entry put the logical processor in the wait-for sipi state. due to this erratum, such vm exits do not occur if the vm entry put the processor in the shutdown state.										
implication	a vmm may fail to deliver a virtual nmi to a virtual machine in the shutdown state.										
workaround	before performing a vm entry to the shutdown state, software should check whether the “virtual nmis” and “nmi-window exiting” vm-execution controls are both 1. if they are, software should clear “nmi-window exiting” and inject an nmi as part of vm entry.										
											
title	execution of invvpid outside 64-bit mode cannot invalidate translations for 64-bit linear addresses										
problem	executions of the invvpid instruction outside 64-bit mode with the invvpid type “individual-address invalidation” ignore bits 63:32 of the linear address in the invvpid descriptor and invalidate translations for bits 31:0 of the linear address.										
implication	the invvpid instruction may fail to invalidate translations for linear addresses that set bits in the range 63:32. because this erratum applies only to executions outside 64-bit mode, it applies only to attempts by a 32-bit virtual-machine monitor (vmm) to invalidate translations for a 64-bit guest. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	a combination of data accesses that are split across cacheline boundaries may lead to a processor hang										
problem	under certain complex micro-architectural conditions, closely spaced data accesses that are split across cacheline boundaries may lead to a processor hang.										
implication	due to this erratum, the processor may hang. this erratum has not been observed with any general purpose operating systems.										
workaround	none identified.										
											
title	perfmon overflow status can not be cleared after certain conditions have occurred										
problem	under very specific timing conditions, if software tries to disable a perfmon counter through msr ia32_perf_global_ctrl (0x38f) or through the per-counter event- select (e.g. msr 0x186) and the counter reached its overflow state very close to that time, then due to this erratum the overflow status indication in msr ia32_perf_gloal_stat (0x38e) may be left set with no way for software to clear it.										
implication	due to this erratum, software may be unable to clear the perfmon counter overflow status indication.										
workaround	software may avoid this erratum by clearing the perfmon counter value prior to disabling it and then clearing the overflow status indication bit.										
											
title	package c6 c-state exit may result in uncorrectable memory errors										
problem	on a subset of processors, during package c6 c-state transitions, internal circuit marginality may cause uncorrectable memory errors to occur on exiting package c6 c- state. the errors will be logged in ia32_mci_status msr with mcacod = 0x009f.										
implication											
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	vmresume may omit check of revision identifier of linked vmcs										
problem	if the vmcs link pointer is valid in the vmcs, vm entry instructions should check that the 32 bits referenced by that pointer contains the processor's vmcs revision identifier and fail if it does not. due to this erratum, vmresume may omit this check and thus not cause vm entry to fail in some cases.										
implication	the revision identifier of the linked vmcs may not be checked. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	an init signal may cause unpredictable behavior after a vmxoff										
problem	if software has used vmx-preemption timer and subsequently leaves vmx operation this erratum may lead to unpredictable behavior, including a system hang. intel has not observed this erratum with any commercially available software.using vmxoff, then an init signal may result in unpredictable behavior.										
implication	this erratum may lead to unpredictable behavior, including a system hang. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	apic timer interrupts may be lost during core c3										
problem	apic timer interrupts intended to awaken from core c3 may be lost under certain timing conditions.										
implication	due to this erratum, a lost timer interrupt may cause the system to hang. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	mci_addr may be incorrect for cache parity errors										
problem	in cases when a wbinvd instruction evicts a line containing an address or data parity error (mcacod of 0x124, and mscod of 0x10), the address of this error should be logged in the mci_addr register. due to this erratum, the logged address may be incorrect, even though mci_status.addrv (bit 63) is set.										
implication	the address reported in mci_addr may not be correct for cases of a parity error found during wbinvd execution.										
workaround	none identified.										
											
title	apic timer interrupt may be lost										
problem	an apic timer interrupt can be lost when it aligns precisely with an internal cpu counter overflow condition (the overflow condition occurs once about every 90 minutes).										
implication	due to this erratum, for certain programmed values of the apic timer, the processor may not recognize and service the interrupt.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	rep movs/stos executing with fast strings enabled and crossing page boundaries with inconsistent memory types may use an incorrect data size or lead to memory-ordering violations										
problem	under certain conditions as described in the software developers manual section “out- of-order stores for string operations in pentium 4, intel xeon, and p6 family processors” the processor performs rep movs or rep stos as fast strings. due to this erratum fast string rep movs/rep stos instructions that cross page boundaries from wb/wc memory types to uc/wp/wt memory types, may start using an incorrect data size or may observe memory ordering violations.										
implication	upon crossing the page boundary the following may occur, dependent on the new page memory type: uc the data size of each write will now always be 8 bytes, as opposed to the original data size. wp the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. wt there may be a memory ordering violation.										
workaround	software should avoid crossing page boundaries from wb or wc memory type to uc, wp or wt memory type within a single rep movs or rep stos instruction that will execute with fast strings enabled.										
											
title	cr0.cd is ignored in vmx operation										
problem	if cr0.cd=1, the mtrrs and pat should be ignored and the uc memory type should be used for all memory accesses. due to this erratum, a logical processor in vmx operation will operate as if cr0.cd=0 even if that bit is set to 1.										
implication	algorithms that rely on cache disabling may not function properly in vmx operation.										
workaround	algorithms that rely on cache disabling should not be executed in vmx root operation.										
											
title	sensitivity in execution unit clock circuitry on a small subset of intel® xeon® processor x5675, x5690 and x5687 may result in unpredictable system behavior										
problem	under a complex set of internal and platform conditions, the execution unit on a small subset of intel® xeon® processor x5675, x5690 and x5687 may not complete some instructions correctly.										
implication	due to this erratum, the execution unit may not complete some instructions correctly, leading to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	virtual-apic page accesses with 32-bit pae paging may cause a system crash										
problem	if a logical processor has ept (extended page tables) enabled, is using 32-bit pae paging, and accesses the virtual-apic page then a complex sequence of internal processor micro-architectural events may cause an incorrect address translation or machine check on either logical processor										
implication	this erratum may result in unexpected faults, an uncorrectable tlb error logged in ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_0000_0001_xxxxb (where x stands for 0 or 1), a guest or hypervisor crash, or other unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ept violations may report bits 11:0 of guest linear address incorrectly										
problem	if a memory access to a linear address requires the processor to update an accessed or dirty flag in a paging-structure entry and if that update causes an ept violation, the processor should store the linear address into the “guest linear address” field in the vmcs. due to this erratum, the processor may store an incorrect value into bits 11:0 of this field. (the processor correctly stores the guest-physical address of the paging- structure entry into the “guest-physical address” field in the vmcs.)										
implication	software may not be easily able to determine the page offset of the original memory access that caused the ept violation. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	software requiring the page offset of the original memory access address can derive it by simulating the effective address computation of the instruction that caused the ept violation.										
											
title											
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9:1 report the highest index value used for any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9:1] to read and write all vmcs fields may omit one field.										
workaround	none identified.										
											
title	the upper 32 bits of cr3 may be incorrectly used with 32-bit paging										
problem	when 32-bit paging is in use, the processor should use a page directory located at the 32-bit physical address specified in bits 31:12 of cr3; the upper 32 bits of cr3 should be ignored. due to this erratum, the processor will use a page directory located at the 64-bit physical address specified in bits 63:12 of cr3.										
implication	the processor may use an unexpected page directory or, if ept (extended page tables) is in use, cause an unexpected ept violation. this erratum applies only if software enters 64-bit mode, loads cr3 with a 64-bit value, and then returns to 32-bit paging without changing cr3. intel has not observed this erratum with any commercially available software.										
workaround	software that has executed in 64-bit mode should reload cr3 with a 32-bit value before returning to 32-bit paging.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated after a uc error is logged										
problem	when a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to update the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated after a uc error is logged.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	eoi-broadcast suppression may not function properly if enabled or disabled while an interrupt is in service										
problem	if a processor supports eoi-broadcast suppression, a write to the local apic's eoi register does not generate a broadcast eoi (even if the interrupt is level-triggered) if bit 12 of the local apic's svr (spurious-interrupt vector register) is set at the time of the write. due to this erratum, the local apic decides whether to generate a broadcast eoi based on the value that bit 12 of the svr had at the time at which the most recent interrupt was delivered or the time of the most recent write to the eoi register (whichever is later).										
implication	if software modifies bit 12 of svr while servicing an interrupt, the next write to the eoi register may not use the new bit value.										
workaround	software should not modify bit 12 of svr while servicing a level-triggered interrupt.										
											
title	an event may intervene before a system management interrupt that results from in or ins										
problem	if an i/o instruction (in, ins, out, or outs) results in an smi (system-management interrupt), the processor will set the io_smi bit at offset 7fa4h in smram. this interrupt should be delivered immediately after execution of the i/o instruction so that the software handling the smi can cause the i/o instruction to be re-executed. due to this erratum, it is possible for another event (e.g., a nonmaskable interrupt) to be delivered before the smi that follows the execution of an in or ins instruction										
implication	if software handling an affected smi uses i/o instruction restart, the handler for the intervening event will not be executed.										
workaround	the smm handler has to evaluate the saved context to determine if the smi was triggered by an instruction that read from an i/o port. the smm handler must not restart an i/o instruction if the platform has not been configured to generate a synchronous smi for the recorded i/o port address.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when "xd bit disable" in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the "execute disable" feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the "load ia32_efer" vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the "execute disable" feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	bios acm may report an incorrect txt.errorcode in multiprocessor configurations										
problem	in multiprocessor configurations, txt.errorcode error information may be lost across bios acm calls due to a synchronization problem.										
implication	in multiprocessor configurations, sinit acm errors may not be correctly reported in txt.errorcode.										
workaround	uniprocessor configurations are unaffected by this erratum. if the platform is changed to a uniprocessor configuration, txt.errorcode will be reported accurately.										
											
title	bios acm reset tpm auxiliary indices function not available										
problem	early server bios acm releases do not support the new reset tpm auxiliary indices function (esi = 0x02).										
implication	calls to the bios acm reset auxiliary indices function on affected acm releases will return control back to the caller without performing the function.										
workaround	none identified.										
											
title	if processor is reset without resetting the ioh with secrets in memory, the bios acm will hand-off to bios with memory locked										
problem	the platform may assert reset only to the processor to change ddr speed or make another configuration change. if cold reset or warm reset is asserted to the processor with secrets in memory without resetting the ioh, the bios acm will hand off to bios with memory locked.										
implication	with memory locked, bios will be unable to initialize memory, resulting in boot failure.										
workaround	if reset# is asserted to both the processor and the ioh, exposure to this erratum does not exist.										
											
title	bios acm scheck may set tpm locality 0 to inactive status										
problem	if bios has set tpm locality 0 to be active, bios acm scheck may reset tpm locality 0 to inactive.										
implication	bios implementations that depend upon locality 0 active status to be preserved across scheck may not behave as expected.										
workaround	bios can set tpm locality 0 to active after scheck if necessary.										
											
title	if bios policy autopromotion fails, txt.acmcrashcode and txt.acmstatus may have incorrect values										
problem	if bios policy autopromotion fails, txt.acmcrashcode and txt.spad may have incorrect values.										
implication	bios implementations depending upon txt.acmcrashcode or txt.spad may not identify bios policy autopromotion failure.										
workaround	none identified.										
											
title	the bios acm may write error codes to the wrong register										
problem	the bios acm may incorrectly write error codes to txt.errorcode (offset 0030h) instead of txt.biosacm.errorcode (offset 0328h).										
implication	txt.errorcode may be overwritten with bios acm error codes.										
workaround	none identified.										
											
title	npw bios acms may allow launch of an mle when the launch control policy disallows npw launch										
problem	with the affected npw (non-production worthy) bios acms, the measured launch environment (e.g., virtual machine monitor or operating system) may boot when the mle launch control policy disallows npw boot.										
implication	measured launch environments may boot with npw bios acms even if the mle launch control policy disallows npw boot.										
workaround	none identified.										
											
title	tpm pcr17 not extended with bios acm values										
problem	with the affected bios acms, tpm (trusted platform module) platform configuration register pcr17 may not be extended with the bios acm version or non-production worthy bit.										
implication	on platforms using the affected bios acms, software depending upon pcr17 attestation may not behave as expected.										
workaround	none identified.										
											
title	bios acm may exit to bios with tpm locality 3 activated										
problem	in multiprocessor configurations, under certain race conditions the bios acm may exit to bios with tpm locality 3 activated.										
implication	if tpm locality 3 is left activated, bios will be unable to activate locality and trusted boot will fail.										
workaround	uniprocessor configurations are unaffected by this erratum. if the platform is changed to a uniprocessor configuration, tpm locality 3 will not be activated on exit to bios.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr										
											
title	smram state-save area above the 4 gb boundary may cause unpredictable system behavior										
problem	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	ensure that the smram state-save area is located entirely below the 4gb address boundary.										
											
title	x87 fpu exception (#mf) may be signaled earlier than expected										
problem	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executing when an enhanced intel speedstep® technology transitions, an intel® turbo boost technology transitions, or a thermal monitor events occurs, the #mf may be taken before pending interrupts are serviced.										
implication	software may observe #mf being signaled before pending interrupts are serviced.										
workaround	none identified.										
											
title	incorrect from_ip value for an rtm abort in btm or bts may be observed										
problem	during rtm (restricted transactional memory) operation when branch tracing is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.										
implication	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.										
workaround	none identified.										
											
title	dr6 register may contain an incorrect value when a mov to ss or pop ss instruction is followed by an xbegin instruction										
problem	if xbegin is executed immediately after an execution of mov to ss or pop ss, a transactional abort occurs and the logical processor restarts execution from the fallback instruction address. if execution of the instruction at that address causes a debug exception, bits [3:0] of the dr6 register may contain an incorrect value.										
implication	when the instruction at the fallback instruction address causes a debug exception, dr6 may report a breakpoint that was not triggered by that instruction, or it may fail to report a breakpoint that was triggered by the instruction.										
workaround	avoid following a mov ss or pop ss instruction immediately with an xbegin instruction.										
											
title											
problem	if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 then opcode bytes f3 0f bc should be interpreted as tzcnt otherwise they will be interpreted as rep bsf. due to this erratum, opcode bytes f3 0f bc may execute as tzcnt even if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 0.										
implication	software that expects rep prefix before a bsf instruction to be ignored may not operate correctly since there are cases in which bsf and tzcnt differ with regard to the flags that are set and how the destination operand is established.										
workaround	software should use the opcode bytes f3 0f bc only if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 and only if the functionality of tzcnt (and not bsf) is desired.										
											
title	pcie* root-port initiated compliance state transmitter equalization settings may be incorrect										
problem	if the processor is directed to enter pcie polling.compliance at 5.0 gt/s or 8.0 gt/s transfer rates, it should use the link control 2 compliance preset/de-emphasis field (bits [15:12]) to determine the correct de-emphasis level. due to this erratum, when the processor is directed to enter polling.compliance from 2.5 gt/s transfer rate, it retains 2.5 gt/s de-emphasis values.										
implication	the processor may operate in polling.compliance mode with an incorrect transmitter de-emphasis level.										
workaround	none identified.										
											
title	the smsw instruction may execute within an enclave										
problem	the smsw instruction is illegal within an intel® software guard extensions (intel® sgx) enclave, and an attempt to execute it within an enclave should result in a #ud (invalid-opcode exception). due to this erratum, the instruction executes normally within an enclave and does not cause a #ud.										
implication	the smsw instruction provides access to cr0 bits 15:0 and will provide that information inside an enclave. these bits include ne, et, ts, em, mp and pe.										
workaround	none identified. if smsw execution inside an enclave is unacceptable, system software should not enable intel sgx.										
											
title	pebs record after a wrmsr to ia32_bios_updt_trig may be incorrect										
problem	a pebs record generated by a wrmsr to ia32_bios_updt_trig msr (79h) may have an incorrect value in the eventing eip field if an instruction prefix was used on the wrmsr.										
implication	the eventing eip field of the generated pebs record may be incorrect. intel has not observed this erratum with any commercially available software.										
workaround	instruction prefixes have no architecturally-defined function for the wrmsr instruction; instruction prefixes should not be used with the wrmsr instruction.										
											
title	intel® processor trace (intel® pt) tip.pgd may not have target ip payload										
problem	when intel pt is enabled and a direct unconditional branch clears ia32_rtit_status.filteren (msr 571h, bit 0), due to this erratum, the resulting tip.pgd (target ip packet, packet generation disable) may not have an ip payload with the target ip.										
implication	it may not be possible to tell which instruction in the flow caused the tip.pgd using only the information in trace packets when this erratum occurs.										
workaround	the intel pt trace decoder can compare direct unconditional branch targets in the source with the filteren address range(s) to determine which branch cleared filteren.										
											
title	operand-size override prefix causes 64-bit operand form of movbe instruction to cause a #ud										
problem	execution of a 64 bit operand movbe instruction with an operand-size override instruction prefix (66h) may incorrectly cause an invalid-opcode exception (#ud).										
implication	a movbe instruction with both rex.w=1 and a 66h prefix will unexpectedly cause an #ud (invalid-opcode exception). intel has not observed this erratum with any commercially available software.										
workaround	do not use a 66h instruction prefix with a 64-bit operand movbe instruction.										
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not- available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	pebs eventing ip field may be incorrect after not-taken branch										
problem	when a pebs (precise-event-based-sampling) record is logged immediately after a not-taken conditional branch (jcc instruction), the eventing ip field should contain the address of the first byte of the jcc instruction. due to this erratum, it may instead contain the address of the instruction preceding the jcc instruction.										
implication	performance monitoring software using pebs may incorrectly attribute pebs events that occur on a jcc to the preceding instruction.										
workaround	none identified.										
											
title	debug exceptions may be lost or misreported following wrmsr to ia32_bios_updt_trig										
problem	if the wrmsr instruction writes to the ia32_bios_updt_trig msr (79h) immediately after an execution of mov ss or pop ss that generated a debug exception, the processor may fail to deliver the debug exception or, if it does, the dr6 register contents may not correctly reflect the causes of the debug exception.										
implication	debugging software may fail to operate properly if a debug exception is lost or does not report complete information.										
workaround	software should avoid using wrmsr instruction immediately after executing mov ss or pop ss										
											
title	attempts to retrain a pcie* link may be ignored										
problem	a pcie link should retrain when retrain link (bit 5) in the link control register (bus 0; device 1; functions 0,1,2; offset 0xb0) is set. due to this erratum, if the link is in the l1 state, it may ignore the retrain request.										
implication	the pcie link may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® processor trace psb+ packets may contain unexpected packets										
problem	some intel processor trace packets should be issued only between tip.pge (target ip packet.packet generation enable) and tip.pgd (target ip packet.packet generation disable) packets. due to this erratum, when a tip.pge packet is generated it may be preceded by a psb+ (packet stream boundary) that incorrectly includes fup (flow update packet) and mode.exec packets.										
implication	due to this erratum, fup and mode.exec may be generated unexpectedly.										
workaround	decoders should ignore fup and mode.exec packets that are not between tip.pge and										
											
title	an apic timer interrupt during core c6 entry may be lost										
problem	due to this erratum, an apic timer interrupt coincident with the core entering c6 state may be lost rather than held for servicing later.										
implication	a lost apic timer interrupt may lead to missed deadlines or a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	placing an intel® pt topa in non-wb memory or writing it within a transactional region may lead to system instability										
problem	if an intel pt topa (table of physical addresses) is not placed in wb (writeback) memory or is written by software executing within an intel® transactional synchronization extension (intel® tsx) transactional region, the system may become unstable.										
implication	unusual treatment of the topa may lead to system instability.										
workaround	none identified. intel pt topa should reside in wb memory and should not be written within a transactional region.										
											
title	vm entry that clears traceen may generate a fup										
problem	if vm entry clears intel® pt (intel processor trace) ia32_rtit_ctl.traceen (msr 570h, bit 0) while packeten is 1 then a fup (flow update packet) will precede the tip.pgd (target ip packet, packet generation disable). vm entry can clear traceen if the vm-entry msr-load area includes an entry for the ia32_rtit_ctl msr.										
implication	when this erratum occurs, an unexpected fup may be generated that creates the appearance of an asynchronous event taking place immediately before or during the vm entry.										
workaround	the intel pt trace decoder may opt to ignore any fup whose ip matches that of a vm entry instruction.										
											
title	edram corrected error events may not be properly logged after a warm reset										
problem	after a warm reset, an edram corrected error may not be logged correctly until the associated machine check register is initialized. this erratum may affect ia32_mc8_status or ia32_mc10_status.										
implication	the edram corrected error information may be lost when this erratum occurs.										
workaround	data from the affected machine check registers should be read and the registers initialized as soon as practical after a warm reset.										
											
title	processor instability may occur when using the peci rdiamsr command										
problem	under certain circumstances, reading a machine check register using the peci (platform environmental control interface) rdiamsr command may result in a machine check, processor hang or shutdown.										
implication	machine check, hang or shutdown may be observed when using the peci rdiamsr command.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enclu[egetkey] ignores keyrequest.miscmask										
problem	the intel® software guard extensions (intel® sgx) enclu[egetkey] instruction ignores the miscmask field in keyrequest structure when computing a provisioning key, a provisioning seal key, or a seal key.										
implication	enclu[egetkey] will return the same key in response to two requests that differ only in the value of keyrequest.miscmask. intel has not observed this erratum with any commercially available software.										
workaround	when executing the enclu[egetkey] instruction, software should ensure the bits set in keyrequest.miscmask are a subset of the bits set in the current secs’ miscselect field.										
											
title	popcnt instruction may take longer to execute than expected										
problem	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.										
implication	software using the popcnt instruction may experience lower performance than expected.										
workaround	none identified										
											
title	enclu[ereport] may cause a #gp when targetinfo.miscselect is non-zero										
problem	the intel® sgx (intel software guard extensions) enclu[ereport] instruction may cause a #gp (general protection fault) if any bit is set in targetinfo structure’s miscselect field.										
implication	this erratum may cause unexpected general-protection exceptions inside enclaves.										
workaround	when executing the enclu[ereport] instruction, software should ensure the bits set in targetinfo.miscselect are a subset of the bits set in the current secs’ miscselect field.										
											
title	a vmx transition attempting to load a non-existent msr may result in a shutdown										
problem	a vmx transition may result in a shutdown (without generating a machine-check event) if a non-existent msr is included in the associated msr-load area. when such a shutdown occurs, a machine check error will be logged with ia32_mci_status.mcacod (bits [15:0]) of 406h, but the processor does not issue the special shutdown cycle. a hardware reset must be used to restart the processor.										
implication	due to this erratum, the hyper-visor may experience an unexpected shutdown.										
workaround	software should not configure vmx transitions to load non-existent msrs.										
											
title	transitions out of 64-bit mode may corrupt the x87 fpu instruction and data pointer registers										
problem	a transition from 64-bit mode to compatibility mode may zero bits [63:32] of the x87 fpu instruction pointer offset (fip) and the x87 fpu data pointer offset (fdp).										
implication	a later instruction that saves x87 fpu state will not save bits [63:32] of the instruction and data pointers of the last non-control instruction executed.										
workaround	64-bit software should save x87 fpu state before leaving 64-bit mode.										
											
title	intel® pt fup may be dropped after ovf										
problem	some intel pt (intel processor trace) ovf (overflow) packets may not be followed by a fup (flow update packet) or tip.pge (target ip packet, packet generation enable).										
implication	when this erratum occurs, an unexpected packet sequence is generated.										
workaround	when it encounters an ovf without a following fup or tip.pge, the intel pt trace decoder should scan for the next tip, tip.pge, or psb+ to resume operation.										
											
title	encls[ecreate] causes #gp if enclave base address is not canonical										
problem	the encls[ecreate] instruction uses an secs (intel sgx enclave control structure) referenced by the srcpage pointer in the pageinfo structure, which is referenced by the rbx register. due to this erratum, the instruction causes a #gp (general-protection fault) if the secs attributes indicate that the enclave should operate in 64-bit mode and the enclave base linear address in the secs is not canonical.										
implication	system software will incur a general-protection fault if it mistakenly programs the secs with a non-canonical address. intel has not observed this erratum with any commercially available software.										
workaround	system software should always specify a canonical address as the base address of the 64-bit mode enclave.										
											
title	data breakpoint may not be detected on a rep movs										
problem	a rep movs instruction that causes an exception or a vm exit may not detect a data breakpoint that occurred on an earlier memory access of that rep movs instruction.										
implication	a debugger may miss a data read/write access if it is done by a rep movs instruction.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor graphics iommu unit may report spurious faults										
problem	the iommu unit for processor graphics pre-fetches context (or extended-context) entries to improve performance. due to the erratum, the iommu unit may report spurious dma remapping faults if prefetching encounters a context (or extended- context) entry which is not marked present.										
implication	software may observe spurious dma remapping faults when the present bit for the context (or extended-context) entry corresponding to the processor graphics device (bus: 0; device: 2; function: 0) is cleared. these faults may be reported when the processor graphics device is quiescent.										
workaround	none identified. instead of marking a context not present, software should mark the context (or extended-context) entry present while using the page table to indicate all the memory pages referenced by the context entry is not present.										
											
title	pcie* and dmi links with lane polarity inversion may result in link failure										
problem	the processor’s pcie and dmi links may fail after exiting package c7 or deeper if the platform requires the link to utilize lane polarity inversion.										
implication	due to this erratum, the processor cannot support lane polarity inversion on the pcie or dmi links when package c7 or deeper is enabled.										
workaround	none identified.										
											
title	pcie* expansion rom base address register may be incorrect										
problem	after pcie 8.0 gt/s link equalization on a root port (bus 0; device 1; function 0, 1, 2) has completed, the expansion rom base address register (offset 38h) may be incorrect.										
implication	software that uses this bar may behave unexpectedly. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a partial workaround for this erratum. software should wait at least 5ms following link equalization before accessing these expansion rom base address register.										
											
title	pcie* perform equalization may lead to link failure										
problem	due to this erratum, when a processor pcie port operating at 8.0 gt/s is directed to redo equalization, either via software or from the link partner, incorrect coefficients may be conveyed during equalization phase 3.										
implication	if the link partner accepts the incorrect coefficients, the link may become unstable. note this affects 8.0 gt/s only.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	when, on a single memory channel with 2133 mhz ddr4 sodimms, mixing different vendors or mixing single rank and dual rank dimms, may lead to a higher rate of correctable errors or system hangs.										
implication	due to this erratum, reported correctable error counts may increase or system may hang.										
workaround	use a single vendor for and do not mix single rank and dual rank 2133 mhz ddr4 sodimm.										
											
title	encls[einit] instruction may unexpectedly #gp										
problem	when using intel® sgx (software guard extensions), the encls[einit] instruction will incorrectly cause a #gp (general protection fault) if the miscselect field of the sigstruct structure is not zero.										
implication	this erratum may cause an unexpected #gp, but only if software has set bits in the miscselect field in sigstruct structure that do not correspond to extended features that can be written to the misc region of the ssa (state save area). intel has not observed this erratum with any commercially available software.										
workaround	when executing the encls[einit] instruction, software should only set bits in the miscselect field in the sigstruct structure that are enumerated as 1 by cpuid.(eax=12h,ecx=0):ebx (the bit vector of extended features that can be written to the misc region of the ssa).										
											
title	intel® processor trace (intel® pt) ovf packet may be lost if immediately preceding a tracestop										
problem	if an intel pt (intel® processor trace) internal buffer overflow occurs immediately before software executes a taken branch or event that enters an intel pt tracestop region, the ovf (overflow) packet may be lost.										
implication	the trace decoder will not see the ovf packet, nor any subsequent packets (e.g., tracestop) that were lost due to overflow.										
workaround	none identified.										
											
title	detecting an intel® pt stopped or error condition within an intel® tsx region may result in a system hang										
problem	while executing within an intel tsx (intel® transactional synchronization extensions) transactional region with intel pt (intel® processor trace) enabled and an event occurs that causes either the error bit (bit 4) or stopped bit (bit 5) in the ia32_rtit_status msr (0571h) to be set then, due to this erratum, the system may hang.										
implication	a system hang may occur when intel pt and intel tsx are used together.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	wrmsr to ia32_bios_updt_trig may be counted as multiple instructions										
problem	when software loads a microcode update by writing to msr ia32_bios_updt_trig (79h) on multiple logical processors in parallel, a logical processor may, due to this erratum, count the wrmsr instruction as multiple instruction-retired events.										
implication	performance monitoring with the instruction-retired event may over count by up to four extra events per instance of wrmsr which targets the ia32_bios_updt_trig register.										
workaround	none identified.										
											
title	the x87 fip may be incorrect										
problem	the x87 fpu should update the x87 fip (fpu instruction pointer) for every non-control x87 instruction executed. due to this erratum, the fip is valid only if the last non- control fp instruction had an unmasked exception.										
implication	when this erratum occurs, an instruction that saves fip (for example, fstenv) may save an incorrect value. software that depends on the fip value for x87 non-control instructions without unmasked exceptions may not operate as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	branch instructions may initialize intel® memory protection extensions (intel® mpx) bound registers incorrectly.										
problem	depending on the current intel® mpx (intel memory protection extensions) configuration, execution of certain branch instructions (near call, near ret, near jmp, and jcc instructions) without a bnd prefix (f2h) initialize the intel mpx bound registers. due to this erratum, execution of such a branch instruction on a user-mode page may not use the intel mpx configuration register appropriate to the current privilege level (bndcfgu for cpl 3 or bndcfgs otherwise) for determining whether to initialize the bound registers; it may thus initialize the bound registers when it should not, or fail to initialize them when it should.										
implication	after a branch instruction on a user-mode page has executed, a #br (bound-range) exception may occur when it should not have or a #br may not occur when one should have.										
workaround	if supervisor software is not expected to execute instructions on user-mode pages, software can avoid this erratum by setting cr4.smep[bit 20] to enable supervisor- mode execution prevention (smep). if smep is not available or if supervisor software is expected to execute instructions on user-mode pages, no workaround is identified.										
											
title	writing a non-canonical value to an lbr msr does not signal a #gp when intel® pt is enabled										
problem	if intel pt (intel processor trace) is enabled, wrmsr will not cause a general- protection exception (#gp) on an attempt to write a non-canonical value to any of the following msrs: •msr_lastbranch_{0 - 31}_from_ip (680h – 69fh) •msr_lastbranch {0 - 31}_to_ip (6c0h – 6dfh) •msr_lastbranch_from_ip (1dbh) •msr_lastbranch_to_ip (1dch) •msr_lastint_from_ip (1ddh) •msr_lastint_to_ip (1deh) instead the same behavior will occur as if a canonical value had been written. specifically, the wrmsr will be dropped and the msr value will not be changed.										
implication	due to this erratum, an expected #gp may not be signaled.										
workaround	none identified.										
											
title	processor may run intel® advanced vector extensions (intel® avx) code much slower than expected										
problem	after a c6 state exit, the execution rate of intel avx instructions may be reduced.										
implication	applications using intel avx instructions may run slower than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	intel® pt buffer overflow may result in incorrect packets										
problem	under complex micro-architectural conditions, an intel pt (processor trace) ovf (overflow) packet may be issued after the first byte of a multi-byte cyc (cycle count) packet, instead of any remaining bytes of the cyc.										
implication	when this erratum occurs, the splicing of the cyc and ovf packets may prevent the intel pt decoder from recognizing the overflow. the intel pt decoder may then encounter subsequent packets that are not consistent with expected behavior.										
workaround	none identified. the decoder may be able to recognize that this erratum has occurred when a two-byte cyc packet is followed by a single byte cyc, where the latter 2 bytes are 0xf302, and where the cyc packets are followed by a fup (flow update packet) and a psb+ (packet stream boundary+). it should then treat the two cyc packets as indicating an overflow.										
											
title	intel® pt psb+ packets may be omitted on a c6 transition										
problem	an intel pt (processor trace) psb+ (packet stream boundary+) set of packets may not be generated as expected when ia32_rtit_status.packetbytecnt[48:32] (msr 0x571) reaches the psb threshold and a logical processor c6 entry occurs within the following one kbyte of trace output.										
implication	after a logical processor enters c6, intel pt output may be missing psb+ sets of packets.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_perf_global_status.trace_topa_pmi bit cannot be set by software										
problem	a wrmsr that attempts to set trace_topa_pmi (bit 55) in the ia32_perf_global_status msr (38eh) by writing a ‘1’ to bit 55 in the ia32_perf_global_status_set (msr (391h) will cause a #gp fault.										
implication	software cannot set the trace_topa_pmi bit.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling vmx-preemption timer blocks hdc operation										
problem	hdc (hardware duty cycling) will not put the physical package into the forced idle state while any logical processor is in vmx non-root operation and the “activate vmx- preemption timer” vm-execution control is 1.										
implication	hdc will not provide the desired power reduction when the vmx-preemption timer is active in vmx non-root operation.										
workaround	none identified										
											
title	enclu[egetkey] instruction ignores miscmask value										
problem	the enclu[egetkey] instruction always generates seal, provision, and provision_seal keys as if the miscmask field in the keyrequest structure is 0.										
implication	the enclu[egetkey] instruction will generate the same keys for different miscmask values.										
workaround	software should not rely on enclu[egetkey] to produce different keys by supplying different miscmask values. software should use other keyrequest fields to produce separation of the keys.										
											
title	intel tsx abort may result in unpredictable system behavior										
problem	certain microarchitectural conditions during an intel® tsx (intel® transactional synchronization extensions) abort may result in unpredictable system behavior.										
implication	software using intel tsx may be unreliable.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	use of prefetch instructions may lead to a violation of memory ordering										
problem	under certain micro architectural conditions, execution of a prefetchh instruction or a prefetchw instruction may cause a load from the prefetched cache line to appear to execute before an earlier load from another cache line.										
implication	software that relies on loads executing in program order may not operate correctly.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	cs limit violation may not be detected										
problem	a cs (code segment) limit reduction may not be properly applied.										
implication	instructions may be executed beyond the cs limit. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	last level cache performance monitoring events may be inaccurate										
problem	the performance monitoring events longest_lat_cache.reference (event 2eh; umask 4fh) and longest_lat_cache.miss (event 2eh; umask 41h) count requests that reference or miss in the last level cache. however, due to this erratum, the count may be incorrect.										
implication	longest_lat_cache events may be incorrect.										
workaround	none identified. software may use the following offcore_requests model-specific sub events that provide related performance monitoring data: demand_data_rd, demand_code_rd, demand_rfo, all_data_rd, l3_miss_demand_data_rd, all_requests.										
											
title	#gp occurs rather than #db on code page split inside an intel® sgx enclave										
problem	when executing within an intel® sgx (software guard extensions) enclave, a #gp (general-protection exception) may be delivered instead of a #db (debug exception) when an instruction breakpoint is detected. this occurs when the instruction to be executed spans two pages, the second of which has an entry in the epcm (enclave page cache map) that is not valid.										
implication	debugging software may not be invoked when an instruction breakpoint is detected.										
workaround	software should ensure that all pages containing enclave instructions have valid epcm entries.										
											
title	execution of vaesenclast instruction may produce a #nm exception instead of a #ud exception										
problem	execution of vaesenclast with vex.l= 1 should signal a #ud (invalid opcode) exception, however, due to the erratum, a #nm (device not available) exception may be signaled.										
implication	as a result of this erratum, an operating system may restore intel avx and other state unnecessarily.										
workaround	none identified.										
											
title	intel® sgx enclave accesses to the apic-access page may cause apic-access vm exits										
problem	in vmx non-root operation, intel sgx (software guard extensions) enclave accesses to the apic-access page may cause apic-access vm exits instead of page faults.										
implication	a vmm (virtual-machine monitor) may receive a vm exit due to an access that should have caused a page fault, which would be handled by the guest os (operating system).										
workaround	a vmm avoids this erratum if it does not map any part of the epc (enclave page cache) to the guest’s apic-access address; an operating system avoids this erratum if it does not attempt indirect enclave accesses to the apic.										
											
title	cr3 filtering does not compare bits [11:5] of cr3 and ia32_rtit_cr3_match in pae paging mode										
problem	in pae paging mode, the cr3[11:5] are used to locate the page-directory-pointer table. due to this erratum, those bits of cr3 are not compared to ia32_rtit_cr3_match (msr 572h) when ia32_rtit_ctl.cr3filter (msr 570h, bit 7) is set.										
implication	if multiple page-directory-pointer tables are co-located within a 4kb region, cr3 filtering will not be able to distinguish between them so additional processes may be traced.										
workaround	none identified.										
											
title	intel® pt packeten change on c-state wake may not generate a tip packet										
problem	a tip.pge (target ip, packet generation enabled) or tip.pgd (target ip, packet generation disabled) packet may not be generated if intel pt (processor trace) packeten changes after ia32_rtit_status.filteren (msr 571h, bit 0) is re-evaluated on wakeup from c6 or deeper sleep state.										
implication	when code enters or exits an ip filter region without a taken branch, tracing may begin or cease without proper indication in the trace output. this may affect trace decoder behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	graphics configuration may not be correctly restored after a package c8 exit										
problem	the processor should ensure internal graphics configuration is restored during a package c8 or deeper exit event. due to this erratum, some internal graphics configurations may not be correctly restored.										
implication	when this erratum occurs, a graphics driver restart may lead to system instability. such a restart may occur when upgrading the graphics driver.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	x87 fdp value may be saved incorrectly										
problem	execution of the fsave, fnsave, fstenv, or fnstenv instructions in real-address mode or virtual-8086 mode may save an incorrect value for the x87 fdp (fpu data pointer). this erratum does not apply if the last non-control x87 instruction had an unmasked exception.										
implication	software operating in real-address mode or virtual-8086 mode that depends on the fdp value for non-control x87 instructions without unmasked exceptions may not operate properly.										
workaround	none identified. software should use the fdp value saved by the listed instructions only when the most recent non-control x87 instruction incurred an unmasked exception.										
											
title	peci frequency limited to 1 mhz										
problem	the peci (platform environmental control interface) 3.1 specification’s operating frequency range is 0.2 mhz to 2 mhz. due to this erratum, peci may be unreliable when operated above 1 mhz.										
implication	platforms attempting to run peci above 1 mhz may not behave as expected.										
workaround	none identified. platforms should limit peci operating frequency to 1 mhz.										
											
title	processor graphics iommu unit may not mask dma remapping faults										
problem	intel® virtualization technology for directed i/o specification specifies setting the fpd (fault processing disable) field in the context (or extended-context) entry of iommu to mask recording of qualified dma remapping faults for dma requests processed through that context entry. due to this erratum, the iommu unit for processor graphics device may record dma remapping faults from processor graphics device (bus: 0; device: 2; function: 0) even when the fpd field is set to 1.										
implication	software may continue to observe dma remapping faults recorded in the iommu fault recording register even after setting the fpd field.										
workaround	none identified. software may mask the fault reporting event by setting the im (interrupt mask) field in the iommu fault event control register (offset 038h in gfxvtbar).										
											
title	processor with intel® sgx support may hang during s3 wake or power-on reset										
problem	processors that support intel sgx (intel software guard extensions) may experience hangs when waking from s3 (standby) system sleep state or during a power-on reset. this erratum may occur even if the intel sgx feature is not enabled.										
implication	due to this erratum, the system may not wake after entering standby sleep state or may not start up after a power-on reset										
workaround	it is possible for the bios to contain a workaround for this erratum. for systems that do not power gate vcc sustain, if the workaround detects this erratum, support for intel sgx will be removed until platform power is disconnected and reapplied.										
											
title	pending x87 fpu exceptions (#mf) may be signaled earlier than expected										
problem	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executed while enhanced intel speedstep® technology transitions, intel® turbo boost technology transitions, or thermal monitor events occur, the pending #mf may be signaled before pending interrupts are serviced.										
implication	software may observe #mf being signaled before pending interrupts are serviced.										
workaround	none identified.										
											
title	ia core ratio change coincident with outstanding read to the de may cause a system hang										
problem	an outstanding read from an ia core to the de (display engine) that is coincident with an ia core ratio change may.result in a system hang.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	tsc is not affected by warm reset										
problem	the tsc (ia32_time_stamp_counter msr 10h) should be cleared on reset. due to this erratum the tsc is not affected by warm reset.										
implication	the tsc is not cleared by a warm reset. the tsc is cleared by power-on reset as expected.										
workaround	none identified.										
											
title	intel® pt buffer overflow indication may be lost if it immediately precedes a tracestop										
problem	if an intel pt (processor trace) internal buffer overflow occurs just before software executes a taken branch or event that enters an intel pt tracestop region, the ovf (overflow) packet may be lost.										
implication	when this erratum occurs, the decoder will not see the ovf packet or any tip.pgd (target ip – packet generation disabled) and may not see the tracestop packet at the end of the trace.										
workaround	none identified.										
											
title	intel® pt cycthresh value of 13 is not supported										
problem	intel pt (intel® processor trace) cyc (cycle count) threshold is configured through cycthresh field in bits [22:19] of ia32_rtit_ctl msr (570h). a value of 13 is advertised as supported by cpuid (leaf 14h, sub-lead 1h). due to this erratum, if cycthresh is set to 13 then the cyc threshold will be 0 cycles instead of 4096 (213-1) cycles.										
implication	cyc packets may be issued in higher rate than expected if threshold value of 13 is used.										
workaround	none identified. software should not use value of 13 for cyc threshold.										
											
title	intel® pt may drop some timing packets after entering thread c3										
problem	intel pt (intel® processor trace) may temporarily stop sending mtc (mini time counter) and cyc (cycle) packets after entering thread c3 state. mtc and cyc packets may be missing in up to 1kb of trace output after entering thread c3.										
implication	some intel pt timing packets may temporarily not be sent after thread c3 is entered.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	underflow and denormal conditions during a vdpps instruction with ymm operands may not produce the expected results										
problem	a vdpps (vector dot product of packed single precision floating-point values) instruction operating on ymm registers with denormal operand(s) or experiencing an underflow may not produce the expected result if the exception is masked in the mxcsr. this may also happen when intermediate multiply results have underflow conditions.										
implication	vdpps with ymm registers may not produce the expected result.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	apic timer interrupt may be delivered early										
problem	when the apic timer is configured to tsc deadline mode, a timer interrupt may occur before the expected deadline if any of ia32_tsc_deadline msr (6e0h) bits [63:56] are set.										
implication	a timer interrupt may be delivered earlier than specified by the ia32_tsc_deadline msr.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	system may hang when using intel® trusted execution technology (intel® txt) and memory that supports address mirroring										
problem	within platforms that utilize memory that supports address mirroring, processors that utilize intel txt (intel trusted execution technology) measured launch environment may fail to boot and hang.										
implication	due to this erratum, system may hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	display flicker may occur when both intel® virtualization technology for directed i/o (intel® vt-d) and fbc are enabled										
problem	display flickering may occur when both fbc (frame buffer compression) and intel vt-d (intel® virtualization technology for directed i/o) are enabled and in use by the display controller.										
implication	due to this erratum, display flickering may be observed.										
workaround	it is possible for the graphics driver to contain a workaround for this erratum. this workaround will disable fbc.										
											
title	certain processors may be configured with an incorrect tdp										
problem	certain processors should be configured with a tdp (thermal design power) limit of 54 or 51 watts. due to this erratum, these processors may be incorrectly configured at 65 w tdp. the following processors are affected by this erratum: intel® core™ i3 processor series, celeron® and pentium® (dual-core with gt1/gt2). a processor that reports a value of 0x208 in tdp_power_of_sku field in msr package_power_sku (msr 614h [14:0]) are affected by this erratum.										
implication	processors affected by this erratum may spend more time in turbo and thus may experience unexpected thermal throttling events.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	movntdqa from wc memory may pass earlier mfence instructions										
problem	an execution of movntdqa or vmovntdqa that loads from wc (write combining) memory may appear to pass an earlier execution of the mfence instruction.										
implication	when this erratum occurs, an execution of movntdqa or vmovntdqa may appear to execute before memory operations that precede the earlier mfence instruction. software that uses mfence to order subsequent executions of the movntdqa instructions may not operate properly.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	integrated audio codec may not be detected										
problem	integrated audio codec may lose power when lpsp (low-power single pipe) mode is enabled for an edp* (embedded display port) or hdmi ports. platforms with intel® smart sound technology (intel® sst) enabled are not affected.										
implication	the audio bus driver may attempt to do enumeration of codecs when edp or hdmi port enters lpsp mode, due to this erratum, the integrated audio codec will not be detected and audio maybe be lost.										
workaround	intel® graphics driver 15.40.11.4308 or later will prevent the integrated audio codec from losing power when lpsp mode is enabled.										
											
title	processor may hang or cause unpredictable system behavior										
problem	under complex microarchitecture conditions, processor may hang with an internal timeout error (mcacod 0400h) logged into ia32_mci_status or cause unpredictable system behavior.										
implication	when this issue occurs, the system may cause unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	rep movs may not operate correctly with ept enabled										
problem	execution of rep movs may incorrectly change [r/e]cx, [r/e]si, and/or [r/e]di register values during instruction execution. this erratum occurs only if the execution would set an accessed or dirty flag in a paging structure to which ept does not allow writes.										
implication	incorrect changes to rcx, rsi, and/or rdi may lead to a block-copy operation with an unexpected length, an unexpected source location, and/or an unexpected destination location.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ring frequency changes may cause a machine check and system hang										
problem	ring frequency changes may lead to a system hang with the processor logging a machine check in ia32_mci_status where the mcacod (bits[15:0]) value is 0x0402 and the mscod (bits[31:16]) value is 0x77yy (yy is any 8-bit value).										
implication	when this erratum occurs, the system will log a machine check and hang. power management activity, including system power state changes, can result in ring frequency changes that may trigger this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	x87 fpu data pointer updated only for instructions that incur unmasked exceptions										
problem	the x87 fpu data pointer points to the data (operand) for the last x87 non-control instruction executed, unless cpuid.(eax=07h,ecx=0h):ebx.fdp_excptn_only[bit 6] is 1, in which case it points to the operand for the last x87 non-control instruction that incurred an unmasked x87 exception. due to this erratum, x87 fpu data pointer behaves as if the fdp_excptn_only flag is 1 even when that bit is 0.										
implication	if the most recent x87 non-control instruction did not incur an unmasked x87 exception, software that then examines the x87 fpu data pointer will see an incorrect value. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	wrmsr to ia32_bios_updt_trig concurrent with an smx senter/ sexit may result in a system hang										
problem	performing wrmsr to ia32_bios_updt_trig (msr 79h) on a logical processor while another logical processor is executing an smx (safer mode extensions) senter/sexit operation (getsec[senter] or getsec[sexit] instruction) may cause the processor to hang.										
implication	when this erratum occurs, the system will hang. intel has not observed this erratum with any commercially available system.										
workaround	none identified.										
											
title	incorrect branch predicted bit in bts/btm branch records										
problem	bts (branch trace store) and btm (branch trace message) send branch records to the debug store management area and system bus respectively. the branch predicted bit (bit 4 of eighth byte in bts/btm records) should report whether the most recent branch was predicted correctly. due to this erratum, the branch predicted bit may be incorrect.										
implication	bts and btm cannot be used to determine the accuracy of branch prediction.										
workaround	none identified.										
											
title	machine_clears.memory_ordering performance monitoring event may undercount										
problem	the performance monitoring event machine_clears.memory_ordering (event c3h; umask 02h) counts the number of machine clears caused by memory ordering conflicts. however due to this erratum, this event may undercount for vgather*/ vpgather* instructions with four or more elements.										
implication	machine_clears.memory_ordering performance monitoring event may undercount.										
workaround	none identified.										
											
title	ctr_frz may not freeze some counters										
problem	ia32_perf_global_status.ctr_frz (msr 38eh, bit 59) is set when either (1) ia32_debugctl.freeze_perfmon_on_pmi (msr 1d9h, bit 12) is set and a pmi is triggered, or (2) software sets bit 59 of ia32_perf_global_status_set (msr 391h). when set, ctr_frz should stop all core performance monitoring counters from counting. however, due to this erratum, ia32_pmc4-7 (msr c5-c8h) may not stop counting. ia32_pmc4-7 are only available when a processor core is not shared by two logical processors.										
implication	general performance monitoring counters 4-7 may not freeze when ia32_perf_global_status.ctr_frz is set.										
workaround	none identified.										
											
title											
problem	the performance monitoring events inst_retired (event c0h; any umask value) and br_inst_retired (event c4h; any umask value) count instructions retired and branches retired, respectively. however, due to this erratum, these events may overcount in certain conditions when: executing vmaskmov* instructions with at least one masked vector element executing rep movs or rep stos with fast strings enabled (ia32_misc_enables msr (1a0h), bit 0 set) an intel mpx #br exception occurs on bndldx/bndstx instructions and the br_inst_retired (event c4h; umask is 00h or 04h) is used.										
implication	inst_retired and br_inst_retired performance monitoring events may overcount.										
workaround	none identified.										
											
title											
problem	the performance monitoring events offcore_response (events b7h and bbh) should count off-core responses matching the request-response configuration specified in msr_offcore_rsp_0 and msr_offcore_rsp_1 (1a6h and 1a7h, respectively) for core-originated requests. however, due to this erratum, dmnd_rfo (bit 1), dmnd_ifetch (bit 2) and other (bit 15) request types may overcount.										
implication	some offcore_response events may overcount.										
workaround	none identified. software may use the following model-specific events that provide related performance monitoring data: offcore_requests (all sub-events), l2_trans.l2_wb and l2_rqsts.pf_miss.										
											
title	using bios to disable cores may lead to a system hang										
problem	using the bios hardware core disable facility may cause the processor to hang when it attempts to enter or exit package c6.										
implication	when this erratum occurs, attempting to enter or exit package c6 state will hang the system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	#gp after rsm may push incorrect rflags value when intel® processor trace (intel® pt) is enabled										
problem	if intel pt is enabled, a #gp (general-protection exception) caused by the instruction fetch immediately following execution of an rsm instruction may push an incorrect value for rflags onto the stack.										
implication	software that relies on the rflags value pushed on the stack under the conditions described may not work properly.										
workaround	none identified.										
											
title	display flickering may be observed with specific edp panels										
problem	the processor may incorrectly configure transmitter buffer characteristics if the associated edp panel requests vesa equalization preset 3, 5, 6, or 8.										
implication	display flickering or display loss maybe observed.										
workaround	intel® graphics driver version 15.40.12.4326 or later contains a workaround for this erratum.										
											
title	pebs record may be generated after being disabled										
problem	a performance monitoring counter may generate a pebs (precise event based sampling) record after disabling pebs or the performance monitoring counter by clearing the corresponding enable bit in ia32_pebs_enable msr (3f1h) or ia32_perf_global_ctrl msr (38fh).										
implication	a pebs record generated after a vmx transition will store into memory according to the post-transition ds (debug store) configuration. these stores may be unexpected if pebs is not enabled following the transition.										
workaround	it is possible for the bios to contain a workaround for this erratum. a software workaround is possible through disallowing pebs during vmx non-root operation and disabling pebs prior to vm entry.										
											
title	mtf vm exit on xbegin instruction may save state incorrectly										
problem	execution of an xbegin instruction while the “monitor trap flag” vm-execution control is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save the address of the xbegin instruction as the instruction pointer (instead of the fallback instruction address specified by the xbegin instruction). in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.										
implication	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	access to intel sgx epc page in blocked state is not reported as an intel sgx-induced page fault										
problem	if a page fault results from an attempt to access a page in the intel sgx (intel® software guard extensions) epc (enclave page cache) that is in the blocked state, the processor does not indicate that the page fault was intel sgx-induced by setting bit 15 of the error code pushed on the stack.										
implication	due to this erratum, software may not recognize these page faults as being intel sgx- induced.										
workaround	before using the eblock instruction to marking a page as blocked, software should mark the page not present.										
											
title	software using intel® tsx may behave unpredictably										
problem	under a complex set of internal timing conditions and system events, software using the intel tsx (intel transactional synchronization extensions) instructions may behave unpredictably.										
implication	this erratum may result in unpredictable behavior of the software using intel tsx.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	dts2.0 fan control regulation is incorrect										
problem	the dts2.0 (digital thermal sensor, version 2.0) fan control temperature is incorrect.										
implication	due to this erratum, the incorrect fan control temperature may lead to the processor running hot enough to reach its thermal throttling point, unnecessarily reducing processor performance. other thermal control methods are not impacted by this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package-c6 exit latency may be higher than expected leading to display flicker										
problem	package-c6 exit latency may be higher than expected.										
implication	due to this erratum, the display may flicker or other isochronous devices may be affected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* ports do not support dll link active reporting										
problem	the pcie base specification requires every “downstream port that supports link speeds greater than 5.0 gt/s” to support dll (data link layer) link active reporting, however, the pcie ports do not support dll link active reporting.										
implication	due to this erratum, the pcie ports do not support dll link active reporting. this may be reported by a pcie compliance test.										
workaround	none identified.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	system may hang when edram is enabled and ddr is operating at 1600 mhz										
problem	when edram is enabled and the ddr operating frequency is 1600 mhz, a system hang may occur.										
implication	when this erratum occurs, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store or an mmx instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (that is, following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	package c3 exit latency may be longer than expected leading to display flicker										
problem	package c3 exit latency may be longer than expected.										
implication	when this erratum occurs on a system with multiple high resolution displays, the displays may flicker.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor ddr vref signals may briefly exceed jedec spec when entering s3 state										
problem	voltage glitch of up to 200 mv on the vref signal lasting for about 1 ms may be observed when entering system s3 state. this violates the jedec ddr specifications										
implication	intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	uncore performance monitoring counters may be disabled or cleared after package c7										
problem	after entering into package c7, the following uncore performance monitoring msrs may be cleared to zero: msr_ unc _perf_global_ctrl (e01h), msr_ unc _perf_global_status (e02h), msr_ unc _perf_fixed_ctrl (394h), msr_ unc _perf_fixed_ctr (395h).										
implication	uncore performance monitoring counters may be disabled and some counter state may be cleared after package c7.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	complex interactions with internal graphics may impact processor responsiveness										
problem	under complex conditions associated with the use of internal graphics, the processor may exceed the max_lat csr values (pci configuration space, offset 03fh, bits[7:0]).										
implication	when this erratum occurs, the processor responsiveness is affected. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title											
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	(management component transport protocol) header packets with tag 0x5 may be dropped										
problem	downstream mctp packets from the processor to the pch will be incorrectly routed during mctp device enumeration if the tag field of the mctp message header has a value of 0x5 and the routing type is route to root complex (type=0).										
implication	the device will function but cannot be mctp managed. note: this issue has only been observed with a synthetic test device where the mctp header field was set to 0x5.										
workaround	mctp devices should not use a tag of 0x5 when performing mctp enumeration.										
											
title	intel® pt topa pmi does not freeze performance monitoring counters										
problem	due to this erratum, if ia32_debugctl.freeze_perfmon_on_pmi (msr 1d9h, bit is set to 1 when intel pt (processor trace) triggers a topa (table of physical addresses) pmi (perfmon interrupt), performance monitoring counters are not frozen as expected.										
implication	performance monitoring counters will continue to count for events that occur during pmi handler execution.										
workaround	pmi handler software can programmatically stop performance monitoring counters upon entry.										
											
title	use of vmaskmov to store when using ept may fail										
problem	use of vmaskmov instructions to store data that splits over two pages, when the instruction resides on the first page may cause a hang if ept (extended page tables) is in use, and the store to the second page requires setting the a/d bits in the ept entry.										
implication	due to this erratum, the cpu may hang on the execution of vmaskmov.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	hwp’s maximum_performance value is reset to 0xff										
problem	according to hwp (hardware p-states) specification, the reset value of the maximum_performance field (bits [15:8]) in ia32_hwp_request msr (774h) should be set to the value of ia32_hwp_capabilities msr (771h) highest_performance field (bits[7:0]) after reset. due to this erratum, the reset value of maximum_performance is always set to 0xff.										
implication	software may see an unexpected value in maximum performance field. hardware clipping will prevent invalid performance states.										
workaround	none identified.										
											
title	hwp’s guaranteed_performance updated only on configurable tdp changes										
problem	according to hwp (hardware p-states) specification, the guaranteed_performance field (bits[15:8]) in the ia32_hwp_capabilities msr (771h) should be updated as a result of changes in the configuration of tdp, rapl (running average power limit), ratl and other platform tuning options that may have dynamic effects on the actual guaranteed performance support level. due to this erratum, the processor will update the guaranteed_performance field only as a result of configurable tdp dynamic changes.										
implication	software may read a stale value of the guaranteed _performance field.										
workaround	none identified										
											
title	hwp’s guaranteed_performance and relevant status/interrupt may be updated more than once per second										
problem	according to hwp (hardware p-states) specification, the guaranteed_performance field (bits[15:8]) in the ia32_hwp_capabilities msr (771h) and the guaranteed_performance_change (bit 0) bit in ia32_hwp_status msr (777h) should not be changed more than once per second nor should the thermal interrupt associated with the change to these fields be signaled more than once per second. due to this erratum, the processor may change these fields and generate the associated interrupt more than once per second.										
implication	hwp interrupt rate due to guaranteed_performance field change can be higher than specified.										
workaround	clearing the guaranteed_performance_change status bit no more than once per second will ensure that interrupts are not generated at too fast a rate.										
											
title	core and/or ring frequency may be briefly lower than expected after bios completes										
problem	due to this erratum, the core and ring frequencies may be lower than expected for up to several seconds after bios completes										
implication	processing immediately after bios completes may take longer than expected. the erratum does not cause any functional failures.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts										
problem	after a fault due to a failed pebs (processor event based sampling) or bts (branch trace store) address translation, the rf (resume flag) may be incorrectly set in the eflags image that is saved.										
implication	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.										
workaround	software should always prevent faults on pebs or bts.										
											
title	some memory performance monitoring events may produce incorrect results when filtering on either os or usr modes										
problem	the memory at-retirement performance monitoring events (listed below) may produce incorrect results when a performance counter is configured in os-only or usr-only modes (bits 17 or 16 in ia32_perfevtselx msr). counters with both os and usr bits set are not affected by this erratum. the list of affected memory at-retirement events is as follows: mem_inst_retired.stlb_miss_loads event d0h, umask 11h mem_inst_retired.stlb_miss_stores event d0h, umask 12h mem_inst_retired.lock_loads event d0h, umask 21h mem_inst_retired.split_loads event d0h, umask 41h mem_inst_retired.split_stores event d0h, umask 42h mem_load_retired.l2_hit event d1h, umask 02h mem_load_retired.l3_hit event d1h, umask 04h mem_load_retired.l4_hit event d1h, umask 80h mem_load_retired.l1_miss event d1h, umask 08h mem_load_retired.l2_miss event d1h, umask 10h mem_load_retired.l3_miss event d1h, umask 20h mem_load_retired.fb_hit event d1h, umask 40h mem_load_l3_hit_retired.xsnp_miss event d2h, umask 01h mem_load_l3_hit_retired.xsnp_hit event d2h, umask 02h mem_load_l3_hit_retired.xsnp_hitm event d2h, umask 04h mem_load_l3_hit_retired.xsnp_none event d2h, umask 08h										
implication	the listed performance monitoring events may produce incorrect results including pebs records generated at an incorrect point.										
workaround	none identified.										
											
title	ring_perf_limit_reasons may be incorrect										
problem	under certain conditions, ring_perf_limit_reasons (msr 6b1h) may incorrectly assert the other status bit (bit 8) as well as the other log bit (bit 24).										
implication	when this erratum occurs, software using this register will incorrectly report clipping because of the other reason.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	hwp may generate thermal interrupt while not enabled										
problem	due to this erratum, the conditions for hwp (hardware p-states) to generate a thermal interrupt on a logical processor may generate thermal interrupts on both logical processors of that core.										
implication	if two logical processors of a core have different configurations of hwp (e.g. only enabled on one), an unexpected thermal interrupt may occur on one logical processor due to the hwp settings of the other logical processor.										
workaround	software should configure hwp consistently on all logical processors of a core.										
											
title	camera device does not issue an msi when intx is enabled										
problem	when both msi (message signaled interrupts) and legacy intx are enabled by the camera device, intx is asserted rather than issuing the msi, in violation of the pci local bus specification.										
implication	due to this erratum, camera device interrupts can be lost leading to device failure.										
workaround	the camera device must disable legacy intx by setting bit 10 of pcicmd (bus 0;										
											
title	violations of intel sgx access-control requirements produce #gp instead of #pf										
problem	intel® software guard extensions (intel® sgx) define new access-control requirements on memory accesses. a violation of any of these requirements causes a page fault (#pf) that sets bit 15 (sgx) in the page-fault error code. due to this erratum, these violations instead cause general-protection exceptions (#gp).										
implication	software resuming from system sleep states s3 or s4 and relying on receiving a page fault from the above enclave accesses may not operate properly.										
workaround	software can monitor #gp faults to detect that an enclave has been destroyed and needs to be rebuilt after resuming from s3 or s4.										
											
title	pcie* and peg aer is not enabled										
problem	the pcie and peg (pcie* express graphics) aer (advanced error reporting) capability is not enabled for server/workstation skus.										
implication	software cannot use aer capabilities.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring counters may undercount when using cpl filtering										
problem	performance monitoring counters configured to count only os or only usr events by setting exactly one of bits 16 or 17 in ia32_perfevtselx msrs (186h-18dh) may not count for a brief period during the transition to a new cpl.										
implication	a measurement of ring transitions (using the edge-detect bit 18 in ia32_perfevtselx) may undercount, such as cpl_cycles.ring0_trans (event 5ch, umask 01h). additionally, the sum of an os-only event and a usr-only event may not exactly equal an event counting both os and usr. intel has not observed any other software-visible impact.										
workaround	none identified.										
											
title											
problem	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.										
implication	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.										
workaround	ensure that the smram state-save area is located entirely below the 4gb address boundary.										
											
title	certain non-canonical ia32_bndcfgs values will not cause vm- entry failures										
problem	if the vm-entry controls load ia32_bndcfgs field (bit 16) is 1, vm-entry should fail when the value of the guest ia32_bndcfgs field in the vmcs is not canonical (that is, when bits 63:47 are not identical). due to this erratum, vm-entry does not fail if bits 63:48 are identical but differ from bit 47. in this case, vm-entry loads the ia32_bndcfgs msr with a value in which bits 63:48 are identical to the value of bit 47 in the vmcs field.										
implication	if the value of the guest ia32_bndcfgs field in the vmcs is not canonical, vm-entry may load the ia32_bndcfgs msr with a value different from that of the vmcs field.										
workaround	none identified.										
											
title	pebs eventingip field may be incorrect under certain conditions										
problem	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.										
implication	when this erratum occurs, performance monitoring software may not attribute the pebs events to the correct instruction.										
workaround	none identified.										
											
title	executing a 256 bit intel avx instruction may cause unpredictable behavior										
problem	under complex micro-architectural conditions, executing a 256 intel avx bit instruction may result in unpredictable system behavior.										
implication	when this erratum occurs, the system may behave unpredictably.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	an x87 store instruction which pends #pe may lead to unexpected behavior when ept a/d is enabled.										
problem	an x87 store instruction which causes a #pe (precision exception) to be pended and updates an ept (extended page tables) a/d bit and causes a vm exit (such as ept violation or #pf vm exit) may lead to unexpected behavior.										
implication	the vmm may experience unexpected x87 fault or a machine check exception with the value of 0x150 in ia32_mc0_status.mcacod (bits [15:0] in msr 401h)										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci may not be functional after power on or s3/s4/s5 resume										
problem	when resuming from s3/s4/s5 or following a power on, peci may fail to function properly.										
implication	when this erratum occurs, the peci does not respond to any command.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a system hang or machine check may occur when edram is enabled										
problem	when edram is enabled, the processor may experience a hang or a machine check exception with an error reported in ia32_mc10_status.										
implication	when this erratum occurs, the system will generate a machine check error or hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	load latency performance monitoring facility may stop counting										
problem	the performance monitoring events mem_trans_retired.load_latency_* (event cdh; umask 01h; any latency) count load instructions whose latency exceed a predefined threshold, where the loads are randomly selected using the load latency facility (pebs extension). however due to this erratum, load latency facility may stop counting load instructions when intel® hyper-threading technology is enabled.										
implication	counters programmed with the affected events stop incrementing and do not generate pebs records.										
workaround	none identified.										
											
title	bndldx and bndstx may not signal #gp on non-canonical bound directory access										
problem	bndldx and bndstx instructions access the bound’s directory and table to load or store bounds. these accesses should signal #gp (general protection exception) when the address is not canonical (i.e., bits 48 to 63 are not the sign extension of bit 47). due to this erratum, #gp may not be generated by the processor when a non-canonical address is used by bndldx or bndstx for their bound directory memory access.										
implication	intel has not observed this erratum with any commercially available software.										
workaround	software should use canonical addresses for bound directory accesses.										
											
title	dts temperature reading may be inaccurate on ddr4 systems										
problem	the temperature reported by the dts (digital thermal sensor) on ddr4 systems may vary from the actual temperature by +5°c to -15°c rather than the specified ±5°c.										
implication	when this erratum occurs, cpu throttling may occur later than expected. intel has not observed this erratum to have any impact on system.										
workaround	none identified.										
											
title	performance monitoring load latency events may be inaccurate for gather instructions										
problem	the performance monitoring events mem_trans_retired.load_latency_* (event cdh; umask 01h; any latency) count load instructions whose latency exceed a predefined threshold, where the loads are randomly selected using the load latency facility (an extension of pebs). however due to this erratum, these events may count incorrectly for vgather*/vpgather* instructions.										
implication	the load latency performance monitoring events may be inaccurate for gather instructions.										
workaround	none identified.										
											
title	ia32_rtit_cr3_match msr bits[11:5] are treated as reserved										
problem	due to this erratum, bits[11:5] in ia32_rtit_cr3_match (msr 572h) are reserved; an msr write that attempts to set that field to a non-zero value will result in a #gp fault.										
implication	the inability to write the identified bit field does not affect the functioning of intel® pt (intel® processor trace) operation because, as described in erratum skl061, the bit field that is the subject of this erratum is not used during intel pt cr3 filtering.										
workaround	ensure that bits 11:5 of the value written to ia32_rtit_cr3_match are zero, including cases where the selected page-directory-pointer-table base address has non- zero bits in this range.										
											
title	apic timer interrupt may not be generated at the correct time in tsc-deadline mode										
problem	after writing to the ia32_tsc_adjust msr (3bh), any subsequent write to the ia32_tsc_deadline msr (6e0h) may incorrectly process the desired deadline. when this erratum occurs, the resulting timer interrupt may be generated at the incorrect time.										
implication	when the local apic (advanced programmable interrupt controller) timer is configured for tsc-deadline mode, a timer interrupt may be generated much earlier than expected or much later than expected. intel has not observed this erratum with most commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	some bits in msr_misc_pwr_mgmt may be updated on writing illegal values to this msr										
problem	attempts to write illegal values to msr_misc_pwr_mgmt (msr 0x1aa) result in #gp (general protection fault) and should not change the msr value. due to this erratum, some bits in the msr may be updated on writing an illegal value.										
implication	certain fields may be updated with allowed values when writing illegal values to msr_misc_pwr_mgmt. such writes will always result in #gp as expected.										
workaround	none identified. software should not attempt to write illegal values to this msr.										
											
title	unpredictable system behavior may occur when system agent enhanced intel speedstep® technology is enabled										
problem	under complex system conditions, system agent enhanced intel speedstep® technology may result in unpredictable system behavior.										
implication	when this erratum occurs, the system may behave unpredictably.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor may hang under complex scenarios										
problem	under complex micro-architectural conditions, the processor may hang with an internal timeout error (mcacod 0400h) logged into ia32_mci_status.										
implication	this erratum results in a processor hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the intel pt cr3 filter is not re-evaluated on vm entry										
problem	on a vmresume or vmlaunch with both traceen[0] and cr3filter[7] in ia32_rtit_ctl (msr 0570h) set to 1 both before the vm entry and after, the new value of cr3 is not compared with ia32_rtit_cr3_match (msr 0572h).										
implication	the intel pt (processor trace) cr3 filtering mechanism may continue to generate packets despite a mismatching cr3 value, or may fail to generate packets despite a matching cr3, as a result of an incorrect value of ia32_rtit_status.contexten[1] (msr 0571h) that results from the failure to re-evaluate the cr3 match on vm entry.										
workaround	none identified.										
											
title	display slowness may be observed under certain display commands scenario										
problem	back-to-back accesses to the vga register ports (i/o addresses 0x3c2, 0x3ce, 0x3cf) will experience higher than expected latency.										
implication	due to this erratum, the processor may redraw the screen slowly when in vga mode.										
workaround	none identified.										
											
title	cpuid tlb associativity information is inaccurate										
problem	cpuid leaf 2 (eax=02h) tlb information inaccurately reports that the shared 2nd- level tlb is 6-way set associative (value c3h), although it is 12-way set associative. other information reported by cpuid leaf 2 is accurate.										
implication	software that uses cpuid shared 2nd-level tlb associativity information for value c3h may operate incorrectly. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	none identified. software should ignore the shared 2nd-level tlb associativity information reported by cpuid for the affected processors.										
											
title	short loops which use ah/bh/ch/dh registers may cause unpredictable system behavior										
problem	under complex micro-architectural conditions, short loops of less than 64 instructions that use ah, bh, ch or dh registers as well as their corresponding wider register (for example, rax, eax or ax for ah) may cause unpredictable system behavior. this can only happen when both logical processors on the same physical processor are active.										
implication	due to this erratum, the system may experience unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor graphics may render incorrectly or may hang following warm reset with package c8 disabled										
problem	processor graphics may not properly restore internal configuration after warm reset when package c8 is disabled.										
implication	due to this erratum processor graphics may render incorrectly or hang on warm reset.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	unpredictable system behavior may occur in ddr4 multi-rank system										
problem	due to incorrect configuration of ddr4 odt by bios, it is possible for a multi-rank system to violate section 4.27 of the ddr4 jedec spec revision jesed79-4a.										
implication	due to this erratum, complex microarchitectural conditions may result in unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	processor may hang on complex sequence of conditions										
problem	a complex set of architectural and micro-architectural conditions may lead to a processor hang with an internal timeout error (mcacod 0400h) logged into ia32_mci_status. when both logical processors in a core are active, this erratum will not occur unless there is no store on one of the logical processors for more than 10 seconds.										
implication	this erratum may result in a processor hang. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	display artifacts may be seen with high bandwidth, multiple display configurations										
problem	with high bandwidth, multiple display configurations, display engine underruns may occur.										
implication	due to this erratum, the display engine may generate display artifacts.										
workaround	this erratum can be worked around by intel graphics driver revisions of 15.46.4.64.4749 or later.										
											
title	spurious corrected errors may be reported										
problem	due to this erratum, spurious corrected errors may be logged in the ia32_mc0_status msr (401h) register with the valid field (bit 63) set, the uncorrected error field bit (bit 61) not set, a model specific error code (bits [31:16]) of 0x0001, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.										
implication	when this erratum occurs, software may see an unusually high rate of reported corrected errors. as it is not possible to distinguish between spurious and non-spurious errors, this erratum may interfere with reporting non-spurious corrected errors.										
workaround	none identified.										
											
title	masked bytes in a vector masked store instructions may cause write back of a cache line										
problem	vector masked store instructions to wb (write-back) memory-type that cross cache lines may lead to cpu writing back cached data even for cache lines where all of the bytes are masked.										
implication	the processor may generate writes of un-modified data. this can affect mmio (memory mapped io) or non-coherent agents in the following ways: for mmio range that is mapped as wb memory type, this erratum may lead to mce (machine check exception) due to writing back data into the mmio space. this applies only to cross page vector masked stores where one of the pages is in mmio range. if the cpu cached data is stale, for example in the case of memory written directly by a non-coherent agent (agent that uses non-coherent writes), this erratum may lead to writing back stale cached data even if these bytes are masked.										
workaround	platforms should not map mmio memory space or non-coherent device memory space as wb memory. if wb is used for mmio range, software or vmm should not map such										
											
title	processor may incorrectly assert prochot during pkgc10										
problem	if the prochot# pin is configured as an output-only signal, prochot# may incorrectly be asserted during pkgc10.										
implication	when this erratum occurs, prochot# may be incorrectly asserted. this can lead to the system fan unnecessarily turning on during pkgc10 or other unexpected platform behaviors.										
workaround	none identified.										
											
title	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception										
problem	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.										
implication	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software or system.										
workaround	as recommended in the ia32 intel® architecture software developer’s manual, the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang										
problem	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).										
implication	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.										
workaround	none identified.										
											
title	b0-b3 bits in dr6 for non-enabled breakpoints may be incorrectly set										
problem	some of the b0-b3 bits (breakpoint conditions detect flags, bits [3:0]) in dr6 may be incorrectly set for non-enabled breakpoints when the following sequence happens: mov or pop instruction to ss (stack segment) selector; next instruction is fp (floating point) that gets fp assist another instruction after the fp instruction completes successfully a breakpoint occurs due to either a data breakpoint on the preceding instruction or a code breakpoint on the next instruction. due to this erratum a non-enabled breakpoint triggered on step 1 or step 2 may be reported in b0-b3 after the breakpoint occurs in step 4.										
implication	due to this erratum, b0-b3 bits in dr6 may be incorrectly set for non-enabled breakpoints.										
workaround	software should not execute a floating point instruction directly after a mov ss or pop ss instruction.										
											
title	changing the memory type for an in-use page translation may lead to memory-ordering violations										
problem	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.										
implication	memory ordering may be violated. intel has not observed this erratum with any commercially available software.										
workaround	software should ensure pages are not being actively used before requesting their memory type be changed.										
											
title	code segment limit/canonical faults on rsm may be serviced before higher priority interrupts/exceptions and may push the wrong address onto the stack										
problem	normally, when the processor encounters a segment limit or canonical fault due to code execution, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. due to this erratum, if rsm (resume from system management mode) returns to execution flow that results in a code segment limit or canonical fault, the #gp fault may be serviced before a higher priority interrupt or exception (for example, nmi (non-maskable interrupt), debug break(#db), machine check (#mc), and so forth). if the rsm attempts to return to a non-canonical address, the address pushed onto the stack for this #gp fault may not match the non-canonical address that caused the fault.										
implication	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	corruption of cs segment register during rsm while transitioning from real mode to protected mode										
problem	during the transition from real mode to protected mode, if an smi (system management interrupt) occurs between the mov to cr0 that sets pe (protection enable, bit 0) and the first far jmp, the subsequent rsm (resume from system management mode) may cause the lower two bits of cs segment register to be corrupted.										
implication	the corruption of the bottom two bits of the cs segment register will have no impact unless software explicitly examines the cs segment register between enabling protected mode and the first far jmp. intel® 64 and ia-32 architectures software developer’s manual volume 3a: system programming guide, part 1, in the section titled “switching to protected mode” recommends the far jmp immediately follows the write to cr0 to enable protected mode. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	debug exception flags dr6.b0-b3 flags may be incorrect for disabled breakpoints										
problem	when a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (dr7.g0-g3 and dr7.l0-l3), the dr6.b0-b3 flags may be incorrect.										
implication	the debug exception dr6.b0-b3 flags may be incorrect for the load if the corresponding breakpoint enable flag in dr7 is disabled.										
workaround	none identified.										
											
title	dr6 may contain incorrect information when the first instruction after a mov ss,r/m or pop ss is a store										
problem	normally, each instruction clears the changes in dr6 (debug status register) caused by the previous instruction. however, the instruction following a mov ss,r/m (mov to the stack segment selector) or pop ss (pop stack segment selector) instruction will not clear the changes in dr6 because data breakpoints are not taken immediately after a mov ss,r/m or pop ss instruction. due to this erratum, any dr6 changes caused by a mov ss,r/m or pop ss instruction may be cleared if the following instruction is a store.										
implication	when this erratum occurs, incorrect information may exist in dr6. this erratum will not be observed under normal usage of the mov ss,r/m or pop ss instructions (that is, following them with an instruction that writes [e/r]sp). when debugging or when developing debuggers, this behavior should be noted.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	fault on enter instruction may result in unexpected values on stack frame										
problem	the enter instruction is used to create a procedure stack frame. due to this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (that is, residual stack data as a result of processing the fault).										
implication	data in the created stack frame may be altered following a fault on the enter instruction. please refer to “procedure calls for block-structured languages” in ia-32 intel® architecture software developer’s manual, vol. 1, basic architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3. faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. intel has not observed this erratum on any commercially available software.										
workaround	none identified.										
											
title	faulting mmx instruction may incorrectly update x87 fpu tag word										
problem	under a specific set of conditions, mmx stores (movd, movq, movntq, maskmovq) which cause memory access faults (#gp, #ss, #pf, or #ac), may incorrectly update the x87 fpu tag word register. this erratum will occur when the following additional conditions are also met. the mmx store instruction must be the first mmx instruction to operate on x87 fpu state (that is, the x87 fp tag word is not already set to 0x0000). for movd, movq, movntq stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to maskmovq).										
implication	if the erratum conditions are met, the x87 fpu tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.										
workaround	none identified.										
											
title											
problem	in general, a pebs record should be generated on the first count of the event after the counter has overflowed. however, ia32_debugctl_msr.freeze_while_smm (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if: a performance counter overflowed before an smi a pebs record has not yet been generated because another count of the event has not occurred the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.										
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.										
workaround	none identified.										
											
title	general protection fault (#gp) for instructions greater than 15 bytes may be preempted										
problem	when the processor encounters an instruction that is greater than 15 bytes in length, a #gp is signaled when the instruction is decoded. under some circumstances, the #gp fault may be preempted by another lower priority fault (for example, page fault (#pf)). however, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #gp fault will occur.										
implication	software may observe a lower-priority fault occurring before or in lieu of a #gp fault. instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.										
workaround	none identified.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	io_smi indication in smram state save area may be set incorrectly										
problem	the io_smi bit in smram’s location 7fa4h is set to “1” by the cpu to indicate a system management interrupt (smi) occurred as the result of executing an instruction that reads from an i/o port. due to this erratum, the io_smi bit may be incorrectly set by: a non-i/o instruction smi is pending while a lower priority event interrupts a rep i/o read a i/o read that redirects to mwait										
implication	smm handlers may get false io_smi indication.										
workaround	the smm handler has to evaluate the saved context to determine if the smi was triggered by an instruction that read from an i/o port. the smm handler must not restart an i/o instruction if the platform has not been configured to generate a synchronous smi for the recorded i/o port address.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title											
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.										
workaround	none identified.										
											
title											
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	mov to/from debug registers causes debug exception										
problem	when in v86 mode, if a mov instruction is executed to/from a debug registers, a general-protection exception (#gp) should be generated. however, in the case when the general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.										
implication	with debug-register protection enabled (that is, the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception will be generated instead of the expected general-protection fault.										
workaround	in general, operating systems do not set the gd bit when they are in v86 mode. the gd bit is generally set and used by debuggers. the debug exception handler should check that the exception did not occur in v86 mode before continuing. if the exception did occur in v86 mode, the exception may be directed to the general-protection exception handler.										
											
title	pebs record not updated when in probe mode										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflows of the counter can result in storage of a pebs record in the pebs buffer. due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new pebs record may not be added to the pebs buffer.										
implication	due to this erratum, the pebs buffer may not be updated by overflows that occur during probe mode.										
workaround	none identified.										
											
title	rep movs/stos executing with fast strings enabled and crossing page boundaries with inconsistent memory types may use an incorrect data size or lead to memory-ordering violations.										
problem	under certain conditions as described in the software developers manual section “out- of-order stores for string operations in pentium® 4, intel® xeon®, and p6 family processors” the processor performs rep movs or rep stos as fast strings. due to this erratum fast string rep movs/rep stos instructions that cross page boundaries from wb/wc memory types to uc/wp/wt memory types, may start using an incorrect data size or may observe memory ordering violations.										
implication	upon crossing the page boundary the following may occur, dependent on the new page memory type: uc the data size of each write will now always be 8 bytes, as opposed to the original data size. wp the data size of each write will now always be 8 bytes, as opposed to the original data size and there may be a memory ordering violation. wt there may be a memory ordering violation.										
workaround	software should avoid crossing page boundaries from wb or wc memory type to uc, wp or wt memory type within a single rep movs or rep stos instruction that will execute with fast strings enabled.										
											
title	reported memory type may not be used to access the vmcs and referenced data structures										
problem	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.										
implication	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.										
workaround	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.										
											
title	single step interrupts with floating point exception pending may be mishandled										
problem	in certain circumstances, when a floating point exception (#mf) is pending during single-step execution, processing of the single-step debug exception (#db) may be mishandled.										
implication	when this erratum occurs, #db will be incorrectly handled as follows: #db is signaled before the pending higher priority #mf (interrupt 16) #db is generated twice on the same instruction										
workaround	none identified.										
											
title	storage of pebs record delayed following execution of mov ss or sti										
problem	when a performance monitoring counter is configured for pebs (precise event based sampling), overflow of the counter results in storage of a pebs record in the pebs buffer. the information in the pebs record represents the state of the next instruction to be executed following the counter overflow. due to this erratum, if the counter overflow occurs after execution of either mov ss or sti, storage of the pebs record is delayed by one instruction.										
implication	when this erratum occurs, software may observe storage of the pebs record being delayed by one instruction following execution of mov ss or sti. the state information in the pebs record will also reflect the one instruction delay.										
workaround	none identified.										
											
title	the processor may report a #ts instead of a #gp fault										
problem	a jump to a busy tss (task-state segment) may cause a #ts (invalid tss exception) instead of a #gp fault (general protection exception).										
implication	operation systems that access a busy tss may get invalid tss fault instead of a #gp fault. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	vm exits due to “nmi-window exiting” may be delayed by one instruction										
problem	if vm entry is executed with the “nmi-window exiting” vm-execution control set to 1, a vm exit with exit reason “nmi window” should occur before execution of any instruction if there is no virtual-nmi blocking, no blocking of events by mov ss, and no blocking of events by sti. if vm entry is made with no virtual-nmi blocking but with blocking of events by either mov ss or sti, such a vm exit should occur after execution of one instruction in vmx non-root operation. due to this erratum, the vm exit may be delayed by one additional instruction.										
implication	vmm software using “nmi-window exiting” for nmi virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual nmi, which is virtually asynchronous. the erratum may affect vmms relying on deterministic delivery of the affected vm exits.										
workaround	none identified.										
											
title	valuesfor lbr/bts/btmwillbe incorrectafteran exitfrom smm										
problem	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect. note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.										
implication	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.										
workaround	none identified.										
											
title	vphminposuw instruction in vex format does not signal #ud (invalid opcode exception) when vex.vvvv !=1111										
problem	processor does not signal #ud fault when executing the reserved instruction vphminposuw with vex.vvvv!=1111. the vphminposuw instruction is described in greater detail in the intel® advanced vector extensions programming reference.										
implication	executing vphminposuw with vex.vvvv != 1111 results in same behavior as vex.vvvv= 1111.										
workaround	sw should not use vphminposuw with vex.vvvv != 1111 in order to ensure future compatibility.										
											
title	pending x87 fpu exceptions (#mf) may be signaled earlier than expected										
problem	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executed while enhanced intel speedstep® technology transitions, intel® turbo boost technology transitions, or thermal monitor events occur, the pending #mf may be signaled before pending interrupts are serviced.										
implication	software may observe #mf being signaled before pending interrupts are serviced. workaround none identified.										
workaround											
											
title											
problem	the intel® 64 and ia-32 architectures software developer’s manual, volume 2b states that execution of vmread or vmwrite should fail if the value of the instruction’s register source operand corresponds to an unsupported field in the vmcs (virtual machine control structure). the correct operation is that the logical processor will set the zf (zero flag), write 0ch into the vm-instruction error field and for vmread leave the instruction’s destination operand unmodified. due to this erratum, the instruction may instead clear the zf, leave the vm-instruction error field unmodified and for vmread modify the contents of its destination operand.										
implication	accessing an unsupported field in vmcs will fail to properly report an error. in addition, vmread from an unsupported vmcs field may unexpectedly change its destination operand. intel has not observed this erratum with any commercially available software.										
workaround	software should avoid accessing unsupported fields in a vmcs.										
											
title	unexpected #ud on vzeroall/vzeroupper										
problem	execution of the vzeroall or vzeroupper instructions in 64-bit mode with vex.w set to 1 may erroneously cause a #ud (invalid-opcode exception).										
implication	the affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.										
workaround	compilers should encode vex.w = 0 for the vzeroall and vzeroupper instructions.										
											
title	execution of opcode 9bh with the vex opcode extension may produce a #nm exception										
problem	attempt to use opcode 9bh with a vex opcode extension should produce a #ud (invalid-opcode) exception. due to this erratum, if cr0.mp and cr0.ts are both 1, the processor may produce a #nm (device-not-available) exception if one of the following conditions exists: 66h, f2h, f3h or rex as a preceding prefix; an illegal map specified in the vex.mmmmm field;										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should not use opcode 9bh with the vex opcode extension.										
											
title	an unexpected page fault or ept violation may occur after another logical processor creates a valid translation for a page										
problem	an unexpected page fault (#pf) or ept violation may occur for a page under the following conditions: the paging structures initially specify no valid translation for the page. software on one logical processor modifies the paging structures so that there is a valid translation for the page (for example, by setting to 1 the present bit in one of the paging-structure entries used to translate the page). software on another logical processor observes this modification (for example, by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). shortly thereafter, software on that other logical processor performs a store to a linear address on the page. in this case, the store may cause a page fault or ept violation that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). intel has not observed this erratum with any commercially available software.										
implication	an unexpected page fault may be reported. there are no other side effects due to this erratum.										
workaround	system software can be constructed to tolerate these unexpected page faults. see section “propagation of paging-structure changes to multiple processors” of volume 3a of ia-32 intel® architecture software developer’s manual, for recommendations for software treatment of asynchronous paging-structure updates.										
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not- available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	unexpected #ud on vpextrd/vpinsrd										
problem	execution of the vpextrd or vpinsrd instructions outside of 64-bit mode with vex.w set to 1 may erroneously cause a #ud (invalid-opcode exception).										
implication	the affected instructions may produce unexpected invalid-opcode exceptions outside 64-bit mode.										
workaround	software should encode vex.w = 0 for executions of the vpextrd and vpinsrd instructions outside 64-bit mode.										
											
title											
problem	when a 2-byte opcode of a conditional branch (opcodes 0f8xh, for any value of x) instruction resides in 16-bit code-segment and is associated with invalid vex prefix, it may sometimes signal a #gp fault (illegal instruction length > 15-bytes) instead of a #ud (illegal opcode) fault.										
implication	due to this erratum, #gp fault instead of a #ud may be signaled on an illegal instruction.										
workaround	none identified.										
											
title											
problem	the “from” address associated with the lbr (last branch record), btm (branch trace message) or bts (branch trace store) may be incorrect for the first branch after a transition of: enhanced intel speedstep® technology t-state (thermal monitor states) s1-state (acpi package sleep state) c1e (enhanced c1 low power state) adaptive thermal throttling										
implication	when the lbrs, btm or bts are enabled, some records may have incorrect branch “from” addresses for the first branch after a transition of enhanced intel speedstep® technology, t-states, s-states, c1e, or adaptive thermal throttling.										
workaround	none identified.										
											
title											
problem	under specific internal conditions, if software tries to write the ia32_fixed_ctr1 msr (30ah) a value that has all bits [31:1] set while the counter was just about to overflow when the write is attempted (that is, its value was 0xffff ffff ffff), then due to this erratum the new value in the msr may be corrupted.										
implication	due to this erratum, ia32_fixed_ctr1 msr may be written with a corrupted value. workaround software may avoid this erratum by writing zeros to the ia32_fixed_ctr1 msr,										
workaround											
											
title	l1 data cache errors may be logged with level set to 1 instead of 0										
problem	when an l1 data cache error is logged in ia32_mci_status[15:0], which is the mca error code field, with a cache error type of the format 0000 0001 rrrr ttll, the ll field may be incorrectly encoded as 01b instead of 00b.										
implication	an error in the l1 data cache may report the same ll value as the l2 cache. software should not assume that an ll value of 01b is the l2 cache.										
workaround	none identified.										
											
title	warm reset may leave the system in an invalid poisoning state and could cause the feature to be disabled										
problem	due to this erratum, the pcie poison forwarding enable and intel® quickpath interconnect (intel® qpi) poison enable bits are cleared by warm reset, but other bits related to the poisoning feature remain set. after the warm reset the system may be in an invalid state in regards to the poisoning bits. this invalid state may cause the feature to be disabled.										
implication	this invalid state may prevent the propagation of the poisoning indication, effectively disabling the feature.										
workaround	if poisoning is disabled, program the following bits to 0 after reset. if poisoning is enabled, program the following bits to 1 after reset:										
											
title	vm entries that return from smm using vmlaunch may not update the launch state of the vmcs										
problem	successful vm entries using the vmlaunch instruction should set the launch state of the vmcs to “launched”. due to this erratum, such a vm entry may not update the launch state of the current vmcs if the vm entry is returning from smm.										
implication	subsequent vm entries using the vmresume instruction with this vmcs will fail. rflags.zf is set to 1 and the value 5 (indicating vmresume with non-launched vmcs) is stored in the vm-instruction error field. this erratum applies only if dual monitor treatment of smi and smm is active.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	interrupt from local apic timer may not be detectable while being delivered										
problem	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.										
implication	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.										
workaround	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.										
											
title	poison packets will be reported to pcie port 1a when forwarded to port 1b										
problem	with respect to data poisoning, the processor iio module supports forwarding poisoned information between the coherent interface and pcie and vice-versa. also the processor iio module supports forwarding poisoned data between peer pcie ports. when the pcie ports 1a and 1b are configured as x4, the outbound poison error is reported on port 1a when a poison packet is forwarded to port 1b.										
implication	when ports 1a and 1b are configured as x4 ports, poison errors reported on the root port are unreliable.										
workaround	none identified.										
											
title	ia32_mci_addr overwritten in the case of multiple recoverable instruction fetch errors										
problem	the instruction fetch machine check error (mcacod 0x150) is a srar (software recoverable action required) error. the address of the location with the error is provided in the corresponding ia32_mci_addr msr. when multiple instruction fetch errors are logged as part of a single machine check event, as indicated by setting of the overflow (bit 62) in the ia32_mci_status msr, then recovery is not possible. due to this erratum, when multiple instruction fetch errors are logged in the same bank, the ia32_mci_misc msr contains all of the correct information including the proper setting for overflow (bit 62); however, the ia32_mci_addr msr is overwritten with a value that corresponds to neither the first or second error.										
implication	when debugging failures associated with the instruction fetch machine check error and the overflow bit is set, the value in ia32_mci_addr will not be valid.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	according to the intel qpi specification, if a target agent receives a packet with a non- zero rsvd_chk field, it should flag it as an “intel qpi link layer detected unsupported/undefined” packet. due to this erratum, the processor does not check the rsvd_chk field nor report the expected error.										
implication	the processor will not flag the “intel qpi link layer detected unsupported/undefined” packet error in the case that the rsvd_chk field is non-zero.										
workaround	none identified.										
											
title	the intel qpi link status register linkinitstatus field incorrectly reports “internal stall link initialization” for certain stall conditions										
problem	the intel qpi link control register (cpubus(1), devices 8, 9; function 0; offset 0x44) bits 17 and 16 allow for the control of the link layer initialization by forcing the link to stall the initialization process until cleared. the intel qpi link status register (cpubus(1), device 8, 9; function 0; offset 0x48) bits 27:24 report the link initialization status (linkinitstatus). the linkinitstatus incorrectly reports “internal stall link initialization” (0001b) for non-intel qpi link control register, bit[17,16] stall conditions. the intel qpi specification does not intend for internal stall conditions to report that status, but rather report the normal “waiting for physical layer ready” (0000b).										
implication	there is no known problem with this behavior since there is no usage model that relies on polling of the linkinitstatus state in the “waiting for physical layer ready” versus “internal stall link initialization” state, and it only advertises the “internal stall link initialization” state for a brief period of time during link layer initialization.										
workaround	none identified.										
											
title	intel qpi tx ac common mode fails specification										
problem	the intel qpi interface specification requires tx ac common mode (accm) to be between -50 mv to 50 mv at 8.0 gt/s. testing across process, voltage, and temperature showed that the accm exceeded the upper end of the specification on several lanes.										
implication	those performing an electrical characterization of the intel qpi interface may notice a violation of the upper end of the accm specification by no more than 5 mv.										
workaround	none identified.										
											
title	prochot_n assertion during warm reset may disable a processor via the frb mechanism										
problem	frb (fault resilient booting) is defined as the ability to boot even when one or more processors in the system fail, as long as there is one processor functional. if a warm reset is asserted during the boot flow before the intel qpi interface is enumerated and while a processor is hot and drives prochot_n, the processor that is driving prochot_n will mistakenly observe prochot_n as a signal to transition itself into frb mode.										
implication	it is possible that a processor may be incorrectly isolated via the frb mechanism if the same processor asserts prochot_n during a warm reset.										
workaround	case 1: systems with a bmc										
											
title	the pcie* current compensation value default is incorrect										
problem	the default current compensation values for pcie buffers may result in non-optimal performance.										
implication	the pcie buffers will not perform as well as possible and performance could be compromised.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	the pcie* link at 8.0 gt/s is transitioning too soon to normal operation while training										
problem	the pcie bus uses high speed serial links that must go through a training process to allow both transmitter and receiver to make adjustments in behavior to optimize the signaling between the transmitter and receiver. when a pcie compliant device must train or retrain the link, training sequences are used. the device must allow enough time for the training to complete before transitioning to normal operation. in the case of pcie equalization at 8.0 gt/s the processor is not allowing enough time to optimize signaling before attempting normal operation.										
implication	due to this erratum, unexpected system behavior may be observed.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title											
problem	the qpils register (cpubus(1); devices 8,9; function 0; offset 0x48), according to the intel® quick path interconnect specification at revisions 1.1 and later, should report the vna/vn0 credits available for the processor tx (transmit port). due to this erratum, the qpils register reports the vna/vn0 credits available for the processor rx (receive port).										
implication	this is a violation of the specification but no functional failures have been observed due to this erratum.										
workaround	none identified.										
											
title	the router value exchanged during intel qpi link layer initialization is set to zero										
problem	during the intel qpi link layer initialization, parameters are exchanged by hardware. the parameters that are received are stored by the receiver. the information is used to setup link operation. one of those parameters that is exchanged is the router value. the router value should be one but it is zero in the processor.										
implication	given that the processor is designed to only go into 2 socket platforms and that the bios is not using this value, there is no known negative impact from the router value being 0.										
workaround	none identified.										
											
title											
problem	when a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accesses the processor may exhibit unexpected behavior.										
implication	due to this erratum unpredictable system behavior may occur. intel has not observed this erratum with any commercially available system.										
workaround	none identified.										
											
title	the processor incorrectly indicates that 16-bit rolling crc is supported										
problem	the intel qpi specification defines two methods of computing crc: 8-bit crc or 16-bit rolling crc. the processor implements only 8-bit crc. the “crc mode supported” bit in the qpilcp registers (devices 8, 9; function 0; offset 40h, bit 11) is set incorrectly indicating that both 8-bit crc and 16-bit rolling crc are supported.										
implication	the “crc mode supported” bit of qpilcp must be disregarded; there should be no attempt to use 16-bit rolling crc mode.										
workaround	the “crc mode” bits in the qpilcl (devices 8, 9; function 0; offset 44h, bits[15:14]) should be left at their reset value of 00b to ensure 8-bit crc is selected.										
											
title	peci write requests that require a retry will always time out										
problem	peci 3.0 introduces a ‘host identification’ field as a way for the peci host device to identify itself to the peci client. this is intended for use in future peci systems that may support more than one peci originator. since peci 3.0 systems do not support the use of multiple originators, peci 3.0 host devices should zero out the unused host id field. peci 3.0 also introduces a ‘retry’ bit as a way for the peci host to indicate to the client that the current request is a ‘retry’ of a previous read or write operation. unless the peci 3.0 host device zeroes out the byte containing the ‘host id & retry bit’ information, peci write requests that require a retry will never complete successfully.										
implication	peci write requests that require a retry may never complete successfully. instead, they will return a timeout completion code of 81h for a period ranging from 1 ms to 30 ms if the ‘retry’ bit is asserted.										
workaround	peci 3.0 host devices should zero out the byte that contains the host id and retry bit information for all peci requests at all times including retries.										
											
title	the vswing of the pcie* transmitter exceeds the specification										
problem	the pcie specification defines a limit for the vswing (voltage swing) of the differential lines that make up a lane to be 1200 mv peak-to-peak when operating at 2.5 gt/s and 5 gt/s. intel has found that the processor’s pcie transmitter may exceed this specification. peak-to-peak swings on a limited number of samples have been observed up to 1450 mv.										
implication	for those taking direct measurements of the pcie transmit traffic coming from the processor may detect that the vswing exceeds the pcie specification. intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	intel qpi interface calibration may log spurious bus and interconnect error machine checks										
problem	the intel qpi interface physical layer performs calibration across all 20 of the lanes and reports the success or failure of the calibration process. due to this erratum, the processor may detect spurious errors during the calibration of the intel qpi interface. the bus and interconnect errors are reported with the ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_1xx0_0000_1111 (where x is zero or one).										
implication	the processor may log spurious bus and interconnect error machine checks reports during intel qpi calibration.										
workaround	is possible for the bios to contain a workaround for this erratum. a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	when a link is degraded on a port due to pcie* signaling issues correctable receiver errors may be reported on the neighboring port										
problem	pci express* interface incorporates a recovery mechanism when certain link degradation occurs by retraining the link without impacting the pending transactions. when a link is degraded on a specific port due to pcie signaling issues, it is possible that correctable receiver errors are reported on the neighboring (logically adjacent) port. the correctable receiver errors are indicated by the pcie aer correctable error bit (xpglberrsts cpubus(0); device 0-3; function 0-3; offset 230h; bit 2).										
implication	software that logs errors on the pcie interface must be aware that errors detected on a specific port could be due to either an error on that specific port or on a neighboring port.										
workaround	none identified.										
											
title											
problem	a cmci (corrected machine check error interrupt) should be generated when the number of corrected errors for a bank reaches the corrected error threshold programmed into the ia32_mci_ctl2 bits [14:0]. for memory scrubbing errors, ia32_mci_status.mcacod (bits [15:0]) with value of 000x_0000_1100_xxxx (where x stands for zero or one), a cmci will not be generated until the number of errors has exceeded the threshold in ia32_mci_ctl2 by 1.										
implication	the cmci will not be generated when expected but rather will be generated on the next corrected error for the bank.										
workaround	it is possible for bios to contain a workaround for this issue. it should be noted that with this workaround if the threshold is programmed to a value of 0, a read of the value will return 1 and the threshold will be 1. all other valid threshold values for the bank will be read back correctly and function as expected.										
											
title	pcie* rx dc common mode impedance is not meeting the specification										
problem	when the pcie rx termination is not powered, the dc common mode impedance has the following requirement: ≥10 kΩ over 0-200 mv range with respect to ground and ≥20 kΩ for voltages ≥200 mv with respect to ground. the processor’s pcie rx do not meet this requirement at 85 degrees c or greater. in a limited number of samples intel has measured an impedance as low as 9.85 kΩ at 50 mv.										
implication	intel has not observed any functional impact due to this violation with any commercially available system.										
workaround	none identified.										
											
title	a modification to the multiple message enable field does not affect the aer interrupt message number field										
problem	the (advanced error interrupt) message number field (rperrsts devices 0-3; functions 0-3; offset 178h; bits[31:27]) should be updated when the number of messages allocated to the root port is changed by writing the multiple message enable field (msimsgctl device 3; function 0; offset 62h; bits[6:4]). however, writing the multiple message enable in the root port does not update the advanced error interrupt message number field.										
implication	due to this erratum, software can allocate only one msi (message signaled interrupt) to the root port.										
workaround	none identified.										
											
title	unexpected pcie* set_slot_power_limit message on writes to lnkcon										
problem	the processor sends the pcie set_slot_power_limit message on writes to the slot capabilities (sltcap devices 0-3; functions 0-3; offset a4h) register. due to this erratum, the processor also sends pcie the set_slot_power_limit message on writes to the lnkcon (cpubus(0); devices 0-3; functions 0-3; offset a0h) register.										
implication	for those monitoring the pcie traffic going across the link, the unexpected pcie set_slot_power_limit message will be detected whenever a write to the lnkcon register occurs. intel has not observed any functional failures due to this erratum on any commercially available system.										
workaround	none identified.										
											
title	enabling intel qpi l0s state may prevent entry into l1										
problem	enabling intel qpi l0s state in a dual processor system with both processor sockets populated may not allow the intel qpi link between the processors to enter the l1 state.										
implication	entry into the package c3 state and lower power package c-states cannot occur if the intel qpi link cannot enter the l1 state. system power consumption may increase.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	locked accesses spanning cachelines that include pci space may lead to a system hang										
problem	a locked memory access which splits across a cacheline boundary that suffers a master abort on a pci bus may lead to a system hang.										
implication	aborted split lock accesses may cause pci devices to become inoperable until a platform reset. intel has not observed this erratum with commercially available software.										
workaround	none identified.										
											
title	intel qpi training sensitivities related to clock detection										
problem	the processor is demonstrating link training sensitivities related to clock detection and will indicate the error with an ia32_mci_status.mscod (bits[21:16]) of 10011 and with an ia32_mci_status.mcacod (bits[15:0]) of 0000_1000_0000_1111.										
implication	due to this erratum, the intel qpi interface may train intermittently and flag a machine check error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	cold boot may fail due to internal timer error										
problem	the processors may not complete a cold boot (that is, a boot from a power-off state) due to an internal timer error machine check, ia32_mci_status.mcacod of 0000_0100_0000_0000. this will result in the processor asserting ierr (internal error).										
implication	the processor may signal ierr during a cold boot when the system is initializing.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* rx common mode return loss is not meeting the specification										
problem	the pcie specification requires that the rx common mode return loss in the range of to 2.5 ghz must be limited to -6 db. the processor’s pcie rx do not meet this requirement. the pcie rx common mode return at 500 mhz has been found to be between -3.5 and -4 db on a limited number of samples.										
implication	intel has not observed any functional failures due to this erratum with any commercially available pcie devices.										
workaround	none identified.										
											
title	the most significant bit of the cec cannot be cleared once set										
problem	the most significant bit of the cec (corrected error count ia32_mci_status (i=12- 19), bit 52) cannot be cleared once it has been set.										
implication	in the case that software attempts to clear the cec and the count exceeds 3fffh, software will read incorrect cec values on subsequent accesses and additional cmcis (corrected machine check error interrupts) will not be generated.										
workaround	none identified. software can avoid this erratum by setting corrected error threshold to a value less than 3fffh, enable cmci and clearing the error count before it exceeds 3fffh.										
											
title	an unexpected page fault or ept violation may occur after another logical processor creates a valid translation for a page										
problem	an unexpected page fault (#pf) or ept violation may occur for a page under the following conditions: the paging structures initially specify no valid translation for the page. software on one logical processor modifies the paging structures so that there is a valid translation for the page (for example, by setting to 1 the present bit in one of the paging-structure entries used to translate the page). software on another logical processor observes this modification (for example, by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). shortly thereafter, software on that other logical processor performs a store to a linear address on the page. in this case, the store may cause a page fault or ept violation that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). intel has not observed this erratum with any commercially available software.										
implication	an unexpected page fault may be reported. there are no other side effects due to this erratum.										
workaround	system software can be constructed to tolerate these unexpected page faults. see section “propagation of paging-structure changes to multiple processors” of volume 3a of ia-32 intel® architecture software developer’s manual, for recommendations for software treatment of asynchronous paging-structure updates.										
											
title	pcie* adaptive equalization may not train to the optimal settings.										
problem	in the case of the pcie equalization procedure for 8 gt/s, the downstream port’s (for example, the processor’s) txeq (transmitter equalization settings) can be fine tuned for each lane during a process called adaptive equalization phase 3. due to this erratum, the processor may not direct the end-agent to the optimal txeq settings.										
implication	the pcie link may not be as robust as possible potentially leading to a higher bit error rate than expected.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	a core may not complete transactions to the caching agent when c- states are enabled leading to an internal timer error										
problem	when multiple cores have outstanding transactions targeted to a single caching agent and one of the cores enters a core c-state before completing the transaction with the targeted caching agent an internal timer machine check error may occur (ia32_mci_status.mcacod of 0000_0100_0000_0000).										
implication	due to this erratum, the processor may experience an internal timer error. workaround none identified.										
workaround											
											
title	tsc is not affected by warm reset										
problem	the tsc (time stamp counter msr 10h) should be cleared on reset. due to this erratum the tsc is not affected by warm reset.										
implication	the tsc is not cleared by a warm reset. the tsc is cleared by power-on reset as expected. intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	warm resets may be converted to power-on resets when recovering from an ierr										
problem	when a warm reset is attempted and an ierr (internal error) happens as indicated by the ia32_mci_status.mcacod of 0000_0100_0000_0000, a power-on reset occurs instead.										
implication	the values in the machine check bank will be lost as a result of the power-on reset. this prevents a os, bios or the bmc (baseboard management controller) from logging the content of the error registers or taking any post-reset actions that are dependent on the machine check information.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	using dma xor with dca may cause a machine check										
problem	if both dca (direct cache access) and dma xor operations are active at the same time, then invalid prefetch hints may be generated. these prefetch transactions may not complete and could result in a timeout machine check, which will cause caterr# to become asserted.										
implication	invalid prefetch hints may not complete resulting in a machine check.										
workaround	if using dma xor operations, disable dca by clearing chanctrl. completion_write_dca_enable (offset 80h; bit 9) in the region described by cb_bar (device: 10; function 0-7; 0ffset 80h).										
											
title	mixed dma xor and legacy operations in the same channel may cause data to be observed out of order										
problem	for mixed channel dma (xor and legacy operations active on the same channel) completion writes from legacy operations may pass completion writes from xor operations resulting in out of order descriptor updates/completions.										
implication	dma descriptor progress may appear out of order with incorrect data.										
workaround	in the dma driver each dma xor descriptor must be followed by an additional legacy descriptor. the legacy descriptor must have a non-zero transfer length and the “null transfer” bit and “completion interrupt” in the descriptor control field set to '1'. the transfer will not actually occur, but a completion interrupt will be generated that indicates that the xor operation has completed. this causes all completion interrupts to be of the legacy type.										
											
title	unexpected dma xor halt and errors when using descriptors with p or q operations disabled										
problem	if a galois field generate/validate base descriptor has either the p operations disable or q operation disable bit set and the corresponding disabled p parity address or q parity address field of the descriptor does not contain a valid/aligned address, the dma channel may halt unexpectedly with destination address errors. the destination address errors will be logged in chanerr_int. dma transfer destination address error (device 4; function 0-7; offset 180h; bit 1).										
implication	the dma may only partially process a dma xor descriptor when a disabled p or q parity address field of the descriptor does not contain a valid/aligned address, resulting in incomplete data, an unexpected dma channel halt and destination address errors.										
workaround	at all times, software must place a valid/aligned address in both the p parity address field and the q parity address field of a dma xor with galois field generate/validate base descriptor even if the p operations disable or q operations disable descriptor fields are set to disable either p or q operations for the descriptor.										
											
title											
problem	if a parity error occurs of source read completion data while inside the dma for >8k descriptor transfer lengths, the dma channel will hang until the next platform reset.this behavior only applies if the data arrived at the dma unit error free (from dram and intel qpi) but then had a parity error in the completion data fifo inside the dma.										
implication	the effected dma channel will hang until the next platform reset. workaround none identified.										
workaround											
											
title	dma cb_bar decode may be incorrect after dma flr										
problem	pcie* flr (function level reset) of the dma function, may result in an incorrect cb_bar (device 4; function 0-7; offset 10h) decode when a memory read of the cb_bar occurs around the same time as the flr.										
implication	a flr may cause a pcie memory read to decode to channel 0 instead of the intended channel resulting in incorrect read data returned.										
workaround	software must quiesce the dma function before issuing flr including:										
											
title	xor dma restricted to  8 kb transfers when multiple channels are in use										
problem	incorrect data transfers can occur if more than one dma channel is in operation and >8 kb xor dma transfer sizes are being used. xor dma transfer size is set by software in the block size field of the xor with galios field generate/validate base descriptor.										
implication	xor dma operation is restricted to  8 kb transfer sizes when multiple dma channels are in use. legacy dma operations may still use up to the maximum 1 mb transfer length.										
workaround	software may either:										
											
title	unable to restart dma after poisoned error during an xor operation										
problem	if the chanerr field read data error (offset a8h; bit 8) is set due to a poisoned completion error during a dma xor operation, the dma stays in the halted state and the read data error bit does not clear										
implication	the xor operations on the dma can not be restarted after a read data error due to a poisoned xor operation.										
workaround	at least one xor descriptor with no read data errors has to be processed for a new chain of xor descriptors to work correctly with the corresponding chanerrmsk (offset ach; bit 8) bit set. upon detection of a read data error, software must clear the chanerr and chanerr_int (device 4; function 0-7; offset 180h) registers and disable the corresponding error mask bit by setting chanerrmsk. then new descriptors can be added to the chain and the dma started by writing the dmacount (offset 86h). once the dma channel is in the running state, software can clear the chanerrmsk. chanerr, chanerrmsk, and dmacount are offsets relative to cb_bar (device 4; function 0-7; 0ffset 10h) on the processors internal io bus (as defined in the iiobusno register).										
											
title	dma restart hang when first descriptor is a legacy type following channel halt due to an extended descriptor error										
problem	when using multiple dma channels, all dma channels may hang if a dma channel restart is attempted with a legacy descriptor as the first descriptor following an error/ halt on an extended descriptor on channel 0 or 1.										
implication	following an extended descriptor error on channel 0 or 1, the channel must be not be restarted with a first descriptor of legacy type including null. does not apply for single channel operation.										
workaround	software must guarantee that the first descriptor processed on restart is an xor gf multiply generation (base type) before using legacy descriptors with interrupts and completions.										
											
title											
problem	if dma xor interrupts and completions are enabled on channel 0 or 1 concurrent with operation on channels 2-7, incorrect data transfers can occur on dma channels 2-7. dma xor interrupts and completions are enabled by setting bits 0 and 3 of descriptor control field of a dma xor with galios field generate/validate base descriptor.										
implication	if dma xor interrupts and completions are enabled, only one interrupt/completion type may be used on any single channel and only channels 0 and 1 may be used.										
workaround	software must either:										
											
title	suspending/resetting an active dma xor channel may cause an incorrect data transfer on other active channels										
problem	suspending an active dma xor channel by setting chancmd.suspend dma bit (offset 84; bit 2) while xor type dma channels are active may cause incorrect data transfer on the other active legacy channels. this erratum may also occur while resetting an active dma xor channel chancmd.reset dma bit (offset 84; bit 5). chancmd is in the region described by cb_bar(device 4; function 0-7; offset 10h) on the processor's internal io bus (as defined in the iiobusno register).										
implication	an incorrect data transfer may occur on the active legacy dma channels.										
workaround	software must suspend all legacy dma channels before suspending an active dma xor channel (channel 0 or 1).										
											
title	dword-aligned dma xor descriptors with fencing and multi- channel operation may cause a channel hang										
problem	dma xor descriptors with dword aligned sources and fencing enabled may result in a xor channel hang until the next platform reset. xor dma fencing is set by software in descriptor control.fence (xor base descriptor, bit 4)										
implication	an xor dma descriptor with non cacheline aligned sources may hang until the next platform reset.										
workaround	do not enable fencing on xor descriptors. fencing can be enabled on legacy descriptors. it is recommended that a null legacy descriptor must be paired with each xor descriptor. software can use fencing of the legacy null descriptor to track full completion of its associated xor descriptor.										
											
title	processor may not restore the vr12 ddr3 voltage regulator phases upon pkg c3 state exit										
problem	during the pkg (package) c3 state entry, the processor directs the vr12 ddr3 voltage regulators to shed phases to reduce power consumption. due to this erratum, the processor may not restore all vr12 ddr3 voltage regulator phases upon pkg c3 state exit. the vr12 ddr3 voltage regulators require all phases to keep the ddr3 voltage plane in tolerance for proper memory subsystem functioning during normal system operation.										
implication	due to this erratum, unpredictable system behavior may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel qpi link layer does not drop unsupported or undefined packets										
problem	the intel qpi should detect an unsupported or undefined packet, drop the offending packet, and log a correctable error with an ia32_mci_status.mcacod of 0000_1100_0000_1111. when the intel qpi detects an unsupported or undefined packet it does not drop the offending packet but it does log the error.										
implication	due to this erratum, intel qpi does not drop unsupported packets. intel has not observed any functional failure on commercially available systems due to this erratum.										
workaround	none identified										
											
title	the equalization phase successful bits are not compliant to the pcie* specification										
problem	pcie specification states that if the phase 1 of transmitter equalization completes successfully as indicated by the lnksts2.equalization phase 1 successful (devices 0- 3; functions 0-3; bit[2]) bit being set to one and if the phase 2 and 3 link training phases are bypassed, the lnksts2.equalization phase 3 successful (devices 0-3; functions 0-3; bit[4]) and lnksts2.equalization phase 2 successful (bit[3]) bits should be set to one. due to this erratum, the processor will only set the equalization phase 2 or 3 successful bits if the phases are completed successfully.										
implication	due to this erratum, equalization phase 2 and 3 successful bits may not be set. intel has not observed any functional failure with commercially available pcie devices.										
workaround	none identified.										
											
title	the intel® virtualization technology for directed i/o (intel® vt-d) queued invalidation status write may fail										
problem	intel® virtualization technology for directed i/o (intel® vt-d) queued invalidation operations issue a status write to modify a semaphore. due to this erratum, the status write may fail.										
implication	when using queued invalidation operations, a failed status write can result in unpredictable system behavior.										
workaround	if operating without queued invalidations, interrupt re-mapping, and x2apic features is feasible, then intel vt-d invalidations should be performed using the intel vt-d register facility (c.f., vtd0_ctxcmd [offset 028h], vtd1_ctxcmd [offset 1028h], vtd0_invaddrreg [offset 0200h] and vtd0_iotlbinv [offset 0208h], vtd1_invaddrreg [offset 1200h] and vtd1_iotlbinv [offset 1208h] in the intel vt- d register region with a base address specified through the vtbar register at 0:5:0, offset 0180h).										
											
title	executing the getsec instruction while throttling may result in a processor hang										
problem	if the processor throttles, due to either high temperature thermal conditions or due to an explicit operating system throttling request (tt1), while executing getsec[senter] or getsec[sexit] instructions, then under certain circumstances, the processor may hang. intel has not been observed this erratum with any commercially available software.										
implication	possible hang during execution of getsec instruction.										
workaround	none identified.										
											
title	incorrect address computed for last byte of fxsave/fxrstor or xsave/xrstor image leads to partial memory update										
problem	a partial memory state save of the fxsave or xsave image or a partial memory state restore of the fxrstor or xrstor image may occur if a memory address exceeds the 64 kb limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4 gb limit while the processor is operating in 32-bit mode.										
implication	fxsave/fxrstor or xsave/xrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.										
workaround	software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits.										
											
title	fp data operand pointer may be incorrectly calculated after an fp access which wraps a 4-gbyte boundary in code that uses 32-bit address size in 64-bit mode										
problem	the fp (floating point) data operand pointer is the effective address of the operand associated with the last non-control fp instruction executed by the processor. if an 80- bit fp access (load or store) uses a 32-bit address size in 64-bit mode and the memory access wraps a 4-gbyte boundary and the fp environment is subsequently saved, the value contained in the fp data operand pointer may be incorrect.										
implication	due to this erratum, the fp data operand pointer may be incorrect. wrapping an 80-bit fp load around a 4-gbyte boundary in this way is not a normal programming practice. intel has not observed this erratum with any commercially available software.										
workaround	if the fp data operand pointer is used in a 64-bit operating system which may run code accessing 32-bit addresses, care must be taken to ensure that no 80-bit fp accesses are wrapped around a 4-gbyte boundary.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	lbr may contain incorrect information when using freeze_lbrs_on_pmi										
problem	when freeze_lbrs_on_pmi is enabled (bit 11 of ia32_debugctl msr (1d9h) is set), and a taken branch retires at the same time that a pmi (performance monitor interrupt) occurs, then under certain internal conditions the record at the top of the lbr stack may contain an incorrect “from” address.										
implication	when the lbrs are enabled with freeze_lrbs_on_pmi, the “from” address at the top of the lbr stack may be incorrect.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring may overcount some events during debugging										
problem	if the debug-control register (dr7) is configured so that some but not all of the breakpoints in the debug-address registers (dr0-dr3) are enabled and one or more of the following performance-monitoring counters are locally enabled (via ia32_cr_permon_evntsel_cntr{3:0}): br_inst_retired br_misp_retired fp_assist fp_assist inst_retired machine_clears mem_load_uops_llc_hit_retired mem_load_uops_misc_retired.llc_miss mem_load_uops_retiredmem_trans_retiredmem_uops_retired other_assists rob_misc_events.lbr_inserts uops_retired any of the globally enabled (via ia32_cr_emon_perf_global_ctrl) counters may overcount certain events when a disabled breakpoint condition is met.										
implication	performance-monitor counters may indicate a number greater than the number of events that occurred.										
workaround	software can disable all breakpoints by clearing dr7. alternatively, software can ensure that, for a breakpoint disabled in dr7, the corresponding debug-address register contains an address that prevents the breakpoint condition from being met (for example, a non-canonical address).										
											
title	hdrlog registers do not report the header for pcie* port 1 packets with detected errors										
problem	the hdrlog registers contain the header information of the first pcie packet detected that contains errors. because of this erratum, the port 1 (iou2) hdrlog registers (cpubus(0), device 1, function 0; offsets 164h, 168h, 16ch, 170h) do not reflect the header of a packet with a detected error.										
implication	the hdrlog registers cannot be used to debug the receipt of packets with detected errors on port 1.										
workaround	none identified.										
											
title	peci temperature data values returned during reset may be non- zero										
problem	the processor peci power-up time line presented in the intel® xeon® processor e5- 1600/e5-2600/e5-4600 product families datasheet - volume one or intel® xeon® e5-2400 product family datasheet- volume two defines the value returned by the peci gettemp() command as 0x0000 - the maximum value - during the 'data not ready' (dnr) phase (starting approximately 100 µs after pwrgood assertion and lasting until approximately 500 µs after reset de-assertion). due to this erratum, the gettemp() command returns a small negative number during the dnr phase.										
implication	the temperature reported during the peci dnr phase may be below the maximum and therefore may not have the intended effect of causing platform fans to operate at full speed until the actual processor temperature becomes available.										
workaround	processor thermal management solutions utilizing peci should operate platform fans at full speed during the peci dnr phase.										
											
title	tsod related smbus transactions may not complete when package c-states are enabled										
problem	the processor may not complete smbus (system management bus) transactions targeting the tsod (temperature sensor on dimm) when package c-states are enabled. due to this erratum, if the processor transitions into a package c-state while an smbus transaction with the tsod is in process, the processor will suspend receipt of the transaction. the transaction completes while the processor is in a package c-state. upon exiting package c-state, the processor will attempt to resume the smbus transaction, detect a protocol violation, and log an error.										
implication	when package c-states are enabled, the smbus communication error rate between the processor and the tsod may be higher than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	dram rapl dynamic range is too narrow on the low side										
problem	the lower limit for the dram rapl (running average power limit) dynamic range is specified to be about 120% of dram minimum power. due to this erratum, the lower limit is enforced at about 170% of dram minimum power. dram minimum power can be found in the minimal dram power field (dram_power_info csr at cpubus(1), device 10, function 2, offset 90h; bits[30:16]).										
implication	dram rapl cannot regulate dram power consumption to as low a level as expected. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	mcacod 0119h reported in ia32_mc3_status is ambiguous										
problem	the machine check error code (mcacod) in the ia32_mc3_status (msr 040dh) register is intended to report the type of error that has been discovered. the 0119h mcacod is correctly logged for mlc (mid-level cache) generic read errors and, due to this erratum, also logged for errors detected as a result of monitor instructions.										
implication	it may not be possible to distinguish the precise operation associated with an mlc machine check error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the processor incorrectly transitions from polling.active to polling.compliance after receiving two ts1 ordered sets with the compliance bit set										
problem	the processor pcie* interface incorrectly transitions from the polling.active link state to the polling.compliance link state after receiving two ts1 ordered sets with the compliance bit set instead of the eight ts1 ordered sets required by the specification.										
implication	it is possible that the pcie link may enter polling.compliance link state unexpectedly. exposure to this erratum requires bit errors on the compliance receive bit (byte 5, bit 4) on sequential ts1 ordered sets.										
workaround	none identified.										
											
title	patrol scrubbing may not resume properly after package c3 and package c6 states										
problem	patrol scrubbing is disabled at entry into package c3 and package c6 states. due to this erratum, the memory subsystem may not get fully scrubbed in the expected hour timeframe.										
implication	memory may not be scrubbed as expected when patrol scrubbing is enabled while package c3 and/or package c6 states are enabled. as a consequence, single bit memory errors may not be proactively corrected and could increase the likelihood of uncorrectable memory errors.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	shallow self-refresh mode is used during s3										
problem	the processor should be instructing dram to utilize deep self-refresh at entry into the s3 state. due to this erratum, the processor is instructing the dram to use shallow self-refresh upon entry into the s3 state.										
implication	the power dissipation of the drams will be greater than expected during s3 state. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	platform idle power may be higher than expected										
problem	the processor may not place the associated dram subsystem in the lowest allowed power state during package c3 and package c6 states. this may cause the platform idle power to be higher than expected.										
implication	platform average power and idle power may be higher than expected. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	peci transactions during an s-state transition may result in a platform cold reset										
problem	due to this erratum, a peci transaction during an s-state transition may result in an unexpected platform cold reset rather than an s-state transition.										
implication	use of peci transactions during an s-state transition can result in a platform reset that terminates transitioning to the desired s-state.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	complex platform conditions during a transition to s4 or s5 state may result in an internal timeout error										
problem	due to this erratum, the bios sequencing associated with s4 (sometimes known as “hibernate”) and s5 (also known as “soft off”), when undertaken with certain complex platform conditions, can result in an internal timeout error as indicated by ia32_mci_status.mcacod of 0000_0100_0000_0000 and ierr assertion. this internal timeout error stops the platform s-state sequencing before platform power down occurs. certain platforms may have logic that, upon detection of the failure to reach power down, initiates a cold reset sequence.										
implication	s4 state or s5 state may not be reliably entered; the platform may not reach the very low power condition.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writes to sdoorbell or b2bdoorbell in conjunction with inbound access to ntb mmio space may hang system										
problem	a posted write targeting the sdoorbell (offset 64h) or b2bdoorbell (offset 140h) mmio registers in the region define by base address register pb01base (bus 0; device 3; function 0: offset 10h) or sb01base (bus m; device 0; function 0; offset 10h) may hang the system. this system hang may occur if the ntb (non-transparent bridge) is processing a transaction from the secondary side of the ntb that is targeting the ntb shared mmio registers or targeting the secondary side configuration registers when the write arrives.										
implication	the system may hang if the processor writes to the local sdoorbell or b2bdoorbell register at the same time that the ntb is processing an inbound transaction.										
workaround	in ntb/ntb (back-to-back) mode, do not use the b2bdoorbell to send interrupts from the local to remote host. instead, configure one of the following local register pairs to point to the remote sb01base region:										
											
title	programming pdir and an additional precise perfmon event may cause unexpected pmi or pebs events										
problem	pdir (precise distribution for instructions retired) mechanism is activated by programming inst_retired.all (event c0h, umask value 00h) on counter 1. when pdir is activated in pebs (precise event based sampling) mode with an additional precise perfmon event, an incorrect pmi or pebs event may occur.										
implication	due to this erratum, when another pebs event is programmed along with pdir, an incorrect pmi or pebs event may occur.										
workaround	software should not program another pebs event in conjunction with the pdir mechanism.										
											
title	a peci rdiamsr command near ierr assertion may cause the peci interface to become unresponsive										
problem	when a peci rdiamsr command is issued to the processor near the time that the processor is experiencing an internal timeout error, as indicated by ia32_mci_status.mcacod of 0000_0100_0000_0000 and ierr assertion, the peci interface may issue an 81h (timeout) response. after a timeout response, the processor will ignore future peci commands until it is reset.										
implication	due to this erratum, peci commands typically used to debug a processor that is not behaving normally - rdpkgconfig and rdpciconfig - may not be available after an internal timeout error.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	long latency transactions may cause i/o devices on the same link to time out										
problem	certain long latency transactions - for example, master aborts on inbound traffic, locked transactions, peer-to-peer transactions, or vendor defined messages - conveyed over the pcie* and dmi2 interfaces can block the progress of subsequent transactions for extended periods. in certain cases, these delays may lead to i/o device timeout that can result in device error reports and/or device off-lining.										
implication	due to this erratum, devices that generate pcie or dmi2 traffic characterized by long latencies can interfere with other traffic types on the same link. this may result in reduced i/o performance and device timeout errors. usb traffic can be particularly sensitive to these delays.										
workaround	avoid the contributing conditions. this can be accomplished by separating traffic types to be conveyed on different links and/or reducing or eliminating long latency transactions.										
											
title	the coherent interface error codes “c2”, “c3”, “da” and “db” are incorrectly flagged										
problem	the coherent interface error status registers (irpp0errst and irpp1errst at cpubus(0), device 5, function 2, offsets 230h and 2b0h respectively) indicate that an error has been detected by the coherent interface. bit 3 indicates that a write cache un-correctable ecc (c2) error has occurred. bit 4 indicates that a csr access crossing 32-bit boundary (c3) error has occurred. bit 13 indicates that a protocol queue/table overflow or underflow (da) error has occurred. bit 14 indicates that a protocol parity error (db) error has occurred. due to this erratum, the processor may incorrectly log the “c2”, “c3”, “da” and “db” error flags.										
implication	the “c2”, “c3”, “da” and “db” error flags are indeterminate.										
workaround	mask off the “c2”, “c3”, “da” and “db” error flags (bit 3, bit 4, bit 13 and bit 14) of the irpp0errctl and irpp1errctl registers at cpubus(0), device 5, function 2, offsets 234h and 2b4h respectively.										
											
title	if multiple poison events are detected within two core clocks, the overflow flag may not be set										
problem	if multiple poison events are detected within two core clocks, the error is logged with an ia32_mci_status.mcacod of 0000_0001_0011_0100 but the ia32_mci_status.over (bit [60]) may not be set.										
implication	due to this erratum, only one poison event may be reported by a logical processor when more than one poison event was encountered.										
workaround	none identified.										
											
title	pci express* capability structure not fully implemented										
problem	according to the pcie* base specification, “the pci express capability structure is required for all pci express device functions.” due to this erratum, some pci express capabilities fields were not implemented (“device capability,” “device status” and “device control”) for cpubus[0], device 5, function 2, reads to these fields will return zero.										
implication	software that depends on the pci express capability structure fields device capability, device status and/or device control will not operate properly.										
workaround	none identified.										
											
title	the pcie* receiver lanes surge protection circuit may intermittently cause a false receive detection on some pcie devices										
problem	the processor implements a surge protection circuit on the pcie receiver lanes. due to this erratum, during platform power-on some pcie devices may trigger the surge protection circuit causing a false receive detect. if this unexpected detection occurs before the processor's pcie lane termination impedances are enabled and the resulting pcie device link training enters the link training polling.active state, the pcie device may incorrectly transition into the polling.compliance state.										
implication	after platform power-on, some pcie devices may not exit from the compliance state causing the link to fail to train or the link may train to a degraded width.										
workaround	a bios change has been identified and may be implemented as a workaround for this erratum.										
											
title	software reads from lmmioh_limit register may be incorrect										
problem	the mmioh is a memory-mapped i/o region relocatable above 4 gb. due to this erratum, software reads of the lmmioh_limit register (local mmio high base, device: 5, function: 0, offset 118h) may yield incorrect results, although software writes to this register function as expected.										
implication	software depending on lmmioh_limit register reads may not behave as expected. intel has not identified any commercially available software that is affected by the erratum.										
workaround	none identified.										
											
title	patrol scrub is incompatible with rank sparing on more than one channel										
problem	the imc (integrated memory controller) permits independent sparing of one rank on each memory channel. due to this erratum, patrol scrub operation is impaired when more than one ranking sparing event occurs.										
implication	if more than one channel has undergone a rank sparing event, patrol scrub may scrub ranks that should have been taken out of service and may skip scrubbing ranks that are in service. in the former case, excessive errors will be reported while in the latter case, memory is incompletely scrubbed.										
workaround	patrol scrub should not be enabled when more than one channel has suffered a rank sparing event. this can be accomplished during the bios initialization phase by either										
											
title	multi-socket intel® txt platform may enter a sequence of warm resets										
problem	due to this erratum, a platform warm reset issued while a processor is attempting an authenticated boot on a multi-socket intel® trusted execution technology (intel® txt) platform may initiate a series of repeating warm resets.										
implication	a warm reset attempt during an authenticated boot on a multi-socket intel txt platform may lead to platform unavailability.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ntb may incorrectly set msi or msi-x interrupt pending bits										
problem	the ntb (non-transparent bridge) may incorrectly set msi (message signaled interrupt) pending bits in msipending (bar pb01base,sb01base; offset 74h) while operating in msi-x mode or set msi-x pending bits in pmsixpba (bar pb01base, sb01base; offset 03000h) while operating in msi mode.										
implication	due to this erratum, ntb incorrectly sets msi or msi-x pending bits. the correct pending bits are also set and it is safe to ignore the incorrectly set bits.										
workaround	none identified.										
											
title	dword aligned xor dma sources may prevent further dma xor progress										
problem	xor dma channels may stop further progress in the presence of locks/pholds if the source pointed to by a dma xor descriptor is not cacheline aligned.										
implication	non-cacheline aligned dma xor sources may hang both channels 0 and 1. a reset is required in order to recover from the hang. legacy dma descriptors on any channel have no source alignment restrictions.										
workaround	software must either:										
											
title	using i/o peer-to-peer write traffic across an ntb may lead to a hang										
problem	if two systems are connected via an ntb (non-transparent bridge), either the internal ntb or an external ntb, and both systems attempt to send i/o peer-to-peer write traffic across the ntb either to memory or an i/o device on the remote system, it is possible for both systems to deadlock.										
implication	due to this erratum, using i/o peer-to-peer write traffic across an ntb may lead to a hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	unable to clear received pme_to_ack in ntb										
problem	when the ntb (non-transparent bridge) is enabled, the received pme_to_ack bit in miscctrlsts (device 3; function 0; offset 188h; bit[48]) can not be cleared if the timeout for receiving pme_to_ack is enabled (device 3; function 0; offset 188h, bit[5] is 0).										
implication	due to this erratum, software may be unable to clear received pme_to_ack. workaround none identified.										
workaround											
											
title	ntb does not set pme_to_ack after a pme_turn_off request										
problem	the ntb (non-transparent bridge) does not set pme_to_ack in miscctrlsts (device 3; function 0: offset 188h; bit [48]) after a pme_turn_off request.										
implication	due to this erratum, the ntb will not acknowledge a pme_turn_off request.										
workaround	acpi or other software must have a time-out to proceed with the power management event and should not wait indefinitely for the ntb to acknowledge the pme_turn_off request.										
											
title	pcmpestri, pcmpestrm, vpcmpestri and vpcmpestrm always operate with 32-bit length registers										
problem	in 64-bit mode, using rex.w=1 with pcmpestri and pcmpestrm or vex.w=1 with vpcmpestri and vpcmpestrm should support a 64-bit length operation with rax/ rdx. due to this erratum, the length registers are incorrectly interpreted as 32-bit values.										
implication	due to this erratum, using rex.w=1 with pcmpestri and pcmpestrm as well as vex.w=1 with vpcmpestri and vpcmpestrm do not result in promotion to 64-bit length registers.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci commands differing only in length field may be interpreted as command retries										
problem	due to this erratum, the processor interprets any peci read or write command that accesses the processor, a downstream pci device, or package configuration space and differs from the preceding request only in the length field as a retry request. that is, a retry will be inferred by the processor even if the read length and write length fields don't match between two consecutive requests, regardless of the state of the host retry bit on the succeeding request.										
implication	back-to-back peci commands that are identical with the exception of the length field may yield incorrect results if processor retry completion codes are ignored by the peci host.										
workaround	peci hosts should retry timed-out commands until they complete successfully by reissuing a peci command sequence identical to the originally timed-out command.										
											
title	performance monitor precise instruction retired event may present wrong indications										
problem	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).										
implication	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.										
workaround	the sampling driver should avoid using sav<100.										
											
title	vm exits from real-address mode due to machine check exceptions may incorrectly save rflags.rf as 1										
problem	if a machine check is encountered while fetching an instruction, and if the resulting machine check exception causes a vm exit, the vm exit should save an rflags value in the guest-state area of the vmcs with the rf value that existed at the time of the machine check. due to this erratum, such vm exits that occur in real-address mode may save rflags.rf as 1 even if it had been 0.										
implication	the processor may fail to report an instruction breakpoint following a return to real- address mode via vm entry.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the integrated memory controller does not enforce cke high for txsdll dclks after self-refresh										
problem	the jedec standard ddr3 sdram specification (no. 79-3e) requires that the cke signal be held high for txsdll dclks after exiting self-refresh before issuing commands that require a locked dll (delay-locked loop). due to this erratum, the integrated memory controller may not meet this requirement with 512 mb, 1 gb, and 2gb devices in single rank per channel configurations.										
implication	violating txsdll may result in dimm clocking issues and may lead to unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	the default value of the i/o base address field does not comply with the pci-to-pci bridge architecture specification										
problem	the pci-to-pci bridge architecture specification defines the default value of the i/o base address field (iobas cpubus(0); device 0-3; function 0-3; offset 1ch; bits [3:2]) to 0. due to this erratum, the processor's default value is 3.										
implication	it is possible that system software will generate an error due to this erratum.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	a sustained series of pcie* posted upstream writes can lead to deadlock										
problem	due to this erratum, a sustained series of pcie posted upstream writes to the same cache line, with no other access of that same cache line, may cause a deadlock.										
implication	under a complex set of conditions, a sustained series of pcie posted upstream writes targeting the same cache line can lead to deadlock. intel has not been observed this erratum with any commercially available system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	extraneous characters are included in the processor brand string										
problem	the processor brand string is provided by the cpuid instruction for leaf values eax=80000002h, 80000003h, and 80000004h. each execution of the three cpuid leaf value returns 16 ascii bytes of the processor brand string in the eax, ebx, ecx, and edx registers. due to this erratum, an extra zero character (“0”, 30h ascii code) and space character (“ “, 20h ascii code) are inserted after the processor number in the brand string output. in the following example brand string, the extraneous characters are underlined: “intel® xeon® cpu e5-2680 0 @ 2.70 ghz”.										
implication	an extraneous “0” and “space” character are included in the processor brand string. workaround the extraneous characters may be ignored or removed by software.										
workaround											
											
title	imc controlled dynamic dram refresh rate can lead to unpredictable system behavior										
problem	drams require a 2x refresh rate when operating above 85°c. due to this erratum, the imc (integrated memory controller) logic intended to double the refresh rate when dram temperature exceeds 85°c can cause dram access failures, leading to unpredictable system behavior.										
implication	the imc is not able to dynamically adjust the dram refresh rate based on dram temperature. if drams may be operated above 85°c then bios must configure the imc for a doubled refresh rate.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	incorrect error address status may get logged										
problem	when a correctable machine check event with a valid address precedes an uncorrectable machine check event without a valid address, the ia32_mci_status over flag (bit 62) should be set and addrv flag (bit 58) should be cleared. due to this erratum, both flags may be set.										
implication	the machine check report logged may incorrectly indicate valid address information when the over flag is set.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the machine check threshold-based error status indication may be incorrect										
problem	a corrected cache hierarchy data or tag error is reported in ia32_mci_status.mcacod (bits [15:0]) with value of 000x_0001_xxxx_xx01 (where x stands for zero or one). an error status indication (bits [54:53]) value of 10b indicates that the corrected error count has exceeded the yellow threshold. due to this erratum, subsequent corrections after the yellow indication has been set may change the error status indication to green (bits [54:53] equal to 00b).										
implication	the threshold-based error status indication is unreliable.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_mci_status registers may contain undefined data after reset										
problem	due to this erratum, if the reset_n signal is asserted while the processor is in a package c state the ia32_mci_status registers may contain undefined data after the processor completes the reset. in particular, the ia32_mci_status.val (bit[63]) may be set incorrectly indicating a valid machine check has been logged.										
implication	invalid errors may be reported in the ia32_mci_status registers. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	refresh cycles for high capacity dimms are not staggered										
problem	certain high capacity dimms, typically quad rank rdimms and lr-dimms, may exceed instantaneous and short-term power limits if refresh cycles are not correctly staggered. due to this erratum, the integrated memory controller is unable to stagger refresh cycles.										
implication	some dimms may exceed power limits during refresh operations leading to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a stream of snoops can lead to a system hang or machine check										
problem	due to this erratum, a stream of snoop requests to a single cache slice may cause the processor in that slice to livelock, resulting in a system hang or internal timer error machine check indicated by ia32_mci_status.mcacod (bits 15:0, 0000 0100 0000 0000).										
implication	a system hang or machine check may occur. intel has not observed this erratum with any commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_mci_status.en may not be set during certain machine check exceptions										
problem	due to this erratum, ia32_mci_status.en may not be set as expected after the mlc (mid-level cache) has logged a fatal error with a mcacod value of 000x_0001_xxxx_xx10 (where x stands for zero or one) and signaled an mce (machine check error) as a result of encountering poisoned data.										
implication	the value of ia32_mci_status.en may be inconsistent with signaling an mce while logging a fatal error, however a machine check exception is still signaled.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel qpi link physical layer error results in mcerr during warm reset										
problem	a warm reset is defined as a reset that does not involve the shutdown of the power to the system (that is, only reset_n is asserted while pwrgood remains asserted). due to this erratum, during warm reset the processor may incorrectly apply common-mode voltage correction on the intel qpi interface, resulting in a link training failure.										
implication	the system may hang when a warm reset is attempted.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	llc cache correctable errors are not counted and logged										
problem	llc cache correctable errors are logged in the corrected_error_count field bits [53:38] of the ia32_mc[19:12]_status msr. due to this erratum, llc cache corrections are not counted and logged.										
implication	software using the corrected error count may not function correctly. a cmci (corrected machine check error interrupt) may not be generated when the error threshold programmed in ia32_cr_mc[19:12]_ctl2.error_threshold (bits [14:0]) would otherwise be expected to be met.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the processor incorrectly transitions from the pcie* recovery.rcvrlock ltssm state to the configuration.linkwidth.start ltssm state										
problem	when a pcie link is operating at 2.5 gt/s and the processor's ltssm (link training and status state machine) is in recovery.rcvrlock state, the processor expects to receive ts1 ordered sets within 24 ms. if it does not receive the ts1s in the allotted time, the ltssm should transition to the detect state. due to this erratum, if the processor does not receive ts1s within 24 ms, it will transition to configuration.linkwidth.start. in that state, if it receives no ts1s, it will transition to detect. if it receives ts1s, it will configure the link appropriately and return to l0.										
implication	the state transition sequence from the recovery.rcvrlock ltssm state to the configuration.linkwidth.start ltssm state is in violation of the pcie specification. intel has not observed any functional failures due to this erratum with any commercially available pcie devices.										
workaround	none identified.										
											
title	writes to b2bspad[15:0] registers may transfer corrupt data between ntb connected systems										
problem	writes to the ntb (non-transparent bridge) b2bspad[15:0] registers (bar pb01base, sb01base; offsets 100h - 13fh) may result in corrupted data transfer between systems.										
implication	using b2bspad[15:0] registers to transfer data may not work as expected. workaround do not use the b2bspad[15:0] to send data from the local to remote host. instead,										
workaround											
											
title	excessive dram rapl power throttling may lead to a system hang or usb device off-lining										
problem	dram rapl (running average power limit) is a facility for limiting the maximum power consumption of the memory subsystem. dram rapl's control mechanism constrains the number of memory transactions during a particular time period. due to this erratum, a very low power limit can throttle certain memory subsystem configurations to an extent that system failure, ranging from permanent loss of usb devices to system hangs, may result.										
implication	using dram rapl to regulate the memory subsystem power to a very low level may cause platform instability.										
workaround	it is possible for the bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title											
problem	the ntb (non-transparent bridge) operating in ntb/rp (ntb to root port mode) using message signaled interrupts (msi or msi-x) in the presence of locks may result in a system hang.										
implication	due to this erratum, system may hang under the condition described above.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	xsaveopt may fail to save some state after transitions into or out of stm										
problem	the xsaveopt instruction may optimize performance by not saving state that has not been modified since the last execution of xrstor. this optimization should occur only if the executions of xsaveopt and xrstor are either both or neither in smm (system- management mode). due to this erratum, this optimization may be performed by the first execution of xsaveopt after a transition into or out of the stm (smm-transfer monitor) if the most recent execution of xrstor occurred before that transition. for transitions into the stm, the erratum applies only to transitions using the vmcall instruction. this erratum can occur only if the two executions are at the same privilege level, use the same linear address, and are either both or neither in vmx non-root operation. the erratum does not apply if software in smm never uses xrstor or xsaveopt.										
implication	this erratum may lead to unpredictable system behavior.										
workaround	stm software should execute the xrstor instruction with the value 0 in edx:eax after each transition into the stm (after setting cr4.osxsave) and before each transition out of the stm. bytes 512 to 575 of the save area used by xrstor should be allocated in memory, but bytes 0 to 511 need not be. bytes 512 to 535 should all be 0.										
											
title	rank sparing may cause an extended system stall										
problem	the integrated memory controller sequencing during a rank sparing copy operation blocks all writes to the memory region associated with the rank being taken out of service. due to this erratum, this block can result in a system stall that persists until the sparing copy operation completes.										
implication	the system can stall at unpredictable times which may be observed as one time instance of system unavailability.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	system hang may occur when memory sparing is enabled										
problem	due to this erratum, enabling memory sparing can result in an internal timer error as indicated by the ia32_mci_status.mcacod of 0000_0100_0000_0000.										
implication	enabling memory sparing may result in a system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling opportunistic self-refresh and pkg c2 state can severely degrade pcie* bandwidth										
problem	due to this erratum, enabling opportunistic self-refresh can lead to the memory controller over-aggressively transitioning dram to self-refresh mode when the processor is in pkg c2 state.										
implication	the pcie interface peak bandwidth can be degraded by as much as 90%.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	mirrored memory writes may lead to system failures										
problem	in mirrored memory mode, each channel manages its memory write bandwidth resources. due to this erratum, if a channel in mirrored memory mode is heavily utilized, it is possible for issued writes to exceed available bandwidth resulting in write failures.										
implication	a system hang or unpredictable system behavior may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	end agent pcie packet errors may result in a system hang										
problem	pcie agents are required by the pcie base specification to identify and report packet errors. due to this erratum, certain invalid completion types from the end agent are not correctly handled by the processor.										
implication	if a pcie end agent issues certain invalid completion types, the system may hang. workaround none identified.										
workaround											
											
title	retraining cannot be initiated by downstream devices in ntb/ntb or ntb/rp configurations										
problem	the pcie base specification requires that a downstream device can initiate link retraining. due to this erratum, link retraining cannot be initiated by the downstream device in a ntb/ntb (non-transparent bridge) or a ntb/rp (root port) configuration.										
implication	the retrain_link field (lnkcon device 3; function 0; offset 1a0h; bit [5]) does not function as expected in the identified configurations; software referencing the downstream device is not able to retrain the link.										
workaround	the link speed and training must be managed by the upstream host in ntb/ntb or ntb/rp configurations.										
											
title	spurious smis may occur due to memhot# assertion										
problem	the imc (integrated memory controller) can be programmed to generate an smi (system management interrupt) on an internal memhot# event assertion through the mhot_smi_en field (mh_maincntl bus: 1; device: 15; function: 0; offset: 104h; bit[17]) or on assertion of the external memhot[1:0]#pin though the mhot_ext_smi_en field (mh_maincntl bus: 1; device: 15; function: 0; offset: 104h; bit[18]). due to this erratum, a spurious smi may be generated every 500us if both internal and external memhot events are enabled simultaneously.										
implication	due to this erratum, excessive smi generation may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie link bandwidth notification capability is incorrect										
problem	a value of 1 in the link_bandwidth_notification_capability field (lkncap bit 21) for a pcie device indicates support for the link bandwidth notification status and interrupt mechanisms. due to this erratum, this field for ports 2c, 2d, 3c and 3d (lkncap bus 0; device 2,3; function 2,3; offset 09ch; bit 21) always reads as 0 when it should read as 1.										
implication	software that reads this field for the listed ports will incorrectly conclude that the link bandwidth notification status and interrupt mechanisms are not available.										
workaround	software should ignore the value of the link_bandwidth_notification_capability field for ports 2c, 2d, 3c, and 3d.										
											
title	port 3a capability_pointer field is incorrect when configured in pcie mode										
problem	the capability_pointer field (capptr bus 0; device 3; function 0; offset 34h; bits [7:0]) should have its value based on the configured mode of the port, pcie or ntb (non-transparent bridge). due to this erratum, this field reports the ntb value (60h) when in pcie mode instead of the pcie value (40h).										
implication	software depending on the value of this field may not behave as expected.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	uncorrectable intel qpi errors may cause the system to power down										
problem	due to this erratum, under a complex set of conditions, intel qpi uncorrectable errors may cause a deadlock between the processor and pch (platform controller hub). the deadlock will cause a processor internal timeout error as indicated by ia32_mci_status.mcacod of 0000_0100_0000_0000, caterr# assertion and a shutdown transaction being sent to the pch. depending on the platform implementation, this will result in reset being asserted to the pch. this deadlock persists, causing the pch to timeout on the reset request. reacting to the reset request timeout, the pch powers down the system.										
implication	the system will be powered down and the ia32_mci_status register contents will be lost. the system may need to be manually powered back on. intel has not observed this erratum in the absence of injected uncorrectable intel qpi errors.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum. this is a partial workaround that causes the system to power cycle, eliminating the need for manual power on. the ia32_mci_status register contents are still lost.										
											
title	four outstanding pcie configuration retries may cause deadlock										
problem	pcie configuration retries are allowed for older generation pci/pci-x bridges that take a long time to respond to configuration cycles after a reset. due to this erratum, a fifth configuration cycle following the fourth pcie configuration retry may not make progress, resulting in a deadlock.										
implication	a deadlock could occur. intel has not observed this erratum with any commercially available system.										
workaround	when configuring devices on pci/pci-x buses, bios should wait for configuration cycles to complete before issuing subsequent configuration cycles.										
											
title	a peci rdpciconfiglocal command referencing a non-existent device may return an unexpected value										
problem	configuration reads to non-existent pci configuration registers should return 0ffff_ffffh. due to this erratum, when the peci rdpciconfiglocal command references a non-existent pci configuration register, the value 0000_0000h may be returned instead of the expected 0ffff_ffffh.										
implication	a peci rdpciconfiglocal command referencing a non-existent device may observe a return value of 0000_0000h. software expecting a return value of 0ffff_ffffh to identify non-existent devices may not work as expected.										
workaround	software that performs enumeration via the peci "rdpciconfiglocal" command should interpret 0ffff_ffffh and 0000_0000h values for the vendor identification and device identification register as indicating a non-existent device.										
											
title	some pcie ccr values are incorrect										
problem	the ccr (class code register) value for the following devices should be 088000h instead is 000000h: bus 0; device 6; function 1-7; offset 09h; bits [23:0] bus 0; device 7; function 0-4; offset 09h; bits [23:0]										
implication	due to this erratum, the ccr base and sub-class status of the listed pcie devices is incorrectly reported and may cause software to conclude that these devices are host bridges and are not general system peripherals.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	when in dmi mode, port 0's device_port_type field is incorrect										
problem	when in dmi mode, the device_port_type field (pxpcap bus 0; device 0; function 0; offset 92h; bits [7:4]) should read as 9h (dmi mode) but incorrectly reads as 4h (pcie* mode).										
implication	software may incorrectly conclude that this port is operating in pcie mode when it is actually being used in the dmi mode.										
workaround	none identified.										
											
title	pcie tph attributes may result in unpredictable system behavior										
problem	tph (transactions processing hints) are optional aids to optimize internal processing of pcie transactions. due to this erratum, certain transactions with tph attributes may be misdirected, resulting in unpredictable system behavior.										
implication	use of the tph feature may affect system stability.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	continuous intel qpi retraining feature indication is incorrect										
problem	the processor is capable of continuous intel qpi retraining. due to this erratum, the field reporting support for this feature “continuous retraining” (qpireut_ph_cpr bus 1; device 8,9; function 3; offset 128h; bit 18) indicates this feature is not supported although it is enabled and cannot be disabled.										
implication	due to this erratum, it is not possible to disable the continuous intel qpi retraining feature.										
workaround	none identified.										
											
title	correctable memory errors may result in unpredictable system behavior										
problem	under certain conditions, the processor may not detect or correct a correctable memory error.										
implication	when this erratum occurs, it may result in unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	ia32_mci_status addrv bit may be incorrectly cleared										
problem	the ia32_mci_status msr's addrv bit (bit 58) is set upon logging an error in order to indicate that the contents of the ia32_mci_addr msr is valid. due to this erratum, a cancelled speculative load of poisoned data spanning a cacheline boundary can clear the addrv flag associated with a previously logged error report.										
implication	the clearing of the addrv flag in ia32_mci_status when this erratum occurs will result in the loss of the address logged in a correctable error report. it should be noted that a cancelled speculative load of poisoned data that crosses a cacheline boundary is an unusual occurrence.										
workaround	none identified.										
											
title	intel® quickdata technology dma lock quiescent flow causes dma state machine to hang										
problem	the lock quiescent flow is a means for an agent to gain sole ownership of another agent's resources by preventing other devices from sending transactions. due to this erratum, during the lock quiescent flow, the intel quickdata technology dma read and write queues are throttled simultaneously. this prevents subsequent read completions from draining into the write queue, hanging the dma lock state machine.										
implication	the dma lock state machine may hang during a lock quiescent flow.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	malformed tlp power management messages may be dropped										
problem	the pcie base specification requires power management messages to use the default traffic class designator, tc0, and receivers to check for violations of this rule. due to this erratum, a tlp using a non-default traffic class designator will be dropped, rather than handled as a malformed tlp.										
implication	an advanced error reporting err_fatal notification will not be logged for malformed tlp power management messages.										
workaround	none identified										
											
title	core frequencies at or below the dram ddr frequency may result in unpredictable system behavior										
problem	the intel speedstep® technology can dynamically adjust the core operating frequency to as low as 1200 mhz. due to this erratum, under complex conditions and when the cores are operating at or below the dram ddr frequency, unpredictable system behavior may result.										
implication	systems using intel speedstep technology with ddr3-1333 or ddr3-1600 memory devices are subject to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	quad rank dimms may not be properly refreshed during ibt_off mode										
problem	the integrated memory controller incorporates a power savings mode known as ibt_off (input buffer termination disabled). due to this erratum, quad rank dimms may not be properly refreshed during ibt_off mode.										
implication	use of ibt_off mode with quad rank dimms may result in unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel® quickdata technology dma non-page-aligned next source/ destination addresses may result in unpredictable system behavior										
problem	non-page aligned intel® quickdata technology dma next source/destination addresses may cause memory read-write collisions.										
implication	due to this erratum, using non-page aligned next source/destination addresses may result in unpredictable system behavior.										
workaround	next source/destination addresses must be page aligned. the intel-provided intel quickdata technology dma driver abides by this alignment rule.										
											
title	enabling relaxed ordering with intel quickdata technology may result in a system hang										
problem	enabling ro (relaxed ordering) for intel quickdata technology transactions via the enable relaxed ordering field (devcon device 4; function 0-7; offset 98h; bit 4) while inbound ro is disabled for the dma via the disable ro field on writes from intel quickdata dma (iiomiscctrl device 5; function 0; offset: 1c0h; bit 22) creates a conflict. the disable inbound ro for intel quickdata dma writes control takes precedence. due to this erratum, the processor will incorrectly return a strongly ordered completion for the transaction which can then live lock or result in a system hang.										
implication	the processor may live lock resulting in a system hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	spurious crc errors may be detected on intel qpi links										
problem	the processor autonomously manages intel qpi (quickpath interconnect) link power state transitions based on link idle intervals. due to this erratum, crc errors may be detected during intel qpi link power state transitions and may be logged in qpireut_err_ced (bus 1; device 8,9; function 3; offset 120h).										
implication	spurious intel qpi link crc errors may be reported.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	peci temperature lower limit may be as high as 7°c										
problem	peci reports temperatures as an offset from the prochot threshold (a negative value when the temperature is below the prochot threshold, zero when at or above that threshold). if the temperature is below 0°c, peci responds with an “invalid temperature” encoding (8002h). due to this erratum, peci may indicate an invalid temperature when the actual temperature is as high as 7°c.										
implication	an invalid temperature report from peci indicates the actual temperature is 7°c or lower. platform facilities depending peci to provide accurate temperature readings between 0°c and 7°c may not function correctly.										
workaround	none identified.										
											
title	the dram power meter may not be accurate										
problem	the dram power meter uses vr (voltage regulator) current readings in combination with weighted activity counters to provide a running estimate of dram subsystem power. due to this erratum, the dram power meter may not be sufficiently accurate for system power management purposes.										
implication	the dram power meter cannot be relied upon to provide accurate dram subsystem power measurements. reduced or variable system performance may be a side effect.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	pcie* port 3 link training may be unreliable in ntb mode										
problem	if pcie port 3 is in ntb (non-transparent bridge) mode and both the root port and endpoint hardware autonomous speed disable fields (lnkcon2 bus 0; device 3; function 0; offset 0c0h; bit 5) are set to 0, link training may fail. the recovery.rcvrlock state may intermittently timeout and transition to the detect state.										
implication	the ntb port link training may be unreliable.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	functionally benign pcie* electrical specification violation compendium										
problem	violations of pcie electrical specifications listed in the table below have been observed.										
implication	intel has not observed failures from the violations listed in this erratum on any commercially available platforms and/or using commercially available pcie devices.										
workaround	none identified.										
											
title	a machine check exception due to instruction fetch may be delivered before an instruction breakpoint										
problem	debug exceptions due to instruction breakpoints take priority over exceptions resulting from fetching an instruction. due to this erratum, a machine check exception resulting from the fetch of an instruction may take priority over an instruction breakpoint if the instruction crosses a 32-byte boundary and the second part of the instruction is in a 32-byte poisoned instruction fetch block.										
implication	instruction breakpoints may not operate as expected in the presence of a poisoned instruction fetch block.										
workaround	none identified.										
											
title	intel® qpi may report a reserved value in the link initialization status field during link training										
problem	an intel qpi (quickpath interconnect) link reports its link training progress in the intel qpi link status register. due to this erratum, the link initialization status (qpils bus 1; device 8,9; function 0; offset 48h; bits [27:24]) incorrectly reports a reserved encoding of 1101b while in the “initial credit return (initializing credits)” state. the correct encoding for the “initial credit return (initializing credits)” state is 0101b.										
implication	software that monitors the link initialization status field during link training may see a reserved encoding reported.										
workaround	none identified. software may ignore or re-interpret the incorrect encoding for this processor.										
											
title	enhanced intel speedstep® technology may cause a system hang										
problem	enhanced intel speedstep® technology dynamically changes core operating frequencies. due to this erratum, under complex conditions, core frequency changes may result in a system hang.										
implication	enhanced intel speedstep technology may cause a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	prochot may be incorrectly asserted at reset										
problem	the prochot signal is used to indicate elevated processor temperatures during normal operation and is used for frb (fault resilient boot) actions during the reset sequence. due to this erratum, the elevated temperature indication usage of prochot can persist into reset and subsequently can cause improper frb actions.										
implication	elevated die temperatures at reset time may impair platform operation. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	package c3-state and package c6-state residency is too low										
problem	the intel qpi link must transition to its l1 power state for the processor to enter package c3-state or package c6-state. due to this erratum, the intel qpi link does not transition to l1 as intended, restricting the processor from reaching package c3-state or package c6-state.										
implication	the increased idle state power consumption caused by reduced package c3-state and package c6-state residency may exceed the processor idle power specification for multi-socket platforms.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	peci rdpkgconfig() may return invalid data for an unsupported channel										
problem	the processor's peci facility can report the current temperature of each of the dimms on a specified channel (peci rdpkgconfig command, index 14h, dimm_temperature_read). valid channel numbers range from 0 to 3. channel numbers outside of the valid range should be detected and flagged. due to this erratum, meaningless values are returned without an error flag when 4 is specified as the channel number.										
implication	using channel 4 with the peci rdpkgconfig dimm_temperature_read command does not return an error flag.										
workaround	none identified.										
											
title	dram pbm overflow may result in a system hang										
problem	the dram pbm (power budget meter) manages dram power consumption. due to this erratum, under complex platform conditions, the dram pbm may throttle the memory subsystem to such a great extent that a system hang results.										
implication	the dram pbm may cause platform instability.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	combining rol transactions with non-rol transactions or marker skipping operations may result in a system hang										
problem	when intel® quick data technology dma rol (raid on load) transactions and non- rol transactions are simultaneously active, and the non-rol address offsets are not cacheline boundary aligned, the non-rol transaction's last partial cacheline data write may be lost leading to a system hang. in addition, when intel quickdata dma rol transactions are active, marker skipping operations may lead to a system hang.										
implication	when this erratum occurs, the processor may live lock resulting in a system hang.										
workaround	none identified. when rol transactions and non-rol transactions are simultaneously active, all non-rol address offsets must be aligned on cacheline boundaries. further, marker skipping operations may not be used on any dma channel when rol transactions are active.										
											
title	error indication in pcie lane error status incorrectly set when operating at 8 gt/s										
problem	the lane error status field in bits[15:0] of lnerrsts (device 1; function 0,1; offset 258h; and device 2,3; function 0,1,2,3; offset 258h) is used to monitor errors on the pcie lanes. due to this erratum, the lnerrsts bits associated with the lanes operating at 8 gt/s port are spuriously set.										
implication	lnerrsts cannot be used to reliably monitor errors on the pcie lanes operating at 8 gt/s.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie* link may not train to full width										
problem	during pcie link training, the receiver looks at symbols in the ts1 and ts2 ordered sets as indicators of lane polarity inversion. if polarity inversion is detected, the receiver must invert those lane(s). due to this erratum, the receiver may incorrectly set polarity inversion.										
implication	pcie links may not train to full width.										
workaround	none identified. perform a secondary bus reset on the link up to three times to achieve full width.										
											
title	the minimum snoop latency requirement that can be specified is 64 microseconds										
problem	the pcie_iltr_ovrd csr (device 10; function 1; offset 78h) and sw_ltr_ovrd msr (0a02h) include fields defined to allow specification of a required maximum snoop latency threshold. that maximum latency is intended to be used by the processor to adjust various operational parameters so that the latency requirement can be met. due to this erratum, the minimum latency value that can be specified via the snoop latency multiplier field (bits[28:26]) and the snoop latency value field (bits[25:16]) is 64 microseconds.										
implication	a minimum snoop latency requirement of 64 microseconds is so long that these registers are not useful.										
workaround	none identified. bios and the os have other means to specify package c-state exit latency maximums, which is the typical use model for setting pcie snoop latency limits.										
											
title	patrol scrubbing doesn't skip ranks disabled after ddr training										
problem	if a rank is detected as failed after completing ddr training then bios will mark it as disabled. disabled ranks are omitted from the os memory map. due to this erratum, a rank disabled after ddr training completes is not skipped by the patrol scrubber. patrol scrubbing of the disabled ranks may result in superfluous correctable and uncorrectable memory error reports.										
implication	disabling ranks after ddr training may result in the over-reporting of memory errors.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	simultaneously enabling patrol scrubbing, package c-states, and rank sparing may cause the patrol scrubber to hang										
problem	patrol scrubbing is a ras facility that scans all physical memory (including any spare ranks) to find errors and attempts to fix single bit errors. patrol scrubbing is suspended when the processor enters a deep package c-state then resumed when that package c- state is exited. due to this erratum, under complex conditions, resuming patrol scrubbing from a package c-state after a rank sparing event may cause the patrol scrubber to hang.										
implication	enabling package c-states, rank sparing, and patrol scrubbing simultaneously can lead to a patrol scrubber hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	patrol scrubbing will report uncorrectable memory errors found on a spare rank										
problem	due to this erratum, patrol scrubbing signals an uncorrectable machine check event when it encounters an uncorrectable error while scrubbing a spare rank. the error logged in ia32_mc{8-11}_status (msr 421h, 425h, 429h, 42dh) will have the pcc field (bit 57) set to '1' and the addrv field (bit 58) set to '0' (that is, there is no address information associated with the error report).										
implication	an uncorrectable machine check event may occur for physical memory that is not in use at the time of the event.										
workaround	none identified.										
											
title	patrol scrubbing during memory mirroring may improperly signal uncorrectable machine checks										
problem	with memory mirroring enabled, patrol scrub detection of an uncorrectable error on one channel of the mirror should be downgraded to a correctable error when valid data is present on the other channel of the mirror. due to this erratum, patrol scrub detection of an uncorrectable error always signals an uncorrectable machine check.										
implication	this erratum may cause reduced availability of systems with mirrored memory.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	directory mode and memory mirroring are incompatible with demand scrubbing or mirror scrubbing										
problem	directory mode is a performance feature used on four socket and scalable platforms to reduce average snoop latency. mirror scrubbing attempts to erase uncorrectable errors found in one mirror channel by overwriting them with the correct data from the other channel. due to this erratum, enabling memory mirroring and directory mode with demand scrubbing and/or mirror scrubbing can result in unpredictable system behavior. patrol scrubbing with memory mirroring enabled and directory mode enabled is not affected by this erratum.										
implication	enabling memory mirroring and directory mode with demand scrubbing and/or mirror scrubbing can lead to unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	spurious power limit interrupt may occur at package c-state exit										
problem	the processor monitors power consumption and uses that information to limit core operating frequency. due to this erratum, power consumption may be improperly calculated by the processor during package c-states. as a result, the processor may incorrectly signal a power limit interrupt.										
implication	in response to a power limit interrupt, the os may choose to operate the processor at its minimum frequency for several milliseconds after the package c-state exit.										
workaround	none identified. the os can mask these interrupts by setting the power limit interrupt enable field (bit 24) in the ia32_therm_interrupt msr (19bh) to 0.										
											
title	intel vt-d translation fault may be dropped										
problem	due to this erratum, under complex conditions, an intel vt-d translation request that results in a dma remapping fault (more commonly called “translation fault”) may be lost.										
implication	an intel vt-d translation fault might not be properly reported.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum										
											
title	the accumulated energy status read service may report a power spike early in boot										
problem	the peci rdpkgconfig() command with an index value of 03h is the accumulated energy status read service. during platform boot, the accumulated energy status read service returns an accumulated energy value of 0. later in the boot flow, due to this erratum, the accumulated energy status read service returns a value that is large. energy values calculated with the first non-zero sample have been observed to be as high as 10kj over a limited number of parts.										
implication	software may interpret values returned by the accumulated energy status read service during boot time as indicating a large power spike. this could lead to unexpected or undesired platform power management actions.										
workaround	once the first non-zero value is detected, the difference between subsequent sequential values is a reliable measure of energy consumed between the sample points.										
											
title	certain uncorrectable errors may cause loss of peci functionality										
problem	a peci completion code of 91h indicates the pcu (power control unit) detected an uncorrectable error that prevented processing of the peci request. due to this erratum, certain pcu or vrm error conditions may lead to a persistent 91h completion code for subsequent peci request. uncorrectable pcu errors are reported with an ia32_mc4_status.mcacod (msr 411h, bits[15:0]) value of 0000_0100_0000_0010, ia32_mc4_status.valid (bit 63) set to 1, and ia32_mc4_status.uc (bit 61) set to 1.										
implication	peci processing may be blocked until either a cold reset or software running on one of the cores clears the ia32_mc4_status register.										
workaround	none identified. software running on one of the cores can clear the ia32_mc4_status register to restore peci functionality.										
											
title	machine check during vm exit may result in vmx abort										
problem	a machine check signaled during vm exit should cause a vmx abort only if the machine check would prevent successful completion of the vm exit; ordinarily, the machine check should be delivered after the vm exit completes. due to this erratum, certain machine checks (for example, an uncorrectable cache error detected by another logical processor) may force a vm exit to result in a vmx abort even when that machine check does not interfere with the vm exit completing correctly.										
implication	certain machine checks that could be reported in the host context for orderly logging and analysis may instead induce a vmx abort and shut down the logical processor.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	address of poisoned data logged in ia32_mci_addr msr may be incorrect										
problem											
implication	under certain complex conditions, it is possible for the indication of poisoned data in one cache line to be incorrectly associated with a different cache line. the mcacod field (ia32_mci_status msr, bits[15:0]) value of 000x_0001_xxxx_xx10 indicates poisoned data but the address logged in the ia32_mci_addr msr may not be that of the poisoned data.										
workaround	due to this erratum, the address with poisoned data may not be correctly logged in the ia32_mci_addr msr.										
											
title	routing intel® high definition audio traffic through vc1 may result in system hang										
problem	when bit 9 in the iiomiscctrl csr (bus 0; device 5; function 0; offset 1c0h) is set, vcp inbound traffic (intel® hd audio) is routed through vc1 to optimize isochronous traffic performance. due to this erratum, vc1 may not have sufficient bandwidth for all traffic routed through it; overflows may occur.										
implication	this erratum can result in lost completions that may cause a system hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel® quickdata technology dma suspend does not transition from armed to halt state										
problem	suspending an intel quickdata technology dma channel while in the armed state should transition the channel to the halt state. due to this erratum, suspending a dma channel while in the armed state does not change the state to halt and will cause the dma engine, when subsequently activated, to ignore the first descriptor's fence control bit and may cause the dma engine to prematurely discard the first descriptor during the copy stage.										
implication	suspending a dma channel while in the armed state will cause the dma engine to ignore descriptor fencing, possibly issue completion status without actually completing all descriptors, and may be subject to unexpected activation of dma transfers.										
workaround	check the dma_trans_state (chansts_0; bus 0; mmio bar: cb_bar [0:7]; offset 88h; bits[2:0]) to ensure the channel state is either idle (001b) or active (000b) before setting susp_dma (chancmd; bus 0; mmio bar: cb_bar [0:7]; offset 84h; bit 2).										
											
title	package_energy_counter register may incorrectly report power consumed by the execution of intel® advanced vector extensions (intel® avx) instructions										
problem	the processor includes a package_energy_counter register to provide real-time energy consumption information. this facility can be accessed by the peci rdpkgconfig() command with an index value of 03h (the accumulated energy status read service), by reading the pkg_energy_status msr (611h) or by reading package_energy_status csr (bus 1; device 10; function 0; offset 90h). due to this erratum, the power consumption reported during the execution of intel® advanced vector extensions (intel® avx) instructions is inaccurate.										
implication	software that uses the package_energy_counter register value during the execution of intel avx instructions may not behave as expected, possibly compromising thermal load balancing, processor throttling, or other platform management operations.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	suspending/resetting a dma xor channel may cause an incorrect data transfer on other active channels										
problem	suspending an active dma xor channel by setting chancmd.suspend dma bit (offset 84; bit 2) while xor type dma channels are active may cause incorrect data transfer on the other active legacy channels. this erratum may also occur while resetting an active dma xor channel chancmd.reset dma bit (offset 84; bit 5). chancmd is in the region described by cb_bar (bus 0; device 4; function 0-7; offset 10h).										
implication	due to this erratum, an incorrect data transfer may occur on the active legacy dma channels.										
workaround	software must suspend all legacy dma channels before suspending an active dma xor channel (channel 0 or 1).										
											
title	intel qpi power management may lead to unpredictable system behavior										
problem	intel qpi protocol includes a mechanism allowing a link in l0 state to dynamically adjust its electrical characteristics for optimal data transmission quality. due to this erratum, intel qpi links may remain in l0p or l1 state long enough to prevent dynamic adjustment, making the link unreliable.										
implication	long-term idle or low utilization intel qpi links can cause system instability. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	intel® qpi l0s exit may cause an uncorrectable machine check										
problem	intel qpi links can transition to a lower power state, l0s, to reduce power consumption during transmitter idle periods. due to this erratum, when an intel qpi link exits l0s state, the resulting retraining may not be successful.										
implication	due to this erratum, an uncorrectable error signaled with ia32_mci_status.mcacod value of 0000_1110_0000_1111 and ia32_mci_status.mscod[5:0] value of 00_0000 may occur when an intel qpi link exits from l0s state.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	coherent interface write cache may report false correctable ecc errors during cold reset										
problem	the integrated i/o's coherent interface write cache includes ecc logic to detect errors. due to this erratum, the write cache can report false ecc errors. this error is signaled by asserting bit 1 (write cache corrected ecc) in the irpp0errst csr (bus 0; device 5; function 2; offset 230h) or the irpp1errst csr (bus 0; device 5; function 2; offset 2b0h).										
implication	if the coherent interface write cache ecc is enabled, the processor may incorrectly indicate correctable ecc errors in the write cache.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel quickdata technology continues to issue requests after detecting 64-bit addressing errors										
problem	intel quickdata technology utilizes the lower 48 address bits of a 64-bit address field. detection of accesses to source address, destination address, descriptor address, chain address, or completion address outside of this 48-bit range are flagged as “64-bit addressing errors” and should halt dma processing. due to this erratum, the intel quickdata dma continues to issue requests after detecting certain 64-bit addressing errors involving raid operations. the failing condition occurs for 64-bit addressing errors in either a channel completion upper address register (chancmp_0, chancmp_1) (bus 0; mmio bar cb_bar [0:7]; offset 98h, 9ch), or in the source or destination addresses of a raid descriptor.										
implication	programming out of range dma address values may result in unpredictable system behavior.										
workaround	ensure all raid descriptors, chancmp_0, and chancmp_1 addresses are within the 48-bit range before starting the dma engine.										
											
title	encountering poison data while memory mirroring is enabled may cause an invalid machine check										
problem	memory mirroring is a ras feature which may allow the memory subsystem to survive an uncorrectable memory error. due to this erratum, under a complex set of conditions, when mirroring and poisoning are both enabled and poison is encountered on one mirror channel, an invalid uncorrectable machine check may occur along with the expected corrected error. they will be reported as an uncorrectable cache hierarchy error, ia32_mci_status with mcacod = 0000_0001_0011_0100 and mscod = 0000_0000_0001_0000, along with a corrected memory controller error, ia32_mci_status with mcacod = 0000_0000_1010_cccc and mscod[2] = 1 in combination with ia32_mci_misc[32] = 1.										
implication	due to this erratum, a spurious uncorrectable machine check may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie* ro may result in a system hang or unpredictable system behavior										
problem	pcie ro (relaxed ordering) is not supported on this processor. due to this erratum, enabling ro or, equivalently, not disabling ro throughout the integrated i/o logic may lead to unpredictable system behavior or a system hang.										
implication	enabling ro for any port or channel may lead to system instability.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel vt-d invalidation time-out error may not be signaled										
problem	intel vt-d (intel virtualization technology for directed i/o) utilizes itags to identify ats (address translation services) invalidation requests for invalidating device-tlbs on endpoint devices. when an ats invalidation response time-out is detected, the corresponding itag is freed and an invalidation time-out error is signaled through the vt-d fault status register. due to this erratum, an ats invalidation response timeout is detected and reported only for the first outstanding itag entry.										
implication	as a result of the erratum, the ats invalidation response timeout condition may not be reliably reported when multiple invalidation requests are outstanding. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	spurious machine check errors may occur										
problem	the ia32_mci_ctl msr comprises enable bits for various machine check events. when a particular machine check event occurs but the associated bit in ia32_mci_ctl msr is not set, the error is not signaled but is logged with the en flag (bit 60 in ia32_mci_status msr) set to zero. further, the logged error report is not protected from being overwritten by succeeding machine check events (whether those events have the associated ia32_mci_ctl bit set or cleared). due to this erratum, it is possible that a ucr (uncorrectable recoverable) error with the associated bit in ia32_mci_ctl msr set will only set the over flag (ia32_mci_status msr bit 62) rather than correctly overwriting the entire previously logged error when that previously logged error does not have ia32_mci_status.en set.										
implication	the machine check handler may interpret the failed overwrite as a spurious error. workaround none identified										
workaround											
											
title	enhanced intel speedstep® technology hardware coordination cannot be disabled										
problem	the processor should permit hardware coordination of enhanced intel speedstep technology requests to be disabled (then use the most recent p-state request from any core or logical processor to set the processor-wide p-state target). due to this erratum, the enhanced intel speedstep technology hardware coordination disable value in bit 0 of the misc_pwr_mgmt msr (1aah) is ignored; hardware coordination is always enabled.										
implication	it is not possible to prevent hardware p-state coordination.										
workaround	none identified.										
											
title	pcie link upconfigure capability is incorrectly advertised as supported										
problem	the processor does not allow pcie devices to dynamically change link width but, due to this erratum, the pcie link upconfigure capability bit is incorrectly advertised as supported.										
implication	when a downstream device attempts to dynamically change the link's width, the link may not correctly retrain, resulting in an incorrect link width, reversed lane numbers, or surprise link down (sld).										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	the ia32_mci_misc.hadbbank field should be ignored										
problem	the ia32_mci_misc.hadbbank field should be ignored										
implication	when analyzing machine check register bank contents, the ia32_mci_misc.hadbbank field should be ignored.										
workaround	none identified										
											
title	when a pcie x4 port detects a logical lane 0 failure, the link will advertise incorrect lane numbers										
problem	the pcie interface incorporates a recovery mechanism for link degradation by retraining the link without affecting pending transactions. when a x4 port detects a lane failure on logical lane 0, the link degrades from x4 to x2 and lane reversal occurs. due to this erratum, after degrading to x2 and reversing the lanes, the link will incorrectly advertise lane numbers as “pad 0 1 0" instead of the correct “pad pad 1 0".										
implication	devices that have the ability to negotiate a link with logical lane 0 on a mid physical lane may fail to successfully train the link.										
workaround	none identified.										
											
title	certain pcie* tlps may be dropped										
problem	a pcie tlp (transaction layer packet) header can specify the request alignment (via byte enables), include tph (transaction processing hints), and request address translation via the at field. due to this erratum, a tlp with non-zero byte enables (i.e., not dword-aligned) that includes a non-zero tph and with an at field of “01” may be dropped.										
implication	under the conditions noted, a pcie tlp may be dropped, causing unpredictable system behavior. intel has not observed this erratum with any commercially available software.										
workaround	platforms must ensure that tph and address translation requests are not used in the same tlp. the most direct means is to disable tph in a pcie device that may request an address translation. this can be accomplished by ensuring that tph requester control register (at offset 08h in the device's tph requester capability structure) bits [9:8] are zero.										
											
title	a machine check exception concurrent with an i/o smi may be erroneously reported as re-startable										
problem	a machine check exception that is delivered between the execution of an i/o instruction (in, ins, out, or outs) and an smi (system-management interrupt) triggered by that instruction may prevent proper handling of the smi; because of this, the machine check exception should not be reported as restartable. due to this erratum, such a machine check exception may be reported as restartable.										
implication	a restartable machine check exception on an i/o instruction concurrent with a resulting smi may result in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the system agent temperature is not available										
problem	due to this erratum, the processor does not record the temperature of the system agent in the temperature field in bits [7:0] of the sa_temperature csr (device 10; function 2; offset: 044h).										
implication	firmware cannot read the temperature of the system agent via accessing the sa_temperature csr.										
workaround	none identified. the system agent temperature is available via peci rdpkgconfig command service, parameter value 00ffh.										
											
title	an acm error may cause a system power down										
problem	an intel txt (intel trusted executed technology) enabled system that detects an acm (authenticated code module) error should perform a warm reset then start-up in non- trusted mode. due to this erratum, an acm error may cause the system to power down.										
implication	the system may unexpectedly power down.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	incorrect retry packets may be sent by a pcie x16 port operating at 8 gt/s										
problem	a pcie x16 port operating at 8 gt/s transmitting 256 byte completion tlps may not replay tlps correctly.										
implication	due to this erratum, unpredictable system behavior may result when a 256 byte completion tlp is replayed on a pcie x16 port operating at 8 gt/s.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	intel® quickdata technology may incorrectly signal a master abort										
problem	under complex conditions, a master abort error suffered by an intel quickdata technology dma channel running non-raid operations may be reported for both the failing transfer and a transfer on a different channel actively performing raid operations. note that master abort errors on intel quickdata technology dma transfers are unusual, generally indicating dma transfer configuration errors.										
implication	due to this erratum, raid intel quickdata technology transfers may receive spurious master abort errors.										
workaround	none identified. to avoid this erratum: (1) ensure non-raid operations do not receive any master aborts errors, (2) do not request fencing (by asserting bit 4) or interrupt on completion (by asserting bit 0) in the descriptor control field, or (3) do not use raid operations.										
											
title	mci_addr may be incorrect for cache parity errors										
problem	in cases when a wbinvd instruction evicts a line containing an address or data parity error (mcacod of 0x124, and mscod of 0x10), the address of this error should be logged in the mci_addr register. due to this erratum, the logged address may be incorrect, even though mci_status.addrv (bit 63) is set.										
implication	the address reported in mci_addr may not be correct for cases of a parity error found during wbinvd execution.										
workaround	none identified.										
											
title	instruction fetch page-table walks may be made speculatively to uncacheable memory										
problem	page-table walks on behalf of instruction fetches may be made speculatively to uncacheable (uc) memory.										
implication	if any paging structures are located at addresses in uncacheable memory that are used for memory-mapped i/o, such i/o operations may be invoked as a result of speculative execution that would never actually occur in the executed code path. intel has not observed this erratum with any commercially available software.										
workaround	software should avoid locating paging structures at addresses in uncacheable memory that are used for memory-mapped i/o.										
											
title	intel® quickdata technology dma channel write abort errors may cause a channel hang										
problem	when the “fence” bit in the base descriptor control field is set, the dma engine assures all data for that operation (and previous operations) has been written before considering a transfer complete and beginning to process the next chained base descriptor. in addition, upon completion of a transfer, the dma engine can notify software of the completion via either an interrupt, a memory write to a programmed location, or both. due to this erratum, the dma engine, while processing chained dma descriptors with fencing or interrupt completion enabled, may hang and not enter the halt state as expected if a write error that results in an abort occurs.										
implication	a dma transfer that suffers a write abort error when fencing or interrupt completion is enabled may hang.										
workaround	do not enable fencing bit [4] or interrupt completion bit [0] in the descriptor control field.										
											
title	the processor may not properly execute code modified using a floating-point store										
problem	under complex internal conditions, a floating-point store used to modify the next sequential instruction may result in the old instruction being executed instead of the new instruction.										
implication	self- or cross-modifying code may not execute as expected. intel has not observed this erratum with any commercially available software.										
workaround	none identified. do not use floating-point stores to modify code.										
											
title	execution of getsec[sexit] may cause a debug exception to be lost										
problem	a debug exception occurring at the same time that getsec[sexit] is executed or when an sexit doorbell event is serviced may be lost.										
implication	due to this erratum, there may be a loss of a debug exception when it happens concurrently with the execution of getsec[sexit]. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	warm reset may cause pcie hot-plug to fail										
problem	the integrated i/o unit uses the vpp (virtual pin port) to communicate with devices that interface to the switches and leds associated with pcie hot-plug sequencing. due to this erratum, vpp operation stalls when a warm reset occurs and then experiences delayed reset. depending on timing alignment with the warm reset event, a vpp transaction in progress around the time of a warm reset may suffer an extended stall or an immediate termination.										
implication	hot-plug sequencing may suffer failures during or shortly after warm resets which may be temporary or persist until the next cold reset.										
workaround	none identified.										
											
title	certain local memory read / load retired perfmon events may undercount										
problem	due to this erratum, the local memory read / load retired perfmon events listed below may undercount. mem_load_uops_retired.llc_hit mem_load_uops_retired.llc_miss* mem_load_uops_llc_hit_retired.xsnp_miss mem_load_uops_llc_hit_retired.xsnp_hit mem_load_uops_llc_hit_retired.xsnp_hitm mem_load_uops_llc_hit_retired.xsnp_none mem_load_uops_llc_miss_retired.local_dram* mem_load_uops_llc_miss_retired.remote_dram* mem_trans_retired.load_latency*										
implication	the affected events may undercount, resulting in inaccurate memory profiles workaround the undercount of these events can be partially resolved (but not eliminated) by										
workaround											
											
title	ia32_mc5_ctl2 is not cleared by a warm reset										
problem	ia32_mc5_ctl2 msr (285h) is documented to be cleared on any reset. due to this erratum this msr is only cleared upon a cold reset.										
implication	the algorithm documented in software developer's manual, volume 3, section titled “cmci initialization” or any other algorithm that counts the ia32_mc5_ctl2 msr being cleared on reset will not function as expected after a warm reset.										
workaround	none identified.										
											
title	rformance monitor counters may produce incorrect results										
problem	when operating with smt enabled, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled event on the corresponding counter with the same number on the physical core's other thread rather than the thread experiencing the event. processors with smt disabled in bios are not affected by this erratum the list of affected memory at-retirement events is as follows: mem_uop_retired.loads mem_uop_retired.stores mem_uop_retired.lock mem_uop_retired.split mem_uop_retired.stlb_miss mem_load_uops_retired.hit_lfb mem_load_uops_retired.l1_hit mem_load_uops_retired.l2_hit mem_load_uops_retired.llc_hit mem_load_uops_llc_hit_retired.xsnp_hit mem_load_uops_llc_hit_retired.xsnp_hitm mem_load_uops_llc_hit_retired.xsnp_miss mem_load_uops_llc_hit_retired.xsnp_none mem_load_uops_retired.llc_miss mem_load_uops_llc_miss_retired.local_dram mem_load_uops_llc_miss_retired.remote_dram mem_load_uops_retired.l2_miss										
implication	due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.										
workaround	none identified.										
											
title	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set										
problem	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.										
implication	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.										
workaround	none identified.										
											
title	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding										
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9:1 report the highest index value used for any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9:1] to read and write all vmcs fields may omit one field.										
workaround	none identified.										
											
title	the upper 32 bits of cr3 may be incorrectly used with 32-bit paging										
problem	when 32-bit paging is in use, the processor should use a page directory located at the 32-bit physical address specified in bits 31:12 of cr3; the upper 32 bits of cr3 should be ignored. due to this erratum, the processor will use a page directory located at the 64-bit physical address specified in bits 63:12 of cr3.										
implication	the processor may use an unexpected page directory or, if ept (extended page tables) is in use, cause an unexpected ept violation. this erratum applies only if software enters 64-bit mode, loads cr3 with a 64-bit value, and then returns to 32-bit paging without changing cr3. intel has not observed this erratum with any commercially available software.										
workaround	software that has executed in 64-bit mode should reload cr3 with a 32-bit value before returning to 32-bit paging.										
											
title	ept violations may report bits 11:0 of guest linear address incorrectly										
problem	if a memory access to a linear address requires the processor to update an accessed or dirty flag in a paging-structure entry and if that update causes an ept violation, the processor should store the linear address into the “guest linear address” field in the vmcs. due to this erratum, the processor may store an incorrect value into bits 11:0 of this field. (the processor correctly stores the guest-physical address of the paging- structure entry into the “guest-physical address” field in the vmcs.)										
implication	software may not be easily able to determine the page offset of the original memory access that caused the ept violation. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	software requiring the page offset of the original memory access address can derive it by simulating the effective address computation of the instruction that caused the ept violation.										
											
title	virtual-apic page accesses with 32-bit pae paging may cause a system crash										
problem	if a logical processor has ept (extended page tables) enabled, is using 32-bit pae paging, and accesses the virtual-apic page then a complex sequence of internal processor micro-architectural events may cause an incorrect address translation or machine check on either logical processor.										
implication	this erratum may result in unexpected faults, an uncorrectable tlb error logged in ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_0000_0001_xxxxb (where x stands for 0 or 1), a guest or hypervisor crash, or other unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* header of a malformed tlp is logged incorrectly										
problem	if a pcie port receives a malformed tlp (transaction layer packet), an error is logged in the uncerrsts register (device 0; function 0; offset 14ch and device 2-3; function 0-3; offset 14ch). due to this erratum, the header of the malformed tlp is logged incorrectly in the hdrlog register (device 0; function 0; offset 164h and device 2-3; function 0-3; offset 164h).										
implication	the pcie header of a malformed tlp is not logged correctly.										
workaround	none identified.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	platform recovery after a machine check may fail										
problem	while attempting platform recovery after a machine check (as indicated by caterr# signaled from the legacy socket), the original error condition may prevent normal platform recovery which can lead to a second machine check. a remote processor detecting a second machine check event will hang immediately.										
implication	due to this erratum, it is possible a system hang may be observed during a warm reset caused by a caterr#.										
workaround	none identified.										
											
title	pcie* correctable error status register may not log receiver error at 8.0 gt/s										
problem	due to this erratum, correctable pcie receiver errors may not be logged in the dpe field (bit 15) of the pcists csr (bus:0; device 1,2,3; function 0-1,0-3,0-3; offset 6h) when operating at 8.0 gt/s.										
implication	correctable receiver errors during 8.0 gt/s operation may not be visible to the os or driver software.										
workaround	none identified										
											
title	configuring pcie* port 3a as an ntb disables eoi forwarding to port 2a										
problem	configuring pcie port 3a as an ntb (non-transparent bridge) requires disabling eoi (end of interrupt) broadcast forwarding to this port by setting bit 26 of miscctrlsts csr (bus 0; device 3; function 0; offset 188h) to 0. due to this erratum, disabling eoi broadcast forwarding to port 3a improperly disables eoi broadcast forwarding to port 2a.										
implication	some platform configurations will not behave as expected.										
workaround	if port 3a is configured as an ntb then devices requiring eoi messages (those using message signaled interrupts and those with their own io apic) must not be connected to port 2a.										
											
title	pcie* lbms bit incorrectly set										
problem	if a pcie link autonomously changes width or speed for reasons other than to attempt to correct unreliable link operation, the port should set labs bit (link autonomous bandwidth status) (bus 0; device 0; function 0 and device 1; function 0-1 and device 2-3; function 0-3; offset 0x1a2; bit 15). due to this erratum, the processor will not set this bit and will incorrectly set lbms bit (link bandwidth management status) (bus 0; device 0; function 0 and device 1; function 0-1 and device 2-3; function 0-3; offset 0x1a2; bit14) instead.										
implication	software that uses the lbms bit or labs bit may behave incorrectly. workaround none identified										
workaround											
											
title	local pcie* p2p traffic on x4 ports may cause a system hang										
problem	under certain conditions, p2p (peer-to-peer) traffic between x4 pcie ports on the same processor (i.e., local) may cause a system hang.										
implication	due to this erratum, the system may hang.										
workaround	none identified.										
											
title	pcie* slave loopback may transmit incorrect sync headers										
problem	the pcie base specification requires that, in the loopback.active state, a loopback slave re-transmits the received bit stream bit-for-bit on the corresponding tx. if the link is directed to enter loopback slave mode at 8 gt/s via ts1 ordered sets with both the loopback and compliance receive bits set, the processor may place sync headers in incorrect locations in the loopback bit stream.										
implication	in pcie cem (card electromechanical specification) rx compliance testing directing the link to loopback slave mode, the received data may not be correctly re-transmitted on the tx, causing the test to fail.										
workaround	none identified										
											
title	performance monitor instructions retired event may not count consistently										
problem	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.										
implication	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	intel® vt-d memory check error on an intel® quickdata technology channel may cause all other channels to master abort										
problem	an intel quickdata dma access to intel® vt-d protected memory that results in a protected memory check error may cause master abort completions on all other intel quickdata dma channels.										
implication	due to this erratum, an error during intel quickdata dma access to an intel® vt-d protected memory address may cause a master abort on other intel quickdata dma channels.										
workaround	none identified.										
											
title	a spurious patrol scrub error may be logged										
problem	when a memory ecc error occurs, a spurious patrol scrub error may also be logged on another memory channel.										
implication	a patrol scrub correctable error may be incorrectly logged.										
workaround											
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	bios acm errata bios acm erratum removed. bios acm erratum removed. bios acm erratum removed. bios acm erratum removed. bios acm unexpected write to the pci f000 segment and s3 resume failure.										
problem	with affected bios acms, scheck may make an unexpected write to the pci f000 segment and bios acm s3 resume may fail.										
implication	the unexpected write to the pci f000 segment may result in unexpected platform behavior. also, bios acm s3 resume may fail without reporting an error code to bios, causing unexpected behavior including tpm pcrs 1-8 being cleared.										
workaround	none.										
											
title	tpm errors may cause the bios acm to hang										
problem	if a tpm error condition such as a missing or non-functional tpm occurs, the bios acm should hand off to bios with a tpm error code to indicate that intel txt launch is not possible. with this erratum, a tpm error may result in a bios acm hang instead of hand-off to bios with a tpm error code.										
implication	intel txt-enabled platforms may hang during bios boot if a tpm error occurs. workaround none.										
workaround											
											
title	tpm policy record with mmio may not behave as expected										
problem	tpm policy record (fit type 8 entry) using mmio may not correctly enable/disable intel txt.										
implication	tpm policy record (fit type 8 entry) using mmio may not correctly enable/disable intel txt.										
workaround	for the affected revision, see the bios acm and sinit acm errata summary table.tpm policy record with i/o read is not affected by this erratum.										
											
title	intel txt policy record with mmio may not behave as expected										
problem	intel txt policy record (fit type 10 entry) using mmio may not correctly enable/ disable intel txt.										
implication	intel txt policy record (fit type 10 entry) using mmio may not correctly enable/ disable intel txt.										
workaround	intel txt policy record with i/o read is not affected by this erratum.										
											
title	intel txt policy may not default to enabled										
problem	if a fit table is present and the fit type 10 record is missing, intel txt policy may not default to enabled.										
implication	intel txt may be disabled if the fit table is present, but the fit type 10 record is missing.										
workaround	implement a fit type 10 record to ensure that intel txt is properly enabled or disabled.										
											
title	intel® trusted execution technology bios acm leaves memory locked when the coin battery is removed and the tpm is not populated										
problem	txt.e2sts (offset 0x8f0) secrets.sts (bit 1) = 0 and block-mem.sts (bit 2) = 1 indicates that the pch cmos memory has been cleared (for example, coin battery removal). at reset if txt.e2sts indicates that the mle established secrets (secrets.sts = 1) or the coin battery has been removed, txt.ests (offset 0x08) wake-error.sts (bit 6) will be set to indicate that a reset occurred when secrets may have been present in memory. with affected bios acm releases, when the coin battery is removed and the tpm is not populated, the bios acm will exit with an error condition, wake-error.sts is not cleared, and memory remains locked.										
implication	with affected bios acm releases, unexpected tpm accesses may occur and/or the memory controller may be locked when the coin battery is removed and the tpm is not populated.										
workaround	none identified.										
											
title	bios acm errors may result in unexpected tpm locality change command										
problem	bios acm errors may result in unexpected tpm locality change command, even if intel txt is disabled using the firmware interface table intel txt policy record or the tpm is not populated.										
implication	while the bios acm waits for the tpm command to timeout, a bios timeout or other unexpected behavior may occur.										
workaround	none identified.										
											
title	bios acm error condition may result in unexpected behavior										
problem	with affected bios acms, an error condition that invokes bios acm error handling may cause a multiprocessor synchronization issue to be exposed.										
implication	on multiprocessor system, a bios acm error condition may result in bios acms start executing an s3 resume or hot-plug flow or other unexpected behavior may occur.										
workaround	none identified.										
											
title	reset due to intel® trusted execution technology error condition may result in bios hang or unexpected behavior										
problem	an intel txt error condition may cause a platform warm reset to occur and expose a multiprocessor synchronization issue during the warm reset latency.										
implication	a bios hang or other unexpected behavior may occur on multiprocessor platforms when an intel txt error condition causes a platform reset to occur.										
workaround	none										
											
title	bios acm changes to the pci configuration space may cause unexpected behavior										
problem	when an intel® txt error occurs on a multiprocessor system, bios acm changes to the pci configuration space may occur before all processors have completed their pcie transactions.										
implication	with affected bios acms, an intel® txt error on a multiprocessor system may result in a pcie transaction not completing, a system hang, or other unexpected behavior.										
workaround	none										
											
title	tpm hang may result in bios hang or other unexpected behavior										
problem	if the tpm fails to respond to locality change commands, the bios acm may exit leaving processor configuration status registers in a state that could cause a bios hang or unexpected behavior.										
implication	a bios hang or other unexpected behavior may occur on intel® txt-enabled platforms if the tpm fails to respond to a locality change commands										
workaround	none										
											
title	sinit acm errata sinit acm erratum removed sinit acm erratum removed sinit acm does not support the acpi 2.0 64-bit xsdt table										
problem	affected sinit acms do not support the acpi 2.0 64-bit xsdt table.										
implication	if a platform provides the 64-bit xsdt table without a 32-bit rsdt table, getsec[senter] will fail with txt.errorcode reporting "rsdt checksum error."										
workaround	bios implementations can implement both the 32-bit rsdt table and the 64-bit xsdt table.										
											
title	sinit acm erratum removed sinit acm erratum removed senter may not identify incorrectly programmed intel® quickdata technology base address registers										
problem	senter may not identify overlap errors between intel® i/o device virtualization base address registers and intel® quickdata base technology address registers.										
implication	incorrectly programmed intel® quickdata technology base address registers may not be identified by sinit acm senter.										
workaround	bios should avoid overlap when programming the intel® quickdata technology base address registers.										
											
title	senter performs incorrect checks on tpm locality 1 and 4										
problem	enter performs incorrect checks on tpm locality 1 and 4										
implication	if tpm locality 1 is active at intel txt software launch, pcr17 extension may fail. if tpm locality 4 is active at intel txt software launch, an erroneous sinit acm error may be reported.										
workaround	tpm localities 0 - 3 should be inactive at intel txt software launch.										
											
title	none										
problem	sinit authenticated code modules (acms) may be susceptible to a buffer overflow issue.										
implication	when intel txt measured launch is invoked using affected sinit authenticated code modules, the platform is susceptible to an os kernel-level exploit which may compromise certain sinit acm functionality.										
workaround	it is possible for a bios update and an updated sinit acm to be used as a workaround for this erratum. previous sinit acm releases will no longer function with the bios update.										
											
title	none										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	intel® quickpath interconnect (intel® qpi) layer may report spurious correctable errors										
problem	intel® qpi may report an inband reset with no width change (error 0x22) correctable error upon exit from the l1 power state as logged in its ia32_mc{5, 20, 21}_status msrs (415h,451h,455h).										
implication	an unexpected inband reset with no width change error may be logged.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	ntb may incorrectly set msi or msi-x interrupt pending bits										
problem	the ntb (non-transparent bridge) may incorrectly set msi (message signaled interrupt) pending bits in msipending (bar pb01base,sb01base; offset 74h) while operating in msi-x mode or set msi-x pending bits in pmsixpba (bar pb01base, sb01base; offset 03000h) while operating in msi mode.										
implication	due to this erratum, ntb incorrectly sets msi or msi-x pending bits. the correct pending bits are also set and it is safe to ignore the incorrectly set bits.										
workaround	none identified.										
											
title	processor may issue unexpected nak dllp upon pcie* l1 exit										
problem	upon exiting the l1 link power state, the processor’s pcie port may unexpectedly issue a nak dllp (data link layer packet).										
implication	pcie endpoints may unexpectedly receive and log a nak dllp.										
workaround	none identified.										
											
title	peci ddr dimm digital thermal reading returns incorrect value										
problem	when using the peci rdpkgconfig() command to read pcs (package config space) service 14 “ddr dimm digital thermal reading”, the value returned is incorrect.										
implication	platform thermal management may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	iio csr lnkcon2 field selectable_de_emphasis cannot be set for dmi2 mode										
problem	the csr lnkcon2 (bus 0; device 0; function 0, offset 0x1c0) field selectable_de_emphasis (bit 6) cannot be set for a link when the dmi port is operating at 5 gt/s.the documentation has the attribute of rw-o (read, write once), but the processor incorrectly operates as read-only. this erratum does not occur when link is operating as a pcie port.										
implication	when the link is in dmi2 mode, the de-emphasis cannot be changed for an upstream component.										
workaround	none identified.										
											
title	pcie* receiver may not meet the specification for ac common mode voltage and jitter										
problem	due to this erratum, pcie receivers may not meet the specification for ac common mode voltage (300 mv) and jitter (78.1 ps) at high temperatures when operating at 5 gt/s.										
implication	specifications for pcie receiver ac common mode voltage and jitter may not be met. intel has not observed this erratum on any commercially available system with any commercially available pcie devices.										
workaround	none identified.										
											
title	receiver termination impedance on pcie 3.0 does not comply with the specification										
problem	the pcie base specification revision 3.0 defines zrx-high-imp-dc-neg and zrx- high-imp-dc-pos for termination impedance of the receiver. the specified impedance for a negative voltage (-150 mv to 0v) is expected to be greater than 1 kohm. sampled measurements of this impedance as low as 400 ohms have been seen. the specified impedance for a positive voltage (> 200 mv) is greater than 20 kohms. sampled measurements of this impedance as low as 14.6 kohms have been seen.										
implication	intel has not observed functional failures from this erratum on any commercially available platforms using any commercially available pcie device.										
workaround	none identified.										
											
title	platform recovery after a machine check may fail										
problem	while attempting platform recovery after a machine check (as indicated by caterr# signaled from the legacy socket), the original error condition may prevent normal platform recovery which can lead to a second machine check. a remote processor detecting a second machine check event will hang immediately.										
implication	due to this erratum, it is possible a system hang may be observed during a warm reset caused by a caterr#.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	usb3 xhci not compatible with msis										
problem	when the pch xhci (extensible host controller interface) is configured to use msi interrupts, a pcie device number conflict between the processor and xhci controller may cause the interrupts be routed incorrectly.										
implication	due to this erratum, unpredictable system behavior may result.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	a memory channel with more than 4 ranks may lead to a system hang										
problem	a memory controller channel with more than 4 ranks and with trr (targeted row refresh) enabled may fail leading to a system hang. this erratum only impacts memory channels with three dual-rank ddr4 rdimms.										
implication	due to this erratum, the system may hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	writing r3qpi performance monitor registers may fail										
problem	due to this erratum, attempting to write r3qpi performance monitor registers (bus 0; device 11; functions 1,2,5,6; offset 0xa0-0xf7) may be unsuccessful.										
implication	a failed write to one or more r3qpi performance monitor registers is likely to yield incorrect performance events counts.										
workaround	consecutively write the identified registers twice with the same value before performance monitoring is globally enabled.										
											
title	enabling ppd may cause unpredictable system behavior										
problem	enabling memory ppd (precharge power down) may cause unpredictable system behavior.										
implication	this erratum may cause unpredictable system behavior.										
workaround	ppd is not supported. use active power down (apd) mode only.										
											
title	cpuid extended topology enumeration leaf may indicate an incorrect number of logical processors										
problem	the extended topology enumeration leaf of cpuid (eax = 0xb) may return an incorrect value in ebx[15:0] for the core level type (ecx[15:8] = 2). in this instance, the number of logical processors at the core level reported in ebx[15:0] should reflect the configuration as shipped by intel.										
implication	software that uses the referenced cpuid function may not properly initialize all logical processors in the system or correctly report the actual number of factory-configured logical processors.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® qpi link re-training after a warm reset or l1 exit may be unsuccessful										
problem	after a warm reset or an l1 exit, the intel® qpi (intel quickpath interconnect) links may not train successfully.										
implication	a failed intel® qpi link can lead to reduced system performance or an inoperable system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	vccin vr phase shedding is disabled										
problem	due to this erratum, the processor does not direct the vccin vr (voltage regulator) to shed phases during low power states.										
implication	platform power consumption may exceed expected levels during deep package c- states.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	quad-rank ddr4 lrdimms may not be properly calibrated										
problem	quad-rank lrdimms require calibration of all four of their dram ranks. due to this erratum, only half of the ranks are calibrated.										
implication	this erratum applies when a memory channel has three quad-rank ddr4 lrdimms. uncalibrated ranks can result in higher correctable and uncorrectable error rates.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	possible non-optimal electrical margins on the ddr command bus										
problem	the processor periodically adjusts drive strength for ddr signals to optimize electrical margins. due to this erratum, the drive strength on the ddr command bus may be incorrectly adjusted.										
implication	reduced electrical margins on the command bus can lead to higher error rates possibly affecting system stability.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	peci commands during reset may result in persistent timeout response										
problem	due to this erratum, a peci (platform environment control interface) command other than getdib(), ping(), or gettemp() received before reset_n is de-asserted may result in a timeout (0x81 completion code) for all subsequent such commands.										
implication	future peci commands other than getdib(), ping(), and gettemp() will not be serviced after this erratum occurs.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	system may hang when using the tph prefetch hint										
problem	when all enabled cores on a socket are simultaneously in core c3, core c6, or package c6 state and a pcie tph (transaction layer packet processing hint) with the prefetch hint set is received, the system may hang.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ts1s do not convey the correct transmitter equalization values during recovery.rcvrlock										
problem	the pcie 3.1 base specification requires that ts1s sent during recovery.rcvrlock following 8.0 gt/s eq (adaptive equalization) contain the final transmitter preset number and coefficient values that were requested by an endpoint during phase 2 of eq. due to this erratum, ts1s with incorrect transmitter preset number values may be sent during recovery.rcvrlock following 8.0 gt/s adaptive equalization.										
implication	endpoints that check these values may, when unexpected values are found, request equalization restart in subsequent tss it sends. if eq requests from the endpoint are supported in the bios or os, eq will be restarted and the link may continue this eq loop indefinitely.										
workaround	none identified.										
											
title	msr_temperature_target msr may read as '0'										
problem	due to this erratum, reading the msr_temperature_target msr (1a2h) may incorrectly return '0'.										
implication	software that depends on the contents of the msr_temperature_target msr may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci rdiamsr() command may fail after core c6 state is entered										
problem	reading core machine check bank registers using the peci (platform environment control interface) rdiamsr() command may fail after core c6 state has been entered.										
implication	invalid data may be returned when using peci to read core machine check bank registers.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	processor may not enter pc3 or pc6 state										
problem	due to this erratum, the processor may not enter pc3 (package c3) or pc6 (package c6) state when intel server platform services firmware is in use.										
implication	the processor may not meet power or thermal operating targets.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	disabling intel® qpi l1 state may cause a machine check on pc3 or pc6 exit										
problem	if intel® qpi l1 state is disabled, exiting pc3 (package c3) or pc6 (package c6) state may signal a machine check with ia32_mc4_status_mscod (bits [31:16]) = 0x70xx.										
implication	disabling intel® qpi link low power states can lead to a machine check if deep package c-states are enabled.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	cltt may cause bios to hang on a subsequent warm reset										
problem	if cltt (closed loop thermal throttling) is enabled when a warm reset is requested, due to this erratum, the processor will resume dimm temperature polling before the memory sub-system has been re-initialized.										
implication	this erratum may lead to a bios hang. the warm reset request will fail, along with subsequence warm reset attempts. the failing condition is cleared by a cold reset.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	systems may experience uncorrectable errors when using 2133 mhz lrdimm										
problem	due to this erratum, a memory subsystem with 2133 mhz lrdimms may experience uncorrectable memory errors.										
implication	the use of 2133 mhz lrdimms may lead to system failure.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* extended tag field may be improperly set										
problem	the extended tag field in the tlp header will not be zero for tlps issued by pcie ports 1a, 1b, 2c, 2d, 3c, and 3d even when the extended tag field enable bit in the device control register (offset 08h, bit 8) is 0.										
implication	this does not affect ports 0, 2a, 2b, 3a and 3b. this will not result in any functional issues when using device that properly track and return the full 8 bit extended tag value with the affected ports. however, if the extended tag field is not returned by a device connected to an affected port then this may result in unexpected completions and completion timeouts.										
workaround	none identified.										
											
title	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation										
problem	if ept (extended page tables) is enabled, a mov to cr3 or vmfunc may be followed by an unexpected page fault or the use of an incorrect page translation.										
implication	guest software may crash or experience unpredictable behavior as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the system may hang when a c/a parity error is detected										
problem	due to this erratum, detection of a c/a (command/address) parity error by the memory controller can lead to a system hang.										
implication	system may experience a hang condition in the presence of c/a parity errors.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a c/a parity error when ddr4 is operating at 2133 mhz may result in unpredictable system behavior										
problem	due to this erratum, when ddr4 is operating at 2133 mhz and a c/a (command/ address) parity error occurs while exiting a package c-state then unpredictable system behavior may occur.										
implication	due to this erratum, the system may experience unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title											
problem	enabling isochronous transfers may lead to spurious correctable memory errors, uncorrectable memory errors, patrol scrub errors and unpredictable system behavior.										
implication	the system may hang, report spurious memory errors, or behave unpredictably.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	enabling secondary to primary snoop overrides on ntb may cause a hang										
problem	due to this erratum, ntb (non-transparent bridge) completions may be dropped when secondary to primary snoop overrides are enabled.										
implication	the system may hang or experience timeout machine checks when the secondary to primary snoop override is enabled. this erratum does not affect primary to secondary snoop override.										
workaround	none identified. a bios code change has been identified and may be implemented to avoid this erratum.										
											
title	memory controller tsod_present settings being improperly cleared										
problem	on single home agent configurations, due to this erratum, the processor interferes with tsod (thermal sensor on dimm) usage by incorrectly clearing the tsod_present field (bits[7:0]) of the smbcntl_1 csr (bus 0; device 19; function 0; offset 0x198) after bios writes that field.										
implication	closed loop thermal throttle will not work as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ddr4 protocol may be violated during c/a parity error handling										
problem	due to this erratum, if the error information in the dram is accessed because of a c/a (command/address) parity error, ddr4 dimm protocol rules may be violated leading to unpredictable system behavior.										
implication	attempts to access ddr4 dimm error information may lead to unpredictable system behavior.										
workaround	none identified. the en field (bit 31) of erf_ddr4_cmd_reg[4-0] csrs (bus 1; device 20,21,23,24; function 0,1; offset 0x24c, 0x250, 0x254, 0x258, 0x26c) must not be set, preventing access to error information.										
											
title	ddr4 power down timing violation										
problem	when ddr4 is operating at 2133 mhz, the processor’s memory control may violate the jedec tprpden timing specification.										
implication	violation of timing specifications can lead to unpredictable system behavior; however, intel has not observed this erratum to impact the operation of any commercially available system using validated dimms by intel platform memory operations.										
workaround	none identified.										
											
title	correctable memory ecc errors may occur at boot										
problem	with memory lockstep enabled, the system may experience correctable memory errors during boot with ia32_mci_status.mcacod= 0x009x (where x is 0,1,2, or 3 and indicates the channel number reporting the error)										
implication	the system may experience correctable memory errors.										
workaround	none identified.										
											
title	remote p2p mctp transactions cause requests timeouts										
problem	remote p2p (peer to peer) mctp (management component transport protocol) messages may cause timeouts with ia32_mci_status.mscod=0x000c.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	reserving resources for isochronous transfers with non-posted prefetching enabled may cause a hang										
problem	resources in the iio (integrated i/o) unit are reserved for isochronous transfers to ensure performance guarantees are met. due to this erratum, enabling non-posted prefetching in the iio when resources are reserved for isochronous traffic may result in a hang.										
implication	due to this erratum, configuring the iio unit to prefetch may result in a system hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	bt timeouts may cause spurious machine checks										
problem	the bt (backup tracker) timeout logic in the home agent can trigger spuriously, causing false machine checks indicated by ia32_mci_status.mscod=0x0200.										
implication	due to this erratum, timeout machine check may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	full duplex ntb traffic can cause a system hang										
problem	if two pcie endpoints target traffic to pb23base (bus 0; device 3; function 0; offset 0x18, 0x1c) and pb45base (bus 0; device 3; function 0; offset 0x20, 0x24) registers at the same time, a deadlock can result.										
implication	due to this erratum, the system may hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	config_tdp_nominal csr implemented at incorrect offset										
problem	the pcie base specification indicates that configuration space headers have a base address register at offset 0x10. due to this erratum, the power control unit’s config_tdp_nominal csr (bus 1; device 30; function 3; offset 0x10) is located where a base address register is expected.										
implication	software may treat the config_tdp_nominal csr as a base address register leading to a failure to boot.										
workaround	none identified.										
											
title	software using intel® tsx may result in unpredictable system behavior										
problem	under a complex set of internal timing conditions and system events, software using the intel® tsx (transactional synchronization extensions) instructions may result in unpredictable system behavior.										
implication	this erratum may result in unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a machine-check exception due to instruction fetch may be delivered before an instruction breakpoint										
problem	debug exceptions due to instruction breakpoints take priority over exceptions resulting from fetching an instruction. due to this erratum, a machine-check exception resulting from the fetch of an instruction may take priority over an instruction breakpoint if the instruction crosses a 32-byte boundary and the second part of the instruction is in a 32-byte poisoned instruction fetch block.										
implication	instruction breakpoints may not operate as expected in the presence of a poisoned instruction fetch block.										
workaround	none identified.										
											
title	spurious corrected errors may be reported										
problem	due to this erratum, spurious corrected errors may be logged in the ia32_mc0_status register with the valid field (bit 63) set, the uncorrected error field (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.										
implication	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.										
workaround	none identified.										
											
title	pcie lbms bit incorrectly set										
problem	if a pcie link autonomously changes width or speed for reasons other than to attempt to correct unreliable link operation, the port should set labs bit (link autonomous bandwidth status) (bus 0; device 0; function 0 and device 1; function 0-1 and device 2-3; function 0-3; offset 0x1a2; bit 15). due to this erratum, the processor will not set this bit and will incorrectly set lbms bit (link bandwidth management status) (bus 0; device 0; function 0 and device 1; function 0-1 and device 2-3; function 0-3; offset 0x1a2; bit14) instead.										
implication	software that uses the lbms bit or labs bit may behave incorrectly.										
workaround	none identified.										
											
title	power consumed during package c6 may exceed specification										
problem	due to this erratum, the processor power usage may be higher than specified for the vccin and/or iio domains while in package c6 state.										
implication	systems may experience increased power consumption while the processor is in package c6.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	platform performance degradation when c1e is enabled										
problem	due to this erratum, when c1e is enabled and after the processor has entered package c1e state, core clock frequency becomes limited to its minimum value (sometimes referred to as pn) until the system exits package c3 state (or deeper) or the system is reset.										
implication	when this erratum occurs, operating frequency will be lower than expected. note: after a package c3 exit, re-entering package c1e state re-imposes this erratum’s frequency limit.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	memory power down entry may lead to unpredictable system behavior										
problem	due to this erratum, the processor may violate ddr4 page close protocol at power down entry.										
implication	when this erratum occurs, it may result in unpredictable system behavior.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	sending peci messages concurrently over two interfaces may result in a system hang										
problem	sending messages concurrently via the peci (platform environment control interface) channel and the ibpeci (in-band peci) channel during package c-state transitions may result in a system hang.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	platform recovery after a machine check may fail										
problem	while attempting platform recovery after a machine check (as indicated by caterr# signaled from the legacy socket), the original error condition may prevent normal platform recovery which can lead to a second machine check. a remote processor detecting a second machine check event will hang immediately										
implication	due to this erratum, it is possible a system hang may be observed during a warm reset caused by a caterr#.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® turbo boost technology does not behave as expected										
problem	due to this erratum, the maximum turbo frequency may be incorrectly set to the maximum non-turbo frequency after bios initialization completes.										
implication	intel® turbo boost technology may appear to be disabled.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie hot plug slot status register may not indicate command completed										
problem	the pcie base specification requires a write to the slot control register (offset a8h) to generate a hot plug command when the downstream port is hot plug capable. due to this erratum, a hot plug command is generated only when one or more of the slot control register bits [11:6] are changed.										
implication	writes to the slot control register that leave bits [11:6] unchanged will not generate a hot plug command and will therefore not generate a command completed event. software that expects a command completed event may not behave as expected.										
workaround	it is possible for software to implement a one-second timeout in lieu of receiving a command completed event.										
											
title	local pcie p2p traffic on x4 ports may cause a system hang										
problem	under certain conditions, p2p (peer-to-peer) traffic with x4 pcie ports on the same processor (i.e., local) may cause a system hang.										
implication	due to this erratum, the system may hang.										
workaround	none identified. local p2p traffic should not be used to or from x4 pcie ports.										
											
title	ntb operating in ntb/rp mode may complete transactions with incorrect reqid										
problem	when the ntb (non-transparent bridge) is operating in ntb/rp (ntb root port mode) it is possible for transactions to be completed with the incorrect reqid (requester id). this erratum occurs when an outbound transaction is aborted before a completion for inbound transaction is returned.										
implication	due to this erratum, a completion timeout and an unexpected completion may be seen by the processor connected to the ntb/rp. intel has not observed this erratum with any commercially available system.										
workaround	none identified.										
											
title	incorrect single-core turbo ratio limit may be applied when using avx instructions										
problem	the avx single-core turbo ratio limit may not be applied correctly, unnecessarily limiting the core frequency.										
implication	single-core avx workloads may not achieve single-core avx turbo limit in some cases. this erratum does not apply to non-avx workloads or multi-core workloads.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	llc error conditions may be dropped or incorrectly signaled										
problem	when two llc (last level cache) errors happen in close proximity, a ucna (uncorrectable no action required) machine check may be dropped or a spurious machine check or cmci (corrected machine check interrupt) may be issued. further, when this erratum occurs, the merged cbo llc machine check bank ia32_mc[17- 19]_status msrs may be incorrect.										
implication	ia32_mc[17-19]_status msr may not reflect most current error.										
workaround	it is possible for the bios to contain a partial workaround for this erratum. the workaround does not address the potential dropped ucna machine check.										
											
title	unexpected system behavior may occur following virtualization of some apic writes										
problem	if the “virtual-interrupt delivery” vm-execution control is enabled, unexpected system behavior may occur following virtualization of the mov to cr8 instruction, memory- mapped accesses to the eoi (end of interrupt), tpr (task priority register), or the interrupt command register to send an interprocessor interrupt to itself. this erratum does not apply to the corresponding wrmsr access.										
implication	the unexpected system behavior may result in incorrect instruction execution, ept (extended page table) violation, page fault, or similar event. these may cause incorrect guest execution or may lead a virtual-machine monitor to terminate the virtual machine that was running at the time.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a ddr4 c/a parity error in lockstep mode may result in a spurious uncorrectable error										
problem	if a memory c/a (command/address) parity error occurs while the memory subsystem is configured in lockstep mode then the channel that observed the error will properly log the error but the associated channel in lockstep will incorrectly log an uncorrectable error in its ia32_mci_status msr.										
implication	due to this erratum, incorrect logging of an uncorrectable memory error in ia32_mci_status may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	some imc and intel qpi functions have incorrect pci capptr values										
problem	the pci capptr (capability pointer register) is defined to contain the offset to the capabilities list structure when the pci pcists (pci status register) bit 4 (capabilities_list) is set to 1. due to this erratum, capptr (offset 0x34) should hold a value of 0x40 but is instead zero for these imc (integrated memory controller) and intel® qpi (intel quickpath interconnect) device: device 8, functions 3,5,6 device 9, functions 3,5,6 device 10, functions 3,5,6 device 19, functions 0-5 device 20, functions 0-3 device 21, functions 0-3 device 22, functions 0-3 device 23, functions 0-3										
implication	software that depends on capptr to access additional capabilities may not behave as expected.										
workaround	software that needs to access these capabilities must take this erratum into account.										
											
title	pcie tlp translation request errors are not properly logged for invalid memory writes										
problem	a pcie memory write tlp (transaction layer packet) with an at field value of 01b (address translation request) does not set the ur (unsupported request) bit (uncerrsts csr, bus 0; device 0; function 0; offset 0x14c; bit 20) as required by the pcie base specification.										
implication	system or software monitoring error status bits may not be notified of an unsupported request. when this erratum occurs, the processor sets the 'advisory_non_fatal_error_status' bit (corerrsts csr, bus 0; device 0; function 0; offset 0x158; bit 13) and drops the failing transaction.										
workaround	none identified.										
											
title	the tsc may be inaccurate when per core p-states are enabled										
problem	due to this erratum, when per core p-states are enabled, the tsc (time stamp counter) may not be synchronized across the processor's cores.										
implication	the rdtsc (read time stamp counter) instruction may return a value that is not monotonically increasing.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	dual ha processors with cltt enabled and no memory on channels 0 and 1 may hang during warm reset										
problem	a dual ha (home agent) processor may hang during an attempted warm reset when there is no memory installed on memory channels 0 and 1 and cltt (closed loop thermal throttling) is enabled.										
implication	due to this erratum, a system may hang during warm reset. this erratum does not occur if the processor has a single ha or at least one dimm is installed on memory channel 0 or 1.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie slave loopback may transmit incorrect sync headers										
problem	the pcie base specification requires that, in the loopback.active state, a loopback slave re-transmits the received bit stream bit-for-bit on the corresponding tx. if the link is directed to enter loopback slave mode at 8 gt/s via ts1 ordered sets with both the loopback and compliance receive bits set, the processor may place sync headers in incorrect locations in the loopback bit stream.										
implication	in pcie cem (card electromechanical specification) rx compliance testing directing the link to loopback slave mode, the received data may not be correctly re-transmitted on the tx, causing the test to fail.										
workaround	none identified.										
											
title	consecutive peci rdiamsr commands when core c6 is enabled may cause a system hang										
problem	consecutive peci (platform environment control interface) rdiamsr commands to access core machine check msrs can result in a system hang when core c6 state is enabled.										
implication	when this erratum occurs, peci commands can lead to a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	data poisoning may not behave as expected										
problem	when data poisoning is enabled, poisoned data consumption may not log and signal an uncorrected machine check error.										
implication	due to this erratum, unpredictable system behavior may result.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling trr with ddr4 lrdimms may lead to unpredictable system behavior										
problem	due to this erratum, trr (targeted row refresh) is not compatible with ddr4 lrdimms.										
implication	unpredictable system behavior may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	warm reset may cause pcie hot-plug sequencing failure										
problem	the integrated i/o unit uses the vpp (virtual pin port) to communicate with power controllers, switches, and leds associated with pcie hot-plug sequencing. due to this erratum, a warm reset occurring when a vpp transaction is in progress may result in an extended vpp stall, termination of the in-flight vpp transaction, or a transient power down of slots subject to vpp power control.										
implication	during or shortly after a warm reset, when this erratum occurs, pcie hot-plug sequencing may experience transient or persistent failures or slots may experience unexpected transient power down events. in certain instances, a cold reset may be needed to fully restore operation.										
workaround	none identified.										
											
title	performance monitor instructions retired event may not count consistently										
problem	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.										
implication	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	c/a parity error injection may cause the system to hang										
problem	when c/a (command address) parity error injections are occurring too frequently, the home agent may be prevented from completing memory transactions. this may result in an internal timer error indicated by ia32_mci_status. mscod=0x0080 and ia32_mci_status. mcacod=0x0400.										
implication	due to this erratum, the system may hang.										
workaround	ensure there is at least 30µs of delay between injections.										
											
title	excessive fan speed										
problem	due to this erratum, fan speed control does not correctly account for the thermal profile at elevated operating temperatures.										
implication	when this erratum occurs, fan speed is higher than required unnecessarily increasing fan power consumption and fan noise.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	disabling pcie ports prevents package c6 entry										
problem	the processor’s pcie links can be disabled by setting the link disable bit in the link control register (lnkcon.link_disable) (bus 0; device 0,1,2,3; function 0,0-1,0-3,0-3; offset 0xa0; bit 4) to 1. due to this erratum, configuring one or more pcie ports to be disabled prevents the processor from entering package c6 state.										
implication	the processor’s inability to reach the package c6 state will result in increased idle power consumption.										
workaround	none identified. for an optimal processor power configuration, unused pcie ports should remain enabled.										
											
title	the system may shut down unexpectedly during a warm reset.										
problem	certain complex internal timing conditions present when a warm reset is requested can prevent the orderly completion of in-flight transactions. it is possible under these conditions that the warm reset will fail and trigger a full system shutdown.										
implication	when this erratum occurs, the system will shut down and all machine check error logs will be lost.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	accessing sb01base mmio space in the presence of bi-directional ntb traffic may result in a system hang										
problem	while transactions are originating from both sides of the ntb, accessing sb01base mmio space may cause the system to hang. for example, the ntb convention of using sb01base mmio doorbell or scratchpad registers to convey interrupt messages across the ntb may result in a system hang. this erratum does not apply if transactions originate from only one side of the ntb.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum. alternatively, split- bar mode can be used to send interrupts between ntb connected systems. intel has released a new version of its ntb driver that offers support for split-bar mode.										
											
title	patrol scrubbing of mirrored memory may log spurious memory errors										
problem	the patrol scrubber, when mirroring is enabled, may incorrectly identify certain data patterns as poison data or as memory errors.										
implication	spurious memory errors and poisoned data may be logged when mirroring is enabled.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	msr_turbo_activation_ratio msr cannot be locked										
problem	setting the turbo_activation_ratio_lock field (bit 31) of the msr_turbo_activation_ratio msr (64ch) has no effect; it does not block future writes to the msr_turbo_activation_ratio msr.										
implication	software cannot rely on locking msr_turbo_activation_ratio msr.										
workaround	none identified.										
											
title	an apic timer interrupt during core c6 entry may be lost										
problem	due to this erratum, an apic timer interrupt coincident with the core entering c6 state may be lost rather than held for servicing later.										
implication	a lost apic timer interrupt may lead to missed deadlines or a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ddr4 clk signal may incorrectly float during warm reset or s3 state										
problem	the processor may not drive the ddr4 clock signal during warm reset or during s3 state rather than driving the signal low as required by the jedec ddr4 specification.										
implication	the anomalous electrical condition of an undriven clock signal can lead to correctable and uncorrectable memory errors (ia32_mci_status.mcacod = 0x009n, where n is the channel number) after a warm reset or when resuming from s3 state.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ddr4 self refresh entry may result in memory read errors										
problem	the processor may violate the jedec power down timing tcpded parameter specification associated with ddr4 self-refresh entry.										
implication	correctable and/or uncorrectable memory read errors may occur.										
workaround	a bios code change has been identified. please refer to latest revision of grantley-ep platform reference code.a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	vt-d memory check error on an intel® quickdata technology channel may cause all other channels to master abort										
problem	an intel® quickdata technology dma access to intel® vt-d protected memory that results in a protected memory check error may cause master abort completions on all other intel® quickdata technology dma channels.										
implication	due to this erratum, an error during intel® quickdata technology dma access to an intel® vt-d protected memory address may cause a master abort on other intel® quickdata technology dma channels.										
workaround	none identified.										
											
title	writes to some control register bits ignore byte enable										
problem	due to this erratum, partial writes to some registers write the full register. the affected registers are: saddbgmm2_cfg (device 12; function 0-7; offset 0xa8 and device 13; function 0-6; offset 0xa8) and llcerrinj_cfg (device 12; function 0-7; offset 0xfc and device 13; function 0-6;										
implication	partial writes of the registers listed above may result in changes to register bytes that were intended to be unmodified.										
workaround	none identified. use aligned, full-width dword (32-bit) read-modify-write sequencing to change a portion or portions of the registers listed.										
											
title	invalid intel® quickdata technology xor descriptor source addressing may lead to unpredictable system behavior										
problem	intel® quickdata technology (that is crystal beach dma v3.2) does not correctly halt and report aborts on illegal source addresses placed in a cbdma descriptor regardless of type (legacy or pq). this abort condition may cause unpredictable system behavior.										
implication	this erratum may lead to unpredictable system behavior.										
workaround	ensure xor dma descriptor source addresses targets valid dram memory locations.										
											
title	warm reset may cause pcie hot-plug sequencing failure										
problem	the integrated i/o unit uses the vpp (virtual pin port) to communicate with power controllers, switches, and leds associated with pcie hot-plug sequencing. due to this erratum, a warm reset occurring when a vpp transaction is in progress may result in an extended vpp stall, termination of the inflight vpp transaction, or a transient power down of slots subject to vpp power control.										
implication	during or shortly after a warm reset, when this erratum occurs, pcie hot-plug sequencing may experience transient or persistent failures or slots may experience unexpected transient power down events. in certain instances, a cold reset may be needed to fully restore operation.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	prochot# assertion during warm reset may cause persistent performance reduction										
problem	assertion of prochot# after reset# deassertion but before bios has completed reset initialization (indicated by cpl3) may result in persistent processor throttling. asserting prochot# during and after reset# assertion for frb (fault resilient boot) tri-stating of the processor is not affected by this erratum.										
implication	when this erratum occurs, the resultant persistent throttling substantially reduces the processor's performance.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	operand-size override prefix causes 64-bit operand form of movbe instruction to cause a problem										
problem	execution of a 64-bit operand movbe instruction with an operand-size override instruction prefix (66h) may incorrectly cause an invalid-opcode exception (#ud).										
implication	a movbe instruction with both rex.w=1 and a 66h prefix will unexpectedly cause an invalid-opcode exception (#ud). intel has not observed this erratum with any commercially available software.										
workaround	do not use a 66h instruction prefix with a 64-bit operand movbe instruction.										
											
title	peci rdiamsr accesses during boot or warm reset may cause the processor to hang										
problem	the processor may hang when peci rdiamsr() accesses occur soon after processor power-on or warm reset.										
implication	when this erratum occurs, the processor will hang and as a result peci will be unable to complete reads to the processor's machine check banks.										
workaround	all peci rdiamsr() accesses should be delayed until the cpu microcode update revision is non-zero. cpu microcode update revision can be accessed by peci rdpkgconfig() with index=0 and parameter=4.										
											
title	ddr4 rank aliasing with heavy memory traffic may lead to a system hang										
problem	under complex conditions, ddr4 rank aliasing during extended periods of heavy memory traffic may lead to a system hang with ia32_mc{17-19}_status.mscod = 0x000c.										
implication	ddr4 rank aliasing may affect the reliability of a highly utilized system.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	early thermal throttling may occur										
problem	systems engineered to published thermal specifications and requirements may throttle early due to insufficient thermal margin on the processor.										
implication	when this erratum occurs, the thermal throttling may begin as much as 2 °c early.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® qpi link re-training after a warm reset or l1 exit may be unsuccessful										
problem	after a warm reset or an l1 exit, the intel® qpi links may not train successfully.										
implication	a failed intel® qpi link can lead to reduced system performance or an inoperable system.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	pcie* header of a malformed tlp is logged incorrectly										
problem	if a pcie port receives a malformed tlp (transaction layer packet), an error is logged in the uncerrsts register (device 0; function 0; offset 14ch and device 2-3; function 0-3; offset 14ch). due to this erratum, the header of the malformed tlp is logged incorrectly in the hdrlog register (device 0; function 0; offset 164h and device 2-3; function 0-3; offset 164h).										
implication	the pcie header of a malformed tlp is not logged correctly.										
workaround	none identified.										
											
title	attempting to enter adr may lead to unpredictable system behavior										
problem	due to this erratum, an attempt to transition the memory subsystem to adr (asynchronous dram self refresh) mode may fail.										
implication	this erratum may lead to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci commands during warm reset may lead to an undefined machine check error										
problem	after a warm reset request is made, generally by bios or in response to a processor error, the processor is not able to accept peci commands until the subsequent reset# signal assertion ends. a peci command during this interval will log an undefined model specific error code of 0x26 in bits[31:24] of the ia32_mci_status msr (411h).										
implication	due to this erratum, attempts to issue peci commands to the processor while reset# is asserted may result in an unexpected error.										
workaround	an external agent that is able to issue peci commands must not issue peci commands during the interval from warm reset request to reset# deassertion.										
											
title	spurious corrected errors may be reported										
problem	due this erratum, spurious corrected errors may be logged in the ia32_mc0_status register with the valid field (bit 63) set, the uncorrected error field (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.										
implication	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.										
workaround	none identified.										
											
title	system hang may occur during warm reset due to smbus activity										
problem	smbus activity during warm reset may lead to a system hang.										
implication	due to this erratum, a system hang may occur during warm reset if activity on the smbus is present.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci pcs package identifier command operates incorrectly on certain skus										
problem	the max thread id value returned via peci pcs (package config space) command, package identifier service (index 00), parameter value 0x0003, may be incorrect on e5-2643v3 and e5-2637v3 skus.										
implication	a peci agent may be given an incorrect count of logical processors.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	intel® trusted execution technology uses incorrect tpm 2.0 nv space index handles										
problem	intel® txt (trusted execution technology) uses tpm (trusted platform module) 2.0 draft specification handles (indices) aux 01800003, ps 01800001, and po 01400003. those handles conflict with the released tcg (trusted computing group) “registry of reserved tpm 2.0 handles and localities”, version 1.0, revision 1.										
implication	intel txt tpm 2.0 handles may conflict with platform manufacturer or owner usage of tpm nv space. intel has not identified any functional impact due to this erratum.										
workaround	none identified.										
											
title	surprise down error status is not set correctly on dmi port										
problem	due to this erratum, the surprise_down_error_status (uncerrsts device 0; function 0; offset 0x14c; bit 5) is not set to 1 when dmi port detects a surprise down error.										
implication	surprise down errors will not be logged for the dmi port. software that relies on this status bit may not behave as expected.										
workaround	none identified.										
											
title											
problem	when a performance monitoring counter is configured to count off_core_response_{1,2} (events b7h and b8h), data obtained for remote dram may be attributed to l3_miss_remote_hop0 (as programmed by msr_offcore_rsp_{1,2} (msrs 1a6h, 1a7h) bit 27) instead of l3_miss_remote_hop1 (bit 28) or l3_miss_remote_hop2p (bit 29). data provided from remote caching agent associated with remote dram is unaffected.										
implication	l3_miss_remote_hop0 may over count, while l3_miss_remote_hop1 and l3_miss_remote_hop2p may undercount.										
workaround	none identified. set all three configuration bits (l3_miss_remote_hop0, l3_miss_remote_hop1, l3_miss_remote_hop2p) to obtain the total count of data supplied by remote agents.										
											
title											
problem	when a single vr (voltage regulator) is used by more than one populated memory channel, power readings of these memory channels may not be accurate.										
implication	rapl (running average power limit) memory power regulation may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a p-state or c-state transition may lead to a system hang										
problem	for a small subset of parts under elevated die temperature conditions, a p-state or c- state transition may result in a system timeout or system shutdown.										
implication	when this erratum occurs, the system may shutdown or report a timeout error; intel has observed transaction completion timeouts and other internal timeouts.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	an iret instruction that results in a task switch by returning from a nested task does not serialize the processor (contrary to the software developer's manual vol. 3 section titled “serializing instructions”).										
implication	software which depends on the serialization property of iret during task switching may not behave as expected. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	none identified. software can execute an mfence instruction immediately prior to the iret instruction if serialization is needed.										
											
title											
problem	a microcode update loaded by the operating system or virtual machine monitor may change the power management configuration previously established by the bios.										
implication	loading a microcode update after bios initialization completes may cause higher than expected idle power.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a spurious patrol scrub error may be logged										
problem	when a memory ecc error occurs, a spurious patrol scrub error may also be logged on another memory channel.										
implication	a patrol scrub correctable error may be incorrectly logged.										
workaround	none identified. the home agent error registers and correctable error count registers (bus 1; device 20; function 2; offset 104-110) provides accurate error information.										
											
title	some offcore_response performance monitoring events may undercount										
problem	the performance monitoring events offcore_response (events b7h and bbh) should count uncore responses matching the request-response configuration specified in msr_offcore_rsps (1a6h and 1a7h, respectively) for core-originated requests. however due to this erratum, corewb (bit 3), pf_l3_data_rd (bit 7), pf_l3_rfo (bit 8), pr_l3_code_rd (bit 9), split_lock_uc_lock (bit 10), and streaming_stores (bit 11) request types may undercount.										
implication	these performance monitoring events may not produce reliable results for the listed request types.										
workaround	none identified										
											
title	enabling adr with udimms may result in unpredictable system behavior										
problem	when adr (asynchronous dimm self-refresh) is enabled during an s3 resume, the processor may cause the udimm to prematurely exit self refresh.										
implication	due to this erratum, unpredictable system behavior may occur when adr is enabled.										
workaround	none identified.										
											
title	mtf vm exit on xbegin instruction may save state incorrectly										
problem	execution of an xbegin instruction while the “monitor trap flag” vm-execution control is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save the address of the xbegin instruction as the instruction pointer (instead of the fallback instruction address specified by the xbegin instruction). in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.										
implication	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	pebs record may be generated after being disabled										
problem	a performance monitoring counter may generate a pebs (precise event based sampling) record after disabling pebs or the performance monitoring counter by clearing the corresponding enable bit in ia32_pebs_enable msr (3f1h) or ia32_perf_global_ctrl msr (38fh).										
implication	a pebs record generated after a vmx transition will store into memory according to the post-transition ds (debug store) configuration. these stores may be unexpected if pebs is not enabled following the transition.										
workaround	it is possible for the bios to contain a workaround for this erratum. a software workaround is possible through disallowing pebs during vmx non-root operation and disabling pebs prior to vm entry.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	data breakpoint coincident with a machine check exception may be lost										
problem	if a data breakpoint occurs coincident with a machine check exception, then the data breakpoint may be lost.										
implication	due to this erratum, a valid data breakpoint may be lost.										
workaround	none identified.										
											
title											
problem	due to this erratum, the supplier may be misattributed to unknown, and the following events may undercount mem_load_uops_retired.l3_hit (event d1h umask 04h) mem_load_uops_retired.l3_miss (event d1h umask 20h) mem_load_uops_l3_hit_retired.xsnp_miss (event d2h umask 01h) mem_load_uops_l3_hit_retired.xsnp_hit (event d2h umask 02h) mem_load_uops_l3_hit_retired.xsnp_hitm (event d2h umask 04h) mem_load_uops_l3_hit_retired.xsnp_none (event d2h umask 08h) mem_load_uops_l3_miss_retired.local_dram (event d3h umask 01h) mem_trans_retired.load_latency (event cdh umask 01h)										
implication	the affected events may undercount, resulting in inaccurate memory profiles. for the affected events that are precise, pebs records may be generated at incorrect points. intel has observed incorrect counts by as much as 20%.										
workaround	none identified.										
											
title	an x87 store instruction which pends #pe while ept is enabled may lead to an unexpected machine check and/or incorrect x87 state information										
problem	the execution of an x87 store instruction which causes a #pe (precision exception) to be pended and also causes a vm-exit due to an ept violation or misconfiguration may lead the vmm logging a machine check exception with a cache hierarchy error (ia32_mci_status.mcacod = 0150h and ia32_mci_status.mscod = 000fh). additionally, fsw.pe and fsw.es (bits 5 and 7 of the fpu status word) may be incorrectly set to 1, and the x87 last instruction opcode (fop) may be incorrect.										
implication	when this erratum occurs, the vmm may receive an unexpected machine check exception and software attempting to handle the #pe may not behave as expected.										
workaround	none identified.										
											
title	interrupt remapping may lead to a system hang										
problem	under complex micro-architectural conditions, back-to-back interrupt requests when interrupt remapping is enabled may lead to a system hang.										
implication	when this erratum occurs, the system hang may be associated with a queued invalidation of the ioapic that does not complete.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writing msr_lastbranch_x_from_ip may #gp when intel® tsx is not supported.										
problem	due to this erratum, on processors that do not support intel tsx (intel® transactional synchronization extensions) (cpuid.07h.ebx bits 4 and 11 are both zero), writes to msr_lastbranch_x_from_ip (msr 680h to 68fh) may #gp unless bits[62:61] are equal to bit[47].										
implication	the value read from msr_lastbranch_x_from_ip is unaffected by this erratum; bits [62:61] contain in_tsx and tsx_abort information respectively. software restoring these msrs from saved values are subject to this erratum.										
workaround	before writing msr_lastbranch_x_from_ip, ensure the value being written has bit[47] replicated in bits[62:61]. this is most easily accomplished by sign extending from bit[47] to bits[62:48].										
											
title	jtag boundary scan for intel qpi and pcie* lanes may report incorrect stuck at 1 errors.										
problem	boundary scan testing of the intel qpi and pcie interfaces may incorrectly report a recurring stuck at 1 failure on intel qpi and pcie receiver lanes. this erratum only affects boundary scan testing and does not affect functional operation of the intel qpi and pcie interfaces.										
implication	this erratum may result in boundary scan test failures reported on one or more of the intel qpi and pcie lanes.										
workaround	none identified.										
											
title	apic timer interrupt may not be generated at the correct time in tsc-deadline mode.										
problem	after writing to the ia32_tsc_adjust msr (3bh), any subsequent write to the ia32_tsc_deadline msr (6e0h) may incorrectly process the desired deadline. when this erratum occurs, the resulting timer interrupt may be generated at the incorrect time.										
implication	when the local apic (advanced programmable interrupt controller) timer is configured for tsc-deadline mode, a timer interrupt may be generated much earlier than expected or much later than expected. intel has not observed this erratum with most commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling isoch mode may cause the system to hang										
problem	when isoch (isochronous) operation is enabled within bios, the system may hang and fail to boot.										
implication	due to this erratum, the system may hang and fail to boot.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pci bars in the home agent will return non-zero values during enumeration										
problem	during system initialization the operating system may access the standard pci bars (base address registers). due to this erratum, accesses to the home agent bar registers (bus 1; device 18; function 0,4; offsets 0x14-0x24) will return non-zero values.										
implication	the operating system may issue a warning. intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	pcie* header of a malformed tlp is logged incorrectly										
problem	if a pcie port receives a malformed tlp (transaction layer packet), an error is logged in the uncerrsts register (device 0; function 0; offset 14ch and device 2-3; function 0-3; offset 14ch). due to this erratum, the header of the malformed tlp is logged incorrectly in the hdrlog register (device 0; function 0; offset 164h and device 2-3; function 0-3; offset 164h).										
implication	the pcie header of a malformed tlp is not logged correctly.										
workaround	none identified.										
											
title	a malformed tlp may block ecrc error logging										
problem	if a pcie* port receives a malformed tlp that also would generate an ecrc check failed error, it should report a malformed tlp error. when malformed tlp errors are masked, the processor should report the lower-precedence ecrc check failed error but, due to this erratum, it does not.										
implication	software that relies upon ecrc check failed error indication may not behave as expected.										
workaround	none identified.										
											
title	the system may hang during an intel® quickpath interconnect (intel® qpi) slow to fast mode transition										
problem	during an intel qpi slow mode to fast mode transition, the ll_status field of the qpipcsts register (bus 0; device 8,9,10; function 0; offset 0xc0) may not be correctly updated to reflect link readiness.										
implication	the system may hang waiting for the qpipcsts.ll_status to update.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	unexpected performance loss when turbo disabled intel® xeon® processor e5-2600 v4 product family 17 specification update december 2016										
problem	when intel turbo boost technology is disabled by ia32_misc_enables msr (416h) turbo_mode_disable bit 38, the ring operating frequency may be below p1 operating frequency.										
implication	processor performance may be below expectations for p1 operating frequency. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	attempting to enter adr may lead to unpredictable system behavior										
problem	due to this erratum, an attempt to transition the memory subsystem to adr (asynchronous dram self refresh) mode may fail.										
implication	this erratum may lead to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	due to this erratum, with ddr4-2133 memory, exiting from pc3 (package c3) or pc6 (package c6) state may lead to unpredictable system behavior.										
implication	this erratum may lead to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the system may shut down unexpectedly during a warm reset										
problem	certain complex internal timing conditions present when a warm reset is requested can prevent the orderly completion of in-flight transactions. it is possible under these conditions that the warm reset will fail and trigger a full system shutdown.										
implication	when this erratum occurs, the system will shut down and all machine check error logs will be lost.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	cat may not behave as expected										
problem	due to this erratum, cat (cache allocation technology) way enforcement may not behave as configured.										
implication	when this erratum occurs, cache quality of service guarantees may not be met. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/interrupt.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title											
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	freeze_while_smm does not prevent event from pending pebs during smm										
problem	in general, a pebs record should be generated on the first count of the event after the counter has overflowed. however, ia32_debugctl_msr.freeze_while_smm (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if a performance counter overflowed before an smi a pebs record has not yet been generated because another count of the event has not occurred. the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.										
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.										
workaround	none identified.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title											
problem	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).										
implication	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.										
workaround	the sampling driver should avoid using sav<100.										
											
title	instruction fetch may cause machine check if page size and memory type was changed without invalidation										
problem	this erratum may cause a machine-check error (ia32_mci_status.mcacod=0150h) on the fetch of an instruction that crosses a 4-kbyte address boundary. it applies only if (1) the 4-kbyte linear region on which the instruction begins is originally translated using a 4-kbyte page with the wb memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-mbyte, 4-mbyte, or 1- gbyte) with the uc memory type; and (3) the instruction fetch occurs after the paging- structure modification but before software invalidates any tlb entries for the linear region.										
implication	due to this erratum an unexpected machine check with error code 0150h may occur, possibly resulting in a shutdown. intel has not observed this erratum with any commercially available software.										
workaround	software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. it can instead use the following algorithm: first clear the p flag in the relevant paging-structure entry (for example, pde); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the p flag and establish the new page size and memory type.										
											
title											
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	interrupt from local apic timer may not be detectable while being delivered										
problem	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.										
implication	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.										
workaround	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.										
											
title											
problem	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executed while enhanced intel speedstep® technology transitions, intel® turbo boost technology transitions, or thermal monitor events occur, the pending #mf may be signaled before pending interrupts are serviced.										
implication	software may observe #mf being signaled before pending interrupts are serviced. workaround none identified.										
workaround											
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store or an mmx instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (that is, following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	processor may livelock during on demand clock modulation										
problem	the processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the ia32_clock_modulation msr (19ah) and the clock modulation duty cycle is set to 12.5% (02h in bits 3:0 of the same msr), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access uc memory.										
implication	program execution may stall on both threads of the core subject to this erratum.										
workaround	this erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the ia32_clock_modulation msr is 18.75% or higher.										
											
title	performance monitor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count										
problem	the performance monitor events other_assists.avx_to_sse (event c1h; umask 08h) and other_assists.sse_to_avx (event c1h; umask 10h) incorrectly increment and over count when an hle (hardware lock elision) abort occurs.										
implication	the performance monitor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count.										
workaround	none identified.										
											
title	performance monitor event dsb2mite_switches.count may over count										
problem	the performance monitor event dsb2mite_switches.count (event abh; umask 01h) should count the number of dsb (decode stream buffer) to mite (macro instruction translation engine) switches. due to this erratum, the dsb2mite_switches.count event will count speculative switches and cause the count to be higher than expected.										
implication	the performance monitor event dsb2mite_switches.count may report count higher than expected.										
workaround	none identified.										
											
title	timed mwait may use deadline of a previous execution										
problem	a timed mwait instruction specifies a tsc deadline for execution resumption. if a wake event causes execution to resume before the deadline is reached, a subsequent timed mwait instruction may incorrectly use the deadline of the previous timed mwait when that previous deadline is earlier than the new one.										
implication	a timed mwait may end earlier than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding										
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9:1 report the highest index value used for any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9:1] to read and write all vmcs fields may omit one field.										
workaround	none identified.										
											
title											
problem	during rtm (restricted transactional memory) operation when branch tracing is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.										
implication	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.										
workaround	none identified.										
											
title	locked load performance monitoring events may under count										
problem	the performance monitoring events mem_trans_retired.load_latency (event cdh; umask 01h), mem_load_retired.l2_hit (event d1h; umask 02h), and mem_uops_retired.locked (event doh; umask 20h) should count the number of locked loads. due to this erratum, these events may under count for locked transactions that hit the l2 cache.										
implication	the above event count will under count on locked loads hitting the l2 cache.										
workaround	none identified.										
											
title	transactional abort may cause an incorrect branch record										
problem	if an intel® transactional synchronization extensions (intel® tsx) transactional abort event occurs during a string instruction, the from-ip in the lbr (last branch record) is not correctly reported.										
implication	due to this erratum, an incorrect from-ip on the top of lbr stack may be observed. workaround none identified.										
workaround											
											
title											
problem	due to this erratum, pmi (performance monitoring interrupt) may be repeatedly issued until the counter overflow bit is cleared in the overflowing counter.										
implication	multiple pmis may be received when a performance monitor counter overflows. workaround none identified. if the pmi is programmed to generate an nmi, software may delay the										
workaround											
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not- available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation										
problem	if ept (extended page tables) is enabled, a mov to cr3 or vmfunc may be followed by an unexpected page fault or the use of an incorrect page translation.										
implication	guest software may crash or experience unpredictable behavior as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® processor trace packet generation may stop sooner than expected										
problem	setting the stop bit (bit 4) in a table of physical addresses entry directs the processor to stop intel pt (processor trace) packet generation when the associated output region is filled. the processor indicates this has occurred by setting the stopped bit (bit 5) of ia32_rtit_status msr (571h). due to this erratum, packet generation may stop earlier than expected.										
implication	when this erratum occurs, the outputoffset field (bits [62:32]) of the ia32_rtit_output_mask_ptrs msr (561h) holds a value that is less than the size of the output region which triggered the stop condition; intel pt analysis software should not attempt to decode packet data bytes beyond the outputoffset.										
workaround	none identified.										
											
title	pebs eventing ip field may be incorrect after not-taken branch										
problem	when a pebs (precise-event-based-sampling) record is logged immediately after a not-taken conditional branch (jcc instruction), the eventing ip field should contain the address of the first byte of the jcc instruction. due to this erratum, it may instead contain the address of the instruction preceding the jcc instruction.										
implication	performance monitoring software using pebs may incorrectly attribute pebs events that occur on a jcc to the preceding instruction.										
workaround	none identified.										
											
title											
problem	an hle (hardware lock elision) transactional region begins with an instruction with the xacquire prefix. due to this erratum, reads from within the transactional region of the memory destination of that instruction may return the value that was in memory before the transactional region began.										
implication	due to this erratum, unpredictable system behavior may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring event instr_retired.all may generate redundant pebs records for an overflow										
problem	due to this erratum, the performance monitoring feature pdir (precise distribution of instructions retired) for instr_retired.all (event c0h; umask 01h) will generate redundant pebs (precise event based sample) records for a counter overflow. this can occur if the lower 6 bits of the performance monitoring counter are not initialized or reset to 0, in the pebs counter reset field of the ds buffer management area.										
implication	the performance monitor feature pdir, may generate redundant pebs records for an overflow.										
workaround	initialize or reset the counters such that lower 6 bits are 0.										
											
title	reset during peci transaction may cause a machine check exception										
problem	if a peci transaction is interrupted by a warm reset, it may result in a machine check exception with mcacod of 0x402.										
implication	when this erratum occurs, the system becomes unresponsive and a machine check will be generated.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® processor trace (intel® pt) mode.exec, pip, and cbr packets are not generated as expected										
problem	the intel® pt mode.exec (mode packet – execution mode leaf), pip (paging information packet), and cbr (core: bus ratio) packets are generated at the following psb+ (packet stream boundary) event rather than at the time of the originating event as expected.										
implication	the decoder may not be able to properly disassemble portions of the binary or interpret portions of the trace because many packets may be generated between the mode.exec, pip, and cbr events and the following psb+ event.										
workaround	the processor inserts these packets as status packets in the psb+ block. the decoder may have to skip forward to the next psb+ block in the trace to obtain the proper updated information to continue decoding.										
											
title	performance monitor instructions retired event may not count consistently										
problem	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.										
implication	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title											
problem	the ia32_pmcx msr (c1h - c8h) general-purpose performance counters may report inaccurate counts when the associated event selection ia32_perfevtselx msr’s (186h - 18dh) anythread field (bit 21) is set and either.										
implication	due to this erratum, ia32_pmcx counters may be inaccurate.										
workaround	none identified.										
											
title	an invalid lbr may be recorded following a transactional abort										
problem	use of intel® transactional synchronization extensions may result in a transactional abort. if an abort occurs immediately following a branch instruction, an invalid lbr (last branch record) may be recorded before the lbr produced by the abort.										
implication	the invalid lbr may interfere with execution path reconstruction prior to the transactional abort.										
workaround	none identified.										
											
title	executing an rsm instruction with intel® processor trace enabled will signal a #gp										
problem	upon delivery of an smi (system management interrupt), the processor saves and then clears traceen in the ia32_rtit_ctl msr (570h), thus disabling intel® processor trace (intel® pt). if the smi handler enables intel pt and it remains enabled when an rsm instruction is executed, a shutdown event should occur. due to this erratum, the processor does not shutdown but instead generates a #gp (general-protection exception).										
implication	when this erratum occurs, a #gp will be signaled.										
workaround	if software enables intel pt in system-management mode, it should disable intel® pt before executing rsm.										
											
title	intel® processor trace pip may be unexpectedly generated										
problem	when intel® processor trace is enabled, psb+ (packet stream boundary) packets may include a pip (paging information packet) even though the os field (bit 2) of ia32_rtit_ctl msr (570h) is 0.										
implication	when this erratum occurs, user-mode tracing (indicated by ia32_rtit_ctl.os = 0) may include cr3 address information. this may be an undesirable leakage of kernel information.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	processor does not check irte reserved bits										
problem	as per the intel® virtualization technology for directed i/o (intel® vt-d) specification, bits 63:haw (host address width) of the posted interrupt descriptor upper address field in the irte (interrupt remapping table entry) must be checked for a value of 0; violations must be reported as an interrupt-remapping fault. due to this erratum, hardware does not perform this check and does not signal an interrupt-remapping fault on violations.										
implication	if software improperly programs the reserved address bits of posted interrupt descriptor upper address in the irte to a value other than zero, hardware will not detect and report the violation.										
workaround	software must ensure posted interrupt address bits 63:haw in the irte are zero.										
											
title	pcie* tph request capability structure incorrectly advertises device specific mode as supported										
problem	the tph (transaction layer packet processing hints) requester capability structure (pci express extended capability id type 0017h) incorrectly reports that device specific mode is supported in its tph requester capability register (bit 2 at offset 04h in the capability structure).										
implication	the processor supports only no st (steering tag) mode. the pci express base specification allows, in this instance, the tph requester capability structure’s tph requester control register (at offset 08h) bits 2:0 to be hardwired to ‘000’, forcing no st mode. advertising device specific mode but forcing no st mode is a violation of the pci express base specification (and may be reported as a compliance issue). intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	package c3 state or deeper may lead to a reset										
problem	due to this erratum, the processor may reset and signal a machine check error with a ia32_mci_status.mcacod value of 0400h when in package c3 state or deeper.										
implication	when this erratum occurs, the processor will reset and report an uncorrectable machine check error.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum. it is possible for the bios to contain a workaround for this erratum										
											
title	vmx-preemption timer may stop operating when acc is enabled										
problem	when the msr_pkg_cst_config_control.acc_enable bit (msr e2h, bit 16) is set, the vmx-preemption timer is not decremented in the hlt state.										
implication	when acc (autonomous c-state control) is enabled, the vmx-preemption timer may not cause a vm exit when expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	intel avx workloads require a reduced maximum turbo ratio. due to this erratum, the intel avx turbo ratio is higher than expected which may cause the processor to exceed iccmax limits and lead to unpredictable system behavior.										
implication	due to this erratum, the processor may exhibit unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writing msr_error_control may cause a #gp										
problem	a wrmsr that attempts to set mode1_memerror_report field (bit 1) and/or mem_correrr_logging_disable field (bit 5) of the msr_error_control msr (17fh) may incorrectly cause a #gp (general protection exception).										
implication	due to this erratum, if bios attempts to change the value of the listed bits, a #gp may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling acc in vmx non-root operation may cause system instability										
problem	acc (autonomous c-state control) is enabled by setting acc_enable (bit 16) of msr_pkg_cst_config_control (e2h) to ‘1’. if acc is enabled while the processor is in vmx non-root operation, an unexpected vm exit, a machine check, or unpredictable system behavior may result.										
implication	enabling acc may lead to system instability.										
workaround	none identified. bios should not enable acc.										
											
title	a spurious patrol scrub error may be logged										
problem	when a memory ecc error occurs, a spurious patrol scrub error may also be logged on another memory channel.										
implication	a patrol scrub correctable error may be incorrectly logged.										
workaround	the home agent error registers and correctable error count registers (bus 1; device 20; function 2; offset 104-110) provides accurate error information.										
											
title	performance monitoring counters may produce incorrect results for br_inst_retired event on logical processor.										
problem	performance monitoring event br_inst_retired (c4h) counts retired branch instructions. due to this erratum, when operating on logical processor 1 of any core, br_inst_retired.far_branch (event c4h; umask 40h) and br_inst_retired. all_branches (event c4h; umask 04h) may count incorrectly. logical processor 0 of all cores and cores with smt disabled are not affected by this erratum.										
implication	due to this erratum, certain performance monitoring event may produce unreliable results when smt is enabled.										
workaround	none identified.										
											
title	processor instability may occur when using the peci rdiamsr command										
problem	under certain circumstances, reading a machine check register using the peci (platform environmental control interface) rdiamsr command may result in a machine check, processor hang or shutdown.										
implication	machine check, hang or shutdown may be observed when using the peci rdiamsr command.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a #ve may not invalidate cached translation information										
problem	an ept (extended page table) violation that causes a #ve (virtualization exception) may not invalidate the guest-physical mappings that were used to translate the guest- physical address that caused the ept violation.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package c-state transitions while inband peci accesses are in progress may cause performance degradation										
problem	when a package c-state transition occurs at the same time an inband peci transaction occurs, prochot# may be incorrectly asserted.										
implication	incorrect assertion of prochot# reduces the core frequency to the minimum operating frequency of 1.2 ghz resulting in persistent performance degradation.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	attempting concurrent enabling of intel® processor trace (intel® pt) with lbr, bts, or btm results in a #gp										
problem	if lbr (last branch records), bts (branch trace store), or btm (branch trace messages) are enabled in the ia32_debugctl msr (1d9h), an attempt to enable intel pt (intel® processor trace) in ia32_rtit_ctl msr (570h) results in a #gp (general protection exception). (note that the btm enable bit in ia32_debugctl msr is named “tr”.) correspondingly, if intel pt was previously enabled when an attempt is made to enable lbr, bts, or btm, a #gp will occur.										
implication	an unexpected #gp may occur when concurrently enabling any one of lbr, bts, or btm with intel pt.										
workaround	none identified.										
											
title	a ddr4 c/a parity error in lockstep mode may result in a spurious uncorrectable error										
problem	if a memory c/a (command/address) parity error occurs while the memory subsystem is configured in lockstep mode then the channel that observed the error will properly log the error but the associated channel in lockstep will incorrectly log an uncorrectable error in its ia32_mci_status msr.										
implication	due to this erratum, incorrect logging of an uncorrectable memory error in ia32_mci_status may occur.										
workaround											
											
title	cores may be unable to reach maximum turbo frequency										
problem	due to this erratum, processors with more than ten cores may be limited to less than the specified maximum turbo frequency.										
implication	when this erratum occurs, the processor performance is reduced.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pebs record may be generated after being disabled										
problem	a performance monitoring counter may generate a pebs (precise event based sampling) record after disabling pebs or the performance monitoring counter by clearing the corresponding enable bit in ia32_pebs_enable msr (3f1h) or ia32_perf_global_ctrl msr (38fh).										
implication	a pebs record generated after a vmx transition will store into memory according to the post-transition ds (debug store) configuration. these stores may be unexpected if pebs is not enabled following the transition.										
workaround	it is possible for the bios to contain a workaround for this erratum. a software workaround is possible through disallowing pebs during vmx non-root operation and disabling pebs prior to vm entry.										
											
title	software using intel® tsx may behave unpredictably										
problem	under a complex set of internal timing conditions and system events, software using the intel tsx (transactional synchronization extensions) instructions may behave unpredictably.										
implication	this erratum may result in unpredictable behavior of the software using tsx. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	some e5-1607v4 and e5-1603v4 parts will incorrectly report support for ddr4-2400										
problem	some e5-1607v4 and e5-1603v4 parts will incorrectly report that they support ddr4- 2400. using ddr4-2400 dimms may result in unpredictable system behavior.										
implication	system may operate their memory sub-systems at ddr4-2400 rather than ddr4- 2133.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	prochot# assertion during warm reset may cause persistent performance reduction										
problem	assertion of prochot# after reset# de-assertion but before bios has completed reset initialization (indicated by cpl3) may result in persistent processor throttling. asserting prochot# during and after reset# assertion for frb (fault resilient boot) tri-stating of the processor is not affected by this erratum.										
implication	when this erratum occurs, the resultant persistent throttling substantially reduces the processor’s performance.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	data breakpoint coincident with a machine check exception may be lost										
problem	if a data breakpoint occurs coincident with a machine check exception, then the data breakpoint may be lost.										
implication	due to this erratum, a valid data breakpoint may be lost.										
workaround	none identified.										
											
title	internal parity errors may incorrectly report overflow in the ia32_mc0_status msr										
problem	due to this erratum, an uncorrectable internal parity error with an ia32_mc0_status.mcacod (bits [15:0]) value of 0005h may incorrectly set the ia32_mc0_status.over flag (bit 62) indicating an overflow when a single error has been observed.										
implication	ia32_mc0_status.over may not accurately indicate multiple occurrences of errors. there is no other impact to normal processor functionality.										
workaround	none identified										
											
title	incorrect vmcs used for pml-index field on vmx transitions into and out of smm										
problem	the pml (page modification log) index field is saved to an incorrect vmcs on an smm vm exit. vm entries that return from smm restore the pml-index field from that same incorrect vmcs.										
implication	the pml-index field is correctly maintained for expected use cases, in which the stm (smm-transfer monitor) does not access the pml-index field in the smm vmcs. if the stm uses vmread to read the field, it will get an incorrect value. in addition, the processor will ignore any modification of the field that the stm makes using vmwrite. intel has not observed this erratum to impact any commercially available software.										
workaround	none identified. to access the pml-index field, stm software should first load the current-vmcs pointer with a pointer to the executive vmcs.										
											
title	certain microcode updates may result in incorrect throttling causing reduced system performance										
problem	microcode updates with signature less than 0b000017 loaded by the operating system may result in excessive and persistent throttling that significantly reduces system performance.										
implication	when this erratum occurs, reduced performance may occur, concurrent with an incorrect assertion of the prochot# signal.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	an intel® hyper-threading technology enabled processor may exhibit internal parity errors or unpredictable system behavior										
problem	under a complex series of microarchitectural events while running intel hyper- threading technology, a correctable internal parity error or unpredictable system behavior may occur.										
implication	a correctable error (ia32_mc0_status.mcacod=0005h and ia32_mc0_status.mscod=0001h) may be logged. the unpredictable system behavior frequently leads to faults (e.g. #ud, #pf, #gp).										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	microcode updates loaded by the operating system may result in excessive and persistent throttling that significantly reduces system performance.										
implication	when this erratum occurs, performance may be reduced, concurrent with an incorrect assertion of the prochot# signal.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writing the iio_llc_ways msr results in an incorrect value										
problem	writing the iio_llc_ways msr (c8bh) always sets bits [1:0] regardless of the value written.										
implication	iio cache way allocation may not act as intended. intel has not seen any functional failure due to this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	turbo may be delayed after exiting c6 when using hwp										
problem	due to this erratum, enabling hwp (hardware-controlled performance states) by setting bit 0 of ia32_pm_enable (msr 770h) may lead to an unexpected delay in reaching turbo frequencies after a core exits c6 sleep state. this erratum does not occur when hwp is not enabled.										
implication	when this erratum occurs, enabling hwp may lead to a visible reduction of system performance.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_mc4_status.val may be incorrectly cleared by warm reset										
problem	due to this erratum, the ia32_mc4_status. val (msr 411h, bit 63) may be incorrectly cleared by a warm reset.										
implication	software may be unaware that a machine check occurred before the warm reset. workaround it is possible for the bios to contain a workaround for this erratum.										
workaround											
											
title	interrupt remapping may lead to a system hang										
problem	under complex micro-architectural conditions, back-to-back interrupt requests when interrupt remapping is enabled may lead to a system hang.										
implication	when this erratum occurs, the system hang may be associated with a queued invalidation of the ioapic that does not complete.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	mem_hot_c23_n dimm temperature reporting does not function correctly										
problem	on single ha (home agent) systems, the mem_hot_c23_n signal can be configured as an output signal that is asserted when a dimm temperature exceeds the throttle threshold (c.f. dimm_temp_th csrs at bus: 1; device: 20; function: 0,1; offset: 120h, 124h). due to this erratum, mem_hot_c23_n is not asserted when it should be.										
implication	platforms that rely on the mem_hot_c23_n for dimm temperature-based throttling will not behave as expected, potentially leading to unpredictable system behavior, excessive dimm aging, and dimm failure. this erratum does not affect mem_hot_c23_n when configured as an input.										
workaround	single ha platforms should use open loop thermal throttling for dimm temperature control, use mem_hot_c01_n as a proxy for mem_hot_c23_n, or have the bmc (or other external agent) periodically read the dimm temperature via peci then use the										
											
title	bi-directional pcie* posted transactions may lead to system hang										
problem	certain bi-directional pcie posted traffic patterns between cpu nodes may lead to a loss of flow control credits resulting in a link hang.										
implication	deadlock on a pcie link may result in a system hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	excessive uncorrected and corrected memory errors may occur following s3 resume or warm reset										
problem	following s3 resume or warm reset, uncorrected and corrected memory errors may occur.										
implication	when this erratum occurs, the system will log correctable errors, signal a machine check, or shut down.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	writing msr_lastbranch_x_from_ip may #gp when intel® tsx is not supported										
problem	due to this erratum, on processors that do not support intel tsx (intel® transactional synchronization extensions) (cpuid.07h.ebx bits 4 and 11 are both zero), writes to msr_lastbranch_x_from_ip (msr 680h to 68fh) may #gp unless bits[62:61] are equal to bit[47].										
implication	the value read from msr_lastbranch_x_from_ip is unaffected by this erratum; bits [62:61] contain in_tsx and tsx_abort information respectively. software restoring these msrs from saved values are subject to this erratum.										
workaround	before writing msr_lastbranch_x_from_ip, ensure the value being written has bit[47] replicated in bits[62:61]. this is most easily accomplished by sign extending from bit[47] to bits[62:48].										
											
title	intel® quickpath interconnect (intel® qpi) layer may report spurious correctable errors										
problem	intel® qpi may report an inband reset with no width change (error 0x22) correctable error upon exit from the l1 power state as logged in its ia32_mc{5, 20, 21}_status msrs (415h,451h,455h).										
implication	an unexpected inband reset with no width change error may be logged.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	peci ddr dimm digital thermal reading returns incorrect value										
problem	when using the peci rdpkgconfig() command to read pcs (package config space) service 14 “ddr dimm digital thermal reading”, the value returned is incorrect.										
implication	platform thermal management may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	iio csr lnkcon2 field selectable_de_emphasis cannot be set for dmi2 mode										
problem	the csr lnkcon2 (bus 0; device 0; function 0, offset 0x1c0) field selectable_de_emphasis (bit 6) cannot be set for a link when the dmi port is operating at 5 gt/s.the documentation has the attribute of rw-o (read, write once), but the processor incorrectly operates as read-only. this erratum does not occur when link is operating as a pcie* port.										
implication	when the link is in dmi2 mode, the de-emphasis cannot be changed for an upstream component.										
workaround	none identified.										
											
title	pcie* receiver may not meet the specification for ac common mode voltage and jitter										
problem	due to this erratum, pcie receivers may not meet the specification for ac common mode voltage (300 mv) and jitter (78.1 ps) at high temperatures when operating at 5 gt/s.										
implication	specifications for pcie receiver ac common mode voltage and jitter may not be met. intel has not observed this erratum on any commercially available system with any commercially available pcie devices.										
workaround	none identified.										
											
title	receiver termination impedance on pcie 3.0 does not comply with the specification										
problem	the pcie base specification revision 3.0 defines zrx-high-imp-dc-neg and zrx- high-imp-dc-pos for termination impedance of the receiver. the specified impedance for a negative voltage (-150 mv to 0v) is expected to be greater than 1 kohm. sampled measurements of this impedance as low as 400 ohms have been seen. the specified impedance for a positive voltage (> 200 mv) is greater than 20 kohms. sampled measurements of this impedance as low as 14.6 kohms have been seen.										
implication	intel has not observed functional failures from this erratum on any commercially available platforms using any commercially available pcie device.										
workaround	none identified.										
											
title	a memory channel with more than 4 ranks may lead to a system hang										
problem	a memory controller channel with more than 4 ranks and with trr (targeted row refresh) enabled may fail leading to a system hang. this erratum only impacts memory channels with three dual-rank ddr4 rdimms.										
implication	due to this erratum, the system may hang.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	writing r3qpi performance monitor registers may fail										
problem	due to this erratum, attempting to write r3qpi performance monitor registers (bus 0; device 11; functions 1,2,5,6; offset 0xa0-0xf7) may be unsuccessful.										
implication	a failed write to one or more r3qpi performance monitor registers is likely to yield incorrect performance events counts.										
workaround	consecutively write the identified registers twice with the same value before performance monitoring is globally enabled.										
											
title	intel® qpi link re-training after a warm reset or l1 exit may be unsuccessful										
problem	after a warm reset or an l1 exit, the intel® qpi (intel quickpath interconnect) links may not train successfully.										
implication	a failed intel® qpi link can lead to reduced system performance or an inoperable system.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	vccin vr phase shedding is disabled										
problem	due to this erratum, the processor does not direct the vccin vr (voltage regulator) to shed phases during low power states.										
implication	platform power consumption may exceed expected levels during deep package c- states.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci commands during reset may result in persistent timeout response										
problem	due to this erratum, a peci (platform environment control interface) command other than getdib(), ping(), or gettemp() received before reset_n is de-asserted may result in a timeout (0x81 completion code) for all subsequent such commands.										
implication	future peci commands other than getdib(), ping(), and gettemp() will not be serviced after this erratum occurs.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	system may hang when using the tph prefetch hint										
problem	when all enabled cores on a socket are simultaneously in core c3, core c6, or package c6 state and a pcie tph (transaction layer packet processing hint) with the prefetch hint set is received, the system may hang.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ts1s do not convey the correct transmitter equalization values during recovery.rcvrlock										
problem	the pcie 3.1 base specification requires that ts1s sent during recovery.rcvrlock following 8.0 gt/s eq (adaptive equalization) contain the final transmitter preset number and coefficient values that were requested by an endpoint during phase 2 of eq. due to this erratum, ts1s with incorrect transmitter preset number values may be sent during recovery.rcvrlock following 8.0 gt/s adaptive equalization.										
implication	endpoints that check these values may, when unexpected values are found, request equalization restart in subsequent tss it sends. if eq requests from the endpoint are supported in the bios or os, eq will be restarted and the link may continue this eq loop indefinitely.										
workaround	none identified.										
											
title	msr_temperature_target msr may read as '0'										
problem	due to this erratum, reading the msr_temperature_target msr (1a2h) may incorrectly return '0'.										
implication	software that depends on the contents of the msr_temperature_target msr may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci rdiamsr() command may fail after core c6 state is entered										
problem	reading core machine check bank registers using the peci (platform environment control interface) rdiamsr() command may fail after core c6 state has been entered.										
implication	invalid data may be returned when using peci to read core machine check bank registers.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	cltt may cause bios to hang on a subsequent warm reset										
problem	if cltt (closed loop thermal throttling) is enabled when a warm reset is requested, due to this erratum, the processor will resume dimm temperature polling before the memory sub-system has been re-initialized.										
implication	this erratum may lead to a bios hang. the warm reset request will fail, along with subsequence warm reset attempts. the failing condition is cleared by a cold reset.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	pcie* extended tag field may be improperly set										
problem	the extended tag field in the tlp header will not be zero for tlps issued by pcie ports 1a, 1b, 2c, 2d, 3c, and 3d even when the extended tag field enable bit in the device control register (offset 08h, bit 8) is 0.										
implication	this does not affect ports 0, 2a, 2b, 3a and 3b. this will not result in any functional issues when using device that properly track and return the full 8-bit extended tag value with the affected ports. however, if the extended tag field is not returned by a device connected to an affected port then this may result in unexpected completions and completion timeouts.										
workaround	none identified.										
											
title	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation										
problem	if ept (extended page tables) is enabled, a mov to cr3 or vmfunc may be followed by an unexpected page fault or the use of an incorrect page translation.										
implication	guest software may crash or experience unpredictable behavior as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	memory controller tsod_present settings being improperly cleared										
problem	on single home agent configurations, due to this erratum, the processor interferes with tsod (thermal sensor on dimm) usage by incorrectly clearing the tsod_present field (bits[7:0]) of the smbcntl_1 csr (bus 0; device 19; function 0; offset 0x198) after bios writes that field.										
implication	closed loop thermal throttle will not work as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ddr4 power down timing violation										
problem	when ddr4 is operating at 2133 mhz, the processor’s memory control may violate the jedec tprpden timing specification.										
implication	violation of timing specifications can lead to unpredictable system behavior; however, intel has not observed this erratum to impact the operation of any commercially available system using validated dimms by intel platform memory operations.										
workaround	none identified.										
											
title	correctable memory ecc errors may occur at boot										
problem	with memory lockstep enabled, the system may experience correctable memory errors during boot with ia32_mci_status.mcacod= 0x009x (where x is 0,1,2, or 3 and indicates the channel number reporting the error)										
implication	the system may experience correctable memory errors.										
workaround	none identified.										
											
title	bt timeouts may cause spurious machine checks										
problem	the bt (backup tracker) timeout logic in the home agent can trigger spuriously, causing false machine checks indicated by ia32_mci_status.mscod=0x0200.										
implication	due to this erratum, timeout machine check may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie type 1 vdms may be silently dropped										
problem	due to this erratum, a pcie type 1 vdms (vendor defined message) is silently dropped unless the vendor id is the mctp (management component transport protocol) value of 0x1ab4.										
implication	pcie type 1 vdms may be unexpectedly dropped. intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	config_tdp_nominal csr implemented at incorrect offset										
problem	the pcie base specification indicates that configuration space headers have a base address register at offset 0x10. due to this erratum, the power control unit’s config_tdp_nominal csr (bus 1; device 30; function 3; offset 0x10) is located where a base address register is expected.										
implication	software may treat the config_tdp_nominal csr as a base address register leading to a failure to boot.										
workaround	none identified.										
											
title	a machine-check exception due to instruction fetch may be delivered before an instruction breakpoint										
problem	debug exceptions due to instruction breakpoints take priority over exceptions resulting from fetching an instruction. due to this erratum, a machine-check exception resulting from the fetch of an instruction may take priority over an instruction breakpoint if the instruction crosses a 32-byte boundary and the second part of the instruction is in a 32-byte poisoned instruction fetch block.										
implication	instruction breakpoints may not operate as expected in the presence of a poisoned instruction fetch block.										
workaround	none identified.										
											
title	power consumed during package c6 may exceed specification										
problem	due to this erratum, the processor power usage may be higher than specified for the vccin and/or iio domains while in package c6 state.										
implication	systems may experience increased power consumption while the processor is in package c6.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	platform performance degradation when c1e is enabled										
problem	due to this erratum, when c1e is enabled and after the processor has entered package c1e state, core clock frequency becomes limited to its minimum value (sometimes referred to as pn) until the system exits package c3 state (or deeper) or the system is reset.										
implication	when this erratum occurs, operating frequency will be lower than expected. note: after a package c3 exit, re-entering package c1e state re-imposes this erratum’s frequency limit.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie correctable error status register may not log receiver error at 8.0 gt/s										
problem	due to this erratum, correctable pcie receiver errors may not be logged in the dpe field (bit 15) of the pcists csr (bus: 0; device 1,2,3; function 0-1, 0-3, 0-3; offset 6h) when operating at 8.0 gt/s.										
implication	correctable receiver errors during 8.0 gt/s operation may not be visible to the os or driver software.										
workaround	none identified.										
											
title	pcie hot-plug slot status register may not indicate command completed										
problem	the pcie base specification requires a write to the slot control register (offset a8h) to generate a hot plug command when the downstream port is hot plug capable. due to this erratum, a hot plug command is generated only when one or more of the slot control register bits [11:6] are changed.										
implication	writes to the slot control register that leave bits [11:6] unchanged will not generate a hot plug command and will therefore not generate a command completed event. software that expects a command completed event may not behave as expected.										
workaround	it is possible for software to implement a one-second timeout in lieu of receiving a command completed event.										
											
title	local pcie p2p traffic on x4 ports may cause a system hang										
problem	under certain conditions, p2p (peer-to-peer) traffic with x4 pcie ports on the same processor (i.e., local) may cause a system hang.										
implication	due to this erratum, the system may hang.										
workaround	none identified. local p2p traffic should not be used to or from x4 pcie ports.										
											
title	illc error conditions may be dropped or incorrectly signaled										
problem	when two llc (last level cache) errors happen in close proximity, a ucna (uncorrectable no action required) machine check may be dropped or a spurious machine check or cmci (corrected machine check interrupt) may be issued. further, when this erratum occurs, the merged cbo llc machine check bank ia32_mc[17- 19]_status msrs may be incorrect.										
implication	ia32_mc[17-19]_status msr may not reflect most current error.										
workaround	it is possible for the bios to contain a partial workaround for this erratum. the workaround does not address the potential dropped ucna machine check.										
											
title	a ddr4 c/a parity error in lockstep mode may result in a spurious uncorrectable error										
problem	if a memory c/a (command/address) parity error occurs while the memory subsystem is configured in lockstep mode then the channel that observed the error will properly log the error but the associated channel in lockstep will incorrectly log an uncorrectable error in its ia32_mci_status msr.										
implication	due to this erratum, incorrect logging of an uncorrectable memory error in ia32_mci_status may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	some imc and intel qpi functions have incorrect pci capptr values										
problem	the pci capptr (capability pointer register) is defined to contain the offset to the capabilities list structure when the pci pcists (pci status register) bit 4 (capabilities_list) is set to 1. due to this erratum, capptr (offset 0x34) should hold a value of 0x40 but is instead zero for these imc (integrated memory controller) and intel® qpi (quickpath interconnect) device: device 8, functions 3,5,6 device 9, functions 3,5,6 device 10, functions 3,5,6 device 19, functions 0-5 device 20, functions 0-3 device 21, functions 0-3 device 22, functions 0-3 device 23, functions 0-3										
implication	software that depends on capptr to access additional capabilities may not behave as expected.										
workaround	software that needs to access these capabilities must take this erratum into account.										
											
title	pcie tlp translation request errors are not properly logged for invalid memory writes										
problem	a pcie memory write tlp (transaction layer packet) with an at field value of 01b (address translation request) does not set the ur (unsupported request) bit (uncerrsts csr, bus 0; device 0; function 0; offset 0x14c; bit 20) as required by the pcie base specification.										
implication	system or software monitoring error status bits may not be notified of an unsupported request. when this erratum occurs, the processor sets the 'advisory_non_fatal_error_status' bit (corerrsts csr, bus 0; device 0; function 0; offset 0x158; bit 13) and drops the failing transaction.										
workaround	none identified.										
											
title	consecutive peci rdiamsr commands when core c6 is enabled may cause a system hang										
problem	consecutive peci (platform environment control interface) rdiamsr commands to access core machine check msrs can result in a system hang when core c6 state is enabled.										
implication	when this erratum occurs, peci commands can lead to a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title											
problem	due to this erratum, trr (targeted row refresh) is not compatible with ddr4 lrdimms.										
implication	unpredictable system behavior may occur.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	c/a parity error injection may cause the system to hang										
problem	when c/a (command address) parity error injections are occurring too frequently, the home agent may be prevented from completing memory transactions. this may result in an internal timer error indicated by ia32_mci_status. mscod=0x0080 and ia32_mci_status. mcacod=0x0400.										
implication	due to this erratum, the system may hang.										
workaround	ensure there is at least 30 µs of delay between injections.										
											
title	the system may shut down unexpectedly during a warm reset.										
problem	certain complex internal timing conditions present when a warm reset is requested can prevent the orderly completion of in-flight transactions. it is possible under these conditions that the warm reset will fail and trigger a full system shutdown.										
implication	when this erratum occurs, the system will shut down and all machine check error logs will be lost.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	patrol scrubbing of mirrored memory may log spurious memory errors										
problem	the patrol scrubber, when mirroring is enabled, may incorrectly identify certain data patterns as poison data or as memory errors.										
implication	spurious memory errors and poisoned data may be logged when mirroring is enabled.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	msr_turbo_activation_ratio msr cannot be locked										
problem	setting the turbo_activation_ratio_lock field (bit 31) of the msr_turbo_activation_ratio msr (64ch) has no effect; it does not block future writes to the msr_turbo_activation_ratio msr.										
implication	software cannot rely on locking msr_turbo_activation_ratio msr.										
workaround	none identified.										
											
title	the system may shut down unexpectedly during a warm reset										
problem	certain complex internal timing conditions present when a warm reset is requested can prevent the orderly completion of in-flight transactions. it is possible under these conditions that the warm reset will fail and trigger a full system shutdown.										
implication	when this erratum occurs, the system will shut down and all machine check error logs will be lost.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	invalid intel® quickdata technology xor descriptor source addressing may lead to unpredictable system behavior										
problem	intel® quickdata technology (i.e. crystal beach dma v3.2) does not correctly halt and report aborts on illegal source addresses placed in a cbdma descriptor regardless of type (legacy or pq). this abort condition may cause unpredictable system behavior.										
implication	this erratum may lead to unpredictable system behavior.										
workaround	ensure xor dma descriptor source addresses targets valid dram memory locations.										
											
title	warm reset may cause pcie hot-plug sequencing failure										
problem	the integrated i/o unit uses the vpp (virtual pin port) to communicate with power controllers, switches, and leds associated with pcie hot-plug sequencing. due to this erratum, a warm reset occurring when a vpp transaction is in progress may result in an extended vpp stall, termination of the in-flight vpp transaction, or a transient power down of slots subject to vpp power control.										
implication	during or shortly after a warm reset, when this erratum occurs, pcie hot-plug sequencing may experience transient or persistent failures or slots may experience unexpected transient power down events. in certain instances, a cold reset may be needed to fully restore operation.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pcie* ur and ca responses may be sent before link enters ler state										
problem	completions with ur (uncorrectable response) and ca (completer abort) status should trigger ler (live error recovery). further, these packets should be dropped upon entering ler. due to this erratum, these completions may not be dropped when ler is triggered.										
implication	since these packets contain no data, there is no loss of error containment. these packets will trigger ler mode; the link will be disabled.										
workaround	none identified.										
											
title	surprise down error status is not set correctly on dmi port										
problem	due to this erratum, the surprise_down_error_status (uncerrsts device0; function); offset 0x14c; bit5) is not set to 1 when dmi port detects a surprise down error.										
implication	surprise down errors will not be logged for the dmi port. this violates the pcie* base specification. software that relies on this status bit may not behave as expected.										
workaround	none identified.										
											
title	intel smi2 in half width mode with dddc enabled will not report rdecc errors										
problem	when a rdecc error occurs on an intel smi2 channel operating at a 1:1 ratio half-width mode and dddc (dual device data correction) enabled, the error logging in the intel® c102/104/112/114 scalable memory buffer and the processor is not properly coordinated.										
implication	although the error flow is correct, error isolation may be affected because the processor may log a rdecc error while the intel c102/104/112/114 scalable memory buffer does not log an error.										
workaround	none identified.										
											
title	pcie* sltcon csrs electromechanical_interlock_control field read as 1										
problem	the pci express base specification rev 3.1 requires that the sltcon (bus 0;device 3- 0;function 3-0;offset 0xa8) csrs’ electromechanical_interlock_control (bit 11) “always returns aa 0 when read”. due to this erratum, a read of this bit returns the last value written.										
implication	software expecting a value of 0 may not function as expected. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	software should ignore read values returned from this register field.										
											
title	intel ddr3 smi2 cap errors are ignored leading to unpredictable system behavior										
problem	an intel smi2 ddr3 cap (command address parity) error, rather than initiating a mirroring event as expected, is ignored leading to unpredictable system behavior.										
implication	when this erratum occurs, it may lead to unpredictable system behavior. note that this behavior does not affect ddr4 memory subsystems.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	peci rdpkgconfig command dram services may behave incorrectly										
problem	the peci (platform environment control interface) rdpkgconfig command may return incorrect results when accessing the dram thermal interface (indices 14 and 22).										
implication	thermal monitoring and control using peci may not behave as expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	some offcore_response performance monitoring events may undercount										
problem	the performance monitoring events offcore_response (events b7h and bbh) should count uncore responses matching the request-response configuration specified in msr_offcore_rsps (1a6h and 1a7h, respectively) for core-originated requests. however due to this erratum, corewb (bit 3), pf_l3_data_rd (bit 7), pf_l3_rfo (bit 8), pr_l3_code_rd (bit 9), split_lock_uc_lock (bit 10), and streaming_stores (bit 11) request types may undercount.										
implication	these performance monitoring events may not produce reliable results for the listed request types.										
workaround	none identified.										
											
title	performance monitoring offcore_respose_{1,2} events may miscount l3_miss_remote_hop										
problem	when a performance monitoring counter is configured to count off_core_response_{1,2} (events b7h and b8h), data obtained for remote dram may be attributed to l3_miss_remote_hop0 (as programmed by msr_offcore_rsp_{1,2} (msrs 1a6h, 1a7h) bit 27) instead of l3_miss_remote_hop1 (bit 28) or l3_miss_remote_hop2p (bit 29). data provided from remote caching agent associated with remote dram is unaffected.										
implication	l3_miss_remote_hop0 may over count, while l3_miss_remote_hop1 and l3_miss_remote_hop2p may undercount.										
workaround	none identified. set all three configuration bits (l3_miss_remote_hop0, l3_miss_remote_hop1, l3_miss_remote_hop2p) to obtain the total count of data supplied by remote agents.										
											
title	some dram and l3 cache performance monitoring events may count incorrectly										
problem	due to this erratum, the supplier information may become stale, and the following events may count incorrectly: mem_load_uops_retired.l3_hit (event d1h umask 04h) mem_load_uops_retired.l3_miss (event d1h umask 20h) mem_load_uops_l3_hit_retired.xsnp_miss (event d2h umask 01h) mem_load_uops_l3_hit_retired.xsnp_hit (event d2h umask 02h) mem_load_uops_l3_hit_retired.xsnp_hitm (event d2h umask 04h) mem_load_uops_l3_hit_retired.xsnp_none (event d2h umask 08h) mem_load_uops_l3_miss_retired.local_dram (event d3h umask 01h) mem_trans_retired.load_latency (event cdh umask 01h) page_walker_loads.dtlb_l3 (event bch umask 14h) page_walker_loads.itlb_l3 (event bch umask 24h) page_walker_loads.dtlb_memory (event bch umask 18h) page_walker_loads.itlb_memory (event bch umask 28h)										
implication	the affected events may count incorrectly, resulting in inaccurate memory profiles. for the affected events that are precise, pebs records may be generated at incorrect points. intel has observed incorrect counts by as much as 40%.										
workaround	none identified.										
											
title	certain settings of vm-execution controls may result in incorrect linear-address translations										
problem	if vm exit occurs from a guest with primary processor-based vm-execution control “activate secondary controls” set to 0 and the secondary processor-based vm- execution control “enable vpid” set to 1, then after a later vm entry with vpid fully enabled (“activate secondary controls” and “enable vpid” set to 1), the processor may use stale linear address translations.										
implication	the processor may incorrectly translate linear addresses. intel has not observed this erratum with any commercially available software.										
workaround	software should not enter a guest with “enable vpid” set to 1 when “activate secondary controls” is set to 0.										
											
title	an iret instruction that results in a task switch does not serialize the processor										
problem	an iret instruction that results in a task switch by returning from a nested task does not serialize the processor (contrary to the software developer’s manual vol. 3 section titled “serializing instructions”).										
implication	software which depends on the serialization property of iret during task switching may not behave as expected. intel has not observed this erratum to impact the operation of any commercially available software.										
workaround	none identified. software can execute an mfence instruction immediately prior to the iret instruction if serialization is needed.										
											
title	a p-state or c-state transition may lead to a system hang										
problem	for a small subset of parts under elevated die temperature conditions, a p-state or c- state transition may result in a system timeout or system shutdown.										
implication	when this erratum occurs, the system may shutdown or report a timeout error; intel has observed transaction completion timeouts and other internal timeouts.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	peci frequency limited to 1 mhz										
problem	the peci (platform environmental control interface) 3.1 specification’s operating frequency range is 0.2 mhz to 2 mhz. due to this erratum, peci may be unreliable when operated above 1 mhz.										
implication	platforms attempting to run peci above 1 mhz may not behave as expected.										
workaround	none identified. platforms should limit peci operating frequency to 1 mhz.										
											
title	none										
problem	if the “virtualize apic accesses” vm-execution control is 1, a 256-bit vgatherqps with an element that maps to the apic-access page may use incorrect addresses to load other elements.										
implication	loading from an incorrect address can result in unexpected behavior with respect to data, faults or vm exits. this erratum will occur only if a guest operating system attempts to access the apic using the vgatherqps instruction. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	a spurious patrol scrub error may be logged										
problem	when a memory ecc error occurs, a spurious patrol scrub error may also be logged on another memory channel.										
implication	a patrol scrub correctable error may be incorrectly logged.										
workaround	none identified.										
											
title	dram device failure with error flow registers enabled may result in a machine check										
problem	during a high rate of correctable dram error events, a ddr4 cap (command/address parity) error may result in an unrecoverable machine check with an ia32_mci_status.mcacod (bits [15:0]) value of 0000 0000 100x xxxx (where x can be 0 or 1) and an ia32_mci_status.mscod (bits [31:16]) value of 0x0200 or with an ia32_mci_status.mcacod value of 0000 0001 xxxx xxxx and an ia32_mci_status.mscod value of 0x000c.										
implication	a high rate of correctable errors, typically the result of a dram device failure, may result in an unrecoverable machine check.										
workaround	a bios code change has been identified and may be implemented as a workaround for this erratum.										
											
title	mtf vm exit on xbegin instruction may save state incorrectly										
problem	execution of an xbegin instruction while the “monitor trap flag” vm-execution control is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save the address of the xbegin instruction as the instruction pointer (instead of the fallback instruction address specified by the xbegin instruction). in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.										
implication	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	pebs record may be generated after being disabled										
problem	a performance monitoring counter may generate a pebs (precise event based sampling) record after disabling pebs or the performance monitoring counter by clearing the corresponding enable bit in ia32_pebs_enable msr (3f1h) or ia32_perf_global_ctrl msr (38fh).										
implication	a pebs record generated after a vmx transition will store into memory according to the post-transition ds (debug store) configuration. these stores may be unexpected if pebs is not enabled following the transition.										
workaround	it is possible for the bios to contain a workaround for this erratum. a software workaround is possible through disallowing pebs during vmx non-root operation and disabling pebs prior to vm entry.										
											
title	pcie* ports do not support dll link active reporting										
problem	the pcie base specification requires every “downstream port that supports link speeds greater than 5.0 gt/s” to support dll (data link layer) link active reporting, however, the pcie ports do not support dll link active reporting.										
implication	due to this erratum, the pcie ports do not support dll link active reporting. this may be reported by a pcie compliance test.										
workaround	none identified.										
											
title	pcie* link speed negotiation may fail after link is re-enabled										
problem	if a pcie link is established then disabled and the link partner’s advertised speeds are changed while the link is disabled, the link may fail to correctly negotiate link speed when it is re-enabled.										
implication	due to this erratum, the pcie link speed negotiation may fail after re-enabling a disabled port.										
workaround	none identified.										
											
title	prochot# assertion during warm reset may cause persistent performance reduction										
problem	assertion of prochot# after reset# de-assertion but before bios has completed reset initialization (indicated by cpl3) may result in persistent processor throttling. asserting prochot# during and after reset# assertion for frb (fault resilient boot) tri-stating of the processor is not affected by this erratum.										
implication	when this erratum occurs, the resultant persistent throttling substantially reduces the processor’s performance.										
workaround	none identified.										
											
title	data breakpoint coincident with a machine check exception may be lost										
problem	if a data breakpoint occurs coincident with a machine check exception, then the data breakpoint may be lost.										
implication	due to this erratum, a valid data breakpoint may be lost.										
workaround	none identified.										
											
title	a corrected internal parity error may result in a system hang										
problem	a corrected internal parity error (ia32_mc0_status.mcacod=0005h and ia32_mc0_status.mscod=000fh, msr 401h bits [15:0] and bits [31:16] respectively) may cause a system hang.										
implication	due to this erratum, a corrected internal parity error may cause a system hang. reset, smi, or init will end the system hang.										
workaround	none identified.										
											
title	ia32_mc0_status may be incorrect after a machine check overflow										
problem	when an srar (software recoverable action required) error is logged in ia32_mc0_status (msr 401h), a subsequent fatal error will correctly set the pcc (bit 57) and over (bit 62) flags but may fail to update other fields in ia32_mc0_status.										
implication	when this erratum occurs, the error logged in ia32_mc0_status is an invalid mixture of an srar error with the pcc flag set. software that reads ia32_mc0_status may not behave as expected.										
workaround	none identified.										
											
title	ia32_mc1_status.miscv may be incorrect on a machine check overflow										
problem	if software writes machine check bank 1 to contain a valid uc error with ia32_mc1_status.miscv cleared, another uc machine check may set ia32_mc1_status.miscv in violation of the overwrite rules.										
implication	when there is a machine check overflow in mc1, the ia32_mc1_status.miscv cannot be relied upon to indicate that ia32_mc1_miscv is valid. all uc errors in mc1 will set miscv.										
workaround	software should not write uc errors into ia32_mc1_status with ia32_mc1_status.miscv=0. software may write ia32_mc1_misc=0 to indicate no valid data in ia32_mc1_misc.										
											
title	pebs eventingip field may be incorrect under certain conditions										
problem	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.										
implication	when this erratum occurs, performance monitoring software may not attribute the pebs events to the correct instruction.										
workaround	none identified.										
											
title	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts										
problem	after a fault due to a failed pebs (processor event based sampling) or bts (branch trace store) address translation, the rf (resume flag) may be incorrectly set in the eflags image that is saved.										
implication	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.										
workaround	software should always prevent faults on pebs or bts.										
											
title	an apic timer interrupt during core c6 entry may be lost										
problem	due to this erratum, an apic timer interrupt coincident with the core entering c6 state may be lost rather than held for servicing later.										
implication	a lost apic timer interrupt may lead to missed deadlines or a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	an x87 store instruction which pends #pe while ept is enabled may lead to an unexpected machine check and/or incorrect x87 state information										
problem	the execution of an x87 store instruction which causes a #pe (precision exception) to be pended and also causes a vm-exit due to an ept violation or misconfiguration may lead the vmm logging a machine check exception with a cache hierarchy error (ia32_mci_status.mcacod = 0150h and ia32_mci_status.mscod = 000fh). additionally, fsw.pe and fsw.es (bits 5 and 7 of the fpu status word) may be incorrectly set to 1, and the x87 last instruction opcode (fop) may be incorrect.										
implication	when this erratum occurs, the vmm may receive an expected machine check exception and software attempting to handle the #pe may not behave as expected.										
workaround	none identified.										
											
title	load latency performance monitoring facility may stop counting										
problem	the performance monitoring events mem_trans_retired.load_latency_* (event cdh; umask 01h; any latency) count load instructions whose latency exceed a predefined threshold, where the loads are randomly selected using the load latency facility (pebs extension). however due to this erratum, load latency facility may stop counting load instructions when intel® hyper-threading technology (intel® ht technology) is enabled.										
implication	counters programmed with the affected events stop incrementing and do not generate pebs records.										
workaround	none identified.										
											
title	certain perfmon events may be counted incorrectly when the processor is not in c0 state										
problem	due to this erratum, the perfmon events listed below may be counted when the logical processor is not in c0 state. idq.empty (event 79h, umask 02h) idq_uops_not_delivered.core (event 9ch, umask 01h) resource_stalls.any (event a2h, umask 01h) adding the following 3 events to existing erratum: cycle_activity.cycles_ldm_pending (event a3h, umask 02h, cmask 02h) cycle_activity.cycles_no_execute (event a3h, umask 04h, cmask 04h) cycle_activity.stalls_ldm_pending (event a3h, umask 06h, cmask 06h)										
implication	the count will be higher than expected.										
workaround	none identified.										
											
title	writing msr_lastbranch_x_from_ip may #gp when intel® transactional synchronization extensions (intel® tsx) is not supported										
problem	due to this erratum, on processors that do not support intel tsx (cpuid.07h.ebx bits 4 and 11 are both zero), writes to msr_lastbranch_x_from_ip (msr 680h to 68fh) may #gp unless bits[62:61] are equal to bit[47].										
implication	the value read from msr_lastbranch_x_from_ip is unaffected by this erratum; bits [62:61] contain in_tsx and tsx_abort information respectively. software restoring these msrs from saved values are subject to this erratum.										
workaround	before writing msr_lastbranch_x_from_ip, ensure the value being written has bit[47] replicated in bits[62:61]. this is most easily accomplished by sign extending from bit[47] to bits[62:48].										
											
title	jtag boundary scan for intel® quickpath interconnect (intel® qpi) and pcie* lanes may report incorrect stuck at 1 errors										
problem	boundary scan testing of the intel qpi and pcie interfaces may incorrectly report a recurring stuck at 1 failure on intel qpi and pcie receiver lanes. this erratum only affects boundary scan testing and does not affect functional operation of the intel qpi and pcie interfaces.										
implication	this erratum may result in boundary scan test failures reported on one or more of the intel qpi and pcie lanes.										
workaround	none identified.										
											
title	apic timer interrupt may not be generated at the correct time in tsc-deadline mode										
problem	after writing to the ia32_tsc_adjust msr (3bh), any subsequent write to the ia32_tsc_deadline msr (6e0h) may incorrectly process the desired deadline. when this erratum occurs, the resulting timer interrupt may be generated at the incorrect time.										
implication	when the local apic (advanced programmable interrupt controller) timer is configured for tsc-deadline mode, a timer interrupt may be generated much earlier than expected or much later than expected. intel has not observed this erratum with most commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling isoch mode may cause the system to hang										
problem	when isoch (isochronous) operation is enabled within bios, the system may hang and fail to boot.										
implication	due to this erratum, the system may hang and fail to boot.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pci bars in the home agent will return non-zero values during enumeration										
problem	during system initialization the operating system may access the standard pci bars (base address registers). due to this erratum, accesses to the home agent bar registers (bus 1; device 18; function 0,4; offsets 0x14-0x24) will return non-zero values.										
implication	the operating system may issue a warning. intel has not observed any functional failures due to this erratum.										
workaround	none identified.										
											
title	pcie* header of a malformed tlp is logged incorrectly										
problem	if a pcie port receives a malformed tlp (transaction layer packet), an error is logged in the uncerrsts register (device 0; function 0; offset 14ch and device 2-3; function 0-3; offset 14ch). due to this erratum, the header of the malformed tlp is logged incorrectly in the hdrlog register (device 0; function 0; offset 164h and device 2-3; function 0-3; offset 164h).										
implication	the pcie header of a malformed tlp is not logged correctly.										
workaround	none identified.										
											
title	a malformed tlp may block ecrc error logging										
problem	if a pcie* port receives a malformed tlp that also would generate an ecrc check failed error, it should report a malformed tlp error. when malformed tlp errors are masked, the processor should report the lower-precedence ecrc check failed error but, due to this erratum, it does not.										
implication	software that relies upon ecrc check failed error indication may not behave as expected.										
workaround	none identified.										
											
title	the system may hang during an intel® quickpath interconnect (intel® qpi) slow to fast mode transition										
problem	during an intel qpi slow mode to fast mode transition, the ll_status field of the qpipcsts register (bus 0; device 8,9,10; function 0; offset 0xc0) may not be correctly updated to reflect link readiness.										
implication	the system may hang waiting for the qpipcsts.ll_status to update.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	unexpected performance loss when turbo disabled										
problem	when intel® turbo boost technology is disabled by ia32_misc_enables msr (416h) turbo_mode_disable bit 38, the ring operating frequency may be below p1 operating frequency.										
implication	processor performance may be below expectations for p1 operating frequency.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	exiting from package c3 or package c6 with ddr4-2133 may lead to unpredictable system behavior										
problem	due to this erratum, with ddr4-2133 memory, exiting from pc3 (package c3) or pc6 (package c6) state may lead to unpredictable system behavior.										
implication	this erratum may lead to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	the system may shut down unexpectedly during a warm reset										
problem	certain complex internal timing conditions present when a warm reset is requested can prevent the orderly completion of in-flight transactions. it is possible under these conditions that the warm reset will fail and trigger a full system shutdown.										
implication	when this erratum occurs, the system will shut down and all machine check error logs will be lost.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	cat may not behave as expected										
problem	due to this erratum, cat (cache allocation technology) way enforcement may not behave as configured.										
implication	when this erratum occurs, cache quality of service guarantees may not be met.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode										
problem	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.										
implication	lbr, bts and btm may report incorrect information in the event of an exception/interrupt.										
workaround	none identified.										
											
title	eflags discrepancy on page faults and on ept-induced vm exits after a translation change										
problem	eflags discrepancy on page faults and on ept-induced vm exits after a translation change. this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.										
implication	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.										
workaround	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.										
											
title	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error										
problem	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.										
implication	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	ler msrs may be unreliable										
problem	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.										
implication	the values of the ler msrs may be unreliable.										
workaround	none identified.										
											
title	monitor or clflush on the local xapic's address space results in hang										
problem	if the target linear address range for a monitor or clflush is mapped to the local xapic's address space, the processor will hang.										
implication	when this erratum occurs, the processor will hang. the local xapic's address space must be uncached. the monitor instruction only functions correctly if the specified linear address range is of the type write-back. clflush flushes data from the cache. intel has not observed this erratum with any commercially available software.										
workaround	do not execute monitor or clflush instructions on the local xapic address space.										
											
title	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code										
problem	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.										
implication	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.										
workaround	none identified.										
											
title	freeze_while_smm does not prevent event from pending pebs during smm										
problem	in general, a pebs record should be generated on the first count of the event after the counter has overflowed. however, ia32_debugctl_msr.freeze_while_smm (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if a performance counter overflowed before an smi a pebs record has not yet been generated because another count of the event has not occurred. the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.										
implication	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.										
workaround	none identified.										
											
title	apic error “received illegal vector” may be lost										
problem	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.										
implication	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.										
workaround	none identified.										
											
title	performance monitor precise instruction retired event may present wrong indications										
problem	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).										
implication	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.										
workaround	the sampling driver should avoid using sav<100.										
											
title	cr0.cd is ignored in vmx operation										
problem	if cr0.cd=1, the mtrrs and pat should be ignored and the uc memory type should be used for all memory accesses. due to this erratum, a logical processor in vmx operation will operate as if cr0.cd=0 even if that bit is set to 1.										
implication	algorithms that rely on cache disabling may not function properly in vmx operation.										
workaround	algorithms that rely on cache disabling should not be executed in vmx root operation.										
											
title	instruction fetch may cause machine check if page size and memory type was changed without invalidation										
problem	this erratum may cause a machine-check error (ia32_mci_status.mcacod=0150h) on the fetch of an instruction that crosses a 4-kbyte address boundary. it applies only if (1) the 4-kbyte linear region on which the instruction begins is originally translated using a 4-kbyte page with the wb memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-mbyte, 4-mbyte, or 1- gbyte) with the uc memory type; and (3) the instruction fetch occurs after the paging- structure modification but before software invalidates any tlb entries for the linear region.										
implication	due to this erratum an unexpected machine check with error code 0150h may occur, possibly resulting in a shutdown. intel has not observed this erratum with any commercially available software.										
workaround	software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. it can instead use the following algorithm: first clear the p flag in the relevant paging-structure entry (for example, pde); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the p flag and establish the new page size and memory type.										
											
title	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception										
problem	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.										
implication	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.										
workaround	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.										
											
title	interrupt from local apic timer may not be detectable while being delivered										
problem	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.										
implication	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.										
workaround	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.										
											
title	pending x87 fpu exceptions (#mf) may be signaled earlier than expected										
problem	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executed while enhanced intel speedstep® technology transitions, intel® turbo boost technology transitions, or thermal monitor events occur, the pending #mf may be signaled before pending interrupts are serviced.										
implication	software may observe #mf being signaled before pending interrupts are serviced.										
workaround	none identified.										
											
title	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store or an mmx* instruction										
problem	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.										
implication	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (that is, following them only with an instruction that writes (e/r)sp).										
workaround	none identified.										
											
title	vex.l is not ignored with vcvt*2si instructions										
problem	the vex.l bit should be ignored for the vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions, however due to this erratum the vex.l bit is not ignored and will cause a #ud.										
implication	unexpected #uds will be seen when the vex.l bit is set to 1 with vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions.										
workaround	software should ensure that the vex.l bit is set to 0 for all scalar instructions.										
											
title	processor may livelock during on demand clock modulation										
problem	the processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the ia32_clock_modulation msr (19ah) and the clock modulation duty cycle is set to 12.5% (02h in bits 3:0 of the same msr), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access uc memory.										
implication	program execution may stall on both threads of the core subject to this erratum.										
workaround	this erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the ia32_clock_modulation msr is 18.75% or higher.										
											
title	performance monitor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count										
problem	the performance monitor events other_assists.avx_to_sse (event c1h; umask 08h) and other_assists.sse_to_avx (event c1h; umask 10h) incorrectly increment and over count when an hle (hardware lock elision) abort occurs.										
implication	the performance monitor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count.										
workaround	none identified.										
											
title	performance monitor event dsb2mite_switches.count may over count										
problem	the performance monitor event dsb2mite_switches.count (event abh; umask 01h) should count the number of dsb (decode stream buffer) to mite (macro instruction translation engine) switches. due to this erratum, the dsb2mite_switches.count event will count speculative switches and cause the count to be higher than expected.										
implication	the performance monitor event dsb2mite_switches.count may report count higher than expected.										
workaround	none identified.										
											
title	timed mwait may use deadline of a previous execution										
problem	a timed mwait instruction specifies a tsc deadline for execution resumption. if a wake event causes execution to resume before the deadline is reached, a subsequent timed mwait instruction may incorrectly use the deadline of the previous timed mwait when that previous deadline is earlier than the new one.										
implication	a timed mwait may end earlier than expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding										
problem	ia32_vmx_vmcs_enum msr (48ah) bits 9:1 report the highest index value used for any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.										
implication	software that uses the value reported in ia32_vmx_vmcs_enum[9:1] to read and write all vmcs fields may omit one field.										
workaround	none identified.										
											
title	incorrect from_ip value for an rtm abort in btm or bts may be observed										
problem	during rtm (restricted transactional memory) operation when branch tracing is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.										
implication	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.										
workaround	none identified.										
											
title	locked load performance monitoring events may under count										
problem	the performance monitoring events mem_trans_retired.load_latency (event cdh; umask 01h), mem_load_retired.l2_hit (event d1h; umask 02h), and mem_uops_retired.locked (event doh; umask 20h) should count the number of locked loads. due to this erratum, these events may under count for locked transactions that hit the l2 cache.										
implication	the above event count will under count on locked loads hitting the l2 cache.										
workaround	none identified.										
											
title	transactional abort may cause an incorrect branch record										
problem	if an intel® transactional synchronization extensions (intel® tsx) transactional abort event occurs during a string instruction, the from-ip in the lbr (last branch record) is not correctly reported.										
implication	due to this erratum, an incorrect from-ip on the top of lbr stack may be observed.										
workaround	none identified.										
											
title	pmi may be signaled more than once for performance monitor counter overflow										
problem	due to this erratum, pmi (performance monitoring interrupt) may be repeatedly issued until the counter overflow bit is cleared in the overflowing counter.										
implication	multiple pmis may be received when a performance monitor counter overflows.										
workaround	none identified. if the pmi is programmed to generate an nmi, software may delay the										
											
title	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception										
problem	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not- available) exception will be raised instead of #ud exception.										
implication	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.										
workaround	software should not use fxsave or fxrstor with the vex prefix.										
											
title	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1										
problem	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.										
implication	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.										
workaround	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.										
											
title	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation										
problem	if ept (extended page tables) is enabled, a mov to cr3 or vmfunc may be followed by an unexpected page fault or the use of an incorrect page translation.										
implication	guest software may crash or experience unpredictable behavior as a result of this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® processor trace packet generation may stop sooner than expected										
problem	setting the stop bit (bit 4) in a table of physical addresses entry directs the processor to stop intel pt (processor trace) packet generation when the associated output region is filled. the processor indicates this has occurred by setting the stopped bit (bit 5) of ia32_rtit_status msr (571h). due to this erratum, packet generation may stop earlier than expected.										
implication	when this erratum occurs, the outputoffset field (bits [62:32]) of the ia32_rtit_output_mask_ptrs msr (561h) holds a value that is less than the size of the output region which triggered the stop condition; intel pt analysis software should not attempt to decode packet data bytes beyond the outputoffset.										
workaround	none identified.										
											
title	pebs eventing ip field may be incorrect after not-taken branch										
problem	when a pebs (precise-event-based-sampling) record is logged immediately after a not-taken conditional branch (jcc instruction), the eventing ip field should contain the address of the first byte of the jcc instruction. due to this erratum, it may instead contain the address of the instruction preceding the jcc instruction.										
implication	performance monitoring software using pebs may incorrectly attribute pebs events that occur on a jcc to the preceding instruction.										
workaround	none identified.										
											
title	reading the memory destination of an instruction that begins an hle transaction may return the original value										
problem	an hle (hardware lock elision) transactional region begins with an instruction with the xacquire prefix. due to this erratum, reads from within the transactional region of the memory destination of that instruction may return the value that was in memory before the transactional region began.										
implication	due to this erratum, unpredictable system behavior may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	performance monitoring event instr_retired.all may generate redundant pebs records for an overflow										
problem	due to this erratum, the performance monitoring feature pdir (precise distribution of instructions retired) for instr_retired.all (event c0h; umask 01h) will generate redundant pebs (precise event based sample) records for a counter overflow. this can occur if the lower 6 bits of the performance monitoring counter are not initialized or reset to 0, in the pebs counter reset field of the ds buffer management area.										
implication	the performance monitor feature pdir, may generate redundant pebs records for an overflow.										
workaround	initialize or reset the counters such that lower 6 bits are 0.										
											
title	reset during peci transaction may cause a machine check exception										
problem	if a peci transaction is interrupted by a warm reset, it may result in a machine check exception with mcacod of 0x402.										
implication	when this erratum occurs, the system becomes unresponsive and a machine check will be generated.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® processor trace (intel® pt) mode.exec, pip, and cbr packets are not generated as expected										
problem	the intel® pt mode.exec (mode packet – execution mode leaf), pip (paging information packet), and cbr (core: bus ratio) packets are generated at the following psb+ (packet stream boundary) event rather than at the time of the originating event as expected.										
implication	the decoder may not be able to properly disassemble portions of the binary or interpret portions of the trace because many packets may be generated between the mode.exec, pip, and cbr events and the following psb+ event.										
workaround	the processor inserts these packets as status packets in the psb+ block. the decoder may have to skip forward to the next psb+ block in the trace to obtain the proper updated information to continue decoding.										
											
title	performance monitor instructions retired event may not count consistently										
problem	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.										
implication	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.										
workaround	none identified.										
											
title	general-purpose performance counters may be inaccurate with any thread										
problem	the ia32_pmcx msr (c1h - c8h) general-purpose performance counters may report inaccurate counts when the associated event selection ia32_perfevtselx msr’s (186h - 18dh) anythread field (bit 21) is set and either.										
implication	due to this erratum, ia32_pmcx counters may be inaccurate.										
workaround	none identified.										
											
title	an invalid lbr may be recorded following a transactional abort										
problem	use of intel® transactional synchronization extensions may result in a transactional abort. if an abort occurs immediately following a branch instruction, an invalid lbr (last branch record) may be recorded before the lbr produced by the abort.										
implication	the invalid lbr may interfere with execution path reconstruction prior to the transactional abort.										
workaround	none identified.										
											
title	executing an rsm instruction with intel® processor trace enabled will signal a #gp										
problem	upon delivery of an smi (system management interrupt), the processor saves and then clears traceen in the ia32_rtit_ctl msr (570h), thus disabling intel® processor trace (intel® pt). if the smi handler enables intel pt and it remains enabled when an rsm instruction is executed, a shutdown event should occur. due to this erratum, the processor does not shutdown but instead generates a #gp (general-protection exception).										
implication	when this erratum occurs, a #gp will be signaled.										
workaround	if software enables intel pt in system-management mode, it should disable intel® pt before executing rsm.										
											
title	intel® processor trace pip may be unexpectedly generated										
problem	when intel® processor trace is enabled, psb+ (packet stream boundary) packets may include a pip (paging information packet) even though the os field (bit 2) of ia32_rtit_ctl msr (570h) is 0.										
implication	when this erratum occurs, user-mode tracing (indicated by ia32_rtit_ctl.os = 0) may include cr3 address information. this may be an undesirable leakage of kernel information.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	processor core ratio changes while in probe mode may result in a hang										
problem	if a processor core ratio change occurs while the processor is in probe mode, the system may hang.										
implication	due to this erratum, the processor may hang.										
workaround	none identified. processor core ratio changes may be disabled to avoid this erratum.										
											
title	processor does not check irte reserved bits										
problem	as per the intel® virtualization technology for directed i/o (intel® vt-d) specification, bits 63:haw (host address width) of the posted interrupt descriptor upper address field in the irte (interrupt remapping table entry) must be checked for a value of 0; violations must be reported as an interrupt-remapping fault. due to this erratum, hardware does not perform this check and does not signal an interrupt-remapping fault on violations.										
implication	if software improperly programs the reserved address bits of posted interrupt descriptor upper address in the irte to a value other than zero, hardware will not detect and report the violation.										
workaround	software must ensure posted interrupt address bits 63:haw in the irte are zero.										
											
title	pcie* tph request capability structure incorrectly advertises device specific mode as supported										
problem	the tph (transaction layer packet processing hints) requester capability structure (pci express extended capability id type 0017h) incorrectly reports that device specific mode is supported in its tph requester capability register (bit 2 at offset 04h in the capability structure).										
implication	the processor supports only no st (steering tag) mode. the pci express base specification allows, in this instance, the tph requester capability structure’s tph requester control register (at offset 08h) bits 2:0 to be hardwired to ‘000’, forcing no st mode. advertising device specific mode but forcing no st mode is a violation of the pci express base specification (and may be reported as a compliance issue). intel has not observed this erratum to impact the operation of any commercially available system.										
workaround	none identified.										
											
title	package c3 state or deeper may lead to a reset										
problem	due to this erratum, the processor may reset and signal a machine check error with a ia32_mci_status.mcacod value of 0400h when in package c3 state or deeper.										
implication	when this erratum occurs, the processor will reset and report an uncorrectable machine check error.										
workaround	it is possible for the bios to contain a workaround for this erratum										
											
title	vmx-preemption timer may stop operating when acc is enabled										
problem	when the msr_pkg_cst_config_control.acc_enable bit (msr e2h, bit 16) is set, the vmx-preemption timer is not decremented in the hlt state.										
implication	when acc (autonomous c-state control) is enabled, the vmx-preemption timer may not cause a vm exit when expected.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	intel® advanced vector extensions (intel® avx) workloads may exceed iccmax limits										
problem	intel avx workloads require a reduced maximum turbo ratio. due to this erratum, the intel avx turbo ratio is higher than expected which may cause the processor to exceed iccmax limits and lead to unpredictable system behavior.										
implication	due to this erratum, the processor may exhibit unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writing msr_error_control may cause a #gp										
problem	a wrmsr that attempts to set mode1_memerror_report field (bit 1) and/or mem_correrr_logging_disable field (bit 5) of the msr_error_control msr (17fh) may incorrectly cause a #gp (general protection exception).										
implication	due to this erratum, if bios attempts to change the value of the listed bits, a #gp may occur.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	enabling acc in vmx non-root operation may cause system instability										
problem	acc (autonomous c-state control) is enabled by setting acc_enable (bit 16) of msr_pkg_cst_config_control (e2h) to ‘1’. if acc is enabled while the processor is in vmx non-root operation, an unexpected vm exit, a machine check, or unpredictable system behavior may result.										
implication	enabling acc may lead to system instability.										
workaround	none identified. bios should not enable acc.										
											
title	a spurious patrol scrub error may be logged										
problem	when a memory ecc error occurs, a spurious patrol scrub error may also be logged on another memory channel.										
implication	a patrol scrub correctable error may be incorrectly logged.										
workaround	the home agent error registers and correctable error count registers (bus 1; device 20; function 2; offset 104-110) provides accurate error information.										
											
title	performance monitoring counters may produce incorrect results for br_inst_retired event on logical processor										
problem	performance monitoring event br_inst_retired (c4h) counts retired branch instructions. due to this erratum, when operating on logical processor 1 of any core, br_inst_retired.far_branch (event c4h; umask 40h) and br_inst_retired. all_branches (event c4h; umask 04h) may count incorrectly. logical processor 0 of all cores and cores with smt disabled are not affected by this erratum.										
implication	due to this erratum, certain performance monitoring event may produce unreliable results when smt is enabled.										
workaround	due to this erratum, certain performance monitoring event may produce unreliable results when smt is enabled.										
											
title	an apic timer interrupt during core c6 entry may be lost										
problem	due to this erratum, an apic timer interrupt coincident with the core entering c6 state may be lost rather than held for servicing later.										
implication	a lost apic timer interrupt may lead to missed deadlines or a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	processor instability may occur when using the peci rdiamsr command										
problem	under certain circumstances, reading a machine check register using the peci (platform environmental control interface) rdiamsr command may result in a machine check, processor hang or shutdown.										
implication	machine check, hang or shutdown may be observed when using the peci rdiamsr command.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	a #ve may not invalidate cached translation information										
problem	an ept (extended page table) violation that causes a #ve (virtualization exception) may not invalidate the guest-physical mappings that were used to translate the guest- physical address that caused the ept violation.										
implication	due to this erratum, the system may hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	package c-state transitions while inband peci accesses are in progress may cause performance degradation										
problem	when a package c-state transition occurs at the same time an inband peci transaction occurs, prochot# may be incorrectly asserted.										
implication	incorrect assertion of prochot# reduces the core frequency to the minimum operating frequency of 1.2ghz resulting in persistent performance degradation.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	attempting concurrent enabling of intel® pt with lbr, bts, or btm results in a #gp										
problem	if lbr (last branch records), bts (branch trace store), or btm (branch trace messages) are enabled in the ia32_debugctl msr (1d9h), an attempt to enable intel pt (intel® processor trace) in ia32_rtit_ctl msr (570h) results in a #gp (general protection exception). (note that the btm enable bit in ia32_debugctl msr is named “tr”.) correspondingly, if intel pt was previously enabled when an attempt is made to enable lbr, bts, or btm, a #gp will occur.										
implication	an unexpected #gp may occur when concurrently enabling any one of lbr, bts, or btm with intel pt.										
workaround	none identified.										
											
title	a ddr4 c/a parity error in lockstep mode may result in a spurious uncorrectable error										
problem	if a memory c/a (command/address) parity error occurs while the memory subsystem is configured in lockstep mode then the channel that observed the error will properly log the error but the associated channel in lockstep will incorrectly log an uncorrectable error in its ia32_mci_status msr.										
implication	due to this erratum, incorrect logging of an uncorrectable memory error in ia32_mci_status may occur.										
workaround											
											
title	cores may be unable to reach maximum turbo frequency										
problem	due to this erratum, processors with more than ten cores may be limited to less than the specified maximum turbo frequency.										
implication	when this erratum occurs, the processor performance is reduced.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	pebs eventingip field may be incorrect under certain conditions										
problem	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.										
implication	when this erratum occurs, performance monitoring software may not attribute the pebs events to the correct instruction.										
workaround	none identified.										
											
title	turbo may be delayed after exiting c6 when using hwp										
problem	due to this erratum, enabling hwp (hardware-controlled performance states) by setting bit 0 of ia32_pm_enable (msr 770h) may lead to an unexpected delay in reaching turbo frequencies after a core exits c6 sleep state. this erratum does not occur when hwp is not enabled.										
implication	when this erratum occurs, enabling hwp may lead to a visible reduction of system performance.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	writing the iio_llc_ways msr results in an incorrect value										
problem	writing the iio_llc_ways msr (c8bh) always sets bits [1:0] regardless of the value written.										
implication	iio cache way allocation may not act as intended. intel has not seen any functional failure due to this erratum.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts										
problem	after a fault due to a failed pebs (processor event based sampling) or bts (branch trace store) address translation, the rf (resume flag) may be incorrectly set in the eflags image that is saved.										
implication	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.										
workaround	software should always prevent faults on pebs or bts.										
											
title	the system may hang when executing a complex sequence of locked instructions										
problem	under certain internal timing conditions while executing a complex sequence of locked instructions, the system may hang.										
implication	the system may hang while executing a complex sequence of locked instructions and cause an internal timeout error machine check (ia32_mci_status.mcacod=0400h).										
workaround	it is possible for the bios to contain a workaround for this problem.										
											
title	software using intel® tsx may behave unpredictably										
problem	under a complex set of internal timing conditions and system events, software using the intel tsx (transactional synchronization extensions) instructions may behave unpredictably.										
implication	this erratum may result in unpredictable behavior of the software using tsx.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	data breakpoint coincident with a machine check exception may be lost										
problem	if a data breakpoint occurs coincident with a machine check exception, then the data breakpoint may be lost.										
implication	due to this erratum, a valid data breakpoint may be lost.										
workaround	none identified.										
											
title	internal parity errors may incorrectly report overflow in the ia32_mc0_status msr										
problem	due to this erratum, an uncorrectable internal parity error with an ia32_mc0_status.mcacod (bits [15:0]) value of 0005h may incorrectly set the ia32_mc0_status.over flag (bit 62) indicating an overflow when a single error has been observed.										
implication	ia32_mc0_status.over may not accurately indicate multiple occurrences of errors. there is no other impact to normal processor functionality.										
workaround	none identified.										
											
title	incorrect vmcs used for pml-index field on vmx transitions into and out of smm										
problem	the pml (page modification log) index field is saved to an incorrect vmcs on an smm vm exit. vm entries that return from smm restore the pml-index field from that same incorrect vmcs.										
implication	the pml-index field is correctly maintained for expected use cases, in which the stm (smm-transfer monitor) does not access the pml-index field in the smm vmcs. if the stm uses vmread to read the field, it will get an incorrect value. in addition, the processor will ignore any modification of the field that the stm makes using vmwrite. intel has not observed this erratum to impact any commercially available software.										
workaround	none identified. to access the pml-index field, stm software should first load the current-vmcs pointer with a pointer to the executive vmcs.										
											
title	an apic timer interrupt during core c6 entry may be lost										
problem	due to this erratum, an apic timer interrupt coincident with the core entering c6 state may be lost rather than held for servicing later.										
implication	a lost apic timer interrupt may lead to missed deadlines or a system hang.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	inband peci concurrent with os patch load may result in incorrect throttling causing reduced system performance										
problem	microcode updates loaded by the operating system may result in excessive and persistent throttling that significantly reduces system performance.										
implication	when this erratum occurs, performance may be reduced, concurrent with an incorrect assertion of the prochot# signal.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	an intel® hyper-threading technology enabled processor may exhibit internal parity errors or unpredictable system behavior										
problem	under a complex series of microarchitectural events while running intel hyper- threading technology, a correctable internal parity error or unpredictable system behavior may occur.										
implication	a correctable error (ia32_mc0_status.mcacod=0005h and ia32_mc0_status.mscod=0001h) may be logged. the unpredictable system behavior frequently leads to faults (e.g., #ud, #pf, #gp).										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	ia32_mc4_status.val may be incorrectly cleared by warm reset										
problem	due to this erratum, the ia32_mc4_status. val (msr 411h, bit 63) may be incorrectly cleared by a warm reset.										
implication	software may be unaware that a machine check occurred before the warm reset.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	some dram and l3 cache performance monitoring events may undercount										
problem	due to this erratum, the supplier may be misattributed to unknown, and the following events may undercount: mem_load_uops_retired.l3_hit (event d1h umask 04h) mem_load_uops_retired.l3_miss (event d1h umask 20h) mem_load_uops_l3_hit_retired.xsnp_miss (event d2h umask 01h) mem_load_uops_l3_hit_retired.xsnp_hit (event d2h umask 02h) mem_load_uops_l3_hit_retired.xsnp_hitm (event d2h umask 04h) mem_load_uops_l3_hit_retired.xsnp_none (event d2h umask 08h) mem_load_uops_l3_miss_retired.local_dram (event d3h umask 01h) mem_trans_retired.load_latency (event cdh umask 01h)										
implication	the affected events may undercount, resulting in inaccurate memory profiles. for the affected events that are precise, pebs records may be generated at incorrect points. intel has observed incorrect counts by as much as 20%.										
workaround	none identified.										
											
title	an x87 store instruction which pends #pe while ept is enabled may lead to an unexpected machine check and/or incorrect x87 state information										
problem	the execution of an x87 store instruction which causes a #pe (precision exception) to be pended and also causes a vm-exit due to an ept violation or misconfiguration may lead the vmm logging a machine check exception with a cache hierarchy error (ia32_mci_status.mcacod = 0150h and ia32_mci_status.mscod = 000fh). additionally, fsw.pe and fsw.es (bits 5 and 7 of the fpu status word) may be incorrectly set to 1, and the x87 last instruction opcode (fop) may be incorrect.										
implication	when this erratum occurs, the vmm may receive an expected machine check exception and software attempting to handle the #pe may not behave as expected.										
workaround	none identified.										
											
title	load latency performance monitoring facility may stop counting										
problem	the performance monitoring events mem_trans_retired.load_latency_* (event cdh; umask 01h; any latency) count load instructions whose latency exceed a predefined threshold, where the loads are randomly selected using the load latency facility (pebs extension). however due to this erratum, load latency facility may stop counting load instructions when intel® hyper-threading technology (intel® ht technology) is enabled.										
implication	counters programmed with the affected events stop incrementing and do not generate pebs records.										
workaround	none identified.										
											
title	bdf87 general-purpose performance monitoring counters 4-7 will not increment do not count with usr mode only filtering										
problem	the ia32_pmc4-7 msr (c5h-c8h) general-purpose performance monitoring counters will not count when the associated cpl filter selection in ia32_perfevtselx msr's (18ah-18dh) usr field (bit 16) is set while os field (bit 17) is not set.										
implication	software depending upon ia32_pmc4-7 to count only usr events will not operate as expected. counting os only events or os and usr events together is unaffected by this erratum.										
workaround	none identified.										
											
title	bdf88 writing msr_lastbranch_x_from_ip may #gp when intel® transactional synchronization extensions (intel® tsx) is not supported										
problem	due to this erratum, on processors that do not support intel tsx (cpuid.07h.ebx bits 4 and 11 are both zero), writes to msr_lastbranch_x_from_ip (msr 680h to 68fh) may #gp unless bits[62:61] are equal to bit[47].										
implication	the value read from msr_lastbranch_x_from_ip is unaffected by this erratum; bits [62:61] contain in_tsx and tsx_abort information respectively. software restoring these msrs from saved values are subject to this erratum.										
workaround	before writing msr_lastbranch_x_from_ip, ensure the value being written has bit[47] replicated in bits[62:61]. this is most easily accomplished by sign extending from bit[47] to bits[62:48].										
											
title	bdf89 apic timer interrupt may not be generated at the correct time in tsc-deadline mode										
problem	after writing to the ia32_tsc_adjust msr (3bh), any subsequent write to the ia32_tsc_deadline msr (6e0h) may incorrectly process the desired deadline. when this erratum occurs, the resulting timer interrupt may be generated at the incorrect time.										
implication	when the local apic (advanced programmable interrupt controller) timer is configured for tsc-deadline mode, a timer interrupt may be generated much earlier than expected or much later than expected. intel has not observed this erratum with most commercially available software.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	bdf90 loading microcode updates or executing an authenticated code module may result in a system hang										
problem	an uncorrectable error (ia32_mc3_status.mcacod=0400 and ia32_mc3_status.mscod=0080) may be logged for processors that have more than 2.5mb last-level-cache per core on attempting to load a microcode update or execute an authenticated code module. this issue does not occur with microcode updates with a signature of 0x0b000021 and greater.										
implication	due to this erratum, the processor may hang when attempting to load a microcode update or execute an authenticated code module.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	bdf91 nvdimm data may not be preserved correctly on power loss or adr activation										
problem	when entering adr (asynchronous dram self-refresh), whether through power loss or a specific adr command, concurrent reads to the nvdimm may prevent the data from being properly preserved.										
implication	after an adr event, memory data may be incorrect and may lead to an ecc error on next access.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	bdf92 link down events behind pcie device connected to cpu root ports can cause cto > 50ms on other root ports										
problem	when a downstream switch connected to a cpu root port experiences a link down it may cause a back pressure event that prevents other cpu root ports from completing transaction for >50ms but less than 100ms.										
implication	when intentionally disabling a pcie link in the system the iio arbiter can get stuck for > 50ms causing other endpoints to exceed their ct value (of 50ms) which is reported as a fatal system err2 condition.										
workaround	set pcie ctos to 100ms or greater if in a vulnerable configuration.										
											
title	table 2. intel® xeon® processor e7-8800/4800 integrated core/uncore errata bdex1 hsx43 pcie* ur and ca responses may be sent before link enters ler state										
problem	completions with ur (uncorrectable response) and ca (completer abort) status should trigger ler (live error recovery). further, these packets should be dropped upon entering ler. due to this erratum, these completions may not be dropped when ler is triggered.										
implication	since these packets contain no data, there is no loss of error containment. these packets will trigger ler mode; the link will be disabled.										
workaround	none.										
											
title	bdex2 ddr4 cap unable to determine which dimm caused cap										
problem	due to a logic issue ddr4 command address parity (cap) feature can correct a cap error, but will not be able to determine the dimm which failed.(formaly ex2, ex24 and ex28).										
implication	unable to determine which dimm had a ddr4 cap error if more than 1 dimm per channel (dpc).										
workaround	none.										
											
title	bdex3 error source id not logged when performing mmio write to region outside memory endpoint bars of downstream device										
problem	the root port does not log the error source id when performing an aligned write to mmio address within root port aperture but outside the bars of downstream device.										
implication	determination of error source not possible on a mmio write outside bars of downstream device by reading errsrcid register. only applies to a mmio write, a read will log error source id.										
workaround	none.										
											
title	bdex4 dimmtempstat_[2-0] and alldimmtempstat and peci service 14\22 may return data for opposite intel® c102/c104 & c112/c114 scalable memory buffer channel										
problem	in some cases dimmtempstat_[2-0] and alldimmtempstat and peci service 14\22 may return data for opposite intel® c102/c104 & c112/c114 scalable memory buffer channel. this only applies to channel 0 and 1 of the respective imc, and channel 2 and 3 are not impacted by this issue.										
implication	sw or fw polling a intel® c102/c104 & c112/c114 scalable memory buffer ddr channel will not know specific channel the reading is for.										
workaround	sw or fw polling dimmtempstat_[2-0] and alldimmtempstat should take this behavior into account.										
											
title	bdex5 clear of one dimmtempstat_[2-0] and mxbtempstat csr ev_asrt_temp* field clears all ev_asrt_temp* fields										
problem	a clear (write of 1 to this rw1c field) to a respective dimmtempstat_[2-0] and mxbtempstat csr ev_asrt_temp* field clears all ev_asrt_temp* fields in the respective csr.										
implication	ev_asrt_temp* fields are asserted only once on a thermal transition crossing the respective ev_asrt_temp* threshold. it is possible that a thermal transition could occur between the reading and clearing dimmtempstat_[2-0] and mxbtempstat ev_asrt_temp* fields and such transition could be lost (i.e. firmware polls ev_asrt_templo then clears ev_asrt_templo, but in between the reading and the clearing ev_asrt_temmid is logged and cleared).										
workaround	clear ev_asrt_temp* fields as soon as possible after reading them. log all bits on a read of the ev_asrt_temp* fields.										
											
title	bdex6 back-to-back page walks due to instruction fetches may cause a system hang										
problem	multiple code fetches in quick succession that generate page walks may result in a system hang causing an internal timer error (an mcacod value of 0400h) logged into ia32_mci_status bits [15:0].										
implication	due to this erratum, the processor may hang and report a machine check.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	bdex7 movntdqa from wc memory may pass earlier locked instructions										
problem	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.										
implication	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.										
workaround	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.										
											
title	bdex8 jtag boundary scan for intel® quickpath interconnect (intel® qpi) and pcie* lanes may report incorrect stuck at 1 errors										
problem	boundary scan testing of the intel qpi and pcie interfaces may incorrectly report a recurring stuck at 1 failure on intel qpi and pcie receiver lanes. this erratum only affects boundary scan testing and does not affect functional operation of the intel qpi and pcie interfaces.										
implication	this erratum may result in boundary scan test failures reported on one or more of the intel qpi and pcie lanes.										
workaround	none identified.										
											
title	cacheable mmio requests may block pcie* memory requests in smm mode										
problem	when operating in smm mode, cacheable mmio requests may prevent pcie memory requests from completing.										
implication	if pcie memory requests are blocked by cacheable mmio requests, the system may hang.										
workaround	do not issue cacheable mmio request during smm mode.										
											
title	ddrcrclktraining csr cannot be read										
problem	due to this erratum, two fields in ddrcrclktraining csr (bus: 2; device:17; function: 5; offset: a1ch), that should have been read-write, vmselogicdelay0 (bit 29) and vmselogicdelay2 (bit 30), are write-only; reading the csr always returns 0s for these fields.										
implication	data read from this register is not reliable. intel has not observed this erratum to affect processor functionality.										
workaround	none identified.										
											
title	performance monitoring event no_alloc_cycles counts incorrectly on logical processors 2 and 3										
problem	due to this erratum, all sub-events of performance monitoring event no_alloc_cycles (event cah) will be incorrect on logical processors 2 and 3. logical processors 0 and 1 are not affected by this erratum.										
implication	using the no_alloc_cycles performance monitoring event on logical processors 2 or 3 will not provide reliable results.										
workaround	use the results of the no_alloc_cycles performance monitoring event only when running the workload on logical processors 0 and/or 1.										
											
title	a and/or d bit may be set on a paging-structure entry that is not present or has reserved bit set										
problem	the a (accessed, bit 5) and/or d (dirty, bit 6) bits in a paging-structure entry (e.g., a page-table entry) may be set to 1 even when that entry has its present bit cleared or has a reserved bit set. this can only occur when one logical processor has cleared the present bit or set a reserved bit in a paging-structure entry, while at the same time another logical processor accesses the contents of a linear address mapped by that entry.										
implication	software that does not expect hardware to modify a paging-structure entry when it is marked not present, or has a reserved bit set, may behave unexpectedly.										
workaround	operating systems can take steps to ensure they are not exposed to this erratum.										
											
title	pci express inbound memory write with ro and ns attributes set will cause the processor to hang intel® xeon phi™ processor x200 product family										
problem	inbound memory writes with the ro (relaxed ordering) and ns (no snoop) attributes set in the tlp will cause the processor to hang.										
implication	when this erratum occurs, the system will experience a hang.										
workaround	bios should disable relaxed ordering for inbound transactions.										
											
title	cltt peci pass-through mode does not work										
problem	when cltt (closed loop thermal throttling) peci pass-through mode is enabled, peci thermal update messages are dropped.										
implication	integrated memory controller does not receive thermal data from the peci update messages.										
workaround	do not use cltt peci pass-through mode for ddr throttling.										
											
title	uncorrectable memory machine check may not set ia32_mc3_status.en										
problem	when an uncorrectable memory error follows a correctable memory error, the error logged may not set the en field (bit 60) in the ia32_mc3_status msr (40ch).										
implication	an uncorrectable machine check may be logged with en incorrectly set to 0, possibly leading to unexpected machine check handler behavior.										
workaround	none identified.										
											
title	package c6 may cause incorrect apic timer value										
problem	the apic timer ccr (current count register) may be too high after waking from package c6. the next timer interrupt will be delivered at the correct time. however, in periodic mode, the reload of the apic timer may be delayed.										
implication	when this erratum occurs, ccr reads may be too high and in periodic mode an apic timer interrupt may occur later than expected.										
workaround	none identified.										
											
title	unsynchronized cross-modifying code operations can cause unexpected instruction execution results										
problem	the act of one processor or system bus master writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction prior to execution of the new code is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.										
implication	in this case the phrase “unexpected or unpredictable execution behavior” encompasses the generation of most of the exceptions listed in the intel architecture software developer's manual volume 3: system programming guide including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.										
workaround	in order to avoid this erratum programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3: system programming guide, section: handling self- and cross-modifying code.										
											
title	upper 48 bits of the scatter/gather mask register do not function as expected										
problem	when one element of a scatter or gather instruction faults, the upper 48 bits of the mask register will be cleared. ideally, only bits corresponding to completed operations should be cleared.										
implication	intel® advanced vector extensions 512 (intel® avx-512) instructions supported by knl use only the lower 16 bits of these mask registers. intel has not observed this erratum to affect commercially available software.										
workaround	none identified										
											
title	dr6 may be zero after data breakpoint on gather, scatter or vrsqrt14 instructions										
problem	if gather, scatter or vrsqrt14 instructions trigger a data breakpoint, the debug status register (dr6) may be cleared.										
implication	software will see a breakpoint trap but with no indication of which data breakpoint register was triggered.										
workaround	none identified.										
											
title	performance monitoring event cpu_clk_unhalted.thread_p counts incorrectly on counter 1 if anythread bit is set for counter 0										
problem	due to this erratum, gp (general-purpose) counter 1 may overcount cpu_clk_unhalted.thread_p (event 3ch umask 00h) if ia32_perfevtsel0.anythread (msr 186h, bit 21) is set.										
implication	cpu_clk_unhalted.thread_p event should not be relied upon on gp counter 1.										
workaround	use only gp counter 0 or fixed counter 1 for unhalted core cycles.										
											
title	an instruction with7or more prefixes may cause a spurious #pf or spuriously read uc memory										
problem	an instruction with 7 or more prefixes can result in a spurious code fetch that may signal a #pf (page fault) or read uc (un-cacheable) memory.										
implication	a spurious uc memory access may result in unexpected and undesired side effect(s). the os may mishandle a spurious #pf due to there being no reason for the #pf										
workaround	avoid using 7 or more prefixes on an instruction. if limiting the number of prefixes is not feasible then marking mmio (memory mapped i/o) as xd (execute disable) in the page tables will prevent speculative reads from uc mmio.										
											
title	machine check exception mscod is incorrect for poisoned case intel® xeon phi™ processor x200 product family										
problem	when poisoned data is received at the edc, mscod should be logged as a data error (encoding = 0x2). instead, the encoding is set for an uncorrectable error (0x40). the effected machine check bank registers are ia32_mc7_status through ia32_mc14_status.										
implication	error reporting for poisoned data is incorrectly reported as an uncorrected error and not a data error. the error flow will be incorrect for poisoned data.										
workaround	none identified.										
											
title	poc_reset_straps csr does not report correct values										
problem	the poc_reset_straps csr (bus: 1; device 30; function 1; offset: a0h) does not correctly report the strap settings.										
implication	the register cannot be used to check the strap settings.										
workaround	a bios workaround has been identified. contact intel representative for more information.										
											
title	invalid vex instructions may not signal a #gp										
problem	under certain conditions, invalid vex instructions with prefixes may not signal a #gp. implication processor may not operate as expected with invalid vex instructions.										
implication											
workaround	none identified.										
											
title	performance monitoring ovfuncore capability is not functional										
problem	due to this erratum, ia32_perf_global_status.ovfuncore (msr 38eh, bit[61]) is always 0 and writing 1 to ia32_perf_global_ovf_ctrl.clrovfuncore (msr 390h, bit[61]) signals #gp.										
implication	software attempting to use ovfuncore capability may not function as expected.										
workaround	none identified.										
											
title	peci pcs (package configuration space) read for max thread id is incorrect										
problem	the peci command rdpkgconfig (index 0) with data max thread id always returns a value of 0x12f regardless of the number of tiles enabled.										
implication	this peci command does not report an accurate max thread id.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	bist results always indicate bist failure										
problem	bist results in bist_results_cfg_2 (bus 0, device 8, function1, offset 0xb8, bits [5:0]) returns 0 regardless of actual bist status.										
implication	bist results in bist_results_cfg_2 are incorrect.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	incorrect linear-address translation may be used for instruction fetch intel® xeon phi™ processor x200 product family										
problem	under complex micro-architectural conditions when mt is active, operations which should invalidate instruction tlb entries may fail to do so. this may lead a later instruction fetch using a stale linear address translation.										
implication	when this erratum occurs, the processor may use incorrect translations, this may result in unexpected faults or other unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	accesses between tohm and 2^45 - 1 may lead to unpredictable system behavior										
problem	a cpu access to addresses at or above tohm (top of high memory) as configured in the tohm csr (bus: 0; device: 5; function: 0; offset: d8h) and below 2^45 may lead to unpredictable system behavior when the l1 data prefetcher is enabled.										
implication	unpredictable system behavior may occur.										
workaround	this address range inclusively between tohm and 2^45 - 1 should be marked as not present in page or ept tables and not used. alternatively, msr_misc_feature_control.l1_data_prefetch_disable (msr 01a4h, bit 0)										
											
title	system may hang when loading a second microcode update										
problem	system may hang during warm reset with a pcu_mc_status.mccod = 0x0402 and pcu_mc_status. msec_fw = 0x9c or 0x9e.										
implication	when this erratum occurs, the system may hang during a warm reset.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	programmatic and peci smbus access may not work as intended										
problem	when bios locks access to smbcntl_0 (bus 1; device 30; function 0; offset 108h) and smbcntl_1 (bus 1; device 30; function; offset 108h), programmatic access outside smm and peci access may not be able to select their intended smbus devices.										
implication	smbus transactions will reference the previously addressed devices.										
workaround	it is possible for bios to contain a partial mitigation for this erratum that enables peci access to change the unlocked portions of smbcntl_0 and smbcntl_1.										
											
title	system may hang during warm reset										
problem	system may hang during warm reset with a pcu_mc_status.mccod = 0x0402 and pcu_mc_status. msec_fw = 0x9c or 0x9e.										
implication	when this erratum occurs, the system may hang during a warm reset.										
workaround	it is possible for the bios to contain a workaround for this erratum.										
											
title	operating with ddr4-2400 memory may cause unpredictable system behavior intel® xeon phi™ processor x200 product family										
problem	operating the processor with ddr4 memory configured to operate at 2400 mt/s may cause unpredictable system behavior.										
implication	when the erratum occurs, the system will exhibit unpredictable system behavior.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	enabling ddr opportunistic self refresh may lead to memory errors										
problem	correctable and uncorrectable memory errors may occur when ddr opportunistic self- refresh is enabled.										
implication	the system may experience a higher rate of memory errors when ddr opportunistic self-refresh is enabled, potentially leading to a system crash.										
workaround	it is possible for bios to contain code changes to work around this erratum.										
											
title	certain memory controller uncorrectable errors do not signal a machine check										
problem	uncorrectable errors logged into the ia32_mci_status registers for bank 7 to bank 16 do not signal a machine check exception if the error cause was ca parity, data parity, or byte en parity (mscod value of 0001h, 0002h, or 0004h, respectively).										
implication	the system may continue execution after encountering an uncorrectable error instead of responding to a machine check exception. uncorrectable errors may lead to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum. implementing this workaround will cause signaling of ierr# instead of mcerr# when this uncorrectable error occurs. there may be an increased delay in error reporting.										
											
title	pcc is not set for certain memory controller uncorrectable errors when poison is enabled										
problem	pcc field (bit[57]) of ia32_mci_status registers for bank 7 to bank 16 is not set as expected for a ca parity error (mscod value of 0001h) when poison is enabled.										
implication	the machine check handlers incorrectly log the error as an uncorrectable error with no action, instead of logging an uncorrectable error and signaling a machine check exception.										
workaround	it is possible for the bios to contain a workaround for this erratum. implementing this workaround will cause signaling of ierr# when this uncorrectable error type occurs, in addition to the machine check exception. there may be an increased delay in error reporting.										
											
title	memory controller machine check errors may be incorrectly logged intel® xeon phi™ processor x200 product family										
problem	uc (uncorrectable) errors logged into the ia32_mci_status registers for bank 7 to bank 16 will not indicate pcc=1 (processor context corrupt, bit 57) and over=1 (bit 62) if the error is overwriting a previous ucna (uncorrected no action required) error.										
implication	the system may continue execution after encountering an uncorrectable error instead of responding to a machine check exception. uncorrectable errors may lead to unpredictable system behavior.										
workaround	it is possible for the bios to contain a workaround for this erratum. implementing this workaround will cause signaling of ierr# instead of mcerr# when this uncorrectable error occurs. there may be an increased delay in error reporting.										
											
title	complex set of conditions may result in unpredictable system behavior										
problem	a complex set of micro-architectural conditions may result in unpredictable system behavior.										
implication	when this erratum occurs, the system may exhibit unpredictable system behavior.										
workaround	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.										
											
title	processor may hang and machine check										
problem	under complex micro-architectural conditions, the processor may hang, resulting in an internal timer error machine check (ia32_mci_status.mcacod=400h; bits [15:0]).										
implication	when this erratum occurs, the system may hang.										
workaround	it is possible for bios to contain a workaround for this erratum.										
											
title	unpredictable system behavior may occur with mcdram scrubbing enabled										
problem	when the mcdram controller is configured in a cache or hybrid mode and error scrubbing is enabled, a complex set of micro-architectural conditions may lead to unpredictable system behavior.										
implication	when this erratum occurs, unpredictable system behavior may occur.										
workaround	bios code change has been identified and may be implemented as a workaround for this erratum.										