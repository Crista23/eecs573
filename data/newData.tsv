title:	reported memory type may not be used to access the vmcs and referenced data structures				
problem:	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.				
implication:	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.				
workaround:	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.				
					
title:	instruction fetch may cause machine check if page size and memory type was changed without invalidation				
problem:	this erratum may cause a machine-check error (ia32_mci_status.mcacod=0150h) on the fetch of an instruction that crosses a 4- kbyte address boundary. it applies only if (1) the 4-kbyte linear region on which the instruction begins is originally translated using a 4-kbyte page with the wb memory type; (2) the paging structures are later modified so that linear region is translated using a large page (2-mbyte, 4-mbyte, or 1-gbyte) with the uc memory type; and (3) the instruction fetch occurs after the paging-structure modification but before software invalidates any tlb entries for the linear region.				
implication:	due to this erratum an unexpected machine check with error code 0150h may occur, possibly resulting in a shutdown. intel has not observed this erratum with any commercially available software.				
workaround:	software should not write to a paging-structure entry in a way that would change, for any linear address, both the page size and the memory type. it can instead use the following algorithm: first clear the p flag in the relevant paging-structure entry (e.g., pde); then invalidate any translations for the affected linear addresses; and then modify the relevant paging-structure entry to set the p flag and establish the new page size and memory type.				
					
title:	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception				
problem:	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device- not-available) exception.				
implication:	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.				
workaround:	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.				
					
title:	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set				
problem:	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.				
implication:	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.				
workaround:	none identified				
					
title:	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1				
problem:	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.				
implication:	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.				
workaround:	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr				
					
title:	smram state-save area above the 4gb boundary may cause unpredictable system behavior				
problem:	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.				
implication:	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.				
workaround:	ensure that the smram state-save area is located entirely below the 4gb address boundary.				
					
title:	x87 fpu exception (#mf) may be signaled earlier than expected				
problem:	x87 instructions that trigger #mf normally service interrupts before the #mf. due to this erratum, if an instruction that triggers #mf is executing when an enhanced intel speedstep® technology transitions, an intel® turbo boost technology transitions, or a thermal monitor events occurs, the #mf may be taken before pending interrupts are serviced.				
implication:	software may observe #mf being signaled before pending interrupts are serviced.				
workaround:	none identified.				
					
title:	incorrect from_ip value for an rtm abort in btm or bts may be observed				
problem:	during rtm (restricted transactional memory) operation when branch tracing is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.				
implication:	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.				
workaround:	none identified.				
					
title:	dr6 register may contain an incorrect value when a mov to ss or pop ss instruction is followed by an xbegin instruction				
problem:	if xbegin is executed immediately after an execution of mov to ss or pop ss, a transactional abort occurs and the logical processor restarts execution from the fallback instruction address. if execution of the instruction at that address causes a debug exception, bits [3:0] of the dr6 register may contain an incorrect value.				
implication:	when the instruction at the fallback instruction address causes a debug exception, dr6 may report a breakpoint that was not triggered by that instruction, or it may fail to report a breakpoint that was triggered by the instruction.				
workaround:	avoid following a mov ss or pop ss instruction immediately with an xbegin instruction.				
					
title:	opcode bytes f3 0f bc may execute as tzcnt even when tzcnt not enumerated by cpuid				
problem:	if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 then opcode bytes f3 0f bc should be interpreted as tzcnt otherwise they will be interpreted as rep bsf. due to this erratum, opcode bytes f3 0f bc may execute as tzcnt even if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 0.				
implication:	software that expects rep prefix before a bsf instruction to be ignored may not operate correctly since there are cases in which bsf and tzcnt differ with regard to the flags that are set and how the destination operand is established.				
workaround:	software should use the opcode bytes f3 0f bc only if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 and only if the functionality of tzcnt (and not bsf) is desired.				
					
title:	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code				
problem:	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.				
implication:	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.				
workaround:	none identified.				
					
title:	the smsw instruction may execute within an enclave				
problem:	the smsw instruction is illegal within an sgx (software guard extensions) enclave, and an attempt to execute it within an enclave should result in a #ud (invalid-opcode exception). due to this erratum, the instruction executes normally within an enclave and does not cause a #ud.				
implication:	the smsw instruction provides access to cr0 bits 15:0 and will provide that information inside an enclave. these bits include ne, et, ts, em, mp and pe.				
workaround:	none identified. if smsw execution inside an enclave is unacceptable, system software should not enable sgx.				
					
title:	wrmsr to ia32_bios_updt_trig concurrent with an smx senter/sexit may result in a system hang				
problem:	performing wrmsr to ia32_bios_updt_trig (msr 79h) on a logical processor while another logical processor is executing an smx (safer mode extensions) senter/sexit operation (getsec[senter] or getsec[sexit] instruction) may cause the processor to hang.				
implication:	when this erratum occurs, the system will hang. intel has not observed this erratum with any commercially available system.				
workaround:	none identified.				
					
title:	intel® pt tip.pgd may not have target ip payload				
problem:	when intel pt (intel processor trace) is enabled and a direct unconditional branch clears ia32_rtit_status.filteren (msr 571h, bit 0), due to this erratum, the resulting tip.pgd (target ip packet, packet generation disable) may not have an ip payload with the target ip.				
implication:	it may not be possible to tell which instruction in the flow caused the tip.pgd using only the information in trace packets when this erratum occurs.				
workaround:	the intel pt trace decoder can compare direct unconditional branch targets in the source with the filteren address range(s) to determine which branch cleared filteren.				
					
title:	operand-size override prefix causes 64-bit operand form of movbe instruction to cause a #ud				
problem:	execution of a 64 bit operand movbe instruction with an operand-size override instruction prefix (66h) may incorrectly cause an invalid-opcode exception (#ud).				
implication:	a movbe instruction with both rex.w=1 and a 66h prefix will unexpectedly cause an #ud (invalid-opcode exception). intel has not observed this erratum with any commercially available software.				
workaround:	do not use a 66h instruction prefix with a 64-bit operand movbe instruction.				
					
title:	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception				
problem:	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid-opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not-available) exception will be raised instead of #ud exception.				
implication:	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.				
workaround:	software should not use fxsave or fxrstor with the vex prefix.				
					
title:	wrmsr may not clear the sticky count overflow bit in the ia32_mci_status msrs’ corrected error count field				
problem:	the sticky count overflow bit is the most significant bit (bit 52) of the corrected error count field (bits[52:38]) in ia32_mci_status msrs. once set, the sticky count overflow bit may not be cleared by a wrmsr instruction. when this occurs, that bit can only be cleared by power-on reset.				
implication:	software that uses the corrected error count field and expects to be able to clear the sticky count overflow bit may misinterpret the number of corrected errors when the sticky count overflow bit is set. this erratum does not affect threshold-based cmci (corrected machine check error interrupt) signaling.				
workaround:	none identified.				
					
title:	pebs eventing ip field may be incorrect after not-taken branch				
problem:	when a pebs (precise-event-based-sampling) record is logged immediately after a not-taken conditional branch (jcc instruction), the eventing ip field should contain the address of the first byte of the jcc instruction. due to this erratum, it may instead contain the address of the instruction preceding the jcc instruction.				
implication:	performance monitoring software using pebs may incorrectly attribute pebs events that occur on a jcc to the preceding instruction.				
workaround:	none identified.				
					
title:	debug exceptions may be lost or misreported following wrmsr to ia32_bios_updt_trig				
problem:	if the wrmsr instruction writes to the ia32_bios_updt_trig msr (79h) immediately after an execution of mov ss or pop ss that generated a debug exception, the processor may fail to deliver the debug exception or, if it does, the dr6 register contents may not correctly reflect the causes of the debug exception.				
implication:	debugging software may fail to operate properly if a debug exception is lost or does not report complete information.				
workaround:	software should avoid using wrmsr instruction immediately after executing mov ss or pop ss				
					
title:	complex interactions with internal graphics may impact processor responsiveness				
problem:	under complex conditions associated with the use of internal graphics, the processor may exceed the max_lat csr values (pci configuration space, offset 03fh, bits[7:0]).				
implication:	when this erratum occurs, the processor responsiveness is affected. intel has not observed this erratum with any commercially available software.				
workaround:	none identified.				
					
title:	intel® processor trace psb+ packets may contain unexpected packets				
problem:	some intel processor trace packets should be issued only between tip.pge (target ip packet.packet generation enable) and tip.pgd (target ip packet.packet generation disable) packets. due to this erratum, when a tip.pge packet is generated it may be preceded by a psb+ (packet stream boundary) that incorrectly includes fup (flow update packet) and mode.exec packets.				
implication:	due to this erratum, fup and mode.exec may be generated unexpectedly.				
workaround:	decoders should ignore fup and mode.exec packets that are not between tip.pge and tip.pgd packets.				
					
title:	placing an intel® pt topa in non-wb memory or writing it within a transactional region may lead to system instability				
problem:	if an intel pt (intel® processor trace) topa (table of physical addresses) is not placed in wb (writeback) memory or is written by software executing within an intel® tsx (intel® transactional synchronization extension) transactional region, the system may become unstable.				
implication:	unusual treatment of the topa may lead to system instability.				
workaround:	none identified. intel pt topa should reside in wb memory and should not be written within a transactional region.				
					
title:	vm entry that clears traceen may generate a fup				
problem:	if vm entry clears intel® pt (intel processor trace) ia32_rtit_ctl.traceen (msr 570h, bit 0) while packeten is 1 then a fup (flow update packet) will precede the tip.pgd (target ip packet, packet generation disable). vm entry can clear traceen if the vm-entry msr-load area includes an entry for the ia32_rtit_ctl msr.				
implication:	when this erratum occurs, an unexpected fup may be generated that creates the appearance of an asynchronous event taking place immediately before or during the vm entry.				
workaround:	the intel pt trace decoder may opt to ignore any fup whose ip matches that of a vm entry instruction.				
					
title:	performance monitor event for outstanding offcore requests and snoop requests may be incorrect				
problem:	the performance monitor event offcore_requests_outstanding (event 60h, any umask value) should count the number of offcore outstanding transactions each cycle. due to this erratum, the counts may be higher or lower than expected.				
implication:	the performance monitor event offcore_requests_outstanding may reflect an incorrect count.				
workaround:	none identified.				
					
title:	enclu[egetkey] ignores keyrequest.miscmask				
problem:	the intel® sgx (software guard extensions) enclu[egetkey] instruction ignores the miscmask field in keyrequest structure when computing a provisioning key, a provisioning seal key, or a seal key.				
implication:	enclu[egetkey] will return the same key in response to two requests that differ only in the value of keyrequest.miscmask. intel has not observed this erratum with any commercially available software.				
workaround:	when executing the enclu[egetkey] instruction, software should ensure the bits set in keyrequest.miscmask are a subset of the bits set in the current secs’s miscselect field.				
					
title:	popcnt instruction may take longer to execute than expected				
problem:	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.				
implication:	software using the popcnt instruction may experience lower performance than expected.				
workaround:	none identified				
					
title:	enclu[ereport] may cause a #gp when targetinfo.miscselect is non- zero				
problem:	the intel® sgx (software guard extensions) enclu[ereport] instruction may cause a #gp (general protection fault) if any bit is set in targetinfo structure’s miscselect field.				
implication:	this erratum may cause unexpected general-protection exceptions inside enclaves.				
workaround:	when executing the enclu[ereport] instruction, software should ensure the bits set in targetinfo.miscselect are a subset of the bits set in the current secs’s miscselect field.				
					
title:	a vmx transition attempting to load a non-existent msr may result in a shutdown				
problem:	a vmx transition may result in a shutdown (without generating a machine-check event) if a non-existent msr is included in the associated msr-load area. when such a shutdown occurs, a machine check error will be logged with ia32_mci_status.mcacod (bits [15:0]) of 406h, but the processor does not issue the special shutdown cycle. a hardware reset must be used to restart the processor.				
implication:	due to this erratum, the hypervisor may experience an unexpected shutdown.				
workaround:	software should not configure vmx transitions to load non-existent msrs.				
					
title:	transitions out of 64-bit mode may lead to an incorrect fdp and fip				
problem:	a transition from 64-bit mode to compatibility or legacy modes may result in cause a subsequent x87 fpu state save to zeroing bits [63:32] of the fdp (x87 fpu data pointer offset) and the fip (x87 fpu instruction pointer offset).				
implication:	leaving 64-bit mode may result in incorrect fdp and fip values when x87 fpu state is saved.				
workaround:	none identified. 64-bit software should save x87 fpu state before leaving 64-bit mode if it needs to access the fdp and/or fip values.				
					
title:	intel® pt fup may be dropped after ovf				
problem:	some intel pt (intel processor trace) ovf (overflow) packets may not be followed by a fup (flow update packet) or tip.pge (target ip packet, packet generation enable).				
implication:	when this erratum occurs, an unexpected packet sequence is generated.				
workaround:	when it encounters an ovf without a following fup or tip.pge, the intel pt trace decoder should scan for the next tip, tip.pge, or psb+ to resume operation.				
					
title:	encls[ecreate] causes #gp if enclave base address is not canonical				
problem:	the encls[ecreate] instruction uses an secs (sgx enclave control structure) referenced by the srcpage pointer in the pageinfo structure, which is referenced by the rbx register. due to this erratum, the instruction causes a #gp (general- protection fault) if the secs attributes indicate that the enclave should operate in 64- bit mode and the enclave base linear address in the secs is not canonical.				
implication:	system software will incur a general-protection fault if it mistakenly programs the secs with a non-canonical address. intel has not observed this erratum with any commercially available software.				
workaround:	system software should always specify a canonical address as the base address of the 64-bit mode enclave.				
					
title:	processor graphics iommu unit may report spurious faults				
problem:	the iommu unit for processor graphics pre-fetches context (or extended-context) entries to improve performance. due to the erratum, the iommu unit may report spurious dma remapping faults if prefetching encounters a context (or extended- context) entry which is not marked present.				
implication:	software may observe spurious dma remapping faults when the present bit for the context (or extended-context) entry corresponding to the processor graphics device (bus: 0; device: 2; function: 0) is cleared. these faults may be reported when the processor graphics device is quiescent.				
workaround:	none identified. instead of marking a context not present, software should mark the context (or extended-context) entry present while using the page table to indicate all the memory pages referenced by the context entry is not present.				
					
title:	processor ddr vref signals may briefly exceed jedec spec when entering s3 state				
problem:	voltage glitch of up to 200mv on the vref signal lasting for about 1ms may be observed when entering system s3 state. this violates the jedec ddr specifications.				
implication:	intel has not observed this erratum to impact the operation of any commercially available system.				
workaround:	none identified.				
					
title:	dr6.b0-b3 may not report all breakpoints matched when a mov/pop ss is followed by a store or an mmx instruction				
problem:	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction boundary following the next instruction is reached. after the debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.				
implication:	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (i.e., following them only with an instruction that writes (e/r)sp).				
workaround:	none identified.				
					
title:	encls[einit] instruction may unexpectedly #gp				
problem:	when using intel® sgx (software guard extensions), the encls[einit] instruction will incorrectly cause a #gp (general protection fault) if the miscselect field of the sigstruct structure is not zero.				
implication:	this erratum may cause an unexpected #gp, but only if software has set bits in the miscselect field in sigstruct structure that do not correspond to extended features that can be written to the misc region of the ssa (state save area). intel has not observed this erratum with any commercially available software.				
workaround:	when executing the encls[einit] instruction, software should only set bits in the miscselect field in the sigstruct structure that are enumerated as 1 by cpuid.(eax=12h,ecx=0):ebx (the bit vector of extended features that can be written to the misc region of the ssa).				
					
title:	intel® pt ovf packet may be lost if immediately preceding a tracestop				
problem:	if an intel pt (intel® processor trace) internal buffer overflow occurs immediately before software executes a taken branch or event that enters an intel pt tracestop region, the ovf (overflow) packet may be lost.				
implication:	the trace decoder will not see the ovf packet, nor any subsequent packets (e.g., tracestop) that were lost due to overflow.				
workaround:	none identified.				
					
title:	wrmsr to ia32_bios_updt_trig may be counted as multiple instructions				
problem:	when software loads a microcode update by writing to msr ia32_bios_updt_trig (79h) on multiple logical processors in parallel, a logical processor may, due to this erratum, count the wrmsr instruction as multiple instruction-retired events.				
implication:	performance monitoring with the instruction-retired event may over count by up to four extra events per instance of wrmsr which targets the ia32_bios_updt_trig register .				
workaround:	none identified.				
					
title:	branch instructions may initialize mpx bound registers incorrectly				
problem:	depending on the current intel® mpx (memory protection extensions) configuration, execution of certain branch instructions (near call, near ret, near jmp, and jcc instructions) without a bnd prefix (f2h) initialize the mpx bound registers. due to this erratum, execution of such a branch instruction on a user-mode page may not use the mpx configuration register appropriate to the current privilege level (bndcfgu for cpl 3 or bndcfgs otherwise) for determining whether to initialize the bound registers; it may thus initialize the bound registers when it should not, or fail to initialize them when it should.				
implication:	after a branch instruction on a user-mode page has executed, a #br (bound-range) exception may occur when it should not have or a #br may not occur when one should have.				
workaround:	if supervisor software is not expected to execute instructions on user-mode pages, software can avoid this erratum by setting cr4.smep[bit 20] to enable supervisor- mode execution prevention (smep). if smep is not available or if supervisor software is expected to execute instructions on user-mode pages, no workaround is identified.				
					
title:	writing a non-canonical value to an lbr msr does not signal a #gp when intel® pt is enabled				
problem:	if intel pt (intel processor trace) is enabled, wrmsr will not cause a general- protection exception (#gp) on an attempt to write a non-canonical value to any of the following msrs:  • msr_lastbranch_{0-31}_from_ip(680h–69fh) • msr_lastbranch__{0-31}_to_ip(6c0h–6dfh) • msr_lastbranch_from_ip(1dbh) • msr_lastbranch_to_ip(1dch)  • msr_lastint_from_ip(1ddh)  • msr_lastint_to_ip(1deh)insteadthesamebehaviorwilloccurasifacanonical value had been written. specifically, the wrmsr will be dropped and the msr value will not be changed.				
implication:	due to this erratum, an expected #gp may not be signaled.				
workaround:	none identified.				
					
title:	processor may run intel® avx code much slower than expected				
problem:	after a c6 state exit, the execution rate of avx instructions may be reduced.				
implication:	applications using avx instructions may run slower than expected.				
workaround:	it is possible for the bios to contain a workaround				
					
title:	intel® pt buffer overflow may result in incorrect packets				
problem:	under complex micro-architectural conditions, an intel pt (processor trace) ovf (overflow) packet may be issued after the first byte of a multi-byte cyc (cycle count) packet, instead of any remaining bytes of the cyc.				
implication:	when this erratum occurs, the splicing of the cyc and ovf packets may prevent the intel pt decoder from recognizing the overflow. the intel pt decoder may then encounter subsequent packets that are not consistent with expected behavior.				
workaround:	none identified. the decoder may be able to recognize that this erratum has occurred when a two-byte cyc packet is followed by a single byte cyc, where the latter 2 bytes are 0xf302, and where the cyc packets are followed by a fup (flow update packet) and a psb+ (packet stream boundary+). it should then treat the two cyc packets as indicating an overflow.				
					
title:	last level cache performance monitoring events may be inaccurate				
problem:	the performance monitoring events longest_lat_cache.reference (event 2eh; umask 4fh) and longest_lat_cache.miss (event 2eh; umask 41h) count requests that reference or miss in the last level cache. however, due to this erratum, the count may be incorrect.				
implication:	longest_lat_cache events may be incorrect.				
workaround:	none identified. software may use the following offcore_requests model-specific sub events that provide related performance monitoring data:  demand_data_rd, demand_code_rd, demand_rfo, all_data_rd, l3_miss_demand_data_rd, all_requests.				
					
title:	#gp occurs rather than #db on code page split inside an intel® sgx enclave				
problem:	when executing within an intel® sgx (software guard extensions) enclave, a #gp (general-protection exception) may be delivered instead of a #db (debug exception) when an instruction breakpoint is detected. this occurs when the instruction to be executed spans two pages, the second of which has an entry in the epcm (enclave page cache map) that is not valid.				
implication:	debugging software may not be invoked when an instruction breakpoint is detected.				
workaround:	software should ensure that all pages containing enclave instructions have valid epcm entries.				
					
title:	execution of vaesenclast instruction may produce a #nm exception instead of a #ud exception				
problem:	execution of vaesenclast with vex.l= 1 should signal a #ud (invalid opcode) exception, however, due to the erratum, a #nm (device not available) exception may be signaled.				
implication:	as a result of this erratum, an operating system may restore avx and other state unnecessarily.				
workaround:	none identified.				
					
title:	intel® sgx enclave accesses to the apic-access page may cause apic- access vm exits				
problem:	in vmx non-root operation, intel sgx (software guard extensions) enclave accesses to the apic-access page may cause apic-access vm exits instead of page faults.				
implication:	a vmm (virtual-machine monitor) may receive a vm exit due to an access that should have caused a page fault, which would be handled by the guest os (operating system).				
workaround:	a vmm avoids this erratum if it does not map any part of the epc (enclave page cache) to the guest’s apic-access address; an operating system avoids this erratum if it does not attempt indirect enclave accesses to the apic.				
					
title:	cr3 filtering does not compare bits [11:5] of cr3 and ia32_rtit_cr3_match in pae paging mode				
problem:	in pae paging mode, the cr3[11:5] are used to locate the page-directory-pointer table. due to this erratum, those bits of cr3 are not compared to ia32_rtit_cr3_match (msr 572h) when ia32_rtit_ctl.cr3filter (msr 570h, bit 7) is set.				
implication:	if multiple page-directory-pointer tables are co-located within a 4kb region, cr3 filtering will not be able to distinguish between them so additional processes may be traced.				
workaround:	none identified.				
					
title:	x87 fdp value may be saved incorrectly				
problem:	execution of the fsave, fnsave, fstenv, or fnstenv instructions in real-address mode or virtual-8086 mode may save an incorrect value for the x87 fdp (fpu data pointer). this erratum does not apply if the last non-control x87 instruction had an unmasked exception.				
implication:	software operating in real-address mode or virtual-8086 mode that depends on the fdp value for non-control x87 instructions without unmasked exceptions may not operate properly.				
workaround:	none identified. software should use the fdp value saved by the listed instructions only when the most recent non-control x87 instruction incurred an unmasked exception.				
					
title:	peci frequency limited to 1 mhz				
problem:	the peci (platform environmental control interface) 3.1 specification’s operating frequency range is 0.2 mhz to 2 mhz. due to this erratum, peci may be unreliable when operated above 1 mhz.				
implication:	platforms attempting to run peci above 1 mhz may not behave as expected.				
workaround:	none identified. platforms should limit peci operating frequency to 1 mhz.				
					
title:	processor graphics iommu unit may not mask dma remapping faults				
problem:	intel® virtualization technology for directed i/o specification specifies setting the fpd (fault processing disable) field in the context (or extended-context) entry of iommu to mask recording of qualified dma remapping faults for dma requests processed through that context entry. due to this erratum, the iommu unit for processor graphics device may record dma remapping faults from processor graphics device (bus: 0; device: 2; function: 0) even when the fpd field is set to 1.				
implication:	software may continue to observe dma remapping faults recorded in the iommu fault recording register even after setting the fpd field.				
workaround:	none identified. software may mask the fault reporting event by setting the im (interrupt mask) field in the iommu fault event control register (offset 038h in gfxvtbar).				
					
title:	intel® pt cycthresh value of 13 is not supported				
problem:	intel pt (intel® processor trace) cyc (cycle count) threshold is configured through cycthresh field in bits [22:19] of ia32_rtit_ctl msr (570h). a value of 13 is advertised as supported by cpuid (leaf 14h, sub-lead 1h). due to this erratum, if cycthresh is set to 13 then the cyc threshold will be 0 cycles instead of 4096 (213- 1) cycles.				
implication:	cyc packets may be issued in higher rate than expected if threshold value of 13 is used.				
workaround:	none identified. software should not use value of 13 for cyc threshold.				
					
title:	enabling vmx-preemption timer blocks hdc operation				
problem:	hdc (hardware duty cycling) will not put the physical package into the forced idle state while any logical processor is in vmx non-root operation and the “activate vmx- preemption timer” vm-execution control is 1.				
implication:	hdc will not provide the desired power reduction when the vmx-preemption timer is active in vmx non-root operation.				
workaround:	none identified.				
					
title:	integrated audio codec may not be detected				
problem:	integrated audio codec may lose power when lpsp (low-power single pipe) mode is enabled for an edp* (embedded displayport) or dp/hdmi ports. platforms with intel® sst (intel® smart sound technology) enabled are not affected.				
implication:	the audio bus driver may attempt to do enumeration of codecs when edp or dp/hdmi port enters lpsp mode, due to this erratum, the integrated audio codec will not be detected and audio maybe be lost.				
workaround:	intel® graphics driver 15.40.11.4312 or later will prevent the integrated audio codec from losing power when lpsp mode is enabled.				
					
title:	display flickering may be observed with specific edp panels				
problem:	the processor may incorrectly configure transmitter buffer characteristics if the associated edp panel requests vesa equalization preset 3, 5, 6, or 8.				
implication:	display flickering or display loss maybe observed.				
workaround:	intel® graphics driver version 15.40.12.4326 or later contains a workaround for this erratum.				
					
title:	incorrect branch predicted bit in bts/btm branch records				
problem:	bts (branch trace store) and btm (branch trace message) send branch records to the debug store management area and system bus respectively. the branch predicted bit (bit 4 of eighth byte in bts/btm records) should report whether the most recent branch was predicted correctly. due to this erratum, the branch predicted bit may be incorrect.				
implication:	bts and btm cannot be used to determine the accuracy of branch prediction.				
workaround:	none identified.				
					
title:	machine_clears.memory_ordering performance monitoring event may undercount				
problem:	the performance monitoring event machine_clears.memory_ordering (event c3h; umask 02h) counts the number of machine clears caused by memory ordering conflicts. however due to this erratum, this event may undercount for vgather*/vpgather* instructions of four or more elements.				
implication:	machine_clears.memory_ordering performance monitoring event may undercount.				
workaround:	none identified.				
					
title:	ctr_frz may not freeze some counters				
problem:	ia32_perf_global_status.ctr_frz (msr 38eh, bit 59) is set when either (1) ia32_debugctl.freeze_perfmon_on_pmi (msr 1d9h, bit 12) is set and a pmi is triggered, or (2) software sets bit 59 of ia32_perf_global_status_set (msr 391h). when set, ctr_frz should stop all core performance monitoring counters from counting. however, due to this erratum, ia32_pmc4-7 (msr c5-c8h) may not stop counting. ia32_pmc4-7 are only available when a processor core is not shared by two logical processors.				
implication:	general performance monitoring counters 4-7 may not freeze when ia32_perf_global_status.ctr_frz is set.				
workaround:	none identified.				
					
title:	instructions and branches retired performance monitoring events may overcount				
problem:	the performance monitoring events inst_retired (event c0h; any umask value) and br_inst_retired (event c4h; any umask value) count instructions retired and branches retired, respectively. however, due to this erratum, these events may overcount in certain conditions when:  - executing vmaskmov* instructions with at least one masked vector element  - executing rep movs or rep stos with fast strings enabled (ia32_misc_enables msr (1a0h), bit 0 set)  - an mpx #br exception occurred on bndldx/bndstx instructions and the br_inst_retired (event c4h; umask is 00h or 04h) is used.				
implication:	inst_retired and br_inst_retired performance monitoring events may overcount.				
workaround:	none identified.				
					
title:	some offcore_response performance monitoring events may overcount				
problem:	the performance monitoring events offcore_response (events b7h and bbh) should count off-core responses matching the request-response configuration specified in msr_offcore_rsp_0 and msr_offcore_rsp_1 (1a6h and 1a7h, respectively) for core-originated requests. however, due to this erratum, dmnd_rfo (bit 1), dmnd_ifetch (bit 2) and other (bit 15) request types may overcount.				
implication:	some offcore_response events may overcount.				
workaround:	none identified. software may use the following model-specific events that provide related performance monitoring data: offcore_requests (all sub-events), l2_trans.l2_wb and l2_rqsts.pf_miss.				
					
title:	instructions fetch #gp after rsm during inter® pt may push incorrect rflags value on stack				
problem:	if intel pt (processor trace) is enabled, a #gp (general protection fault) caused by the instruction fetch immediately following execution of an rsm instruction may push an incorrect value for rflags onto the stack.				
implication:	software that relies on rflags value pushed on the stack under the conditions described may not work properly.				
workaround:	none identified.				
					
title:	access to sgx epc page in blocked state is not reported as an sgx- induced page fault				
problem:	if a page fault results from attempting to access a page in the sgx (intel® software guard extensions) epc (enclave page cache) that is in the blocked state, the processor does not set bit 15 of the error code and thus fails to indicate that the page fault was sgx-induced.				
implication:	due to this erratum, software may not recognize these page faults as being sgx- induced.				
workaround:	before using the eblock instruction to marking a page as blocked, software should use paging to mark the page not present.				
					
title:	mtf vm exit on xbegin instruction may save state incorrectly				
problem:	execution of an xbegin instruction while the monitor trap flag vm-execution control is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save as instruction pointer the address of the xbegin instruction instead of the fallback instruction address specified by the xbegin instruction. in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.				
implication:	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.				
workaround:	none identified				
					
title:	intel® turbo boost technology may be incorrectly reported as supported on intel® coretm i3 u/h/s, select intel® mobile pentium®, intel® mobile celeron®, intel® pentium® and intel® celeron® processors				
problem:	these processors may incorrectly report support for intel® turbo boost technology via cpuid.06h.eax bit 1.				
implication:	the cpuid instruction may report turbo boost technology as supported even though the processor does not permit operation above the base frequency.				
workaround:	none identified.				
					
title:	performance monitoring counters may undercount when using cpl filtering				
problem:	performance monitoring counters configured to count only os or only usr events by setting exactly one of bits 16 or 17 in ia32_perfevtselx msrs (186h-18dh) may not count for a brief period during the transition to a new cpl.				
implication:	a measurement of ring transitions (using the edge-detect bit 18 in ia32_perfevtselx) may undercount, such as cpl_cycles.ring0_trans (event 5ch, umask 01h). additionally, the sum of an os-only event and a usr-only event may not exactly equal an event counting both os and usr. intel has not observed any other software-visible impact				
workaround:	none identified.				
					
title:	executing a 256 bit avx instruction may cause unpredictable behavior				
problem:	under complex micro-architectural conditions, executing a 256 avx bit instruction may result in unpredictable system behavior.				
implication:	when this erratum occurs, the system may behave unpredictably.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	system may hang during display power cycles				
problem:	when the display is turned on after being shutoff to save power or when the display is exiting psr (panel self refresh) mode, the system may hang.				
implication:	when this erratum occurs the system may hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	certain non-canonical ia32_bndcfgs values will not cause vm-entry failures				
problem:	if the vm-entry controls load ia32_bndcfgs field (bit 16) is 1, vm-entry should fail when the value of the guest ia32_bndcfgs field in the vmcs is not canonical (that is, when bits 63:47 are not identical). due to this erratum, vm-entry does not fail if bits 63:48 are identical but differ from bit 47. in this case, vm-entry loads the ia32_bndcfgs msr with a value in which bits 63:48 are identical to the value of bit 47 in the vmcs field.				
implication:	if the value of the guest ia32_bndcfgs field in the vmcs is not canonical, vm-entry may load the ia32_bndcfgs msr with a value different from that of the vmcs field.				
workaround:	none identified.				
					
title:	pebs eventingip field may be incorrect under certain conditions				
problem:	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.				
implication:	when this erratum occurs, performance monitoring software may not attribute the pebs events to the correct instruction.				
workaround:	none identified.				
					
title:	hwp’s guaranteed_performance updated only on configurable tdp changes				
problem:	according to hwp (hardware p-states) specification, the guaranteed_performance field (bits[15:8]) in the ia32_hwp_capabilities msr (771h) should be updated as a result of changes in the configuration of tdp, rapl (running average power limit), and other platform tuning options that may have dynamic effects on the actual guaranteed performance support level. due to this erratum, the processor will update the guaranteed_performance field only as a result of configurable tdp dynamic changes.				
implication:	software may read a stale value of the guaranteed _performance field.				
workaround:	none identified.				
					
title:	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts				
problem:	after a fault due to a failed pebs (processor event based sampling) or bts (branch trace store) address translation, the rf (resume flag) may be incorrectly set in the eflags image that is saved.				
implication:	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.				
workaround:	software should always prevent faults on pebs or bts.				
					
title:	intel® pt topa pmi does not freeze performance monitoring counters				
problem:	due to this erratum, if ia32_debugctl.freeze_perfmon_on_pmi (msr 1d9h, bit 12) is set to 1 when intel pt (processor trace) triggers a topa (table of physical addresses) pmi (perfmon interrupt), performance monitoring counters are not frozen as expected.				
implication:	performance monitoring counters will continue to count for events that occur during pmi handler execution.				
workaround:	pmi handler software can programmatically stop performance monitoring counters upon entry.				
					
title:	hwp’s maximum_performance value is reset to 0xff				
problem:	according to hwp (hardware p-states) specification, the reset value of the maximum_performance field (bits [15:8]) in ia32_hwp_request msr (774h) should be set to the value of ia32_hwp_capabilities msr (771h) highest_performance field (bits[7:0]) after reset. due to this erratum, the reset value of maximum_performance is always set to 0xff.				
implication:	software may see an unexpected value in maximum performance field. hardware clipping will prevent invalid performance states.				
workaround:	none identified.				
					
title:	hwp’s guaranteed_performance and relevant status/interrupt may be updated more than once per second				
problem:	according to hwp (hardware p-states) specification, the guaranteed_performance field (bits[15:8]) in the ia32_hwp_capabilities msr (771h) and the guaranteed_performance_change (bit 0) bit in ia32_hwp_status msr (777h) should not be changed more than once per second nor should the thermal interrupt associated with the change to these fields be signaled more than once per second. due to this erratum, the processor may change these fields and generate the associated interrupt more than once per second				
implication:	hwp interrupt rate due to guaranteed_performance field change can be higher than specified				
workaround:	clearing the guaranteed_performance_change status bit no more than once per second will ensure that interrupts are not generated at too fast a rate				
					
title:	some memory performance monitoring events may produce incorrect results when filtering on either os or usr modes				
problem:	the memory at-retirement performance monitoring events (listed below) may produce incorrect results when a performance counter is configured in os-only or usr-only modes (bits 17 or 16 in ia32_perfevtselx msr). counters with both os and usr bits set are not affected by this erratum.  the list of affected memory at-retirement events is as follows: mem_inst_retired.stlb_miss_loads event d0h, umask 11h mem_inst_retired.stlb_miss_stores event d0h, umask 12h mem_inst_retired.lock_loads event d0h, umask 21h mem_inst_retired.split_loads event d0h, umask 41h mem_inst_retired.split_stores event d0h, umask 42h mem_load_retired.l2_hit event d1h, umask 02h mem_load_retired.l3_hit event d1h, umask 04h mem_load_retired.l4_hit event d1h, umask 80h mem_load_retired.l1_miss event d1h, umask 08h mem_load_retired.l2_miss event d1h, umask 10h mem_load_retired.l3_miss event d1h, umask 20h mem_load_retired.fb_hit event d1h, umask 40h				
implication:	the listed performance monitoring events may produce incorrect results including pebs records generated at an incorrect point				
workaround:	none identified				
					
title:	hwp may generate thermal interrupt while not enabled				
problem:	due to this erratum, the conditions for hwp (hardware p-states) to generate a thermal interrupt on a logical processor may generate thermal interrupts on both logical processors of that core.				
implication:	if two logical processors of a core have different configurations of hwp (e.g. only enabled on one), an unexpected thermal interrupt may occur on one logical processor due to the hwp settings of the other logical processor.				
workaround:	software should configure hwp consistently on all logical processors of a core.				
					
title:	camera device does not issue an msi when intx is enabled				
problem:	when both msi (message signaled interrupts) and legacy intx are enabled by the camera device, intx is asserted rather than issuing the msi, in violation of the pci local bus specification.				
implication:	due to this erratum, camera device interrupts can be lost leading to device failure.				
workaround:	the camera device must disable legacy intx by setting bit 10 of pcicmd (bus 0; device 5; function 0; offset 04h) before msi is enabled				
					
title:	an x87 store instruction which pends #pe may lead to unexpected behavior when ept a/d is enabled.				
problem:	an x87 store instruction which causes a #pe (precision exception) to be pended and updates an ept (extended page tables) a/d bit may lead to unexpected behavior.				
implication:	the vmm may experience unexpected x87 fault or a machine check exception with the value of 0x150 in ia32_mc0_status.mcacod (bits [15:0] in msr 401h)				
workaround:	it is possible for the bios to contain a workaround for this erratum				
					
title:	use of vmaskmov to store when using ept may fail				
problem:	use of vmaskmov instructions to store data that splits over two pages, when the instruction resides on the first page may cause a hang if ept (extended page tables) is in use, and the store to the second page requires setting the a/d bits in the ept entry.				
implication:	due to this erratum, the cpu may hang on the execution of vmaskmov				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	peci may not be functional after package c10 resume				
problem:	when resuming from package c10, peci may fail to function properly.				
implication:	when this erratum occurs, the peci does not respond to any command.				
workaround:	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.				
					
title:	attempts to retrain a pcie* link may be ignored				
problem:	a pcie link should retrain when retrain link (bit 5) in the link control register (bus 0; device 1; functions 0,1,2; offset 0xb0) is set. due to this erratum, if the link is in the l1 state, it may ignore the retrain request				
implication:	the pcie link may not behave as expected.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	pcie* expansion rom base address register may be incorrect				
problem:	after pcie 8.0 gt/s link equalization on a root port (bus 0; device 1; function 0, 1, 2) has completed, the expansion rom base address register (offset 38h) may be incorrect.				
implication:	software that uses this bar may behave unexpectedly. intel has not observed this erratum with any commercially available software.				
workaround:	none identified				
					
title:	pcie* port does not support dll link activity reporting				
problem:	the pcie base specification requires dll (data link layer) link activity reporting when 8 gt/s link speed is supported. due to this erratum, link activity reporting is not supported				
implication:	due to this erratum, pcie port does not support dll link activity reporting when 8 gt/s is supported.				
workaround:	none identified				
					
title:	bndldx and bndstx may not signal #gp on non-canonical bound directory access				
problem:	bndldx and bndstx instructions access the bound’s directory and table to load or store bounds. these accesses should signal #gp (general protection exception) when the address is not canonical (i.e. bits 48 to 63 are not the sign extension of bit 47). due to this erratum, #gp may not be generated by the processor when a non- canonical address is used by bndldx or bndstx for their bound directory memory access.				
implication:	intel has not observed this erratum with any commercially available software.				
workaround:	software should use canonical addresses for bound directory accesses.				
					
title:	ring_perf_limit_reasons may be incorrect				
problem:	under certain conditions, ring_perf_limit_reasons (msr 6b1h) may incorrectly assert the other status bit (bit 8) as well as the other log bit (bit 24).				
implication:	when this erratum occurs, software using this register will incorrectly report clipping because of the other reason.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	processor may exceed vcccore iccmax during multi-core turbo				
problem:	due to this erratum, the maximum ring frequency limit is incorrectly configured to be 100mhz higher than intended.				
implication:	vcccore iccmax may be temporarily exceeded when all the cores are executing at a turbo frequency.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	performance monitoring load latency events may be inaccurate for gather instructions				
problem:	the performance monitoring events mem_trans_retired.load_latency_* (event cdh; umask 01h; any latency) count load instructions whose latency exceed a predefined threshold, where the loads are randomly selected using the load latency facility (an extension of pebs). however due to this erratum, these events may count incorrectly for vgather*/vpgather* instructions.				
implication:	the load latency performance monitoring events may be inaccurate for gather instructions.				
workaround:	none identified				
					
title:	edram corrected error events may not be properly logged after a warm reset				
problem:	after a warm reset, an edram corrected error may not be logged correctly until the associated machine check register is initialized. this erratum may affect ia32_mc8_status or ia32_mc10_status.				
implication:	the edram corrected error information may be lost when this erratum occurs.				
workaround:	data from the affected machine check registers should be read and the registers initialized as soon as practical after a warm reset.				
					
title:	unpredictable system behavior may occur when system agent enhanced intel® speedstep® is enabled				
problem:	under complex system conditions, sa-gv (system agent enhanced intel® speedstep®) may result in unpredictable system behavior.				
implication:	when this erratum occurs, the system may behave unpredictably.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	processor may hang under complex scenarios				
problem:	under a complex micro-architectural conditions, the processor may hang with an internal timeout error (mcacod 0400h) logged into ia32_mci_status.				
implication:	this erratum may result in a processor hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	some bits in msr_misc_pwr_mgmt may be updated on writing illegal values to this msr				
problem:	attempts to write illegal values to msr_misc_pwr_mgmt (msr 0x1aa) result in #gp (general protection fault) and should not change the msr value. due to this erratum, some bits in the msr may be updated on writing an illegal value.				
implication:	certain fields may be updated with allowed values when writing illegal values to msr_misc_pwr_mgmt. such writes will always result in #gp as expected.				
workaround:	none identified. software should not attempt to write illegal values to this msr.				
					
title:	violations of intel® software guard extensions (intel® sgx) access-control requirements produce #gp instead of #pf				
problem:	intel® software guard extensions (intel® sgx) define new access-control requirements on memory accesses. a violation of any of these requirements causes a page fault (#pf) that sets bit 15 (sgx) in the page-fault error code. due to this erratum, these violations instead cause general-protection exceptions (#gp).				
implication:	software resuming from system sleep states s3 or s4 and relying on receiving a page fault from the above enclave accesses may not operate properly.				
workaround:	software can monitor #gp faults to detect that an enclave has been destroyed and needs to be rebuilt after resuming from s3 or s4				
					
title:	ia32_rtit_cr3_match msr bits[11:5] are treated as reserved				
problem:	due to this erratum, bits[11:5] in ia32_rtit_cr3_match (msr 572h) are reserved; an msr write that attempts to set that field to a non-zero value will result in a #gp fault.				
implication:	the inability to write the identified bit field does not affect the functioning of intel® pt (intel® processor trace) operation because, as described in erratum skl061, the bit field that is the subject of this erratum is not used during intel pt cr3 filtering.				
workaround:	ensure that bits 11:5 of the value written to ia32_rtit_cr3_match are zero, including cases where the selected page-directory-pointer-table base address has non-zero bits in this range.				
					
title:	apic timer interrupt may not be generated at the correct time in tsc- deadline mode				
problem:	after writing to the ia32_tsc_adjust msr (3bh), any subsequent write to the ia32_tsc_deadline msr (6e0h) may incorrectly process the desired deadline. when this erratum occurs, the resulting timer interrupt may be generated at the incorrect time.				
implication:	when the local apic (advanced programmable interrupt controller) timer is configured for tsc-deadline mode, a timer interrupt may be generated much earlier than expected or much later than expected. intel has not observed this erratum with most commercially available software.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	the intel pt cr3 filter is not re-evaluated on vm entry				
problem:	on a vmresume or vmlaunch with both traceen[0] and cr3filter[7] in ia32_rtit_ctl (msr 0570h) set to 1 both before the vm entry and after, the new value of cr3 is not compared with ia32_rtit_cr3_match (msr 0572h).				
implication:	the intel pt (processor trace) cr3 filtering mechanism may continue to generate packets despite a mismatching cr3 value, or may fail to generate packets despite a matching cr3, as a result of an incorrect value of ia32_rtit_status.contexten[1] (msr 0571h) that results from the failure to re-evaluate the cr3 match on vm entry.				
workaround:	none identified.				
					
title:	display slowness may be observed under certain display commands scenario				
problem:	back to back access to the vga register ports (i/o addresses 0x3c2, 0x3ce, 0x3cf) will experience higher than expected latency.				
implication:	due to this erratum, the processor may redraw the slowly when in vga mode.				
workaround:	none identified.				
					
title:	short loops which use ah/bh/ch/dh registers may cause unpredictable system behavior				
problem:	under complex micro-architectural conditions, short loops of less than 64 instructions that use ah, bh, ch or dh registers as well as their corresponding wider register (e.g. rax, eax or ax for ah) may cause unpredictable system behavior. this can only happen when both logical processors on the same physical processor are active.				
implication:	due to this erratum, the system may experience unpredictable system behavior.				
workaround:	it is possible for the bios to contain a workaround for this erratum				
					
title:	cpuid tlb associativity information is inaccurate				
problem:	cpuid leaf 2 (eax=02h) tlb information inaccurately reports that the shared 2nd- level tlb is 6-way set associative (value c3h), although it is 12-way set associative. other information reported by cpuid leaf 2 is accurate.				
implication:	software that uses cpuid shared 2nd-level tlb associativity information for value c3h may operate incorrectly. intel has not observed this erratum to impact the operation of any commercially available software				
workaround:	none identified. software should ignore the shared 2nd-level tlb associativity information reported by cpuid for the affected processors.				
					
title:	processor graphics may render incorrectly or may hang following warm reset with package c8 disabled				
problem:	processor graphics may not properly restore internal configuration after warm reset when package c8 is disabled.				
implication:	due to this erratum processor graphics may render incorrectly or hang on warm reset.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	using different vendors for 2400 mhz ddr4 udimms may cause correctable errors or a system hang				
problem:	when using 2400 mhz ddr4 udimms from different vendors within the same channel, a higher rate of correctable errors may occur or the system may hang.				
implication:	due to this erratum, reported correctable error counts may increase or the system may hang.				
workaround:	none identified. use a single vendor for 2400 mhz udimms				
					
title:	two dimms per channel 2133mhz ddr4 sodimm daisy-chain systems with different vendors may hang				
problem:	when, on a single memory channel with 2133 mhz ddr4 sodimms, mixing different vendors or mixing single rank and dual rank dimms, may lead to a higher rate of correctable error to system hangs.				
implication:	due to this erratum, reported correctable error counts may increase or system may hang.				
workaround:	use a single vendor for and do not mix single rank and dual rank 2133 mhz ddr4 sodimm.				
					
title:	unpredictable system behavior may occur in ddr4 multi-rank system				
problem:	due to incorrect configuration of ddr4 odt by bios, it is possible for a multi-rank system to violate section 4.27 of the ddr4 jedec spec revision jesed79-4a.				
implication:	due to this erratum, complex microarchitectural conditions may result in unpredictable system behavior.				
workaround:	a bios workaround has been identified.				
					
title:	processor graphics may render incorrectly when edram is enabled				
problem:	during high display bandwidth scenarios with edram is enabled, the display engine may generate display artifacts.				
implication:	due to this erratum, the display engine may generate display artifacts.				
workaround:	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum. additionally, an updated intel® graphics driver may be needed for this workaround.				
					
title:	processor may hang on complex sequence of conditions				
problem:	a complex set of architectural and micro-architectural conditions may lead to a processor hang with an internal timeout error (mcacod 0400h) logged into ia32_mci_status. when both logical processors in a core are active, this erratum will not occur unless there is no store on one of the logical processors for more than 10 seconds.				
implication:	this erratum may result in a processor hang. intel has not observed this erratum with any commercially available software.				
workaround:	none identified.				
					
title:	potential partial trace data loss in intel® trace hub odla when storing to memory				
problem:	when intel® trace hub’s odla (on-die logic analyzer) is configured to trace to memory, under complex microarchitectural conditions, the trace may lose a timestamp.				
implication:	some odla trace data may be lost. this erratum does not affect other trace data sources. typically, lost trace data will be displayed as “overflow.” subsequent timestamps will allow the trace decoder to resume tracing. intel has not observed this erratum in commercially available software.				
workaround:	none identified. for a particular workload, changing the memory buffer size or disabling deep compression may eliminate the microarchitectural condition that causes the erratum.				
					
title:	the soc may not detect a battery charger or may fail to connect to a usb host				
problem:	during power-on, when the soc is used in device mode instead of host mode, the usb d+ line may have a 2 µsec glitch to 3.3 v.				
implication:	due to this erratum, the platform may not detect a battery charger (and hence not charge the battery) or the soc may not successfully connect to an attached usb host.				
workaround:	power the soc on before connecting to its usb port. alternatively, manually disconnecting and re-connecting the usb cable restores operation after the erratum has occurred.				
					
title:	rgb666 pixel format display panel may not operate as expected				
problem:	due to this erratum, the rgb666 format support on the soc has restrictions on the horizontal resolution. for single link mipi* dsi (display serial interface), the horizontal resolution must be evenly divisible by 4. for dual link mipi dsi, one-half the horizontal resolution plus the overlapping pixels must be evenly divisible by 4.				
implication:	due to this erratum, the rgb666 panel may not operate as expected.				
workaround:	for dual link panels with overlap, choose the overlap so that one-half the horizontal resolution plus the overlapping pixels is evenly divisible by 4. for single link panels the horizontal resolution must be evenly divisible by 4				
					
title:	lpddr3 tinit0 jedec* duration may be longer than specification requirement				
problem:	jedec standard jesd209-3 requires a maximum power ramp duration tinit0 of 20ms. due to this erratum, the soc may not comply with the tinit0 specification.				
implication:	intel has not observed this erratum to impact the functionality or performance of any commercially available lpddr3 parts. intel has obtained waivers from vendors who provide commonly used lpddr3 dram parts				
workaround:	none identified.				
					
title:	hdmi and dvi displays may flicker or blank out when using certain pixel frequencies				
problem:	due to this erratum, hdmi (high-definition multimedia interface) and dvi (digital visual interface) ports may send data out at an incorrect rate, that is different than the one requested when using certain pixel frequencies.				
implication:	when this erratum occurs, panels may flicker or blank out. the impacted pixel frequencies are: 218.25mhz, 218.70mhz, 220.50mhz, 221.20mhz, 229.50mhz, 233.793mhz and 234.00mhz.				
workaround:	select a video mode that does not use an affected pixel frequency. statusfor the steppings affected, see the summary table of changes.				
					
title:	popcnt instruction may take longer to execute than expected				
problem:	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.				
implication:	software using the popcnt instruction may experience lower performance than expected.				
workaround:	none identified.				
					
title:	lpss uart not fully compatible with 16550 uart				
problem:	stick parity bit, lcr[5], (line control register, hsuart0_bar0, offset 0ch; bit [5] for hsuart0 and hsuart1_bar0, offset 0ch; bit [5] for hsuart1) does not follow the 16550 specified behavior, instead the parity bit is always logic 0.				
implication:	lpss (low power sub-system) uarts are not fully 16550 compatible and may cause an error when connected to a uart device that requires the stick parity feature.				
workaround:	do not use stick parity mode of uart.				
					
title:	llama
problem:	after processing a usb wake event, the usb xhci controller may not reenter d3 state.				
implication:	when this erratum occurs, the affected usb xhci controller may not recognize subsequent usb wake events. when this erratum occurs, pme status bit [15] of register power management control/status (pm_cs) (bus 0; device 20; function 20; offset 74h) remains at 1.				
workaround:	the software driver should set pmctrl[28] (bus 0; device 14; function 0; offset 80a4h) after the xhci controller enters d0 state following an exit from d3 state.				
					
title:	soc pcie* gen 2 refclk jitter does not meet pcie* specification with ssc enabled				
problem:	soc pcie* refclk does not meet pcie* jitter specification when ssc is enabled.				
implication:	this issue only impacts pcie* interface when it is running at gen 2 speed when ssc is enabled. no impact to pcie* gen 1 operation. intel has not observed any functional failures due to this erratum.				
workaround:	there are no known issues with enabling ssc on pcie interface that operates at gen 1 speed. however, if ssc is enabled while pcie* interface is running at gen 2 speed, system refclk will experience jitter would not meet pcie specifications.				
					
title:	sd card / sdio controller preset_value does not change transfer frequency				
problem:	the preset_value (cmd12_err_stat_host_ctrl_2 csr at bus 0; device 18; function 0; offset 3ch, bit 31) does not change the sd card/ sdio bus transfer frequency as required by the sd host controller standard specification version 3.0.				
implication:	drivers that attempt to utilize preset_value may not obtain the maximum transfer rate of an attached uhs sd card or sdio bus.				
workaround:	software should set the uhs_mode field (bits [1816] of the cmd12_err_stat_host_ctrl_2 csr) before setting the preset_value bit to reach the maximum transfer rate.				
					
title:	ia32_debugctl.freeze_perfmon_on_pmi is incorrectly cleared by smi				
problem:	freeze_perfmon_on_pmi (bit 12) in the ia32_debugctl msr (1d9h) is erroneously cleared during delivery of an smi (system-management interrupt).				
implication:	as a result of this erratum the performance monitoring counters will continue to count after a pmi occurs in smm (system-management mode).				
workaround:	none identified.				
					
title:	redirection of rsm to probe mode may not generate an lbr record				
problem:	a redirection of the rsm instruction to probe mode may not generate the lbr (last branch record) record that would have been generated by a non-redirected rsm instruction.				
implication:	the lbr stack may be missing a record when redirection of rsm to probe mode is used. The LBR stack will still properly describe the code flow of non-SMM code.				
workaround:	none identified.				
					
title:	unsynchronized cross-modifying code operations can cause unexpected instruction execution results				
problem:	the act of one processor or system bus master writing data into a currently executing code segment of a second processor with the intent of having the second processor execute that data as code is called cross-modifying code (xmc). xmc that does not force the second processor to execute a synchronizing instruction prior to execution of the new code is called unsynchronized xmc. software using unsynchronized xmc to modify the instruction byte stream of a processor can see unexpected or unpredictable execution behavior from the processor that is executing the modified code.				
implication:	in this case the phrase "unexpected or unpredictable execution behavior" encompasses the generation of most of the exceptions listed in the intel architecture software developer's manual volume 3: system programming guide including a general protection fault (gpf) or other unexpected behaviors. in the event that unpredictable execution causes a gpf the application executing the unsynchronized xmc operation would be terminated by the operating system.				
workaround:	in order to avoid this erratum programmers should use the xmc synchronization algorithm as detailed in the intel architecture software developer's manual volume 3 system programming guide section handling self- and cross-modifying code.				
					
title:	reported memory type may not be used to access the vmcs and referenced data structures				
problem:	bits 53:50 of the ia32_vmx_basic msr report the memory type that the processor uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.				
implication:	bits 53:50 of the ia32_vmx_basic msr report that the wb (write-back) memory type will be used but the processor may use a different memory type.				
workaround:	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.				
					
title:	a page fault may not be generated when the ps bit is set to “1” in a pml4e or pdpte				
problem:	on processors supporting intel® 64 architecture the ps bit (page size bit 7) is reserved in pml4es and pdptes. if the translation of the linear address of a memory access encounters a pml4e or a pdpte with ps set to 1 a page fault should occur. due to this erratum, ps of such an entry is ignored and no page fault will occur due to its being set.				
implication:	software may not operate properly if it relies on the processor to deliver page faults when reserved bits are set in paging-structure entries.				
workaround:	software should not set bit 7 in any pml4e or pdpte that has present bit (bit 0) set to “1”.				
					
title:	some performance counter overflows may not be logged in ia32_perf_global_status when freeze_perfmon_on_pmi is enabled				
problem:	when enabled, freeze_perfmon_on_pmi bit 12 in ia32_debugctl msr (1d9h) freezes pmcs (performance monitoring counters) on a pmi (performance monitoring interrupt) request by clearing the ia32_perf_global_ctrl msr (38fh). due to this erratum, when freeze_perfmon_on_pmi is enabled and two or more pmcs overflow within a small window of time and pmi is requested, then subsequent pmc overflows may not be logged in ia32_perf_global_status msr (38eh).				
implication:	on a pmi, subsequent pmc overflows may not be logged in ia32_perf_global_status msr.				
workaround:	re-enabling the pmcs in ia32_perf_global_ctrl will log the overflows that were not previously logged in ia32_perf_global_status.				
					
title:	cs limit violations may not be detected after vm entry				
problem:	the processor may fail to detect a cs limit violation on fetching the first instruction after vm entry if the first byte of that instruction is outside the cs limit but the last byte of the instruction is inside the limit.				
implication:	the processor may erroneously execute an instruction that should have caused a general protection exception.				
workaround:	when a vmm emulates a branch instruction it should inject a general protection exception if the instruction’s target eip is beyond the cs limit.				
					
title:	pebs record eventingip field may be incorrect after cs.base change				
problem:	due to this erratum a pebs (precise event base sampling) record generated after an operation which changes cs.base may contain an incorrect address in the eventingip field.				
implication:	software attempting to identify the instruction which caused the pebs event may identify the incorrect instruction when non-zero cs.base is supported and cs.base is changed. intel has not observed this erratum to impact the operation of any commercially available system.				
workaround:	none identified.				
					
title:	movntdqa from wc memory may pass earlier locked instructions				
problem:	an execution of movntdqa that loads from wc (write combining) memory may appear to pass an earlier locked instruction to a different cache line.				
implication:	software that expects a lock to fence subsequent movntdqa instructions may not operate properly. if the software does not rely on locked instructions to fence the subsequent execution of movntdqa then this erratum does not apply.				
workaround:	software that requires a locked instruction to fence subsequent executions of movntdqa should insert an lfence instruction before the first execution of movntdqa following the locked instruction. if there is already a fencing or serializing instruction between the locked instruction and the movntdqa, then an additional lfence is not necessary.				
					
title:	performance monitor instructions retired event may not count consistently				
problem:	performance monitor instructions retired (event c0h; umask 00h) and the instruction retired fixed counter (ia32_fixed_ctr0 msr (309h)) are used to track the number of instructions retired. due to this erratum, certain situations may cause the counter(s) to increment when no instruction has retired or to not increment when specific instructions have retired.				
implication:	a performance counter counting instructions retired may over or under count. the count may not be consistent between multiple executions of the same code.				
workaround:	none identified.				
					
title:					
problem:	when freeze_lbrs_on_pmi flag (bit 11) in ia32_debugctl msr (1d9h) is set, the lbr (last branch record) stack is frozen on a hardware pmi (performance monitoring interrupt) request. when freeze_perfmon_on_pmi flag (bit 12) in ia32_debugctl msr is set, a pmi request clears each of the enable fields of the ia32_perf_global_ctrl msr (38fh) to disable counters. due to this erratum, when freeze_lbrs_on_pmi and/or freeze_perfmon_on_pmi is set in ia32_debugctl msr and the local apic is disabled or the pmi lvt is masked, the lbr stack and/or performance counters freeze on pmi may not function correctly.				
implication:	performance monitoring software may not function properly if the lbr stack and performance counters freeze on pmi do not operate as expected. intel has not observed this erratum to impact any commercially available system.				
workaround:	none identified.				
					
title:	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1				
problem:	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.				
implication:	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable MSR. Intel has not observed this erratum with any commercially available software.				
workaround:	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.				
					
title:	lpddr3 tinit0 duration may be longer than specification requirement				
problem:	jedec standard jesd209-3 requires a maximum power ramp duration tinit0 of 20ms. due to this erratum, the soc may not comply with the tinit0 specification.				
implication:	intel has not observed this erratum to impact the functionality or performance of any commercially available lpddr3 parts. intel has obtained waivers from vendors who provide commonly used lpddr3 dram parts.				
workaround:	none identified.				
					
title:	xhci usb2.0 split-transactions error counter reset issue				
problem:	the xhci controller may not reset its split transaction error counter if a high-speed usb hub propagates a mal-formed bit from a low-speed or full-speed usb device exhibiting non-usb specification compliant signal quality.				
implication:	the implication is device dependent. full speed and low speed devices behind the hub may be re-enumerated and may cause a device to not function as expected				
workaround:	software driver can be modified to workaround this erratum. statusfor the steppings affected, see the summary table of changes.				
					
title:	soc may not meet pcie* clock jitter specification				
problem:	the soc’s pcie refclk signals may not meet pcie jitter specifications when operating at 5.0 gt/s with ssc (spread spectrum clocking) enabled.				
implication:	the platform may not meet refclk jitter specification. intel has not observed any functional failures due to this erratum.				
workaround:	none identified.				
					
title:	sata host controller does not pass certain compliance tests				
problem:	the soc sata host controller oob (out of band) host responses, oob transmit gap, and oob transmit burst length do not pass serial ata interoperability program revision 1.4.3, unified test document version 1.01 tests oob-03[a/b], oob-05, and oob-06[a/b].				
implication:	intel has obtained a waiver for these tests. intel has not observed any functional failures due to this erratum.				
workaround:	none identified.				
					
title:	rtit trace may contain fup.far packet with incorrect address				
problem:	the fup.far (flow update packet for far transfer) generated by rtit (real time instruction trace) on a far transfer instruction should contain the linear address of the first byte of the next sequential instruction after the far transfer instruction. due to this erratum, far transfer instructions with more than 3 prefixes may incorrectly include an address between the first byte of the far transfer instruction and the last byte of the far transfer instruction.				
implication:	the rtit trace decoder may incorrectly decode the trace due to an incorrect address in the fup packet.				
workaround:	the rtit trace decoder can identify a fup.far in the middle of a far transfer instruction and treat that fup.far as if it was coming from the first byte of the following sequential instruction.				
					
title:	rtit fup.buffovf packet may be incorrectly followed by a tip packet				
problem:	when rtit (real time instruction trace) suffers an internal buffer overflow, packet generation stops temporarily, after which a fup.buffovf (flow update packet for buffer overflow) is sent to indicate the lip that follows the instruction upon which tracing resumes. in some cases, however, this packet will be immediately followed by a fup.tip (flow update packet for target ip) which was generated by a branch instruction that executed during the overflow. the ip payload of this fup.tip will be the lip of the instruction upon which tracing resumes.				
implication:	the spurious fup.tip packet may cause the rtit trace decoder to fail.				
workaround:	the rtit trace decoder should ignore any fup.tip packet that immediately follows a fup.buffovf whose ip matches the ip payload of the fup.buffovf.				
					
title:	rtit cyc packet payload values may be off by 1 cycle				
problem:	when rtit (real time instruction trace) is enabled with rtit_ctl.cyc_acc msr (768h) bit 1 set to 1, all cyc (cycle count) packets have a payload value that is one less than the number of cycles that have actually passed. note that for cyc packets with a payload value of 0, the correct value may be 0 or 1.				
implication:	the trace decoder will produce inaccurate performance data when using cyc packets to track software performance.				
workaround:	as a partial workaround, the trace decoder should add 1 to the payload value of any cyc packet with a non-zero payload.				
					
title:	first mtc packet after rtit enable may be incorrect				
problem:	when rtit (real time instruction trace) is enabled, indicated by triggeren in bit 2 of the rtit_status msr (769h) transitioning from 0 to 1, the first mtc (mini time counter) packet may be sent at the wrong time.				
implication:	the rtit trace decoder will make incorrect assumptions about the tsc value based on an asynchronous mtc packet.				
workaround:	the rtit trace decoder should ignore the first mtc that follows trace enabling. statusfor the steppings affected, see the summary table of changes.				
					
title:	usb device mode may not be functional when connected to usb1.x				
problem:	device mode may not be functional when connected to usb 1.x host or hub.				
implication:	due to this erratum, the soc in device mode may be unable to connect to usb 1.x host or hub.				
workaround:	none identified..				
					
title:	multiple drivers that access the gpio registers concurrently may result in unpredictable system behavior				
problem:	the pcu (platform control unit) in soc may not be able to process concurrent accesses to the gpio registers. due to this sighting, read instructions may return 0xffffffff and write instructions may be dropped.				
implication:	multiple drivers concurrently accessing gpio registers may result in unpredictable system behavior.				
workaround:	it is possible for the display driver to contain a workaround for this erratum. statusfor the steppings affected, see the summary table of changes.				
					
title:	power rail leakage at power on				
problem:	at power on, leakage from the v1p05a power rail to the v1p8a power rail may result in raising the v1p8a rail to about 400mv prior to that rail being powered.				
implication:	intel has not observed this erratum to impact the operation of any commercially available platform.				
workaround:	none identified.				
					
title:	pcie* refclk drivers remain enabled in sx states				
problem:	in sx states, the pcie refclk (clk_diff_n [0:3]) signals stay at 1.05v level instead of shutting off completely.				
implication:	intel has observed a worst case leakage of about 6mw per clock pair during sx states for each connected pcie device. intel has not observed any functional failures as a result of this erratum.				
workaround:	none identified.				
					
title:	sd card / sdio controller preset_value does not change transfer frequency				
problem:	the preset_value (cmd12_err_stat_host_ctrl_2 csr at bus 0; device 18; function 0; mmio offset 3ch, bit 31) does not change the sd card/ sdio bus transfer frequency as required by the sd host controller standard specification version 3.0.				
implication:	drivers that attempt to utilize preset_value may not obtain the maximum transfer rate of an attached uhs sd card or sdio bus.				
workaround:	software should set the uhs_mode field (bits [1816] of the cmd12_err_stat_host_ctrl_2 csr) before setting the preset_value bit to reach the maximum transfer rate.				
					
title:	incorrect detection of usb lfps may lead to usb 3.0 link errors				
problem:	the usb 3.0 host controller may incorrectly detect lfps (low frequency periodic signal) on certain soc parts.				
implication:	when this erratum occurs, the usb 3.0 host controller may not enumerate the link or may encounter unrecoverable errors during operation.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	usb high speed links may disconnect when subject to eft events				
problem:	when subjected to eft (electric fast transient) events, the xhci host controller usb When subjected to EFT (Electric Fast Transient) events, the xHCI host controller USB				
implication:	when this erratum occurs, the usb high speed device may be falsely disconnected.				
workaround:	none identified.				
					
title:	xhci usb controller may not resume after s3 exit problem:				
problem:					
implication:					
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	lpc serr generation can not be independently disabled				
problem:	lpc serr# events are incorrectly propagated to trigger the nmi interrupt when the see field of the pcie_reg_command register (bus 0; device 31; function 0; offset 4h) is cleared. this erratum only affects systems with attached lpc devices that signal serr# events.				
implication:	serr for lpc cannot be disabled using pcie_reg_command see bit. serr# is used on the lpc bus to carry the legacy isa iochk# parity error indication.				
workaround:	none identified. software can clear nsc (nmi status and control) msr (bus 0; device 31; function 0; offset 61h) sne field to disable serr for both nmi and lpc.				
					
title:	some rtit packets following psb may be sent out of order or dropped				
problem:	when a complex micro-architectural condition occurs concurrently with the generation of a rtit (real-time instruction trace) psb (packet stream boundary) packet, the packets that immediately follow the psb could precede or overwrite some older packets. this erratum applies to no more than 21 packets immediately following the psb.				
implication:	the rtit packet output immediately following a psb may not accurately reflect software behavior, and may result in an rtit decoder error.				
workaround:	none identified.				
					
title:	system may hang when ddr dynamic self-refresh is enabled				
problem:	the system may hang when ddr dynamic self-refresh is enabled.				
implication:	when this erratum occurs, the system hangs. a cold reset is required to recover the system.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	usb3 phy may become unreliable on certain soc parts				
problem:	when the system enters s0i3 sleep state, the contents of usb3 phy configuration registers may change sometimes.				
implication:	due to this erratum, the usb3 device connected to the port may not be detected or the port may downgrade to usb2 speed.				
workaround:	it is possible for bios to contain a workaround for this erratum. statusfor the steppings affected, see the summary table of changes.				
					
title:	system may experience inability to boot or may cease operation				
problem:	under certain conditions where activity is high for several years the lpc, rtc and sd card may stop functioning in the outer years of use.				
implication:	lpc and rtc circuitry that stops functioning may cause operation to cease or inability to boot. sd card that stops functioning may cause sd cards to be unrecognized. intel has only observed this behavior in simulation. designs that implement the lpc interface at the 1.8v signal voltage are not affected by the lpc part of this erratum.				
workaround:	firmware code changes for lpc and rtc circuitry and mitigations for sd card circuitry have been identified and may be implemented for this erratum.				
					
title:	xhci host controller reset may lead to system hang				
problem:	an access to xhci configuration space within 1ms of setting the xhci hcrst (host controller reset) bit of the usb command register (xhcibar, offset 80h, bit [1]) or a second setting of the hcrst bit within 120ms may cause the xhci host controller to fail to respond.				
implication:	due to this erratum, the system may hang.				
workaround:	software must not access xhci configuration space within 1ms or set hcrst bit within 120ms of setting the hcrst bit.				
					
title:	processor may not wake from c6 or deeper sleep state				
problem:	the processor may not wake after a sleep state entered with mwait target c-state of c6 and sub c-state of 2 or a target c-state deeper than c6 is requested.				
implication:	when this erratum occurs, the system may hang.				
workaround:	it is possible for the firmware to contain a workaround for this erratum. statusfor the steppings affected, see the summary table of changes.				
					
title:	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode				
problem:	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms.  however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s.  subsequent bts and btm operations which report the lbr will also be incorrect.				
implication:	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.				
workaround:	none identified.				
					
title:	eflags discrepancy on page faults and on ept-induced vm exits after a translation change				
problem:	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.				
implication:	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.				
workaround:	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.				
					
title:	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error				
problem:	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15:0]) appearing as binary value, 000x 0000 0001 0100, in the mci_status register.				
implication:	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.				
workaround:	none identified.				
					
title:	ler msrs may be unreliable				
problem:	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.				
implication:	the values of the ler msrs may be unreliable.				
workaround:	none identified.				
					
title:	monitor or clflush on the local xapic's address space results in hang				
problem:	if the target linear address range for a monitor or clflush is mapped to the local xapic's address space, the processor will hang.				
implication:	when this erratum occurs, the processor will hang. the local xapic's address space must be uncached. the monitor instruction only functions correctly if the specified linear address range is of the type write-back. clflush flushes data from the cache. intel has not observed this erratum with any commercially available software.				
workaround:	do not execute monitor or clflush instructions on the local xapic address space.				
					
title:	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang				
problem:	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).				
implication:	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.				
workaround:	none identified.				
					
title:	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code				
problem:	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.				
implication:	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.				
workaround:	none identified.				
					
title:	freeze_while_smm does not prevent event from pending  pebs during smm				
problem:	in general, a pebs record should be generated on the first count of the event after the counter	has	overflowed.	however,	ia32_debugctl_msr.freeze_while_smm (msr 1d9h,  bit [14])  prevents performance  counters from counting  during  smm (system management mode). due to this erratum, if 1.a performance counter overflowed before an smi 2.a pebs record has not yet been generated because another count of the event has not occurred 3.the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.
implication:	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.				
workaround:	none identified.				
					
title:	apic error “received illegal vector” may be lost				
problem:	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.				
implication:	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.				
workaround:	none identified.				
					
title:	changing the memory type for an in-use page translation may lead to memory-ordering violations				
problem:	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.				
implication:	memory ordering may be violated. intel has not observed this erratum with any commercially available software.				
workaround:	software should ensure pages are not being actively used before requesting their memory type be changed.				
					
title:	performance monitor precise instruction retired event may present wrong indications				
problem:	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).				
implication:	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.				
workaround:	the sampling driver should avoid using sav<100.				
					
title:	cr0				
problem:	if cr0.cd=1, the mtrrs and pat should be ignored and the uc memory type should be used for all memory accesses. due to this erratum, a logical processor in vmx operation will operate as if cr0.cd=0 even if that bit is set to 1.				
implication:	algorithms that rely on cache disabling may not function properly in vmx operation.				
workaround:	algorithms that rely on cache disabling should not be executed in vmx root operation.				
					
title:	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception				
problem:	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.				
implication:	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.				
workaround:	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.				
					
title:	processor may fail to acknowledge a tlp request				
problem:	when a pcie root port’s receiver is in receiver l0s power state and the port initiates a recovery event, it will issue training sets to the link partner. the link partner will respond by initiating an l0s exit sequence. prior to transmitting its own training sets, the link partner may transmit a tlp (transaction layer packet) request. due to this erratum, the root port may not acknowledge the tlp request.				
implication:	after completing the recovery event, the pcie link partner will replay the tlp request. the link partner may set a correctable error status bit, which has no functional effect.				
workaround:	none identified.				
					
title:	interrupt from local apic timer may not be detectable while being  delivered				
problem:	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.				
implication:	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.				
workaround:	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.				
					
title:	pcie* root-port initiated compliance state transmitter equalization settings may be incorrect				
problem:	if the processor is directed to enter pcie polling.compliance at 5.0 gt/s or 8.0 gt/s transfer rates, it should use the link control 2 compliance preset/de-emphasis field (bits [15:12]) to determine the correct de-emphasis level. due to this erratum, when the processor is directed to enter polling.compliance from 2.5 gt/s transfer rate, it retains 2.5 gt/s de-emphasis values.				
implication:	the processor may operate in polling.compliance mode with an incorrect transmitter de-emphasis level.				
workaround:	none identified.				
					
title:	pcie* controller may incorrectly log errors on transition to rxl0s				
problem:	due to this erratum, if a link partner transitions to rxl0s state within 20 ns of entering l0 state, the pcie controller may incorrectly log an error in “correctable error status.receiver error status” field (bus 0, device 2, function 0, 1, 2 and device 6, function 0, offset 1d0h, bit 0).				
implication:	correctable receiver errors may be incorrectly logged.	intel has not observed any functional impact due to this erratum with any commercially available add-in cards.			
workaround:	none identified.				
					
title:	unused pcie* lanes may report correctable errors				
problem:	due to this erratum, during pcie* link down configuration, unused lanes may report a correctable error detected in bus 0, device 1, function 0-2, and device 6, function 0, offset 158h, bit 0.				
implication:	correctable errors may be reported by a pcie controller for unused lanes.				
workaround:	none identified.				
					
title:	pcie root port may not initiate link speed change				
problem:	the pcie base specification requires the upstream component to maintain the pcie link at the target link speed or the highest speed supported by both components on the link, whichever is lower. pcie root port will not initiate the link speed change without being triggered by the software when the root port maximum link speed is configured to be 5.0 gt/s. system bios will trigger the link speed change under normal boot scenarios. however, bios is not involved in some scenarios such as link disable/re- enable or secondary bus reset and therefore the speed change may not occur unless initiated by the downstream component. this erratum does not affect the ability of the downstream component to initiate a link speed change. all known 5.0gb/s-capable pcie downstream components have been observed to initiate the link speed change without relying on the root port to do so.				
implication:	due to this erratum, the pcie root port may not initiate a link speed change during some hardware scenarios causing the pcie link to operate at a lower than expected speed. intel has not observed this erratum with any commercially available platform.				
workaround:	none identified.				
					
title:					
problem:					
implication:					
workaround:	none identified.				
					
title:	dr6 ss is followed by a store or an mmx instruction				
problem:	normally, data breakpoints matches that occur on a mov ss, r/m or pop ss will not cause a debug exception immediately after mov/pop ss but will be delayed until the instruction  boundary  following  the  next  instruction  is  reached.  after  the  debug exception occurs, dr6.b0-b3 bits will contain information about data breakpoints matched during the mov/pop ss as well as breakpoints detected by the following instruction. due to this erratum, dr6.b0-b3 bits may not contain information about data breakpoints matched during the mov/pop ss when the following instruction is either an mmx instruction that uses a memory addressing mode with an index or a store instruction.				
implication:	when this erratum occurs, dr6 may not contain information about all breakpoints matched. this erratum will not be observed under the recommended usage of the mov ss,r/m or pop ss instructions (i.e., following them only with an instruction that writes (e/r)sp).				
workaround:	none identified.				
					
title:	vex 				
problem:	the vex.l bit should be ignored for the vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions, however due to this erratum the vex.l bit is not ignored and will cause a #ud.				
implication:	unexpected #uds will be seen when the vex.l bit is set to 1 with vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions.				
workaround:	software should ensure that the vex.l bit is set to 0 for all scalar instructions.				
					
title:	pcie* atomic transactions from two or more pcie controllers may cause starvation				
problem:	on a processor pcie controller configuration in which two or more controllers receive concurrent atomic transactions, a pcie controller may experience starvation which eventually can lead to a completion timeout.				
implication:	atomic transactions from two or more pcie controllers may lead to a completion timeout. atomic transactions from only one controller will not be affected by this erratum. intel has not observed this erratum with any commercially available device.				
workaround:	none identified.				
					
title:	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set				
problem:	after a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to be counted in  the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated when the uc bit (bit 61) is set to 1.				
implication:	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.				
workaround:	none identified.				
					
title:	pcie* controller may initiate speed change while in dl_init state causing certain pcie devices to fail to train				
problem:	the pcie controller supports hardware autonomous speed change capabilities. due to this erratum, the pcie controller may initiate speed change while in the dl_init state which may prevent link training for certain pcie devices.				
implication:	certain pcie devices may fail to complete dl_init causing the pcie link to fail to train.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	spurious vt-d interrupts may occur when the pfo bit is set				
problem:	when the pfo (primary fault overflow) field (bit [0] in the vt-d fsts [fault status] register) is set to 1, further faults should not generate an interrupt. due to this erratum, further interrupts may still occur.				
implication:	unexpected invalidation queue error interrupts may occur. intel has not observed this erratum with any commercially available software.				
workaround:	software should be written to handle spurious vt-d fault interrupts.				
					
title:	processor may livelock during on demand clock modulation				
problem:	the processor may livelock when (1) a processor thread has enabled on demand clock modulation via bit 4 of the ia32_clock_modulation msr (19ah) and the clock modulation duty cycle is set to 12.5% (02h in bits 3:0 of the same msr), and (2) the other processor thread does not have on demand clock modulation enabled and that thread is executing a stream of instructions with the lock prefix that either split a cacheline or access uc memory.				
implication:	program execution may stall on both threads of the core subject to this erratum.				
workaround:	this erratum will not occur if clock modulation is enabled on all threads when using on demand clock modulation or if the duty cycle programmed in the ia32_clock_modulation msr is 18.75% or higher.				
					
title:					
problem:					
implication:	ia32_mc2_status.over may not accurately indicate multiple occurrences of uncorrectable internal parity errors. there is no other impact to normal processor functionality.				
workaround:	none identified.				
					
title:	performance monitor events other_assists other_assists.sse_to_avx may over count				
problem:	the performance monitor events other_assists.avx_to_sse (event c1h; umask 08h) and other_assists.sse_to_avx (event c1h; umask 10h) incorrectly increment and over count when an hle (hardware lock elision) abort occurs.				
implication:	the performance monirtor events other_assists.avx_to_sse and other_assists.sse_to_avx may over count.				
workaround:	none identified.				
					
title:	performance monitor event dsb2mite_switches count				
problem:	the performance monitor event dsb2mite_switches.count (event abh; umask 01h) should count the number of dsb (decode stream buffer) to mite (macro instruction translation engine) switches. due to this erratum, the dsb2mite_switches.count event will count speculative switches and cause the count to be higher than expected.				
implication:	the performance monitor event dsb2mite_switches.count may report count higher than expected.				
workaround:	none identified. 				
					
title:	timed mwait may use deadline of a previous execution				
problem:	a timed mwait instruction specifies a tsc deadline for execution resumption. if a wake event causes execution to resume before the deadline is reached, a subsequent timed mwait instruction may incorrectly use the deadline of the previous timed mwait when that previous deadline is earlier than the new one.				
implication:	a timed mwait may end earlier than expected.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding				
problem:	ia32_vmx_vmcs_enum msr (48ah) bits 9 any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.				
implication:	software that uses the value reported in ia32_vmx_vmcs_enum[9 write all vmcs fields may omit one field.				
workaround:	none identified.				
					
title:	incorrect from_ip value for an rtm abort in btm or bts may be observed				
problem:	during rtm (restricted transactional memory) operation when branch tracing is enabled using btm (branch trace message) or bts (branch trace store), the incorrect eip value (from_ip pointer) may be observed for an rtm abort.				
implication:	due to this erratum, the from_ip pointer may be the same as that of the immediately preceding taken branch.				
workaround:	none identified.				
					
title:	locked load performance monitoring events may under count				
problem:	the  performance  monitoring  events  mem_trans_retired.load_latency  (event cdh;  umask  01h),  mem_load_retired.l2_hit  (event  d1h;  umask  02h),  and mem_uops_retired.locked (event doh; umask 20h) should count the number of locked  loads.  due  to  this  erratum,  these  events  may  under  count  for  locked transactions that hit the l2 cache.				
implication:	the above event count will under count on locked loads hitting the l2 cache.				
workaround:	none identified.				
					
title:	transactional abort may produce an incorrect branch record				
problem:	if an intel® tsx transactional abort event occurs during a string instruction, the from- ip in the lbr (last branch record) is not correctly reported.				
implication:	due to this erratum, an incorrect from-ip on the lbr stack may be observed.				
workaround:	none identified.				
					
title:	smram state-save area above the 4gb boundary may cause unpredictable system behavior				
problem:	if bios uses the rsm instruction to load the smbase register with a value that would cause any part of the smram state-save area to have an address above 4-gbytes, subsequent transitions into and out of smm (system-management mode) might save and restore processor state from incorrect addresses.				
implication:	this erratum may cause unpredictable system behavior. intel has not observed this erratum with any commercially available system.				
workaround:	ensure that the smram state-save area is located entirely below the 4gb address boundary.				
					
title:	pmi may be signaled more than once for performance monitor counter overflow				
problem:	due to this erratum, pmi (performance monitoring interrupt) may be repeatedly issued until the counter overflow bit is cleared in the overflowing counter.				
implication:	multiple pmis may be received when a performance monitor counter overflows.				
workaround:	none identified. if the pmi is programmed to generate an nmi, software may delay the eoi (end-of- interrupt) register write for the interrupt until after the overflow indications have been cleared.				
					
title:	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception				
problem:	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not-available) exception will be raised instead of #ud exception.				
implication:	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.				
workaround:	software should not use fxsave or fxrstor with the vex prefix.				
					
title:	intel® turbo boost technology may be incorrectly reported as				
problem:	mobile intel® pentium® processors and mobile intel® celeron® processors celeron processors may incorrectly report support for intel turbo boost technology via cpuid.06h.eax bit 1.				
implication:	the cpuid instruction may report turbo boost technology as supported even though the processor does not permit operation above the maximum non-turbo frequency.				
workaround:	none identified.				
					
title:	the sample/preload jtag command does not sample the display transmit signals				
problem:	the display transmit signals are not correctly sampled by the sample/preload jtag command, violating the boundary scan specification (ieee 1149.1). 				
implication:	the sample/preload command cannot be used to sample display transmit signals.				
workaround:	none identified.				
					
title:	vm exit may set ia32_efer.nxe when ia32_misc_enable bit 34 is set to 1				
problem:	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe. due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.				
implication:	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.				
workaround:	a virtual machine monitor should not allow guest software to write to the ia32_misc_enable msr.				
					
title:	for the steppings affected, see the summary table of changes. chap counter values may be cleared after package c7 or deeper c-state				
problem:	the chap (chipset hardware architecture performance) counters which do not have a "start" opcode present in the cmd register will not be preserved across a package c7 or deeper c-state.				
implication:	chap counter data is not saved/restored after package c7 or deeper c-state causing counts to be lost; actions based on those counts may not occur as expected.				
workaround:	none identified.				
					
title:	opcode bytes f3 0f bc may execute as tzcnt even when tzcnt not enumerated by cpuid				
problem:	if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 1 then opcode bytes f3 0f bc should be interpreted as tzcnt otherwise they will be interpreted as rep bsf. due to this erratum, opcode bytes f3 0f bc may execute as tzcnt even if cpuid.(eax=07h, ecx=0):ebx.bmi1 (bit 3) is 0.				
implication:	software that expects rep prefix before a bsf instruction to be ignored may not operate correctly since there are cases in which bsf and tzcnt differ with regard to the flags that are set and how the destination operand is established.				
workaround:	software should use the opcode bytes f3 0f bc only if cpuid.(eax=07h, ecx=0)				
					
title:	back to back updates of the vt-d root table pointer may lead to an unexpected dma remapping fault				
problem:	a vt-d (intel® virtualization technology for directed i/o) root table pointer update that completes followed by a second root table pointer update that also completes, without performing a global invalidation of either the context-cache or the iotlb between the two updates, may lead to an unexpected dma remapping fault. july 2017 5th generation intel® core and m- processor families, mobile intel® pentium® and celeron® processor families 27				
implication:	back to back root table pointer updates may cause an unexpected dma remapping fault. intel has not observed this erratum with any commercially available software.				
workaround:	software must not perform a second root table pointer update before doing a global invalidation of either the context-cache or the iotlb.				
					
title:	a mov to cr3 when ept is enabled may lead to an unexpected page fault or an incorrect page translation				
problem:	if ept (extended page tables) is enabled, a mov to cr3 or vmfunc may be followed by an unexpected page fault or the use of an incorrect page translation.				
implication:	guest software may crash or experience unpredictable behavior as a result of this erratum.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	peer io device writes to the gmadr may lead to a system hang				
problem:	the system may hang when a peer io device uses the peer aperture to directly write into the gmadr (graphics memory address range).				
implication:	due to this erratum, the system may hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	spurious corrected errors may be reported				
problem:	due this erratum, spurious corrected errors may be logged in the ia32_mc0_status register with the valid field (bit 63) set, the uncorrected error field (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.				
implication:	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.				
workaround:	none identified.				
					
title:	intel® pt packet generation may stop sooner than expected				
problem:	setting the stop bit (bit 4) in a table of physical addresses entry directs the processor to stop intel pt (processor trace) packet generation when the associated output region is filled. the processor indicates this has occurred by setting the stopped bit (bit 5) of ia32_rtit_status msr (571h). due to this erratum, packet generation may stop earlier than expected.				
implication:	when this erratum occurs, the outputoffset field [62 ia32_rtit_output_mask_ptrs msr (561h) holds a value that is less than the size of the output region which triggered the stop condition; intel pt analysis software should not attempt to decode packet data bytes beyond the outputoffset.				
workaround:	none identified.				
					
title:	pebs eventing ip field may be incorrect after not-taken branch 				
problem:	when a pebs (precise-event-based-sampling) record is logged immediately after a not-taken conditional branch (jcc instruction), the eventing ip field should contain the address of the first byte of the jcc instruction. due to this erratum, it may instead contain the address of the instruction preceding the jcc instruction.				
implication:	performance monitoring software using pebs may incorrectly attribute pebs events that occur on a jcc to the preceding instruction.				
workaround:	none identified.				
					
title:	reading the memory destination of an instruction that begins an hle transaction may return the original value				
problem:	an hle (hardware lock elision) transactional region begins with an instruction with the xacquire prefix. due to this erratum, reads from within the transactional region of the memory destination of that instruction may return the value that was in memory before the transactional region began.				
implication:	due to this erratum, unpredictable system behavior may occur.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	package c7 entry may cause display artifact				
problem:	due to this erratum, package c7 entry may exceed published latencies.				
implication:	when this erratum occurs, it is possible that isochronous requirements may not be met. intel has not observed this erratum to affect isochronous elements other than display.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	intel® tsx instructions not available				
problem:	intel tsx (transactional synchronization extensions) instructions are not supported and not reported by cpuid.				
implication:	the intel tsx feature is not available.				
workaround:	none identified.				
					
title:	spurious corrected errors may be reported				
problem:	due this erratum, spurious corrected errors may be logged in the mc0_status register with the valid (bit 63) set, the uncorrected error (bit 61) not set, a model specific error code (bits [31:16]) of 0x000f, and an mca error code (bits [15:0]) of 0x0005. if cmci is enabled, these spurious corrected errors also signal interrupts.				
implication:	when this erratum occurs, software may see corrected errors that are benign. these corrected errors may be safely ignored.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	performance monitoring event instr_retired redundant pebs records for an overflow				
problem:	due to this erratum, the performance monitoring feature pdir (precise distribution of instructions retired) for instr_retired.all (event c0h; umask 01h) will generate redundant pebs (precise event based sample) records for a counter overflow. this can occur if the lower 6 bits of the performance monitoring counter are not initialized or reset to 0, in the pebs counter reset field of the ds buffer management area.				
implication:	the performance monitor feature pdir, may generate redundant pebs records for an overflow.				
workaround:	initialize or reset the counters such that lower 6 bits are 0.				
					
title:	concurrent core and graphics operation at turbo ratios may lead to system hang				
problem:	workloads that attempt concurrent operation of cores and graphics in their respective turbo ranges, under certain conditions may result in a system hang.				
implication:	concurrent core and graphics operation may hang the system.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	the system may hang on first package c6 or deeper c-state				
problem:	under certain conditions following a cold boot, exiting the first package c6 or deeper c- state may hang the system.				
implication:	due to this erratum, the system may hang exiting a package c6 or deeper c-state.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	svm doorbells are not correctly preserved across package c-states				
problem:	svm (shared virtual memory) doorbell registers are incorrectly preserved across package c-states (c7 and deeper).				
implication:	due to this erratum, software that uses svm may experience unreliable behavior from the graphics device.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	using the fivr spread spectrum control mailbox may not produce the requested range				
problem:	values programmed into the fivr ssc (fully integrated voltage regulator spread spectrum control) mailbox may not result in the expected spread spectrum range.				
implication:	the actual fivr spread spectrum range may not be the same as the programmed values affecting the usefulness of fivr ssc mailbox as a means to reduce emi (electromagnetic interference).				
workaround:	it is possible for bios to contain a workaround for this erratum.				
					
title:	intel® processor trace (intel® pt) mode  are not generated as expected				
problem:	the  intel®  pt  mode.exec  (mode  packet  –  execution  mode  leaf),  pip  (paging information packet), and cbr (core:bus ratio) packets are generated at the following psb+ (packet stream boundary) event rather than at the time of the originating event as expected.				
implication:	the decoder may not be able to properly disassemble portions of the binary or interpret portions of the trace because many packets may be generated between the mode.exec, pip, and cbr events and the following psb+ event.				
workaround:	the processor inserts these packets as status packets in the psb+ block. the decoder may have to skip forward to the next psb+ block in the trace to obtain the proper updated information to continue decoding.				
					
title:	performance monitor instructions retired event may not count consistently				
problem:	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.				
implication:	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.				
workaround:	none identified.				
					
title:	general-purpose performance counters may be inaccurate with any thread				
problem:	the ia32_pmcx msr (c1h - c8h) general-purpose performance counters may report inaccurate counts when the associated event selection ia32_perfevtselx msr’s (186h - 18dh) anythread field (bit 21) is set and either the os field (bit 17) or usr field (bit 16) is set (but not both set).				
implication:	due to this erratum, ia32_pmcx counters may be inaccurate.				
workaround:	none identified				
					
title:	glitches on internal voltage planes during package c9/c10 exit may cause a system hang				
problem:	internally generated processor voltage planes may exhibit unexpected voltage glitches during a package c9/c10 exit.				
implication:	when this erratum occurs, the system may hang. intel has not observed this erratum with any commercially available system.				
workaround:	it is possible for bios to contain a workaround for this erratum				
					
title:					
problem:					
implication:					
workaround:	if software enables intel® pt in system-management mode, it should disable intel® pt before executing rsm.				
					
title:	intel® processor trace pip may be unexpectedly generated				
problem:	when intel® processor trace (intel® pt) is enabled, psb+ (packet stream boundary) packets may include a pip (paging information packet) even though the os field (bit 2) of ia32_rtit_ctl msr (570h) is 0.				
implication:	when this erratum occurs, user-mode tracing (indicated by ia32_rtit_ctl.os = 0) may include cr3 address information. this may be an undesirable leakage of kernel information.				
workaround:	it is possible for bios to contain a workaround for this erratum				
					
title:	a #ve may not invalidate cached translation information				
problem:	an ept (extended page table) violation that causes a #ve (virtualization exception) may not invalidate the guest-physical mappings that were used to translate the guest-physical address that caused the ept violation.				
implication:	due to this erratum, the system may hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	frequent entries into package c8, c9, or c10 may cause a hang 				
problem:	it is possible for the processor to signal a machine check exception when deep packages c-states, c8, c9, or c10, are entered too frequently, typically less than 200us apart. the processor will not be able to process the machine check and will hang.				
implication:	due to this erratum, the processor may signal a machine check exception (ia32_mci_status.mccod = 0x0400) and the processor will hang.				
workaround:	it is possible for bios to contain a workaround for this erratum.				
					
title:	some performance monitor events may overcount during tlb misses				
problem:	the following performance monitor events may significantly overcount when multiple tlb misses happen nearly concurrently: 1.itlb_misses (event 85h, umask 01h, 02h, 04h, 08h, 10h) 2.dtlb_load_misses (event 08h, umask 01h, 02h, 04h, 08h, 10h) 3.dtlb_store_misses (event 49h, umask 01h, 02h, 04h, 08h, 10h) 4.page_walker_loads (event bch, all umasks)				
implication:	when this erratum occurs, counts accumulated for the listed events may significantly exceed the correct counts.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	intel® processor trace psb+ packets may contain unexpected packets				
problem:	some intel processor trace packets should be issued only between tip.pge (target ip packet.packet generation enable) and tip.pgd (target ip packet.packet generation disable) packets. due to this erratum, when a tip.pge packet is generated it may be preceded by a psb+ (packet stream boundary) that incorrectly includes fup (flow update packet) and mode.exec packets.				
implication:	due to this erratum, fup and mode.exec may be generated unexpectedly.				
workaround:	decoders should ignore fup and mode.exec packets that are not between tip.pge and tip.pgd packets.				
					
title:	writing non-zero value to ia32_rtit_cr3_match [63:48] will cause #gp				
problem:	bits [63 reserved and therefore writing non-zero values to them will cause a #gp				
implication:	due  to  this  erratum,  a  #gp  fault  will  occur  if  a  non-zero  value  is  written  to ia32_rtit_cr3_match[63:48].				
workaround:	software should avoid writing non-zero values to bits [63 ia32_rtit_cr3_match msr.				
					
title:	core c6 may cause interrupts to be serviced out of order				
problem:	if the apic isr (in-service register) indicates in-progress interrupt(s) at core c6 entry, a lower priority interrupt pending in the irr (interrupt request register) may be executed after core c6 exit, delaying completion of the higher priority interrupt’s service routine.				
implication:	an interrupt may be processed out of its intended priority order immediately after core c6 exit.				
workaround:	it is possible for bios to contain a workaround for this erratum.				
					
title:	the display may not resume correctly after package c8-c10 exit				
problem:	display configuration is not properly restored after a package c8-c10 exit.				
implication:	the display engine may not function correctly after package c8-c10 exit leading to an incorrect display.				
workaround:	it is possible for bios to contain a workaround for this erratum				
					
title:	lpddr3 memory training may cause platform boot failure				
problem:	due to this erratum, lpddr3 memory sub-systems may not successfully complete training.				
implication:	when this erratum occurs, the platform may fail to boot successfully				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	aggressive ramp down of voltage may result in unpredictable behavior				
problem:	aggressive ramp down of vcc voltage may result in insufficient voltage to meet power demand.				
implication:	due to this erratum, unpredictable system behavior or hangs may be observed.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	performance monitor event for outstanding offcore requests and snoop requests may be incorrect				
problem:	the performance monitor event offcore_requests_outstanding (event 60h, any umask value) should count the number of offcore outstanding transactions each cycle. due to this erratum, the counts may be higher or lower than expected.				
implication:	the performance monitor event offcore_requests_outstanding may reflect an incorrect count.				
workaround:	none identified.				
					
title:	dr6 register may contain an incorrect value when a mov to ss or  pop ss instruction is followed by an xbegin instruction				
problem:	if xbegin is executed immediately after an execution of mov to ss or pop ss, a transactional abort occurs and the logical processor restarts execution from the fallback instruction address. if execution of the instruction at that address causes a debug exception, bits [3:0] of the dr6 register may contain an incorrect value.				
implication:	when the instruction at the fallback instruction address causes a debug exception, dr6 may report a breakpoint that was not triggered by that instruction, or it may fail to report a breakpoint that was triggered by the instruction.				
workaround:	avoid  following  a  mov  ss  or  pop  ss  instruction  immediately  with  an  xbegin instruction.				
					
title:	the corrected error count overflow bit in ia32_ mc0_status is not updated after a uc error is logged				
problem:	when a uc (uncorrected) error is logged in the ia32_mc0_status msr (401h), corrected errors will continue to update the lower 14 bits (bits 51:38) of the corrected error count. due to this erratum, the sticky count overflow bit (bit 52) of the corrected error count will not get updated after a uc error is logged.				
implication:	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.				
workaround:	none identified.				
					
title:	processor may incorrectly enter into package-c states c8, c9, or c10				
problem:	the processor may not fully honor all ltr (latency tolerance register) values when selecting the package c-state level.				
implication:	due to this erratum, the exit latency of an incorrect package c-state may lead to media artifacts such as audio glitching. intel has not observed this erratum with any commercially available software				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	certain llc frequency changes may result in unpredictable system behavior				
problem:	a large frequency or voltage change for the llc (last level cache) and associated logic can lead to unpredictable system behavior				
implication:	due to this erratum, unpredictable system behavior may be observed.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	operand-size override prefix causes 64-bit operand form of movbe instruction to cause a #ud				
problem:	execution of a 64 bit operand movbe instruction with an operand-size override instruction prefix (66h) may incorrectly cause an invalid-opcode exception (#ud).				
implication:	a movbe instruction with both rex.w=1 and a 66h prefix will unexpectedly cause an invalid-opcode exception (#ud). intel has not observed this erratum with any commercially available software.				
workaround:	do not use a 66h instruction prefix with a 64-bit operand movbe instruction.				
					
title:	processor operation at turbo frequencies above 3 the processor to hang				
problem:	the processor may not run reliably when operating at turbo frequencies above 3.2 ghz.				
implication:	due to this erratum, the processor may hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	ddr-1600 with a reference clock of 100 mhz may cause s3 entry failure				
problem:	due to this erratum, platform state s3 entry with a ddr-1600 memory subsystem may cause the ddr reference clock, when configured at 100 mhz, to briefly switch to 133 mhz resulting in unpredictable system behavior.				
implication:	when this erratum occurs, the system may experience unpredictable system behavior.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	popcnt instruction may take longer to execute than expected				
problem:	popcnt instruction execution with a 32 or 64 bit operand may be delayed until previous non-dependent instructions have executed.				
implication:	software using the popcnt instruction may experience lower performance than expected.				
workaround:	none identified.				
					
title:	system may hang or video may be distorted after graphics rc6 exit				
problem:	in a specific scenario, when the processor graphics exits rc6 and a processor core exits c6 at the same time, the system may become unresponsive or the video may become distorted.				
implication:	the system may hang or video may be distorted.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	certain edp* displays may not function as expected 				
problem:	when the processor attempts to receive data on the edp aux bus, the impedance seen by the display’s aux bus drivers will be significantly below the vesa* edp* (embedded displayport*) specification’s requirement for the vaux(rx) (edp auxiliary channel) input impedance.				
implication:	certain edp displays may not operate as expected.				
workaround:	none identified.				
					
title:	instruction fetch power saving feature may cause unexpected instruction execution				
problem:	under a complex set of micro-architectural conditions, an instruction fetch dynamic power savings feature may cause the processor to execute unexpected instructions.				
implication:	when this erratum occurs, instances of unexpected #gp (general protection fault) or #pf (page fault) have been observed. unexpected faults may lead to an application or operating system crash.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	c8 or deeper sleep state exit may result in an incorrect hdcp key				
problem:	the hdcp (high-bandwidth digital content protection) key may be incorrect after a package c8 or deeper sleep state exit.				
implication:	when this erratum occurs, drm (digital rights management) video playback may not behave as expected.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	ia core ratio change coincident with outstanding read to the de may cause a system hang				
problem:	an outstanding read from an ia core to the de (display engine) that is coincident with an ia core ratio change may result in a system hang.				
implication:	due to this erratum, the system may hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	ddr1600 clocking marginality may lead to unpredictable system behavior				
problem:	the memory controller’s ddr clock, when operating at ddr1600 frequencies and at elevated temperatures, may not operate within tolerance and may lead to unpredictable system behavior.				
implication:	due to this erratum, unpredictable system behavior may occur.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	package c9/c10 exit may cause a system hang				
problem:	certain processors may not reliably exit package c9/c10 states.				
implication:	due to this erratum, the system may hang.				
workaround:	it is possible for bios to contain processor configuration data and code changes as a workaround for this erratum.				
					
title:	pl3 power limit control mechanism may not release frequency restrictions				
problem:	the  pl3  mechanism  imposes  peak  frequency  constraints  on  all  domains  (core, graphics, and ring) when a current spike that might cause accelerated battery aging is detected. due to this erratum, these constraints may not be released when the current spike has ended.				
implication:	the processor clock frequencies may be unnecessarily limited.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	frequency difference between ia core(s) and ring domains may cause unpredictable system behavior				
problem:	operating one or more of the ia (intel® architecture) cores at a frequency significantly higher than the ring operating frequency may cause unpredictable system behavior. intel has observed this erratum to occur when the software explicitly requests the ring and ia core(s) to operate at different frequencies or when ia core(s) are transitioning in and out of c-states with the ia core(s) operating at frequencies much higher than the ring frequency. exposure to this erratum may be increased when the ia cores run at or close to p0 p-state frequency.				
implication:	due to this erratum, system may hang or experience unpredictable system behavior.				
workaround:	it is possible for bios to contain processor a workaround for this erratum.				
					
title:	i/o subsystem clock gating may cause a system hang				
problem:	certain complex internal conditions and timing relationships during clock gating of the i/o subsystem may cause a system hang and may lead to a timeout machine check with an ia32_mci_status.mcacod of 0400h.				
implication:	due to this erratum, the processor may hang and may report a machine check.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	intel® trusted execution technology uses incorrect tpm 2  index handles				
problem:	intel® txt (trusted execution technology) uses tpm (trusted platform module) 2.0 draft specification handles (indices) aux 01800003, ps 01800001, and po 01400003. those handles conflict with the released tcg (trusted computing group) “registry of reserved tpm 2.0 handles and localities”, version 1.0, revision 1.				
implication:	txt tpm 2.0 handles may conflict with platform manufacturer or owner usage of tpm nv space. intel has not identified any functional impact due to this erratum.				
workaround:	none identified.				
					
title:	transitions through package c7 or deeper may result in a system hang				
problem:	under certain conditions, entry into a package c7 or deeper c-state may result in a system hang on the subsequent c-state exit				
implication:	due to this erratum, the processor may experience a system hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	page_walker_loads performance monitoring event may count incorrectly				
problem:	due to this erratum, the page_walker_loads (event bch) performance monitoring event may overcount or may undercount				
implication:	these performance monitoring events may not produce reliable results				
workaround:	none identified.				
					
title:	the system may hang when exiting from deep package c-states				
problem:	when exiting from package c7-c10, the system may hang.				
implication:	the system may hang when exiting from package c-states				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	certain local memory read/load retired perfmon events may undercount				
problem:	due to this erratum, the local memory read/load retired perfmon events listed below may undercount.				
implication:	the affected events may undercount, resulting in inaccurate memory profiles. intel has observed under counts by as much as 20%.				
workaround:	none identified.				
					
title:	the system may hang when executing a complex sequence of locked instructions				
problem:	under certain internal timing conditions while executing a complex sequence of locked instructions, the system may hang				
implication:	the system may hang while executing a complex sequence of locked instructions and cause an internal timeout error machine check (ia32_mci_status.mcacod=0400h).				
workaround:	it is possible for the bios to contain a workaround for this problem.				
					
title:	certain settings of vm-execution controls may result in incorrect linear-address translations				
problem:	if vm exit occurs from a guest with primary processor-based vm-execution control “activate  secondary  controls”  set  to  0  and  the  secondary  processor-based  vm- execution control “enable vpid” set to 1, then after a later vm entry with vpid fully enabled (“activate secondary controls” and “enable vpid” set to 1), the processor may use stale linear address translations.				
implication:	the processor may incorrectly translate linear addresses.  intel has not observed this erratum with any commercially available software.				
workaround:	software should not enter a guest with “enable vpid” set to 1 when “activate secondary controls” is set to 0.				
					
title:	an iret instruction that results in a task switch does not serialize  the processor				
problem:	an iret instruction that results in a task switch by returning from a nested task does not serialize the processor (contrary to the software developer’s manual vol. 3 section titled "serializing instructions").				
implication:	software which depends on the serialization property of iret during task switching may not behave as expected. intel has not observed this erratum to impact the operation of any commercially available software.				
workaround:	none identified. software can execute an mfence instruction immediately prior to the iret instruction if serialization is needed.				
					
title:	attempting concurrent enabling of intel® pt with lbr, bts, or btm results in a #gp				
problem:	if lbr (last branch records), bts (branch trace store), or btm (branch trace messages) are enabled in the ia32_debugctl msr (1d9h), an attempt to enable intel pt (intel® processor trace) in ia32_rtit _ctl msr (570h) results in a #gp (general protection exception). (note that the btm enable bit in ia32_debugctl msr is named “tr”.) correspondingly, if intel pt was previously enabled when an attempt is made to enable lbr, bts, or btm, a #gp will occur.				
implication:	an unexpected #gp may occur when concurrently enabling any one of lbr, bts, or btm with intel pt.				
workaround:	none identified				
					
title:	processor may hang when package c-states are enabled				
problem:	when package c6 or deeper c-states are enabled, certain micro-architectural conditions during a c-state exit may cause the processor to hang.				
implication:	due to this erratum, a system hang may occur.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	setting traceen while clearing branchen in ia32_rtit_ctl causes a #gp				
problem:	a wrmsr to ia32_rtit_ctl (msr 0570h) that sets traceen (bit 0) and clears branchen (bit 13) will cause a #gp (general protection exception)				
implication:	intel® processor trace cannot be enabled without enabling control flow trace packets.				
workaround:	none identified.				
					
title:	processor graphics iommu unit may not mask dma remapping faults				
problem:	intel® virtualization technology for directed i/o specification specifies setting the fpd (fault processing disable) field in the context (or extended-context) entry of iommu to mask recording of qualified dma remapping faults for dma requests processed through that context entry. due to this erratum, the iommu unit for processor graphics device may record dma remapping faults from processor graphics device (bus: 0; device: 2; function: 0) even when the fpd field is set to 1.				
implication:	software may continue to observe dma remapping faults recorded in the iommu fault recording register even after setting the fpd field.				
workaround:	none identified. software may mask the fault reporting event by setting the im (interrupt mask) field in the iommu fault event control register (offset 038h in gfxvtbar).				
					
title:	processor graphics iommu unit may report spurious faults				
problem:	the iommu unit for processor graphics pre-fetches context (or extended-context) entries to improve performance. due to the erratum, the iommu unit may report spurious dma remapping faults if prefetching encounters a context (or extended-context) entry which is not marked present.				
implication:	software may observe spurious dma remapping faults when the present bit for the context (or extended-context) entry corresponding to the processor graphics device (bus				
workaround:	none identified. instead of marking a context not present, software should mark the context (or extended-context) entry present while using the page table to indicate all the memory pages referenced by the context entry is not present.				
					
title:	peci frequency limited to 1 mhz				
problem:	the processor should ensure internal graphics configuration is restored during a package c7 or deeper exit event. due to this erratum, some internal graphics configurations may not be correctly restored.				
implication:	when this erratum occurs, a graphics driver restart may lead to system instability. such a restart may occur when upgrading the graphics driver.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	reads or writes to lbrs with intel® pt enabled will result in a #gp				
problem:	on processors where the use of intel pt (intel® processor trace) and lbrs (last branch records) are mutually exclusive, reads of the lbr msrs should return 0s and writes to them should be ignored. due to this erratum, reads and writes to the lbr msrs while ia32_rtit_ctl msr (570h) traceen bit 0 is 1 will result in a #gp.				
implication:	when this erratum occurs, a #gp will occur. lbrs are not available when intel pt is enabled.				
workaround:	none identified.				
					
title:	graphics configuration may not be correctly restored after a package c7 exit 				
problem:	the processor should ensure internal graphics configuration is restored during a package c7 or deeper exit event. due to this erratum, some internal graphics configurations may not be correctly restored.				
implication:	when this erratum occurs, a graphics driver restart may lead to system instability. such a restart may occur when upgrading the graphics driver.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	mtf vm exit on xbegin instruction may save state incorrectly				
problem:	execution of an xbegin instruction while the “monitor trap flag” vm-execution control is 1 will be immediately followed by an mtf vm exit. if advanced debugging of rtm transactional regions has been enabled, the vm exit will erroneously save the address of the xbegin instruction as the instruction pointer (instead of the fallback instruction address specified by the xbegin instruction). in addition, it will erroneously set bit 16 of the pending-debug-exceptions field in the vmcs indicating that a debug exception or a breakpoint exception occurred.				
implication:	software using the monitor trap flag to debug or trace transactional regions may not operate properly. intel has not observed this erratum with any commercially available software.				
workaround:	none identified.				
					
title:	back-to-back page walks due to instruction fetches may cause a system hang				
problem:	multiple code fetches in quick succession that generate page walks may result in a system hang causing an internal timer error (an mcacod value of 0400h) logged into ia32_mci_status bits [15:0].				
implication:	due to this erratum, the processor may hang and report a machine check.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	pebs record may be generated after being disabled				
problem:	a performance monitoring counter may generate a pebs (precise event based sampling) record after disabling pebs or the performance monitoring counter by clearing the corresponding enable bit in ia32_pebs_enable msr (3f1h) or ia32_perf_global_ctrl msr (38fh).				
implication:	a pebs record generated after a vmx transition will store into memory according to the post-transition ds (debug store) configuration. these stores may be unexpected if pebs is not enabled following the transition.				
workaround:	it is possible for the bios to contain a workaround for this erratum. a software workaround is possible through disallowing pebs during vmx non-root operation and disabling pebs prior to vm entry.				
					
title:	some offcore_response performance monitoring events related to rfo request types may count incorrectly				
problem:	the performance monitoring events offcore_response (events b7h and bbh) should count uncore responses matching the request-response configuration specified in msr_offcore_rsp_0 (1a6h) and msr_offcore_rsp_1 (1a7h) for core-originated requests. however, due to this erratum, response type no_supp bit [17] may be reported instead of local bit [26] for request types dmnd_rfo bit [1] and pf_rfo bit [5].				
implication:	the specified performance monitoring events may count incorrectly.				
workaround:	none identified.				
					
title:	movntdqa from wc memory may pass earlier locked instructions				
problem:	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.				
implication:	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.				
workaround:	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.				
					
title:	data breakpoint coincident with a machine check exception may be lost				
problem:	if a data breakpoint occurs coincident with a machine check exception, then the data breakpoint may be lost.				
implication:	due to this erratum, a valid data breakpoint may be lost.				
workaround:	none identified.				
					
title:	internal parity errors may incorrectly report overflow in the ia32_mc0_status msr				
problem:	due to this erratum, an uncorrectable internal parity error with an ia32_mc0_status.mcacod (bits [15				
implication:	ia32_mc0_status.over may not accurately indicate multiple occurrences of errors. there is no other impact to normal processor functionality.				
workaround:	none identified.				
					
title:	an intel® hyper-threading technology enabled processor may exhibit internal parity errors or unpredictable system behavior				
problem:					
implication:					
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	performance monitoring counters may undercount when using cpl filtering				
problem:	performance monitoring counters configured to count only os or only usr events by setting exactly one of bits 16 or 17 in ia32_perfevtselx msrs (186h-18dh) may not count for a brief period during the transition to a new cpl.				
implication:	due to this erratum, performance monitoring counters may report counts lower than expected.				
workaround:	none identified.				
					
title:	pebs eventingip field may be incorrect under certain conditions				
problem:	the eventingip field in the pebs (processor event-based sampling) record reports the address of the instruction that triggered the pebs event. under certain complex microarchitectural conditions, the eventingip field may be incorrect.				
implication:	a measurement of ring transitions (using the edge-detect bit 18 in ia32_perfevtselx) may  undercount,  such  as  cpl_cycles.ring0_trans  (event  5ch,  umask  01h). additionally, the sum of an os-only event and a usr-only event may not exactly equal an event counting both os and usr. intel has not observed any other software-visible impact.				
workaround:	none identified.				
					
title:	rf may be incorrectly set in the eflags that is saved on a fault in pebs or bts				
problem:	after a fault due to a failed pebs (processor event based sampling) or bts (branch trace store) address translation, the rf (resume flag) may be incorrectly set in the eflags image that is saved.				
implication:	when this erratum occurs, a code breakpoint on the instruction following the return from handling the fault will not be detected. this erratum only happens when the user does not prevent faults on pebs or bts.				
workaround:	software should always prevent faults on pebs or bts.				
					
title:	some memory performance monitoring events may produce incorrect results when filtering on either os or usr modes				
problem:	the memory at-retirement performance monitoring events (listed below) may produce incorrect results when a performance counter is configured in os-only or usr-only modes (bits 17 or 16 in ia32_perfevtselx msr). counters with both os and usr bits set are not affected by this erratum. the list of affected memory at-retirement events for bdw is as follows: mem_uops_retired.stlb_miss_loads event d0h, umask 11h mem_uops_retired.stlb_miss_stores event d0h, umask 12h mem_uops_retired.lock_loads event d0h, umask 21h  mem_uops_retired.split_loads event d0h, umask 41h mem_uops_retired.split_stores event d0h, umask 42h mem_load_uops_retired.l2_hit event d1h, umask 02h mem_load_uops_retired.l3_hit event d1h, umask 04h mem_load_uops_retired.l1_miss event d1h, umask 08h mem_load_uops_retired.l2_miss event d1h, umask 10h mem_load_uops_retired.l3_miss event d1h, umask 20h mem_load_uops_retired.hit_lfb event d1h, umask 40h mem_load_l3_hit_retired.xsnp_miss event d2h, umask 01h mem_load_l3_hit_retired.xsnp_hit event d2h, umask 02h mem_load_l3_hit_retired.xsnp_hitm event d2h, umask 04h mem_load_l3_hit_retired.xsnp_none event d2h, umask 08h mem_load_uops_l3_miss_retired.local_dram event d3h, umask 01h				
implication:	the listed performance monitoring events may produce incorrect results including pebs records generated at an incorrect point.				
workaround:	none identified.				
					
title:	some dram and l3 cache performance monitoring events may undercount				
problem:	due to this erratum, the supplier may be misattributed to unknown, and the following events may undercount: mem_load_uops_retired.l3_hit (event d1h umask 04h) mem_load_uops_retired.l3_miss (event d1h umask 20h) mem_load_uops_l3_hit_retired.xsnp_miss (event d2h umask 01h) mem_load_uops_l3_hit_retired.xsnp_hit (event d2h umask 02h) mem_load_uops_l3_hit_retired.xsnp_hitm (event d2h umask 04h) mem_load_uops_l3_hit_retired.xsnp_none (event d2h umask 08h) mem_load_uops_l3_miss_retired.local_dram (event d3h umask 01h) mem_trans_retired.load_latency (event cdh umask 01h)				
implication:	the affected events may undercount, resulting in inaccurate memory profiles.for the affected events that are precise, pebs records may be generated at incorrect points. intel has observed incorrect counts by as much as 20%				
workaround:	none identified				
					
title:	an x87 store instruction which pends #pe while ept is enabled may  lead to an unexpected machine check and/or incorrect x87 state information				
problem:	the execution of an x87 store instruction which causes a #pe (precision exception) to be pended and also causes a vm-exit due to an ept violation or misconfiguration may lead the vmm logging a machine check exception with a cache hierarchy error (ia32_mci_status.mcacod  =  0150h  and  ia32_mci_status.mscod  =  000fh). additionally, fsw.pe and fsw.es (bits 5 and 7 of the fpu status word) may be incorrectly set to 1, and the x87 last instruction opcode (fop) may be incorrect.				
implication:	when this erratum occurs, the vmm may receive an expected machine check exception and software attempting to handle the #pe may not behave as expected.				
workaround:	none identified				
					
title:	general-purpose performance monitoring counters 4-7 do not count with usr mode only filtering				
problem:	the ia32_pmc4-7 msr (c5h-c8h) general-purpose performance monitoring counters will not count when the associated cpl filter selection in ia32_perfevtselx msr's (18ah-18dh) usr field (bit 16) is set while os field (bit 17) is not set.				
implication:	software depending upon ia32_pmc4-7 to count only usr events will not operate as expected. counting os only events or os and usr events together is unaffected by this erratum.				
workaround:	none identified				
					
title:	writing msr_lastbranch_x_from_ip may #gp when intel® tsx is not supported				
problem:	due to this erratum, on processors that do not support intel tsx (intel® transactional synchronization extensions) (cpuid.07h.ebx bits 4 and 11 are both zero), writes to msr_lastbranch_x_from_ip (msr 680h to 68fh) may #gp unless bits[62:61] are equal to bit[47].				
implication:	the value read from msr_lastbranch_x_from_ip is unaffected by this erratum; bits [62:61] contain in_tsx and tsx_abort information respectively. software restoring these msrs from saved values are subject to this erratum.				
workaround:	before writing msr _lastbranch_x_from_ip, ensure the value being written has bit[47] replicated in bits[62				
					
title:	an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss instruction if it is followed by an instruction that signals a floating point exception				
problem:	a mov ss/pop ss instruction should inhibit all interrupts including debug breakpoints until after execution of the following instruction. this is intended to allow the sequential execution of mov ss/pop ss and mov [r/e]sp, [r/e]bp instructions without having an invalid stack during interrupt handling. however, an enabled debug breakpoint or single step trap may be taken after mov ss/pop ss if this instruction is followed by an instruction that signals a floating point exception rather than a mov [r/e]sp, [r/e]bp instruction. this results in a debug exception being signaled on an unexpected instruction boundary since the mov ss/pop ss and the following instruction should be executed atomically.				
implication:	this can result in incorrect signaling of a debug exception and possibly a mismatched stack segment and stack pointer. if mov ss/pop ss is not followed by a mov [r/e]sp, [r/e]bp, there may be a mismatched stack segment and stack pointer on any exception. intel has not observed this erratum with any commercially available software or system.				
workaround:	as recommended in the ia32 intel® architecture software developer’s manual, the use of mov ss/pop ss in conjunction with mov [r/e]sp, [r/e]bp will avoid the failure since the mov [r/e]sp, [r/e]bp will not generate a floating point exception. developers of debug tools should be aware of the potential incorrect debug event signaling created by this erratum.				
					
title:	apic error “received illegal vector” may be lost				
problem:	apic (advanced programmable interrupt controller) may not update the esr (error status register) flag received illegal vector bit [6] properly when an illegal vector error is received on the same internal clock that the esr is being written (as part of the write-read esr access flow). the corresponding error interrupt will also not be generated for this case.				
implication:	due to this erratum, an incoming illegal vector error may not be logged into esr properly and may not generate an error interrupt.				
workaround:	none identified.				
					
title:	an uncorrectable error logged in ia32_cr_mc2_status may also result in a system hang				
problem:	uncorrectable errors logged in ia32_cr_mc2_status msr (409h) may also result in a system hang causing an internal timer error (mcacod = 0x0400h) to be logged in another machine check bank (ia32_mci_status).				
implication:	uncorrectable errors logged in ia32_cr_mc2_status can further cause a system hang and an internal timer error to be logged.				
workaround:	none identified.				
					
title:	changing the memory type for an in-use page translation may lead to memory-ordering violations				
problem:	under complex microarchitectural conditions, if software changes the memory type for data being actively used and shared by multiple threads without the use of semaphores or barriers, software may see load operations execute out of order.				
implication:	memory ordering may be violated. intel has not observed this erratum with any commercially available software.				
workaround:	software should ensure pages are not being actively used before requesting their memory type be changed.				
					
title:	code segment limit/canonical faults on rsm may be serviced before higher priority interrupts/exceptions and may push the wrong address onto the stack				
problem:	normally, when the processor encounters a segment limit or canonical fault due to code execution, a #gp (general protection exception) fault is generated after all higher priority interrupts and exceptions are serviced. due to this erratum, if rsm (resume from system management mode) returns to execution flow that results in a code segment limit or canonical fault, the #gp fault may be serviced before a higher priority interrupt or exception (for example, nmi (non-maskable interrupt), debug break(#db), machine check (#mc), and so forth). if the rsm attempts to return to a non-canonical address, the address pushed onto the stack for this #gp fault may not match the non-canonical address that caused the fault.				
implication:	operating systems may observe a #gp fault being serviced before higher priority interrupts and exceptions. intel has not observed this erratum on any commercially available software.				
workaround:	none identified.				
					
title:	debug exception flags dr6 breakpoints				
problem:	when a debug exception is signaled on a load that crosses cache lines with data forwarded from a store and whose corresponding breakpoint enable flags are disabled (dr7.g0-g3 and dr7.l0-l3), the dr6.b0-b3 flags may be incorrect.				
implication:	the  debug  exception  dr6.b0-b3  flags  may  be  incorrect  for  the  load  if  the corresponding breakpoint enable flag in dr7 is disabled.				
workaround:	none identified.				
					
title:	dr6 may contain incorrect information when the first instruction after a mov ss,r/m or pop ss is a store				
problem:	normally, each instruction clears the changes in dr6 (debug status register) caused by the previous instruction. however, the instruction following a mov ss,r/m (mov to the stack segment selector) or pop ss (pop stack segment selector) instruction will not clear the changes in dr6 because data breakpoints are not taken immediately after a mov ss,r/m or pop ss instruction. due to this erratum, any dr6 changes caused by a mov ss,r/m or pop ss instruction may be cleared if the following instruction is a store.				
implication:	when this erratum occurs, incorrect information may exist in dr6. this erratum will not be observed under normal usage of the mov ss,r/m or pop ss instructions (that is, following them with an instruction that writes [e/r]sp). when debugging or when developing debuggers, this behavior should be noted.				
workaround:	none identified.				
					
title:	eflags discrepancy on page faults and on ept-induced vm exits after a translation change				
problem:	this erratum is regarding the case where paging structures are modified to change a linear address from writable to non-writable without software performing an appropriate tlb invalidation. when a subsequent access to that address by a specific instruction (add, and, btc, btr, bts, cmpxchg, dec, inc, neg, not, or, rol/ror, sal/sar/shl/shr, shld, shrd, sub, xor, and xadd) causes a page fault or an ept- induced vm exit, the value saved for eflags may incorrectly contain the arithmetic flag values that the eflags register would have held had the instruction completed without fault or vm exit. for page faults, this can occur even if the fault causes a vm exit or if its delivery causes a nested fault.				
implication:	none identified. although the eflags value saved by an affected event (a page fault or an ept-induced vm exit) may contain incorrect arithmetic flag values, intel has not identified software that is affected by this erratum. this erratum will have no further effects once the original instruction is restarted because the instruction will produce the same results as if it had initially completed without fault or vm exit.				
workaround:	if the handler of the affected events inspects the arithmetic portion of the saved eflags value, then system software should perform a synchronized paging structure modification and tlb invalidation.				
					
title:	fault on enter instruction may result in unexpected values on stack frame				
problem:	the enter instruction is used to create a procedure stack frame. due to this erratum, if execution of the enter instruction results in a fault, the dynamic storage area of the resultant stack frame may contain unexpected values (that is, residual stack data as a result of processing the fault).				
implication:	data in the created stack frame may be altered following a fault on the enter instruction. please refer to “procedure calls for block-structured languages” in ia-32 intel®  architecture  software  developer’s  manual,  vol.  1,  basic  architecture, for information on the usage of the enter instructions. this erratum is not expected to occur in ring 3.  faults are usually processed in ring 0 and stack switch occurs when transferring to ring 0. intel has not observed this erratum on any commercially available software.				
workaround:	none identified.				
					
title:	faulting mmx instruction may incorrectly update x87 fpu tag word				
problem:	under a specific set of conditions, mmx stores (movd, movq, movntq, maskmovq) which cause memory access faults (#gp, #ss, #pf, or #ac), may incorrectly update the x87 fpu tag word register. this erratum will occur when the following additional conditions are also met. the mmx store instruction must be the first mmx instruction to operate on x87 fpu state (that is, the x87 fp tag word is not already set to 0x0000). for movd, movq, movntq stores, the instruction must use an addressing mode that uses an index register (this condition does not apply to maskmovq).				
implication:	if the erratum conditions are met, the x87 fpu tag word register may be incorrectly set to a 0x0000 value when it should not have been modified.				
workaround:	none identified.				
					
title:	freeze_while_smm does not prevent event from pending pebs during smm				
problem:	in general, a pebs record should be generated on the first count of the event after the counter has overflowed.  however, ia32_debugctl_msr.freeze_while_smm (msr 1d9h, bit [14]) prevents performance counters from counting during smm (system management mode). due to this erratum, if: a performance counter overflowed before an smi a pebs record has not yet been generated because another count of the event has not occurred the monitored event occurs during smm then a pebs record will be saved after the next rsm instruction. when freeze_while_smm is set, a pebs should not be generated until the event occurs outside of smm.				
implication:	a pebs record may be saved after an rsm instruction due to the associated performance counter detecting the monitored event during smm; even when freeze_while_smm is set.				
workaround:	none identified.				
					
title:	general protection fault (#gp) for instructions greater than 15 bytes may be preempted				
problem:	when the processor encounters an instruction that is greater than 15 bytes in length, a #gp is signaled when the instruction is decoded. under some circumstances, the #gp fault may be preempted by another lower priority fault (for example, page fault (#pf)). however, if the preempting lower priority faults are resolved by the operating system and the instruction retried, a #gp fault will occur.				
implication:	software may observe a lower-priority fault occurring before or in lieu of a #gp fault. instructions of greater than 15 bytes in length can only occur if redundant prefixes are placed before the instruction.				
workaround:	none identified.				
					
title:	#gp on segment selector descriptor that straddles canonical boundary may not provide correct exception error code				
problem:	during a #gp (general protection exception), the processor pushes an error code on to the exception handler’s stack. if the segment selector descriptor straddles the canonical boundary, the error code pushed onto the stack may be incorrect.				
implication:	an incorrect error code may be pushed onto the stack. intel has not observed this erratum with any commercially available software.				
workaround:	none identified.				
					
title:	io_smi indication in smram state save area may be set incorrectly				
problem:	the io_smi bit in smram’s location 7fa4h is set to “1” by the cpu to indicate a system management interrupt (smi) occurred as the result of executing an instruction that reads from an i/o port. due to this erratum, the io_smi bit may be incorrectly set by: • a non-i/o instruction • smi is pending while a lower priority event interrupts • a rep i/o read • a i/o read that redirects to mwait				
implication:	smm handlers may get false io_smi indication.				
workaround:	the smm handler has to evaluate the saved context to determine if the smi was triggered by an instruction that read from an i/o port. the smm handler must not restart an i/o instruction if the platform has not been configured to generate a synchronous smi for the recorded i/o port address.				
					
title:	ler msrs may be unreliable				
problem:	due to certain internal processor events, updates to the ler (last exception record) msrs, msr_ler_from_lip (1ddh) and msr_ler_to_lip (1deh), may happen when no update was expected.				
implication:	the values of the ler msrs may be unreliable.				
workaround:	none identified.				
					
title:	lbr, bts, btm may report a wrong address when an exception/ interrupt occurs in 64-bit mode				
problem:	an exception/interrupt event should be transparent to the lbr (last branch record), bts (branch trace store) and btm (branch trace message) mechanisms. however, during a specific boundary condition where the exception/interrupt occurs right after the execution of an instruction at the lower canonical boundary (0x00007fffffffffff) in 64-bit mode, the lbr return registers will save a wrong return address with bits 63 to 48 incorrectly sign extended to all 1’s. subsequent bts and btm operations which report the lbr will also be incorrect.				
implication:	lbr, bts and btm may report incorrect information in the event of an exception/ interrupt.				
workaround:	none identified.				
					
title:	mci_status overflow bit may be incorrectly set on a single instance of a dtlb error				
problem:	a single data translation look aside buffer (dtlb) error can incorrectly set the overflow (bit [62]) in the mci_status register. a dtlb error is indicated by mca error code (bits [15				
implication:	due to this erratum, the overflow bit in the mci_status register may not be an accurate indication of multiple occurrences of dtlb errors. there is no other impact to normal processor functionality.				
workaround:	none identified.				
					
title:	mov to/from debug registers causes debug exception				
problem:	when in v86 mode, if a mov instruction is executed to/from a debug registers, a general-protection exception (#gp) should be generated. however, in the case when the general detect enable flag (gd) bit is set, the observed behavior is that a debug exception (#db) is generated instead.				
implication:	with debug-register protection enabled (that is, the gd bit set), when attempting to execute a mov on debug registers in v86 mode, a debug exception will be generated instead of the expected general-protection fault.				
workaround:	in general, operating systems do not set the gd bit when they are in v86 mode. the gd bit is generally set and used by debuggers. the debug exception handler should check that the exception did not occur in v86 mode before continuing. if the exception did occur in v86 mode, the exception may be directed to the general-protection exception handler.				
					
title:	pebs record not updated when in probe mode				
problem:	when a performance monitoring counter is configured for pebs (precise event based sampling), overflows of the counter can result in storage of a pebs record in the pebs buffer. due to this erratum, if the overflow occurs during probe mode, it may be ignored and a new pebs record may not be added to the pebs buffer.				
implication:	due to this erratum, the pebs buffer may not be updated by overflows that occur during probe mode.				
workaround:	none identified.				
					
title:	reported memory type may not be used to access the vmcs and referenced data structures				
problem:	bits 53 uses to access the vmcs and data structures referenced by pointers in the vmcs. due to this erratum, a vmx access to the vmcs or referenced data structures will instead use the memory type that the mtrrs (memory-type range registers) specify for the physical address of the access.				
implication:	bits 53 will be used but the processor may use a different memory type.				
workaround:	software should ensure that the vmcs and referenced data structures are located at physical addresses that are mapped to wb memory type by the mtrrs.				
					
title:	single step interrupts with floating point exception pending may be mishandled				
problem:	in certain circumstances, when a floating point exception (#mf) is pending during single-step execution, processing of the single-step debug exception (#db) may be mishandled.				
implication:	when this erratum occurs, #db will be incorrectly handled as follows • #db is signaled before the pending higher priority #mf (interrupt 16) • #db is generated twice on the same instruction				
workaround:	none identified.				
					
title:	storage of pebs record delayed following execution of mov ss or sti				
problem:	when a performance monitoring counter is configured for pebs (precise event based sampling), overflow of the counter results in storage of a pebs record in the pebs buffer. the information in the pebs record represents the state of the next instruction to be executed following the counter overflow. due to this erratum, if the counter overflow occurs after execution of either mov ss or sti, storage of the pebs record is delayed by one instruction.				
implication:	when this erratum occurs, software may observe storage of the pebs record being delayed by one instruction following execution of mov ss or sti. the state information in the pebs record will also reflect the one instruction delay.				
workaround:	none identified.				
					
title:	vm exits due to “nmi-window exiting” may be delayed by one instruction				
problem:	if vm entry is executed with the “nmi-window exiting” vm-execution control set to 1, a vm exit with exit reason “nmi window” should occur before execution of any instruction if there is no virtual-nmi blocking, no blocking of events by mov ss, and no blocking of events by sti. if vm entry is made with no virtual-nmi blocking but with blocking of events by either mov ss or sti, such a vm exit should occur after execution of one instruction in vmx non-root operation. due to this erratum, the vm exit may be delayed by one additional instruction.				
implication:	vmm software using “nmi-window exiting” for nmi virtualization should generally be unaffected, as the erratum causes at most a one-instruction delay in the injection of a virtual nmi, which is virtually asynchronous. the erratum may affect vmms relying on deterministic delivery of the affected vm exits.				
workaround:	none identified.				
					
title:	valuesforlbr/bts/btmwillbeincorrectafteranexitfromsmm				
problem:	after a return from smm (system management mode), the cpu will incorrectly update the lbr (last branch record) and the bts (branch trace store), hence rendering their data invalid. the corresponding data if sent out as a btm on the system bus will also be incorrect. note: this issue would only occur when one of the 3 above mentioned debug support facilities are used.				
implication:	the value of the lbr, bts, and btm immediately after an rsm operation should not be used.				
workaround:	none identified.				
					
title:	vphminposuw instruction in vex format does not signal #ud (invalid opcode exception) when vex				
problem:	processor does not signal #ud fault when executing the reserved instruction vphminposuw with vex.vvvv!=1111. the vphminposuw instruction is described in greater detail in the intel® advanced vector extensions programming reference.				
implication:	executing vphminposuw with vex.vvvv != 1111 results in same behavior as vex.vvvv= 1111.				
workaround:	sw should not use vphminposuw with vex.vvvv != 1111 in order to ensure future compatibility.				
					
title:	vmread/vmwrite instruction may not fail when accessing an unsupported field in vmcs				
problem:	the intel® 64 and ia-32 architectures software developer’s manual, volume 2b states that execution of vmread or vmwrite should fail if the value of the instruction’s register source operand corresponds to an unsupported field in the vmcs (virtual machine control structure). the correct operation is that the logical processor will set the zf (zero flag), write 0ch into the vm-instruction error field and for vmread leave the instruction’s destination operand unmodified. due to this erratum, the instruction may instead clear the zf, leave the vm-instruction error field unmodified and for vmread modify the contents of its destination operand.				
implication:	accessing an unsupported field in vmcs will fail to properly report an error. in addition, vmread from an unsupported vmcs field may unexpectedly change its destination operand. intel has not observed this erratum with any commercially available software.				
workaround:	software should avoid accessing unsupported fields in a vmcs.				
					
title:	unexpected #ud on vzeroall/vzeroupper				
problem:	execution of the vzeroall or vzeroupper instructions in 64-bit mode with vex.w set to 1 may erroneously cause a #ud (invalid-opcode exception).				
implication:	the affected instructions may produce unexpected invalid-opcode exceptions in 64-bit mode.				
workaround:	compilers should encode vex.w = 0 for the vzeroall and vzeroupper instructions.				
					
title:	execution of opcode 9bh with the vex opcode extension may produce a #nm exception				
problem:	attempt to use opcode 9bh with a vex opcode extension should produce a #ud (invalid-opcode) exception. due to this erratum, if cr0.mp and cr0.ts are both 1, the processor may produce a #nm (device-not-available) exception if one of the following conditions exists 66h, f2h, f3h or rex as a preceding prefix; an illegal map specified in the vex.mmmmm field;				
implication:	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.				
workaround:	software should not use opcode 9bh with the vex opcode extension.				
					
title:	an unexpected page fault or ept violation may occur after another logical processor creates a valid translation for a page				
problem:	an unexpected page fault (#pf) or ept violation may occur for a page under the following conditions the paging structures initially specify no valid translation for the page. software on one logical processor modifies the paging structures so that there is a valid translation for the page (for example, by setting to 1 the present bit in one of the paging-structure entries used to translate the page). software on another logical processor observes this modification (for example, by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). shortly thereafter, software on that other logical processor performs a store to a linear address on the page. in this case, the store may cause a page fault or ept violation that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). intel has not observed this erratum with any commercially available software.				
implication:	an unexpected page fault may be reported. there are no other side effects due to this erratum.				
workaround:	system software can be constructed to tolerate these unexpected page faults. see section “propagation of paging-structure changes to multiple processors” of volume 3a of ia-32 intel® architecture software developer’s manual, for recommendations for software treatment of asynchronous paging-structure updates.				
					
title:	execution of fxsave or fxrstor with the vex prefix may produce a #nm exception				
problem:	attempt to use fxsave or fxrstor with a vex prefix should produce a #ud (invalid- opcode) exception. if either the ts or em flag bits in cr0 are set, a #nm (device-not-available) exception will be raised instead of #ud exception.				
implication:	due to this erratum a #nm exception may be signaled instead of a #ud exception on an fxsave or an fxrstor with a vex prefix.				
workaround:	software should not use fxsave or fxrstor with the vex prefix.				
					
title:	unexpected #ud on vpextrd/vpinsrd				
problem:	execution of the vpextrd or vpinsrd instructions outside of 64-bit mode with vex.w set to 1 may erroneously cause a #ud (invalid-opcode exception).				
implication:	the affected instructions may produce unexpected invalid-opcode exceptions outside 64-bit mode.				
workaround:	software should encode vex.w = 0 for executions of the vpextrd and vpinsrd instructions outside 64-bit mode.				
					
title:	lbr, btm or bts records may have incorrect branch from information after an enhanced intel® speedstep technology/t-state/s-state/c1e transition or adaptive thermal throttling				
problem:	the “from” address associated with the lbr (last branch record), btm (branch trace message) or bts (branch trace store) may be incorrect for the first branch after a transition of: • enhanced intel speedstep® technology • t-state (thermal monitor states) • s1-state (acpi package sleep state) • c1e (enhanced c1 low power state) • adaptive thermal throttling				
implication:	when the lbrs, btm or bts are enabled, some records may have incorrect branch “from” addresses for the first branch after a transition of enhanced intel speedstep® technology, t-states, s-states, c1e, or adaptive thermal throttling.				
workaround:	none identified.				
					
title:	a write to the ia32_fixed_ctr1 msr may result in incorrect value in certain conditions				
problem:	under specific internal conditions, if software tries to write the ia32_fixed_ctr1 msr (30ah) a value that has all bits [31:1] set while the counter was just about to overflow when the write is attempted (that is, its value was 0xffff ffff ffff), then due to this erratum the new value in the msr may be corrupted.				
implication:	due to this erratum, ia32_fixed_ctr1 msr may be written with a corrupted value.				
workaround:	software may avoid this erratum by writing zeros to the ia32_fixed_ctr1 msr, before the desired write operation.				
					
title:	l1 data cache errors may be logged with level set to 1 instead of 0				
problem:	when an l1 data cache error is logged in ia32_mci_status[15 error code field, with a cache error type of the format 0000 0001 rrrr ttll, the ll field may be incorrectly encoded as 01b instead of 00b.				
implication:	an error in the l1 data cache may report the same ll value as the l2 cache. software should not assume that an ll value of 01b is the l2 cache.				
workaround:	none identified.				
					
title:	warm reset may leave the system in an invalid poisoning state and could cause the feature to be disabled				
problem:	due to this erratum, the pcie poison forwarding enable and intel® quickpath interconnect (intel® qpi) poison enable bits are cleared by warm reset, but other bits related to the poisoning feature remain set. after the warm reset the system may be in an invalid state in regards to the poisoning bits. this invalid state may cause the feature to be disabled.				
implication:	this invalid state may prevent the propagation of the poisoning indication, effectively disabling the feature.				
workaround:	if poisoning is disabled, program the following bits to 0 after reset. if poisoning is enabled, program the following bits to 1 after reset the ia32_mcg_contain.poison_enable bit (msr 178h, bit 0). it should be noted that each thread must perform this action. the ia32_mcg_contain.poison_enable (msr 178h, bit 0). the poisfen bit (iiomiscctrl; cpubus(0); device 5; function 0; offset 1c0h; bit 37). the dmask bit (uncedmask; cpubus(0); device 0, 1, 2, 3; functions 0, 1, 2, 3; offset 218h; bit 12).				
					
title:	vm entries that return from smm using vmlaunch may not update the launch state of the vmcs				
problem:	successful vm entries using the vmlaunch instruction should set the launch state of the vmcs to “launched”. due to this erratum, such a vm entry may not update the launch state of the current vmcs if the vm entry is returning from smm.				
implication:	subsequent vm entries using the vmresume instruction with this vmcs will fail. rflags.zf is set to 1 and the value 5 (indicating vmresume with non-launched vmcs) is stored in the vm-instruction error field. this erratum applies only if dual monitor treatment of smi and smm is active.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	interrupt from local apic timer may not be detectable while being delivered				
problem:	if the local-apic timer’s ccr (current-count register) is 0, software should be able to determine whether a previously generated timer interrupt is being delivered by first reading the delivery-status bit in the lvt timer register and then reading the bit in the irr (interrupt-request register) corresponding to the vector in the lvt timer register. if both values are read as 0, no timer interrupt should be in the process of being delivered. due to this erratum, a timer interrupt may be delivered even if the ccr is 0 and the lvt and irr bits are read as 0. this can occur only if the dcr (divide configuration register) is greater than or equal to 4. the erratum does not occur if software writes zero to the initial count register before reading the lvt and irr bits.				
implication:	software that relies on reads of the lvt and irr bits to determine whether a timer interrupt is being delivered may not operate properly.				
workaround:	software that uses the local-apic timer must be prepared to handle the timer interrupts, even those that would not be expected based on reading ccr and the lvt and irr bits; alternatively, software can avoid the problem by writing zero to the initial count register before reading the lvt and irr bits.				
					
title:	ia32_mci_addr overwritten in the case of multiple recoverable instruction fetch errors				
problem:	the instruction fetch machine check error (mcacod 0x150) is a srar (software recoverable action required) error. the address of the location with the error is provided in the corresponding ia32_mci_addr msr. when multiple instruction fetch errors are logged as part of a single machine check event, as indicated by setting of the overflow (bit 62) in the ia32_mci_status msr, then recovery is not possible. due to this erratum, when multiple instruction fetch errors are logged in the same bank, the ia32_mci_misc msr contains all of the correct information including the proper setting for overflow (bit 62); however, the ia32_mci_addr msr is overwritten with a value that corresponds to neither the first or second error.				
implication:	when debugging failures associated with the instruction fetch machine check error and the overflow bit is set, the value in ia32_mci_addr will not be valid.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	the processor does not detect intel® quickpath interconnect (intel® qpi) rsvd_chk field violations				
problem:	according to the intel qpi specification, if a target agent receives a packet with a non- zero  rsvd_chk  field,  it  should  flag  it  as  an  “intel  qpi  link  layer  detected unsupported/undefined” packet. due to this erratum, the processor does not check the rsvd_chk field nor report the expected error.				
implication:	the processor will not flag the “intel qpi link layer detected unsupported/undefined” packet error in the case that the rsvd_chk field is non-zero.				
workaround:	none identified.				
					
title:	the intel qpi link status register linkinitstatus field incorrectly reports “internal stall link initialization” for certain stall conditions				
problem:	the intel qpi link control register (cpubus(1), devices 8, 9; function 0; offset 0x44) bits 17 and 16 allow for the control of the link layer initialization by forcing the link to stall  the  initialization  process  until  cleared.  the  intel  qpi  link  status  register (cpubus(1), device 8, 9; function 0; offset 0x48) bits 27:24 report the link initialization status (linkinitstatus). the linkinitstatus incorrectly reports “internal stall link initialization” (0001b) for non-intel qpi link control register, bit[17,16] stall conditions. the intel qpi specification does not intend for internal stall conditions to report that status, but rather report the normal “waiting for physical layer ready” (0000b).				
implication:	there is no known problem with this behavior since there is no usage model that relies on polling of the linkinitstatus state in the “waiting for physical layer ready” versus “internal stall link initialization” state, and it only advertises the “internal stall link initialization” state for a brief period of time during link layer initialization.				
workaround:	none identified.				
					
title:	intel qpi tx ac common mode fails specification				
problem:	the intel qpi interface specification requires tx ac common mode (accm) to be between -50 mv to 50 mv at 8.0 gt/s. testing across process, voltage, and temperature showed that the accm exceeded the upper end of the specification on several lanes.				
implication:	those performing an electrical characterization of the intel qpi interface may notice a violation of the upper end of the accm specification by no more than 5 mv.				
workaround:	none identified.				
					
title:	prochot_n assertion during warm reset may disable a processor via the frb mechanism				
problem:	frb (fault resilient booting) is defined as the ability to boot even when one or more processors in the system fail, as long as there is one processor functional. if a warm reset is asserted during the boot flow before the intel qpi interface is enumerated and while a processor is hot and drives prochot_n, the processor that is driving prochot_n will mistakenly observe prochot_n as a signal to transition itself into frb mode.				
implication:	it is possible that a processor may be incorrectly isolated via the frb mechanism if the same processor asserts prochot_n during a warm reset.				
workaround:	case 1 case 1.1: legacy processor gets disabled: the system will not boot. the bmc can detect this case by observing that legacy socket is occupied, but the processor times out on peci ping() command. since bmc knows it did not disable legacy socket, it can assume this is an error case. case 1.2: non-legacy processor gets disabled: if system boots with one or more fewer sockets, bmc will observe a discrepancy between socket occupied pins and response to peci ping() command. if bmc did not disable the affected socket, it can conclude they were accidentally disabled due to this issue. the bmc can respond to either case by issuing a cold reset to the platform. case 2: systems without a bmc case 2.1: legacy socket gets disabled: this will prevent booting. the pch (platform control hub) tco logic can be strapped to reset the platform if the cpu does not fetch code after reset. case 2.2: non-legacy socket gets disabled: bios cannot read socket occupied pin from other socket. therefore, bios cannot tell the difference between a tri-stated socket and unpopulated socket. enable autoack in the intel® qpi interface enumeration which will ensure that a warm reset asserted before the intel® quick path interconnect enumeration will be converted into a power-cycle reset.				
					
title:	the pcie* link at 8 operation while training				
problem:	the pcie bus uses high speed serial links that must go through a training process to allow both transmitter and receiver to make adjustments in behavior to optimize the signaling between the transmitter and receiver. when a pcie compliant device must train or retrain the link, training sequences are used. the device must allow enough time for the training to complete before transitioning to normal operation. in the case of pcie equalization at 8.0 gt/s the processor is not allowing enough time to optimize signaling before attempting normal operation.				
implication:	due to this erratum, unexpected system behavior may be observed.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	qpils reports the vna/vn0 credits available for the processor rx rather than tx				
problem:	the qpils register (cpubus(1); devices 8,9; function 0; offset 0x48), according to the intel® quick path interconnect specification at revisions 1.1 and later, should report the vna/vn0 credits available for the processor tx (transmit port). due to this erratum, the qpils register reports the vna/vn0 credits available for the processor rx (receive port).				
implication:	this is a violation of the specification but no functional failures have been observed due to this erratum.				
workaround:	none identified.				
					
title:	the router value exchanged during intel qpi link layer initialization is set to zero				
problem:	during the intel qpi link layer initialization, parameters are exchanged by hardware. the parameters that are received are stored by the receiver. the information is used to setup link operation. one of those parameters that is exchanged is the router value. the router value should be one but it is zero in the processor.				
implication:	given that the processor is designed to only go into 2 socket platforms and that the bios is not using this value, there is no known negative impact from the router value being 0.				
workaround:	none identified.				
					
title:	a first level data cache parity error may result in unexpected behavior				
problem:	when a load occurs to a first level data cache line resulting in a parity error in close proximity to other software accesses to the same cache line and other locked accesses the processor may exhibit unexpected behavior.				
implication:	due to this erratum unpredictable system behavior may occur. intel has not observed this erratum with any commercially available system.				
workaround:	none identified.				
					
title:	the processor incorrectly indicates that 16-bit rolling crc is supported				
problem:	the intel qpi specification defines two methods of computing crc rolling crc. the processor implements only 8-bit crc. the “crc mode supported” bit in the qpilcp registers (devices 8, 9; function 0; offset 40h, bit 11) is set incorrectly indicating that both 8-bit crc and 16-bit rolling crc are supported.				
implication:	the “crc mode supported” bit of qpilcp must be disregarded; there should be no attempt to use 16-bit rolling crc mode.				
workaround:	the “crc mode” bits in the qpilcl (devices 8, 9; function 0; offset 44h, bits[15 should be left at their reset value of 00b to ensure 8-bit crc is selected.				
					
title:	peci write requests that require a retry will always time out				
problem:	peci 3.0 introduces a ‘host identification’ field as a way for the peci host device to identify itself to the peci client. this is intended for use in future peci systems that may support more than one peci originator. since peci 3.0 systems do not support the use of multiple originators, peci 3.0 host devices should zero out the unused host id field. peci 3.0 also introduces a ‘retry’ bit as a way for the peci host to indicate to the client that the current request is a ‘retry’ of a previous read or write operation. unless the peci 3.0 host device zeroes out the byte containing the ‘host id & retry bit’ information, peci write requests that require a retry will never complete successfully.				
implication:	peci write requests that require a retry may never complete successfully. instead, they will return a timeout completion code of 81h for a period ranging from 1 ms to 30 ms if the ‘retry’ bit is asserted.				
workaround:	peci 3.0 host devices should zero out the byte that contains the host id and retry bit information for all peci requests at all times including retries.				
					
title:	the vswing of the pcie* transmitter exceeds the specification				
problem:	the pcie specification defines a limit for the vswing (voltage swing) of the differential lines that make up a lane to be 1200 mv peak-to-peak when operating at 2.5 gt/s and 5 gt/s. intel has found that the processor’s pcie transmitter may exceed this specification. peak-to-peak swings on a limited number of samples have been observed up to 1450 mv.				
implication:	for those taking direct measurements of the pcie transmit traffic coming from the processor may detect that the vswing exceeds the pcie specification. intel has not observed any functional failures due to this erratum.				
workaround:	none identified.				
					
title:	intel qpi interface calibration may log spurious bus and interconnect error machine checks				
problem:	the intel qpi interface physical layer performs calibration across all 20 of the lanes and reports the success or failure of the calibration process. due to this erratum, the processor may detect spurious errors during the calibration of the intel qpi interface. the bus and interconnect errors are reported with the ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_1xx0_0000_1111 (where x is zero or one).				
implication:	the processor may log spurious bus and interconnect error machine checks reports during intel qpi calibration.				
workaround:	is possible for the bios to contain a workaround for this erratum. a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	when a link is degraded on a port due to pcie* signaling issues correctable receiver errors may be reported on the neighboring port				
problem:	pci express* interface incorporates a recovery mechanism when certain link degradation occurs by retraining the link without impacting the pending transactions. when a link is degraded on a specific port due to pcie signaling issues, it is possible that correctable receiver errors are reported on the neighboring (logically adjacent) port. the correctable receiver errors are indicated by the pcie aer correctable error bit (xpglberrsts cpubus(0); device 0-3; function 0-3; offset 230h; bit 2).				
implication:	software that logs errors on the pcie interface must be aware that errors detected on a specific port could be due to either an error on that specific port or on a neighboring port.				
workaround:	none identified.				
					
title:	a cmci is only generated when the memory controller’s correctable error count threshold is exceeded				
problem:	a cmci (corrected machine check error interrupt) should be generated when the number of corrected errors for a bank reaches the corrected error threshold programmed into the ia32 _mci_ctl2 bits [14				
implication:	the cmci will not be generated when expected but rather will be generated on the next corrected error for the bank.				
workaround:	it is possible for bios to contain a workaround for this issue. it should be noted that with this workaround if the threshold is programmed to a value of 0, a read of the value will return 1 and the threshold will be 1. all other valid threshold values for the bank will be read back correctly and function as expected.				
					
title:	pcie* rx dc common mode impedance is not meeting the specification				
problem:	when the pcie rx termination is not powered, the dc common mode impedance has the following requirement: ≥10 kΩ over 0-200 mv range with respect to ground and ≥20 kΩ for voltages ≥200 mv with respect to ground. the processor’s pcie rx do not meet this requirement at 85 degrees c or greater. in a limited number of samples intel has measured an impedance as low as 9.85 kΩ at 50 mv.				
implication:	intel  has  not  observed  any  functional  impact  due  to  this  violation  with  any commercially available system.				
workaround:	none identified.				
					
title:	a modification to the multiple message enable field does not affect the aer interrupt message number field				
problem:	the (advanced error interrupt) message number field (rperrsts devices 0-3; functions 0-3; offset 178h; bits[31 field (msimsgctl device 3; function 0; offset 62h; bits[6:4]). however, writing the multiple message enable in the root port does not update the advanced error interrupt message number field.				
implication:	due to this erratum, software can allocate only one msi (message signaled interrupt) to the root port.				
workaround:	none identified.				
					
title:	unexpected pcie* set_slot_power_limit message on writes to lnkcon				
problem:	the processor sends the pcie set_slot_power_limit message on writes to the slot capabilities (sltcap devices 0-3; functions 0-3; offset a4h) register. due to this erratum, the processor also sends pcie the set_slot_power_limit message on writes to the lnkcon (cpubus(0); devices 0-3; functions 0-3; offset a0h) register.				
implication:	for those monitoring the pcie traffic going across the link, the unexpected pcie set_slot_power_limit message will be detected whenever a write to the lnkcon register occurs. intel has not observed any functional failures due to this erratum on any commercially available system.				
workaround:	none identified.				
					
title:	enabling intel qpi l0s state may prevent entry into l1				
problem:	enabling intel qpi l0s state in a dual processor system with both processor sockets populated may not allow the intel qpi link between the processors to enter the l1 state.				
implication:	entry into the package c3 state and lower power package c-states cannot occur if the intel qpi link cannot enter the l1 state. system power consumption may increase.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	locked accesses spanning cachelines that include pci space may lead to a system hang				
problem:	a locked memory access which splits across a cacheline boundary that suffers a master abort on a pci bus may lead to a system hang.				
implication:	aborted split lock accesses may cause pci devices to become inoperable until a platform reset. intel has not observed this erratum with commercially available software.				
workaround:	none identified.				
					
title:	intel qpi training sensitivities related to clock detection				
problem:	the processor is demonstrating link training sensitivities related to clock detection and will indicate the error with an ia32_mci_status.mscod (bits[21:16]) of 10011 and with an ia32_mci_status.mcacod (bits[15:0]) of 0000_1000_0000_1111.				
implication:	due to this erratum, the intel qpi interface may train intermittently and flag a machine check error.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	pcie* rx common mode return loss is not meeting the specification				
problem:	the pcie specification requires that the rx common mode return loss in the range of 0.05 to 2.5 ghz must be limited to -6 db. the processor’s pcie rx do not meet this requirement. the pcie rx common mode return at 500 mhz has been found to be between -3.5 and -4 db on a limited number of samples.				
implication:	intel  has  not  observed  any  functional  failures  due  to  this  erratum  with  any commercially available pcie devices.				
workaround:	none identified.				
					
title:	the most significant bit of the cec cannot be cleared once set				
problem:	the most significant bit of the cec (corrected error count ia32_mci_status (i=12- 19), bit 52) cannot be cleared once it has been set.				
implication:	in the case that software attempts to clear the cec and the count exceeds 3fffh, software will read incorrect cec values on subsequent accesses and additional cmcis (corrected machine check error interrupts) will not be generated.				
workaround:	none identified. software can avoid this erratum by setting corrected error threshold to a value less than 3fffh, enable cmci and clearing the error count before it exceeds 3fffh.				
					
title:	an unexpected page fault or ept violation may occur after another logical processor creates a valid translation for a page				
problem:	an unexpected page fault (#pf) or ept violation may occur for a page under the following conditions: the paging structures initially specify no valid translation for the page. software on one logical processor modifies the paging structures so that there is a valid translation for the page (for example, by setting to 1 the present bit in one of the paging-structure entries used to translate the page). software on another logical processor observes this modification (for example, by accessing a linear address on the page or by reading the modified paging-structure entry and seeing value 1 for the present bit). shortly thereafter, software on that other logical processor performs a store to a linear address on the page. in this case, the store may cause a page fault or ept violation that indicates that there is no translation for the page (for example, with bit 0 clear in the page-fault error code, indicating that the fault was caused by a not-present page). intel has not observed this erratum with any commercially available software.				
implication:	an unexpected page fault may be reported. there are no other side effects due to this erratum.				
workaround:	system software can be constructed to tolerate these unexpected page faults. see section “propagation of paging-structure changes to multiple processors” of volume 3a of ia-32 intel® architecture software developer’s manual, for recommendations for software treatment of asynchronous paging-structure updates.				
					
title:	pcie* adaptive equalization may not train to the optimal settings				
problem:	in the case of the pcie equalization procedure for 8 gt/s, the downstream port’s (for example, the processor’s) txeq (transmitter equalization settings) can be fine tuned for each lane during a process called adaptive equalization phase 3. due to this erratum, the processor may not direct the end-agent to the optimal txeq settings.				
implication:	the pcie link may not be as robust as possible potentially leading to a higher bit error rate than expected.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	a core may not complete transactions to the caching agent when c- states are enabled leading to an internal timer error				
problem:	when multiple cores have outstanding transactions targeted to a single caching agent and one of the cores enters a core c-state before completing the transaction with the targeted caching agent an internal timer machine check error may occur (ia32_mci_status.mcacod of 0000_0100_0000_0000).				
implication:	due to this erratum, the processor may experience an internal timer error.				
workaround:	none identified.				
					
title:	tsc is not affected by warm reset				
problem:	the tsc (time stamp counter msr 10h) should be cleared on reset. due to this erratum the tsc is not affected by warm reset.				
implication:	the tsc is not cleared by a warm reset. the tsc is cleared by power-on reset as expected. intel has not observed any functional failures due to this erratum.				
workaround:	none identified.				
					
title:	warm resets may be converted to power-on resets when recovering from an ierr				
problem:	when a warm reset is attempted and an ierr (internal error) happens as indicated by the ia32_mci_status.mcacod of 0000_0100_0000_0000, a power-on reset occurs instead.				
implication:	the values in the machine check bank will be lost as a result of the power-on reset. this prevents a os, bios or the bmc (baseboard management controller) from logging the content of the error registers or taking any post-reset actions that are dependent on the machine check information.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	using dma xor with dca may cause a machine check				
problem:	if both dca (direct cache access) and dma xor operations are active at the same time, then invalid prefetch hints may be generated. these prefetch transactions may not complete and could result in a timeout machine check, which will cause caterr# to become asserted.				
implication:	invalid prefetch hints may not complete resulting in a machine check.				
workaround:	if using dma xor operations, disable dca by clearing chanctrl. completion_write _dca_enable (offset 80h; bit 9) in the region described by cb_bar (device: 10; function 0-7; 0ffset 80h).				
					
title:	mixed dma xor and legacy operations in the same channel may cause data to be observed out of order				
problem:	for mixed channel dma (xor and legacy operations active on the same channel) completion writes from legacy operations may pass completion writes from xor operations resulting in out of order descriptor updates/completions.				
implication:	dma descriptor progress may appear out of order with incorrect data.				
workaround:	in the dma driver each dma xor descriptor must be followed by an additional legacy descriptor. the legacy descriptor must have a non-zero transfer length and the “null transfer” bit and “completion interrupt” in the descriptor control field set to '1'. the transfer will not actually occur, but a completion interrupt will be generated that indicates that the xor operation has completed. this causes all completion interrupts to be of the legacy type.				
					
title:	unexpected dma xor halt and errors when using descriptors with p or q operations disabled				
problem:	if a galois field generate/validate base descriptor has either the p operations disable or q operation disable bit set and the corresponding disabled p parity address or q parity address field of the descriptor does not contain a valid/aligned address, the dma channel may halt unexpectedly with destination address errors. the destination address errors will be logged in chanerr_int. dma transfer destination address error (device 4; function 0-7; offset 180h; bit 1).				
implication:	the dma may only partially process a dma xor descriptor when a disabled p or q parity address field of the descriptor does not contain a valid/aligned address, resulting in incomplete data, an unexpected dma channel halt and destination address errors.				
workaround:	at all times, software must place a valid/aligned address in both the p parity address field and the q parity address field of a dma xor with galois field generate/validate base descriptor even if the p operations disable or q operations disable descriptor fields are set to disable either p or q operations for the descriptor.				
					
title:	dma xor channel may hang on source read completion data parity error for >8k descriptors				
problem:	if a parity error occurs of source read completion data while inside the dma for >8k descriptor  transfer  lengths,  the  dma  channel  will  hang  until  the  next  platform reset.this behavior only applies if the data arrived at the dma unit error free (from dram and intel qpi) but then had a parity error in the completion data fifo inside the dma.				
implication:	the effected dma channel will hang until the next platform reset.				
workaround:	none identified.				
					
title:	dma cb_bar decode may be incorrect after dma flr				
problem:	pcie* flr (function level reset) of the dma function, may result in an incorrect cb_bar (device 4; function 0-7; offset 10h) decode when a memory read of the cb_bar occurs around the same time as the flr.				
implication:	a flr may cause a pcie memory read to decode to channel 0 instead of the intended channel resulting in incorrect read data returned.				
workaround:	software must quiesce the dma function before issuing flr including ensure clients are no longer referencing the driver. ensure all outstanding descriptors have completed via the normal completion writeback notifications by reading chancmp, chansts, and dmacount. issue flr and ensure no new dma transactions are started until flr has completed. chancmp (offset 98h) and chansts (offset 88h), and dmacount (offset 86h) are offsets relative to cb_bar on the processor's internal io bus (as defined in the iiobusno register).				
					
title:	xor dma restricted to ≤ 8 kb transfers when multiple channels are in use				
problem:	incorrect data transfers can occur if more than one dma channel is in operation and >8 kb xor dma transfer sizes are being used. xor dma transfer size is set by software in the block size field of the xor with galios field generate/validate base descriptor.				
implication:	xor dma operation is restricted to ≤ 8 kb transfer sizes when multiple dma channels are in use. legacy dma operations may still use up to the maximum 1 mb transfer length.				
workaround:	software may either use a single dma channel for both legacy and xor operation types both up to the maximum 1mb transfer size. use multiple dma channels where xor operation types are ≤ 8 kb transfer size and legacy operation types are up to 1 mb transfer size.				
					
title:	unable to restart dma after poisoned error during an xor operation				
problem:	if the chanerr field read data error (offset a8h; bit 8) is set due to a poisoned completion error during a dma xor operation, the dma stays in the halted state and the read data error bit does not clear				
implication:	the xor operations on the dma can not be restarted after a read data error due to a poisoned xor operation.				
workaround:	at least one xor descriptor with no read data errors has to be processed for a new chain of xor descriptors to work correctly with the corresponding chanerrmsk (offset ach; bit 8) bit set. upon detection of a read data error, software must clear the chanerr and chanerr_int (device 4; function 0-7; offset 180h) registers and disable  the  corresponding  error  mask  bit  by  setting  chanerrmsk.  then  new descriptors can be added to the chain and the dma started by writing the dmacount (offset 86h). once the dma channel is in the running state, software can clear the chanerrmsk.  chanerr,  chanerrmsk,  and  dmacount  are  offsets  relative  to cb_bar (device 4; function 0-7; 0ffset 10h) on the processors internal io bus (as defined in the iiobusno register).				
					
title:	dma restart hang when first descriptor is a legacy type following channel halt due to an extended descriptor error				
problem:	when using multiple dma channels, all dma channels may hang if a dma channel restart is attempted with a legacy descriptor as the first descriptor following an error/ halt on an extended descriptor on channel 0 or 1.				
implication:	following an extended descriptor error on channel 0 or 1, the channel must be not be restarted with a first descriptor of legacy type including null. does not apply for single channel operation.				
workaround:	software must guarantee that the first descriptor processed on restart is an xor gf multiply generation (base type) before using legacy descriptors with interrupts and completions.				
					
title:	jsp cbdma errata bf508s: operation with dma xor interrupts/ completions enabled restricted to channel 0 and 1				
problem:	if dma xor interrupts and completions are enabled on channel 0 or 1 concurrent with operation on channels 2-7, incorrect data transfers can occur on dma channels 2-7. dma xor interrupts and completions are enabled by setting bits 0 and 3 of descriptor control field of a dma xor with galios field generate/validate base descriptor.				
implication:	if dma xor interrupts and completions are enabled, only one interrupt/completion type may be used on any single channel and only channels 0 and 1 may be used.				
workaround:	software must either only use only legacy interrupts and completions on all channels. use only dma channels 0 and 1 where: — only dma xor interrupts/completions are enabled on channel 0 and is only used for dma xor operations. — only legacy interrupts/completions are enabled on channel 1 and is only used for dma legacy operations.				
					
title:	suspending/resetting an active dma xor channel may cause an incorrect data transfer on other active channels				
problem:	suspending an active dma xor channel by setting chancmd.suspend dma bit (offset 84; bit 2) while xor type dma channels are active may cause incorrect data transfer on the other active legacy channels. this erratum may also occur while resetting an active dma xor channel chancmd.reset dma bit (offset 84; bit 5). chancmd is in the region described by cb_bar(device 4; function 0-7; offset 10h) on the processor's internal io bus (as defined in the iiobusno register).				
implication:	an incorrect data transfer may occur on the active legacy dma channels.				
workaround:	software must suspend all legacy dma channels before suspending an active dma xor channel (channel 0 or 1).				
					
title:	dword-aligned dma xor descriptors with fencing and multi- channel operation may cause a channel hang				
problem:	dma xor descriptors with dword aligned sources and fencing enabled may result in a xor channel hang until the next platform reset. xor dma fencing is set by software in descriptor control.fence (xor base descriptor, bit 4)				
implication:	an xor dma descriptor with non cacheline aligned sources may hang until the next platform reset.				
workaround:	do  not  enable  fencing  on  xor  descriptors.  fencing  can  be  enabled  on  legacy descriptors. it is recommended that a null legacy descriptor must be paired with each xor descriptor. software can use fencing of the legacy null descriptor to track full completion of its associated xor descriptor.				
					
title:	intel qpi link layer does not drop unsupported or undefined packets				
problem:	the intel qpi should detect an unsupported or undefined packet, drop the offending packet, and log a correctable error with an ia32_mci_status.mcacod of 0000_1100_0000_1111. when the intel qpi detects an unsupported or undefined packet it does not drop the offending packet but it does log the error.				
implication:	due to this erratum, intel qpi does not drop unsupported packets. intel has not observed any functional failure on commercially available systems due to this erratum.				
workaround:	none identified				
					
title:	the equalization phase successful bits are not compliant to the pcie* specification				
problem:	pcie specification states that if the phase 1 of transmitter equalization completes successfully as indicated by the lnksts2.equalization phase 1 successful (devices 0- 3; functions 0-3; bit[2]) bit being set to one and if the phase 2 and 3 link training phases are bypassed, the lnksts2.equalization phase 3 successful (devices 0-3; functions 0-3; bit[4]) and lnksts2.equalization phase 2 successful (bit[3]) bits should be set to one. due to this erratum, the processor will only set the equalization phase 2 or 3 successful bits if the phases are completed successfully.				
implication:	due to this erratum, equalization phase 2 and 3 successful bits may not be set. intel has not observed any functional failure with commercially available pcie devices.				
workaround:	none identified.				
					
title:	executing the getsec instruction while throttling may result in a processor hang				
problem:	if the processor throttles, due to either high temperature thermal conditions or due to an explicit operating system throttling request (tt1), while executing getsec[senter] or getsec[sexit] instructions, then under certain circumstances, the processor may hang. intel has not been observed this erratum with any commercially available software.				
implication:	possible hang during execution of getsec instruction.				
workaround:	none identified.				
					
title:	incorrect address computed for last byte of fxsave/fxrstor or xsave/xrstor image leads to partial memory update				
problem:	a partial memory state save of the fxsave or xsave image or a partial memory state restore of the fxrstor or xrstor image may occur if a memory address exceeds the 64 kb limit while the processor is operating in 16-bit mode or if a memory address exceeds the 4 gb limit while the processor is operating in 32-bit mode.				
implication:	fxsave/fxrstor or xsave/xrstor will incur a #gp fault due to the memory limit violation as expected but the memory state may be only partially saved or restored.				
workaround:	software should avoid memory accesses that wrap around the respective 16-bit and 32-bit mode memory limits.				
					
title:	execution of vaesimc or vaeskeygenassist with an illegal value for vex.vvvv may produce a #nm exception				
problem:	the vaesimc and vaeskeygenassist instructions should produce a #ud (invalid- opcode) exception if the value of the vvvv field in the vex prefix is not 1111b. due to this erratum, if cr0.ts is “1”, the processor may instead produce a #nm (device-not- available) exception.				
implication:	due to this erratum, some undefined instruction encodings may produce a #nm instead of a #ud exception.				
workaround:	software should always set the vvvv field of the vex prefix to 1111b for instances of the vaesimc and vaeskeygenassist instructions.				
					
title:	lbr may contain incorrect information when using freeze_lbrs_on_pmi				
problem:	when freeze_lbrs_on_pmi is enabled (bit 11 of ia32_debugctl msr (1d9h) is set), and a taken branch retires at the same time that a pmi (performance monitor interrupt) occurs, then under certain internal conditions the record at the top of the lbr stack may contain an incorrect “from” address.				
implication:	when the lbrs are enabled with freeze_lrbs_on_pmi, the “from” address at the top of the lbr stack may be incorrect.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	performance monitoring may overcount some events during debugging				
problem:	if the debug-control register (dr7) is configured so that some but not all of the breakpoints in the debug-address registers (dr0-dr3) are enabled and one or more of the following performance-monitoring counters are locally enabled (via ia32_cr_permon_evntsel_cntr{3:0}): br_inst_retired br_misp_retired fp_assist fp_assist inst_retired machine_clears mem_load_uops_llc_hit_retired mem_load_uops_misc_retired.llc_miss mem_load_uops_retiredmem_trans_retiredmem_uops_retired other_assists rob_misc_events.lbr_inserts uops_retired any of the globally enabled (via ia32_cr_emon_perf_global_ctrl) counters may overcount certain events when a disabled breakpoint condition is met.				
implication:	performance-monitor counters may indicate a number greater than the number of events that occurred.				
workaround:	software can disable all breakpoints by clearing dr7. alternatively, software can ensure that, for a breakpoint disabled in dr7, the corresponding debug-address register contains an address that prevents the breakpoint condition from being met (for example, a non-canonical address).				
					
title:	hdrlog registers do not report the header for pcie* port 1 packets with detected errors				
problem:	the hdrlog registers contain the header information of the first pcie packet detected that contains errors. because of this erratum, the port 1 (iou2) hdrlog registers (cpubus(0), device 1, function 0; offsets 164h, 168h, 16ch, 170h) do not reflect the header of a packet with a detected error.				
implication:	the hdrlog registers cannot be used to debug the receipt of packets with detected errors on port 1.				
workaround:	none identified.				
					
title:	peci temperature data values returned during reset may be non- zero				
problem:	the processor peci power-up time line presented in the intel® xeon® processor e5- 1600/e5-2600/e5-4600 product families datasheet - volume one or intel® xeon® e5-2400 product family datasheet- volume two defines the value returned by the peci gettemp() command as 0x0000 - the maximum value - during the 'data not ready' (dnr) phase (starting approximately 100 µs after pwrgood assertion and lasting until approximately 500 µs after reset de-assertion). due to this erratum, the gettemp() command returns a small negative number during the dnr phase.				
implication:	the temperature reported during the peci dnr phase may be below the maximum and therefore may not have the intended effect of causing platform fans to operate at full speed until the actual processor temperature becomes available.				
workaround:	processor thermal management solutions utilizing peci should operate platform fans at full speed during the peci dnr phase.				
					
title:	tsod related smbus transactions may not complete when package c-states are enabled				
problem:	the processor may not complete smbus (system management bus) transactions targeting the tsod (temperature sensor on dimm) when package c-states are enabled. due to this erratum, if the processor transitions into a package c-state while an smbus transaction with the tsod is in process, the processor will suspend receipt of the transaction. the transaction completes while the processor is in a package c-state. upon exiting package c-state, the processor will attempt to resume the smbus transaction, detect a protocol violation, and log an error.				
implication:	when package c-states are enabled, the smbus communication error rate between the processor and the tsod may be higher than expected.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	dram rapl dynamic range is too narrow on the low side				
problem:	the lower limit for the dram rapl (running average power limit) dynamic range is specified to be about 120% of dram minimum power. due to this erratum, the lower limit is enforced at about 170% of dram minimum power. dram minimum power can be found in the minimal dram power field (dram_power_info csr at cpubus(1), device 10, function 2, offset 90h; bits[30:16]).				
implication:	dram rapl cannot regulate dram power consumption to as low a level as expected.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	mcacod 0119h reported in ia32_mc3_status is ambiguous				
problem:	the machine check error code (mcacod) in the ia32_mc3_status (msr 040dh) register is intended to report the type of error that has been discovered. the 0119h mcacod is correctly logged for mlc (mid-level cache) generic read errors and, due to this erratum, also logged for errors detected as a result of monitor instructions.				
implication:	it may not be possible to distinguish the precise operation associated with an mlc machine check error.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	the processor incorrectly transitions from polling polling.compliance after receiving two ts1 ordered sets with the compliance bit set				
problem:	the processor pcie* interface incorrectly transitions from the polling.active link state to the polling.compliance link state after receiving two ts1 ordered sets with the compliance bit set instead of the eight ts1 ordered sets required by the specification.				
implication:	it is possible that the pcie link may enter polling.compliance link state unexpectedly. exposure to this erratum requires bit errors on the compliance receive bit (byte 5, bit				
workaround:	none identified.				
					
title:	patrol scrubbing may not resume properly after package c3 and package c6 states				
problem:	patrol scrubbing is disabled at entry into package c3 and package c6 states. due to this erratum, the memory subsystem may not get fully scrubbed in the expected 24-hour timeframe.				
implication:	memory may not be scrubbed as expected when patrol scrubbing is enabled while package c3 and/or package c6 states are enabled. as a consequence, single bit memory errors may not be proactively corrected and could increase the likelihood of uncorrectable memory errors.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	platform idle power may be higher than expected				
problem:	the processor may not place the associated dram subsystem in the lowest allowed power state during package c3 and package c6 states. this may cause the platform idle power to be higher than expected.				
implication:	platform average power and idle power may be higher than expected.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	peci transactions during an s-state transition may result in a platform cold reset				
problem:	due to this erratum, a peci transaction during an s-state transition may result in an unexpected platform cold reset rather than an s-state transition.				
implication:	use of peci transactions during an s-state transition can result in a platform reset that terminates transitioning to the desired s-state.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	complex platform conditions during a transition to s4 or s5 state may result in an internal timeout error				
problem:	due to this erratum, the bios sequencing associated with s4 (sometimes known as “hibernate”) and s5 (also known as “soft off”), when undertaken with certain complex platform conditions, can result in an internal timeout error as indicated by ia32_mci_status.mcacod  of  0000_0100_0000_0000  and  ierr  assertion.  this internal timeout error stops the platform s-state sequencing before platform power down occurs. certain platforms may have logic that, upon detection of the failure to reach power down, initiates a cold reset sequence.				
implication:	s4 state or s5 state may not be reliably entered; the platform may not reach the very low power condition.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	writes to sdoorbell or b2bdoorbell in conjunction with inbound access to ntb mmio space may hang system				
problem:	a posted write targeting the sdoorbell (offset 64h) or b2bdoorbell (offset 140h) mmio registers in the region define by base address register pb01base (bus 0; device 3; function 0: offset 10h) or sb01base (bus m; device 0; function 0; offset 10h) may hang the system. this system hang may occur if the ntb (non-transparent bridge) is processing a transaction from the secondary side of the ntb that is targeting the ntb shared mmio registers or targeting the secondary side configuration registers when the write arrives.				
implication:	the system may hang if the processor writes to the local sdoorbell or b2bdoorbell register at the same time that the ntb is processing an inbound transaction.				
workaround:	in ntb/ntb (back-to-back) mode, do not use the b2bdoorbell to send interrupts from the local to remote host. instead, configure one of the following local register pairs to point to the remote sb01base region pb23base (device: 3; function: 0; offset: 18h) and pbar2xlat (offset 10h) from pb01base or sb01base regions; pb45base (device: 3; function: 0; offset: 20h) and pbar4xlat (offset 18h) from pb01base, or sb01base regions; the local host may then write directly to the pdoorbell (offset 60h) from the pb23base/pb45base region defined above. in ntb/rp (bridge to root port) mode, the sdoorbell register cannot be used by the processor on the primary side of the ntb to interrupt the processor on the secondary side. instead, dedicate a bar and xlat pair, either pb23base/pbar2xlat or pb45base/pbar4xlat, to generate an interrupt directed directly into the msi/msix (message signaled interrupt) interrupt range on the remote processor. the device driver or client on the remote host must point the appropriate pbarnxlat register to its msi/msix interrupt range. the processor on the primary side can then write the msi/msix interrupt to the dedicated bar which will be translated by the ntb to the msi/msix region of the secondary side’s processor.				
					
title:	programming pdir and an additional precise perfmon event may cause unexpected pmi or pebs events				
problem:	pdir (precise distribution for instructions retired) mechanism is activated by programming inst_retired.all (event c0h, umask value 00h) on counter 1. when pdir is activated in pebs (precise event based sampling) mode with an additional precise perfmon event, an incorrect pmi or pebs event may occur.				
implication:	due to this erratum, when another pebs event is programmed along with pdir, an incorrect pmi or pebs event may occur.				
workaround:	software should not program another pebs event in conjunction with the pdir mechanism.				
					
title:	a peci rdiamsr command near ierr assertion may cause the peci interface to become unresponsive				
problem:	when a peci rdiamsr command is issued to the processor near the time that the processor is experiencing an internal timeout error, as indicated by ia32_mci_status.mcacod of 0000_0100_0000_0000 and ierr assertion, the peci interface may issue an 81h (timeout) response. after a timeout response, the processor will ignore future peci commands until it is reset.				
implication:	due to this erratum, peci commands typically used to debug a processor that is not behaving normally - rdpkgconfig and rdpciconfig - may not be available after an internal timeout error.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	long latency transactions may cause i/o devices on the same link to time out				
problem:	certain long latency transactions - for example, master aborts on inbound traffic, locked transactions, peer-to-peer transactions, or vendor defined messages - conveyed over the pcie* and dmi2 interfaces can block the progress of subsequent transactions for extended periods.  in certain cases, these delays may lead to i/o device timeout that can result in device error reports and/or device off-lining.				
implication:	due to this erratum, devices that generate pcie or dmi2 traffic characterized by long latencies can interfere with other traffic types on the same link. this may result in reduced i/o performance and device timeout errors. usb traffic can be particularly sensitive to these delays.				
workaround:	avoid the contributing conditions. this can be accomplished by separating traffic types to be conveyed on different links and/or reducing or eliminating long latency transactions.				
					
title:	the coherent interface error codes “c2”, “c3”, “da” and “db” are incorrectly flagged				
problem:	the coherent interface error status registers (irpp0errst and irpp1errst at cpubus(0), device 5, function 2, offsets 230h and 2b0h respectively) indicate that an error has been detected by the coherent interface. bit 3 indicates that a write cache un-correctable ecc (c2) error has occurred. bit 4 indicates that a csr access crossing 32-bit boundary (c3) error has occurred. bit 13 indicates that a protocol queue/table overflow or underflow (da) error has occurred. bit 14 indicates that a protocol parity error (db) error has occurred. due to this erratum, the processor may incorrectly log the “c2”, “c3”, “da” and “db” error flags.				
implication:	the “c2”, “c3”, “da” and “db” error flags are indeterminate.				
workaround:	mask off the “c2”, “c3”, “da” and “db” error flags (bit 3, bit 4, bit 13 and bit 14) of the irpp0errctl and irpp1errctl registers at cpubus(0), device 5, function 2, offsets 234h and 2b4h respectively.				
					
title:	if multiple poison events are detected within two core clocks, the overflow flag may not be set				
problem:	if multiple poison events are detected within two core clocks, the error is logged with an ia32_mci_status.mcacod of 0000_0001_0011_0100 but the ia32_mci_status.over (bit [60]) may not be set.				
implication:	due to this erratum, only one poison event may be reported by a logical processor when more than one poison event was encountered.				
workaround:	none identified.				
					
title:	pci express* capability structure not fully implemented				
problem:	according to the pcie* base specification, “the pci express capability structure is required for all pci express device functions.” due to this erratum, some pci express capabilities fields were not implemented (“device capability,” “device status” and “device control”) for cpubus[0], device 5, function 2, reads to these fields will return zero.				
implication:	software that depends on the pci express capability structure fields device capability, device status and/or device control will not operate properly.				
workaround:	none identified.				
					
title:	software reads from lmmioh_limit register may be incorrect				
problem:	the mmioh is a memory-mapped i/o region relocatable above 4 gb. due to this erratum, software reads of the lmmioh_limit register (local mmio high base, device				
implication:	software depending on lmmioh_limit register reads may not behave as expected. intel has not identified any commercially available software that is affected by the erratum.				
workaround:	none identified.				
					
title:	patrol scrub is incompatible with rank sparing on more than one channel				
problem:	the imc (integrated memory controller) permits independent sparing of one rank on each memory channel. due to this erratum, patrol scrub operation is impaired when more than one ranking sparing event occurs.				
implication:	if more than one channel has undergone a rank sparing event, patrol scrub may scrub ranks that should have been taken out of service and may skip scrubbing ranks that are in service. in the former case, excessive errors will be reported while in the latter case, memory is incompletely scrubbed.				
workaround:	patrol scrub should not be enabled when more than one channel has suffered a rank sparing event. this can be accomplished during the bios initialization phase by either not enabling the patrol scrub feature not enabling the rank sparing feature. alternatively, during run time one of the following can be implemented • patrol scrub can be disabled when the second rank sparing event occurs • disallowing any rank sparing event after the first one please refer to the latest version of the bios specification update and release notes.				
					
title:	multi-socket intel® txt platform may enter a sequence of warm resets				
problem:	due to this erratum, a platform warm reset issued while a processor is attempting an authenticated boot on a multi-socket intel® trusted execution technology (intel® txt) platform may initiate a series of repeating warm resets.				
implication:	a warm reset attempt during an authenticated boot on a multi-socket intel txt platform may lead to platform unavailability.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	ntb may incorrectly set msi or msi-x interrupt pending bits				
problem:	the ntb (non-transparent bridge) may incorrectly set msi (message signaled interrupt) pending bits in msipending (bar pb01base,sb01base; offset 74h) while operating in msi-x mode or set msi-x pending bits in pmsixpba (bar pb01base, sb01base; offset 03000h) while operating in msi mode.				
implication:	due to this erratum, ntb incorrectly sets msi or msi-x pending bits. the correct pending bits are also set and it is safe to ignore the incorrectly set bits.				
workaround:	none identified.				
					
title:	dword aligned xor dma sources may prevent further dma xor progress				
problem:	xor dma channels may stop further progress in the presence of locks/pholds if the source pointed to by a dma xor descriptor is not cacheline aligned.				
implication:	non-cacheline aligned dma xor sources may hang both channels 0 and 1. a reset is required in order to recover from the hang. legacy dma descriptors on any channel have no source alignment restrictions.				
workaround:	software must either ensure xor dma descriptors only point to cache-line aligned sources (best performance) or a legacy dma copy must be used prior to non-cacheline aligned dma operations to guarantee that the source mis-alignment is on dword15 of the cacheline. the required source that must be misaligned to dword15, depends on the following desired subsequent dma xor operations: — dma xor validate (raid5/ p-only): the p-source must be mis-aligned to dword15 (last dword). — dma xor validate (raid6/p+q): the q-source must be mis-aligned to dword15 (last dword). — dma xor generate or update: the last source (which will be different based on numblk) must be misaligned to dword15 (last dword).				
					
title:	using i/o peer-to-peer write traffic across an ntb may lead to a hang				
problem:	if two systems are connected via an ntb (non-transparent bridge), either the internal ntb or an external ntb, and both systems attempt to send i/o peer-to-peer write traffic across the ntb either to memory or an i/o device on the remote system, it is possible for both systems to deadlock.				
implication:	due to this erratum, using i/o peer-to-peer write traffic across an ntb may lead to a hang.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	ntb does not set pme_to_ack after a pme_turn_off request				
problem:	the ntb (non-transparent bridge) does not set pme_to_ack in miscctrlsts (device 3; function 0: offset 188h; bit [48]) after a pme_turn_off request.				
implication:	due to this erratum, the ntb will not acknowledge a pme_turn_off request.				
workaround:	acpi or other software must have a time-out to proceed with the power management event and should not wait indefinitely for the ntb to acknowledge the pme_turn_off request.				
					
title:	pcmpestri, pcmpestrm, vpcmpestri and vpcmpestrm always operate with 32-bit length registers				
problem:	in 64-bit mode, using rex.w=1 with pcmpestri and pcmpestrm or vex.w=1 with vpcmpestri and vpcmpestrm should support a 64-bit length operation with rax/ rdx. due to this erratum, the length registers are incorrectly interpreted as 32-bit values.				
implication:	due to this erratum, using rex.w=1 with pcmpestri and pcmpestrm as well as vex.w=1 with vpcmpestri and vpcmpestrm do not result in promotion to 64-bit length registers.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	peci commands differing only in length field may be interpreted as command retries				
problem:	due to this erratum, the processor interprets any peci read or write command that accesses the processor, a downstream pci device, or package configuration space and differs from the preceding request only in the length field as a retry request. that is, a retry will be inferred by the processor even if the read length and write length fields don't match between two consecutive requests, regardless of the state of the host retry bit on the succeeding request.				
implication:	back-to-back peci commands that are identical with the exception of the length field may yield incorrect results if processor retry completion codes are ignored by the peci host.				
workaround:	peci hosts should retry timed-out commands until they complete successfully by reissuing a peci command sequence identical to the originally timed-out command.				
					
title:	performance monitor precise instruction retired event may present wrong indications				
problem:	when the pdir (precise distribution for instructions retired) mechanism is activated (inst_retired.all (event c0h, umask value 00h) on counter 1 programmed in pebs mode), the processor may return wrong pebs/pmi interrupts and/or incorrect counter values if the counter is reset with a sav below 100 (sample-after-value is the counter reset value software programs in msr ia32_pmc1[47:0] in order to control interrupt frequency).				
implication:	due to this erratum, when using low sav values, the program may get incorrect pebs or pmi interrupts and/or an invalid counter state.				
workaround:	the sampling driver should avoid using sav<100.				
					
title:	vm exits from real-address mode due to machine check exceptions may incorrectly save rflags.rf as 1				
problem:	if a machine check is encountered while fetching an instruction, and if the resulting machine check exception causes a vm exit, the vm exit should save an rflags value in the guest-state area of the vmcs with the rf value that existed at the time of the machine check. due to this erratum, such vm exits that occur in real-address mode may save rflags.rf as 1 even if it had been 0.				
implication:	the processor may fail to report an instruction breakpoint following a return to real- address mode via vm entry.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	the integrated memory controller does not enforce cke high for txsdll dclks after self-refresh				
problem:	the jedec standard ddr3 sdram specification (no. 79-3e) requires that the cke signal  be  held  high  for  txsdll  dclks  after  exiting  self-refresh  before  issuing commands that require a locked dll (delay-locked loop). due to this erratum, the integrated memory controller may not meet this requirement with 512 mb, 1 gb, and 2gb devices in single rank per channel configurations.				
implication:	violating txsdll may result in dimm clocking issues and may lead to unpredictable system behavior.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	the default value of the i/o base address field does not comply with the pci-to-pci bridge architecture specification				
problem:	the pci-to-pci bridge architecture specification defines the default value of the i/o base address field (iobas cpubus(0); device 0-3; function 0-3; offset 1ch; bits [3:2]) to 0. due to this erratum, the processor's default value is 3.				
implication:	it is possible that system software will generate an error due to this erratum.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	a sustained series of pcie* posted upstream writes can lead to deadlock				
problem:	due to this erratum, a sustained series of pcie posted upstream writes to the same cache line, with no other access of that same cache line, may cause a deadlock.				
implication:	under a complex set of conditions, a sustained series of pcie posted upstream writes targeting the same cache line can lead to deadlock. intel has not been observed this erratum with any commercially available system.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	extraneous characters are included in the processor brand string				
problem:	the processor brand string is provided by the cpuid instruction for leaf values eax=80000002h, 80000003h, and 80000004h. each execution of the three cpuid leaf value returns 16 ascii bytes of the processor brand string in the eax, ebx, ecx, and edx registers. due to this erratum, an extra zero character (“0”, 30h ascii code) and space character (“ “, 20h ascii code) are inserted after the processor number in the brand string output. in the following example brand string, the extraneous characters are underlined				
implication:	an extraneous “0” and “space” character are included in the processor brand string.				
workaround:	the extraneous characters may be ignored or removed by software.				
					
title:	imc controlled dynamic dram refresh rate can lead to unpredictable system behavior				
problem:	drams require a 2x refresh rate when operating above 85°c. due to this erratum, the imc (integrated memory controller) logic intended to double the refresh rate when dram  temperature  exceeds  85°c  can  cause  dram  access  failures,  leading  to unpredictable system behavior.				
implication:	the imc is not able to dynamically adjust the dram refresh rate based on dram temperature. if drams may be operated above 85°c then bios must configure the imc for a doubled refresh rate.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	incorrect error address status may get logged				
problem:	when a correctable machine check event with a valid address precedes an uncorrectable machine check event without a valid address, the ia32_mci_status over flag (bit 62) should be set and addrv flag (bit 58) should be cleared. due to this erratum, both flags may be set.				
implication:	the machine check report logged may incorrectly indicate valid address information when the over flag is set.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	the machine check threshold-based error status indication may be incorrect				
problem:	a corrected cache hierarchy data or tag error is reported in ia32_mci_status.mcacod (bits [15				
implication:	the threshold-based error status indication is unreliable.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	ia32_mci_status registers may contain undefined data after reset				
problem:	due to this erratum, if the reset_n signal is asserted while the processor is in a package c state the ia32_mci_status registers may contain undefined data after the processor completes the reset. in particular, the ia32_mci_status.val (bit[63]) may be set incorrectly indicating a valid machine check has been logged.				
implication:	invalid errors may be reported in the ia32_mci_status registers.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	refresh cycles for high capacity dimms are not staggered				
problem:	certain high capacity dimms, typically quad rank rdimms and lr-dimms, may exceed instantaneous and short-term power limits if refresh cycles are not correctly staggered. due to this erratum, the integrated memory controller is unable to stagger refresh cycles.				
implication:	some dimms may exceed power limits during refresh operations leading to unpredictable system behavior.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	a stream of snoops can lead to a system hang or machine check				
problem:	due to this erratum, a stream of snoop requests to a single cache slice may cause the processor in that slice to livelock, resulting in a system hang or internal timer error machine check indicated by ia32_mci_status.mcacod (bits 15:0, 0000 0100 0000 0000).				
implication:	a system hang or machine check may occur. intel has not observed this erratum with any commercially available software.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	ia32_mci_status exceptions				
problem:	due to this erratum, ia32_mci_status.en may not be set as expected after the mlc (mid-level cache) has logged a fatal error with a mcacod value of 000x_0001_xxxx_xx10 (where x stands for zero or one) and signaled an mce (machine check error) as a result of encountering poisoned data.				
implication:	the value of ia32_mci_status.en may be inconsistent with signaling an mce while logging a fatal error, however a machine check exception is still signaled.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	llc cache correctable errors are not counted and logged				
problem:	llc cache correctable errors are logged in the corrected_error_count field bits [53 of the ia32_mc[19:12]_status msr. due to this erratum, llc cache corrections are not counted and logged.				
implication:	software using the corrected error count may not function correctly. a cmci (corrected machine check error interrupt) may not be generated when the error threshold programmed in ia32_cr_mc[19:12]_ctl2.error_threshold (bits [14:0]) would otherwise be expected to be met.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	the processor incorrectly transitions from the pcie* recovery.rcvrlock ltssm state to the configuration.linkwidth.start ltssm state				
problem:	when a pcie link is operating at 2.5 gt/s and the processor's ltssm (link training and status state machine) is in recovery.rcvrlock state, the processor expects to receive ts1 ordered sets within 24 ms. if it does not receive the ts1s in the allotted time, the ltssm should transition to the detect state. due to this erratum, if the processor does not receive ts1s within 24 ms, it will transition to configuration.linkwidth.start. in that state, if it receives no ts1s, it will transition to detect. if it receives ts1s, it will configure the link appropriately and return to l0.				
implication:	the  state  transition  sequence  from  the  recovery.rcvrlock  ltssm  state  to  the configuration.linkwidth.start ltssm state is in violation of the pcie specification. intel has not observed any functional failures due to this erratum with any commercially available pcie devices.				
workaround:	none identified.				
					
title:	writes to b2bspad[15:0] registers may transfer corrupt data between ntb connected systems				
problem:	writes to the ntb (non-transparent bridge) b2bspad[15 sb01base; offsets 100h - 13fh) may result in corrupted data transfer between systems.				
implication:	using b2bspad[15 pb23base (device 3; function 0; offset 18h) and pbar2xlat (offset 10h) from pb01base or sb01base regions; pb45base (device 3; function 0; offset 20h) and pbar4xlat(offset 18h) from pb01base, or sb01base regions;				
workaround:	it is possible for the bios to contain processor configuration data and code changes as a workaround for this erratum.				
					
title:	ntb operating in ntb/rp mode with msi/msi-x interrupts may cause system hang				
problem:	the ntb (non-transparent bridge) operating in ntb/rp (ntb to root port mode) using message signaled interrupts (msi or msi-x) in the presence of locks may result in a system hang.				
implication:	due to this erratum, system may hang under the condition described above.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	xsaveopt may fail to save some state after transitions into or out of stm				
problem:	the xsaveopt instruction may optimize performance by not saving state that has not been modified since the last execution of xrstor. this optimization should occur only if the executions of xsaveopt and xrstor are either both or neither in smm (system- management mode). due to this erratum, this optimization may be performed by the first execution of xsaveopt after a transition into or out of the stm (smm-transfer monitor) if the most recent execution of xrstor occurred before that transition. for transitions into the stm, the erratum applies only to transitions using the vmcall instruction. this erratum can occur only if the two executions are at the same privilege level, use the same linear address, and are either both or neither in vmx non-root operation. the erratum does not apply if software in smm never uses xrstor or xsaveopt.				
implication:	this erratum may lead to unpredictable system behavior.				
workaround:	stm software should execute the xrstor instruction with the value 0 in edx				
					
title:	rank sparing may cause an extended system stall				
problem:	the integrated memory controller sequencing during a rank sparing copy operation blocks all writes to the memory region associated with the rank being taken out of service. due to this erratum, this block can result in a system stall that persists until the sparing copy operation completes.				
implication:	the system can stall at unpredictable times which may be observed as one time instance of system unavailability.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	system hang may occur when memory sparing is enabled				
problem:	due to this erratum, enabling memory sparing can result in an internal timer error as indicated by the ia32_mci_status.mcacod of 0000_0100_0000_0000.				
implication:	enabling memory sparing may result in a system may hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	enabling opportunistic self-refresh and pkg c2 state can severely degrade pcie* bandwidth				
problem:	due to this erratum, enabling opportunistic self-refresh can lead to the memory controller over-aggressively transitioning dram to self-refresh mode when the processor is in pkg c2 state.				
implication:	the pcie interface peak bandwidth can be degraded by as much as 90%.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	mirrored memory writes may lead to system failures				
problem:	in mirrored memory mode, each channel manages its memory write bandwidth resources. due to this erratum, if a channel in mirrored memory mode is heavily utilized, it is possible for issued writes to exceed available bandwidth resulting in write failures.				
implication:	a system hang or unpredictable system behavior may occur.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	end agent pcie packet errors may result in a system hang				
problem:	pcie agents are required by the pcie base specification to identify and report packet errors. due to this erratum, certain invalid completion types from the end agent are not correctly handled by the processor.				
implication:	if a pcie end agent issues certain invalid completion types, the system may hang.				
workaround:	none identified.				
					
title:	retraining cannot be initiated by downstream devices in ntb/ntb or ntb/rp configurations				
problem:	the pcie base specification requires that a downstream device can initiate link retraining. due to this erratum, link retraining cannot be initiated by the downstream device in a ntb/ntb (non-transparent bridge) or a ntb/rp (root port) configuration.				
implication:	the retrain_link field (lnkcon device 3; function 0; offset 1a0h; bit [5]) does not function as expected in the identified configurations; software referencing the downstream device is not able to retrain the link.				
workaround:	the link speed and training must be managed by the upstream host in ntb/ntb or ntb/rp configurations.				
					
title:	pcie port in ntb mode flags upstream slot power limit message as ur				
problem:	when the processor is in ntb (non-transparent bridge) mode, it should ignore upstream slot power limit messages from the root port it is connected to. due to this erratum, the processor generates ur (unsupported request) on these slot power limit messages when in ntb mode.				
implication:	due to this erratum, some messages will be improperly flagged with ur.				
workaround:	upstream slot power limit message should be disabled in the identified configurations.				
					
title:	spurious smis may occur due to memhot# assertion				
problem:	the imc (integrated memory controller) can be programmed to generate an smi (system management interrupt) on an internal memhot# event assertion through the mhot_smi_en field (mh_maincntl bus				
implication:	due to this erratum, excessive smi generation may occur.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	pcie link bandwidth notification capability is incorrect				
problem:	a value of 1 in the link_bandwidth_notification_capability field (lkncap bit 21) for a pcie device indicates support for the link bandwidth notification status and interrupt mechanisms. due to this erratum, this field for ports 2c, 2d, 3c and 3d (lkncap bus 0; device 2,3; function 2,3; offset 09ch; bit 21) always reads as 0 when it should read as 1.				
implication:	software that reads this field for the listed ports will incorrectly conclude that the link bandwidth notification status and interrupt mechanisms are not available.				
workaround:	software should ignore the value of the link_bandwidth_notification_capability field for ports 2c, 2d, 3c, and 3d.				
					
title:	uncorrectable intel qpi errors may cause the system to power down				
problem:	due to this erratum, under a complex set of conditions, intel qpi uncorrectable errors may cause a deadlock between the processor and pch (platform controller hub). the deadlock will cause a processor internal timeout error as indicated by ia32_mci_status.mcacod of 0000_0100_0000_0000, caterr# assertion and a shutdown transaction being sent to the pch. depending on the platform implementation, this will result in reset being asserted to the pch. this deadlock persists, causing the pch to timeout on the reset request. reacting to the reset request timeout, the pch powers down the system.				
implication:	the system will be powered down and the ia32_mci_status register contents will be lost. the system may need to be manually powered back on. intel has not observed this erratum in the absence of injected uncorrectable intel qpi errors.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum. this is a partial workaround that causes the system to power cycle, eliminating the need for manual power on. the ia32_mci_status register contents are still lost.				
					
title:	four outstanding pcie configuration retries may cause deadlock				
problem:	pcie configuration retries are allowed for older generation pci/pci-x bridges that take a long time to respond to configuration cycles after a reset. due to this erratum, a fifth configuration  cycle  following  the  fourth  pcie  configuration  retry  may  not  make progress, resulting in a deadlock.				
implication:	a deadlock could occur. intel has not observed this erratum with any commercially available system.				
workaround:	when configuring devices on pci/pci-x buses, bios should wait for configuration cycles to complete before issuing subsequent configuration cycles.				
					
title:	a peci rdpciconfiglocal command referencing a non-existent device may return an unexpected value				
problem:	configuration reads to non-existent pci configuration registers should return 0ffff_ffffh. due to this erratum, when the peci rdpciconfiglocal command references a non-existent pci configuration register, the value 0000_0000h may be returned instead of the expected 0ffff_ffffh.				
implication:	a peci rdpciconfiglocal command referencing a non-existent device may observe a return value of 0000_0000h. software expecting a return value of 0ffff_ffffh to identify non-existent devices may not work as expected.				
workaround:	software that performs enumeration via the peci "rdpciconfiglocal" command should interpret 0ffff_ffffh and 0000_0000h values for the vendor identification and device identification register as indicating a non-existent device.				
					
title:	when in dmi mode, port 0's device_port_type field is incorrect				
problem:	when in dmi mode, the device_port_type field (pxpcap bus 0; device 0; function 0; offset 92h; bits [7:4]) should read as 9h (dmi mode) but incorrectly reads as 4h (pcie* mode).				
implication:	software may incorrectly conclude that this port is operating in pcie mode when it is actually being used in the dmi mode.				
workaround:	none identified.				
					
title:	pcie tph attributes may result in unpredictable system behavior				
problem:	tph (transactions processing hints) are optional aids to optimize internal processing of pcie transactions. due to this erratum, certain transactions with tph attributes may be misdirected, resulting in unpredictable system behavior.				
implication:	use of the tph feature may affect system stability.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	continuous intel qpi retraining feature indication is incorrect				
problem:	the processor is capable of continuous intel qpi retraining. due to this erratum, the field reporting support for this feature “continuous retraining” (qpireut_ph_cpr bus 1; device 8,9; function 3; offset 128h; bit 18) indicates this feature is not supported although it is enabled and cannot be disabled.				
implication:	due to this erratum, it is not possible to disable the continuous intel qpi retraining feature.				
workaround:	none identified.				
					
title:	correctable memory errors may result in unpredictable system behavior				
problem:	under certain conditions, the processor may not detect or correct a correctable memory error.				
implication:	when this erratum occurs, it may result in unpredictable system behavior.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	intel® quickdata technology dma lock quiescent flow causes dma state machine to hang				
problem:	the lock quiescent flow is a means for an agent to gain sole ownership of another agent's resources by preventing other devices from sending transactions. due to this erratum, during the lock quiescent flow, the intel quickdata technology dma read and write queues are throttled simultaneously. this prevents subsequent read completions from draining into the write queue, hanging the dma lock state machine.				
implication:	the dma lock state machine may hang during a lock quiescent flow.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	malformed tlp power management messages may be dropped				
problem:	the pcie base specification requires power management messages to use the default traffic class designator, tc0, and receivers to check for violations of this rule. due to this erratum, a tlp using a non-default traffic class designator will be dropped, rather than handled as a malformed tlp.				
implication:	an advanced error reporting err_fatal notification will not be logged for malformed tlp power management messages.				
workaround:	none identified				
					
title:	core frequencies at or below the dram ddr frequency may result in unpredictable system behavior				
problem:	the intel speedstep® technology can dynamically adjust the core operating frequency to as low as 1200 mhz. due to this erratum, under complex conditions and when the cores are operating at or below the dram ddr frequency, unpredictable system behavior may result.				
implication:	systems using intel speedstep technology with ddr3-1333 or ddr3-1600 memory devices are subject to unpredictable system behavior.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	quad rank dimms may not be properly refreshed during ibt_off mode				
problem:	the integrated memory controller incorporates a power savings mode known as ibt_off (input buffer termination disabled). due to this erratum, quad rank dimms may not be properly refreshed during ibt_off mode.				
implication:	use of ibt_off mode with quad rank dimms may result in unpredictable system behavior.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	intel® quickdata technology dma non-page-aligned next source/ destination addresses may result in unpredictable system behavior				
problem:	non-page aligned intel® quickdata technology dma next source/destination addresses may cause memory read-write collisions.				
implication:	due to this erratum, using non-page aligned next source/destination addresses may result in unpredictable system behavior.				
workaround:	next source/destination addresses must be page aligned. the intel-provided intel quickdata technology dma driver abides by this alignment rule.				
					
title:	spurious crc errors may be detected on intel qpi links				
problem:	the processor autonomously manages intel qpi (quickpath interconnect) link power state transitions based on link idle intervals. due to this erratum, crc errors may be detected  during  intel  qpi  link  power  state  transitions  and  may  be  logged  in qpireut_err_ced (bus 1; device 8,9; function 3; offset 120h).				
implication:	spurious intel qpi link crc errors may be reported.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	peci temperature lower limit may be as high as 7°c				
problem:	peci reports temperatures as an offset from the prochot threshold (a negative value when the temperature is below the prochot threshold, zero when at or above that threshold).  if  the  temperature  is  below  0°c,  peci  responds  with  an  “invalid temperature” encoding (8002h). due to this erratum, peci may indicate an invalid temperature when the actual temperature is as high as 7°c.				
implication:	an invalid temperature report from peci indicates the actual temperature is 7°c or lower. platform facilities depending peci to provide accurate temperature readings between 0°c and 7°c may not function correctly.				
workaround:	none identified.				
					
title:	the dram power meter may not be accurate				
problem:	the dram power meter uses vr (voltage regulator) current readings in combination with weighted activity counters to provide a running estimate of dram subsystem power. due to this erratum, the dram power meter may not be sufficiently accurate for system power management purposes.				
implication:	the dram power meter cannot be relied upon to provide accurate dram subsystem power measurements. reduced or variable system performance may be a side effect.				
workaround:	it is possible for bios to contain a workaround for this erratum.				
					
title:	a machine check exception due to instruction fetch may be delivered before an instruction breakpoint				
problem:	debug exceptions due to instruction breakpoints take priority over exceptions resulting from fetching an instruction. due to this erratum, a machine check exception resulting from the fetch of an instruction may take priority over an instruction breakpoint if the instruction crosses a 32-byte boundary and the second part of the instruction is in a 32-byte poisoned instruction fetch block.				
implication:	instruction breakpoints may not operate as expected in the presence of a poisoned instruction fetch block.				
workaround:	none identified.				
					
title:	enhanced intel speedstep® technology may cause a system hang				
problem:	enhanced intel speedstep® technology dynamically changes core operating frequencies. due to this erratum, under complex conditions, core frequency changes may result in a system hang.				
implication:	enhanced intel speedstep technology may cause a system hang.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	prochot may be incorrectly asserted at reset				
problem:	the prochot signal is used to indicate elevated processor temperatures during normal operation and is used for frb (fault resilient boot) actions during the reset sequence. due to this erratum, the elevated temperature indication usage of prochot can persist into reset and subsequently can cause improper frb actions.				
implication:	elevated die temperatures at reset time may impair platform operation.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	package c3-state and package c6-state residency is too low				
problem:	the intel qpi link must transition to its l1 power state for the processor to enter package c3-state or package c6-state. due to this erratum, the intel qpi link does not transition to l1 as intended, restricting the processor from reaching package c3-state or package c6-state.				
implication:	the increased idle state power consumption caused by reduced package c3-state and package c6-state residency may exceed the processor idle power specification for multi-socket platforms.				
workaround:	it is possible for bios to contain a workaround for this erratum.				
					
title:	dram pbm overflow may result in a system hang not return an error flag.				
problem:	the dram pbm (power budget meter) manages dram power consumption. due to this erratum, under complex platform conditions, the dram pbm may throttle the memory subsystem to such a great extent that a system hang results.				
implication:	the dram pbm may cause platform instability.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	combining rol transactions with non-rol transactions or marker skipping operations may result in a system hang				
problem:	when intel® quick data technology dma rol (raid on load) transactions and non- rol transactions are simultaneously active, and the non-rol address offsets are not cacheline boundary aligned, the non-rol transaction's last partial cacheline data write may be lost leading to a system hang. in addition, when intel quickdata dma rol transactions are active, marker skipping operations may lead to a system hang.				
implication:	when this erratum occurs, the processor may live lock resulting in a system hang.				
workaround:	none identified. when rol transactions and non-rol transactions are simultaneously active, all non-rol address offsets must be aligned on cacheline boundaries. further, marker  skipping  operations  may  not  be  used  on  any  dma  channel  when  rol transactions are active.				
					
title:	error indication in pcie lane error status incorrectly set when operating at 8 gt/s				
problem:	the lane error status field in bits[15 258h; and device 2,3; function 0,1,2,3; offset 258h) is used to monitor errors on the pcie lanes. due to this erratum, the lnerrsts bits associated with the lanes operating at 8 gt/s port are spuriously set.				
implication:	lnerrsts cannot be used to reliably monitor errors on the pcie lanes operating at 8 gt/s.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	pcie* link may not train to full width				
problem:	during pcie link training, the receiver looks at symbols in the ts1 and ts2 ordered sets as indicators of lane polarity inversion. if polarity inversion is detected, the receiver must invert those lane(s). due to this erratum, the receiver may incorrectly set polarity inversion.				
implication:	pcie links may not train to full width.				
workaround:	none identified. perform a secondary bus reset on the link up to three times to achieve full width.				
					
title:	patrol scrubbing doesn't skip ranks disabled after ddr training				
problem:	if a rank is detected as failed after completing ddr training then bios will mark it as disabled. disabled ranks are omitted from the os memory map. due to this erratum, a rank disabled after ddr training completes is not skipped by the patrol scrubber. patrol scrubbing of the disabled ranks may result in superfluous correctable and uncorrectable memory error reports.				
implication:	disabling ranks after ddr training may result in the over-reporting of memory errors.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	simultaneously enabling patrol scrubbing, package c-states, and rank sparing may cause the patrol scrubber to hang				
problem:	patrol scrubbing is a ras facility that scans all physical memory (including any spare ranks) to find errors and attempts to fix single bit errors. patrol scrubbing is suspended when the processor enters a deep package c-state then resumed when that package c- state is exited. due to this erratum, under complex conditions, resuming patrol scrubbing from a package c-state after a rank sparing event may cause the patrol scrubber to hang.				
implication:	enabling package c-states, rank sparing, and patrol scrubbing simultaneously can lead to a patrol scrubber hang.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	patrol scrubbing will report uncorrectable memory errors found on a spare rank				
problem:	due to this erratum, patrol scrubbing signals an uncorrectable machine check event when it encounters an uncorrectable error while scrubbing a spare rank. the error logged in ia32_mc{8-11}_status (msr 421h, 425h, 429h, 42dh) will have the pcc field (bit 57) set to '1' and the addrv field (bit 58) set to '0' (that is, there is no address information associated with the error report).				
implication:	an uncorrectable machine check event may occur for physical memory that is not in use at the time of the event.				
workaround:	none identified.				
					
title:	directory mode and memory mirroring are incompatible with demand scrubbing or mirror scrubbing				
problem:	directory mode is a performance feature used on four socket and scalable platforms to reduce average snoop latency. mirror scrubbing attempts to erase uncorrectable errors found in one mirror channel by overwriting them with the correct data from the other channel. due to this erratum, enabling memory mirroring and directory mode with demand  scrubbing  and/or  mirror  scrubbing  can  result  in  unpredictable  system behavior. patrol scrubbing with memory mirroring enabled and directory mode enabled is not affected by this erratum.				
implication:	enabling memory mirroring and directory mode with demand scrubbing and/or mirror scrubbing can lead to unpredictable system behavior.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	spurious power limit interrupt may occur at package c-state exit				
problem:	the processor monitors power consumption and uses that information to limit core operating frequency. due to this erratum, power consumption may be improperly calculated by the processor during package c-states. as a result, the processor may incorrectly signal a power limit interrupt.				
implication:	in response to a power limit interrupt, the os may choose to operate the processor at its minimum frequency for several milliseconds after the package c-state exit.				
workaround:	none identified. the os can mask these interrupts by setting the power limit interrupt enable field (bit 24) in the ia32_therm_interrupt msr (19bh) to 0.				
					
title:	intel vt-d translation fault may be dropped				
problem:	due to this erratum, under complex conditions, an intel vt-d translation request that results in a dma remapping fault (more commonly called “translation fault”) may be lost.				
implication:	an intel vt-d translation fault might not be properly reported.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum				
					
title:	the accumulated energy status read service may report a power spike early in boot				
problem:	the peci rdpkgconfig() command with an index value of 03h is the accumulated energy status read service. during platform boot, the accumulated energy status read service returns an accumulated energy value of 0. later in the boot flow, due to this erratum, the accumulated energy status read service returns a value that is large. energy values calculated with the first non-zero sample have been observed to be as high as 10kj over a limited number of parts.				
implication:	software may interpret values returned by the accumulated energy status read service during boot time as indicating a large power spike. this could lead to unexpected or undesired platform power management actions.				
workaround:	once  the  first  non-zero  value  is  detected,  the  difference  between  subsequent sequential values is a reliable measure of energy consumed between the sample points.				
					
title:	certain uncorrectable errors may cause loss of peci functionality				
problem:	a peci completion code of 91h indicates the pcu (power control unit) detected an uncorrectable error that prevented processing of the peci request. due to this erratum, certain pcu or vrm error conditions may lead to a persistent 91h completion code for subsequent peci request. uncorrectable pcu errors are reported with an ia32_mc4_status.mcacod (msr 411h, bits[15:0]) value of 0000_0100_0000_0010, ia32_mc4_status.valid (bit 63) set to 1, and ia32_mc4_status.uc (bit 61) set to 1.				
implication:	peci processing may be blocked until either a cold reset or software running on one of the cores clears the ia32_mc4_status register.				
workaround:	none identified. software running on one of the cores can clear the ia32_mc4_status register to restore peci functionality.				
					
title:	machine check during vm exit may result in vmx abort				
problem:	a machine check signaled during vm exit should cause a vmx abort only if the machine check would prevent successful completion of the vm exit; ordinarily, the machine check should be delivered after the vm exit completes. due to this erratum, certain machine checks (for example, an uncorrectable cache error detected by another logical processor) may force a vm exit to result in a vmx abort even when that machine check does not interfere with the vm exit completing correctly.				
implication:	certain machine checks that could be reported in the host context for orderly logging and analysis may instead induce a vmx abort and shut down the logical processor.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	routing intel® high definition audio traffic through vc1 may result in system hang				
problem:	when bit 9 in the iiomiscctrl csr (bus 0; device 5; function 0; offset 1c0h) is set, vcp inbound traffic (intel® hd audio) is routed through vc1 to optimize isochronous traffic performance. due to this erratum, vc1 may not have sufficient bandwidth for all traffic routed through it; overflows may occur.				
implication:	this erratum can result in lost completions that may cause a system hang.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	intel® quickdata technology dma suspend does not transition from armed to halt state				
problem:	suspending an intel quickdata technology dma channel while in the armed state should transition the channel to the halt state. due to this erratum, suspending a dma channel while in the armed state does not change the state to halt and will cause the dma engine, when subsequently activated, to ignore the first descriptor's fence control bit and may cause the dma engine to prematurely discard the first descriptor during the copy stage.				
implication:	suspending a dma channel while in the armed state will cause the dma engine to ignore descriptor fencing, possibly issue completion status without actually completing all descriptors, and may be subject to unexpected activation of dma transfers.				
workaround:	check the dma_trans_state (chansts_0; bus 0; mmio bar 88h; bits[2:0]) to ensure the channel state is either idle (001b) or active (000b) before setting susp_dma (chancmd; bus 0; mmio bar: cb_bar [0:7]; offset 84h; bit 2).				
					
title:	package_energy_counter register may incorrectly report power consumed by the execution of intel® advanced vector extensions (intel® avx) instructions				
problem:	the processor includes a package_energy_counter register to provide real-time energy consumption information. this facility can be accessed by the peci rdpkgconfig() command with an index value of 03h (the accumulated energy status read service), by reading the pkg_energy_status msr (611h) or by reading package_energy_status csr (bus 1; device 10; function 0; offset 90h). due to this erratum, the power consumption reported during the execution of intel® advanced vector extensions (intel® avx) instructions is inaccurate.				
implication:	software that uses the package_energy_counter register value during the execution of intel avx instructions may not behave as expected, possibly compromising thermal load balancing, processor throttling, or other platform management operations.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	suspending/resetting a dma xor channel may cause an incorrect data transfer on other active channels				
problem:	suspending an active dma xor channel by setting chancmd.suspend dma bit (offset 84; bit 2) while xor type dma channels are active may cause incorrect data transfer on the other active legacy channels. this erratum may also occur while resetting an active dma xor channel chancmd.reset dma bit (offset 84; bit 5). chancmd is in the region described by cb_bar (bus 0; device 4; function 0-7; offset 10h).				
implication:	due to this erratum, an incorrect data transfer may occur on the active legacy dma channels.				
workaround:	software must suspend all legacy dma channels before suspending an active dma xor channel (channel 0 or 1).				
					
title:	intel® qpi l0s exit may cause an uncorrectable machine check				
problem:	intel qpi links can transition to a lower power state, l0s, to reduce power consumption during transmitter idle periods. due to this erratum, when an intel qpi link exits l0s state, the resulting retraining may not be successful.				
implication:	due to this erratum, an uncorrectable error signaled with ia32_mci_status.mcacod value of 0000_1110_0000_1111 and ia32_mci_status.mscod[5:0] value of 00_0000 may occur when an intel qpi link exits from l0s state.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	coherent interface write cache may report false correctable ecc errors during cold reset				
problem:	the integrated i/o's coherent interface write cache includes ecc logic to detect errors. due to this erratum, the write cache can report false ecc errors. this error is signaled by asserting bit 1 (write cache corrected ecc) in the irpp0errst csr (bus 0; device 5; function 2; offset 230h) or the irpp1errst csr (bus 0; device 5; function 2; offset 2b0h).				
implication:	if the coherent interface write cache ecc is enabled, the processor may incorrectly indicate correctable ecc errors in the write cache.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	intel quickdata technology continues to issue requests after detecting 64-bit addressing errors				
problem:	intel quickdata technology utilizes the lower 48 address bits of a 64-bit address field. detection of accesses to source address, destination address, descriptor address, chain address, or completion address outside of this 48-bit range are flagged as “64-bit addressing errors” and should halt dma processing. due to this erratum, the intel quickdata dma continues to issue requests after detecting certain 64-bit addressing errors involving raid operations. the failing condition occurs for 64-bit addressing errors in either a channel completion upper address register (chancmp_0, chancmp_1) (bus 0; mmio bar cb_bar [0:7]; offset 98h, 9ch), or in the source or destination addresses of a raid descriptor.				
implication:	programming out of range dma address values may result in unpredictable system behavior.				
workaround:	ensure all raid descriptors, chancmp_0, and chancmp_1 addresses are within the 48-bit range before starting the dma engine.				
					
title:	pcie* ro may result in a system hang or unpredictable system behavior				
problem:	pcie ro (relaxed ordering) is not supported on this processor. due to this erratum, enabling ro or, equivalently, not disabling ro throughout the integrated i/o logic may lead to unpredictable system behavior or a system hang.				
implication:	enabling ro for any port or channel may lead to system instability.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	intel vt-d invalidation time-out error may not be signaled				
problem:	intel vt-d (intel virtualization technology for directed i/o) utilizes itags to identify ats (address translation services) invalidation requests for invalidating device-tlbs on endpoint devices. when an ats invalidation response time-out is detected, the corresponding itag is freed and an invalidation time-out error is signaled through the vt-d fault status register. due to this erratum, an ats invalidation response timeout is detected and reported only for the first outstanding itag entry.				
implication:	as a result of the erratum, the ats invalidation response timeout condition may not be reliably reported when multiple invalidation requests are outstanding. intel has not observed this erratum with any commercially available software.				
workaround:	none identified.				
					
title:	spurious machine check errors may occur				
problem:	the ia32_mci_ctl msr comprises enable bits for various machine check events. when a particular machine check event occurs but the associated bit in ia32_mci_ctl msr is not set, the error is not signaled but is logged with the en flag (bit 60 in ia32_mci_status msr) set to zero. further, the logged error report is not protected from being overwritten by succeeding machine check events (whether those events have the associated ia32_mci_ctl bit set or cleared). due to this erratum, it is possible that a ucr (uncorrectable recoverable) error with the associated bit in ia32_mci_ctl msr set will only set the over flag (ia32_mci_status msr bit 62) rather than correctly overwriting the entire previously logged error when that previously logged error does not have ia32_mci_status.en set.				
implication:	the machine check handler may interpret the failed overwrite as a spurious error.				
workaround:	none identified				
					
title:	enhanced intel speedstep® technology hardware coordination cannot be disabled				
problem:	the processor should permit hardware coordination of enhanced intel speedstep technology requests to be disabled (then use the most recent p-state request from any core or logical processor to set the processor-wide p-state target). due to this erratum, the enhanced intel speedstep technology hardware coordination disable value in bit 0 of the misc_pwr_mgmt msr (1aah) is ignored; hardware coordination is always enabled.				
implication:	it is not possible to prevent hardware p-state coordination.				
workaround:	none identified.				
					
title:	pcie link upconfigure capability is incorrectly advertised as supported				
problem:	the processor does not allow pcie devices to dynamically change link width but, due to this erratum, the pcie link upconfigure capability bit is incorrectly advertised as supported.				
implication:	when a downstream device attempts to dynamically change the link's width, the link may not correctly retrain, resulting in an incorrect link width, reversed lane numbers, or surprise link down (sld).				
workaround:	it is possible for bios to contain a workaround for this erratum.				
					
title:	the ia32_mci_misc				
problem:	the ia32_mci_misc.hadbbank field should be ignored				
implication:	when analyzing machine check register bank contents, the ia32_mci_misc.hadbbank field should be ignored.				
workaround:	none identified				
					
title:	when a pcie x4 port detects a logical lane 0 failure, the link will advertise incorrect lane numbers				
problem:	the pcie interface incorporates a recovery mechanism for link degradation by retraining the link without affecting pending transactions. when a x4 port detects a lane failure on logical lane 0, the link degrades from x4 to x2 and lane reversal occurs. due to this erratum, after degrading to x2 and reversing the lanes, the link will incorrectly advertise lane numbers as “pad 0 1 0" instead of the correct “pad pad 1 0".				
implication:	devices that have the ability to negotiate a link with logical lane 0 on a mid physical lane may fail to successfully train the link.				
workaround:	none identified.				
					
title:	a machine check exception concurrent with an i/o smi may be erroneously reported as re-startable				
problem:	a machine check exception that is delivered between the execution of an i/o instruction (in, ins, out, or outs) and an smi (system-management interrupt) triggered by that instruction may prevent proper handling of the smi; because of this, the machine check exception should not be reported as restartable. due to this erratum, such a machine check exception may be reported as restartable.				
implication:	a restartable machine check exception on an i/o instruction concurrent with a resulting smi may result in unpredictable system behavior.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	vex				
problem:	the vex.l bit should be ignored for the vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions, however due to this erratum the vex.l bit is not ignored and will cause a #ud.				
implication:	unexpected #uds will be seen when the vex.l bit is set to 1 with vcvtss2si, vcvtsd2si, vcvttss2si, and vcvttsd2si instructions.				
workaround:	software should ensure that the vex.l bit is set to 0 for all scalar instructions.				
					
title:	the system agent temperature is not available				
problem:	due to this erratum, the processor does not record the temperature of the system agent in the temperature field in bits [7:0] of the sa_temperature csr (device 10; function 2; offset: 044h).				
implication:	firmware  cannot  read  the  temperature  of  the  system agent  via accessing  the sa_temperature csr.				
workaround:	none identified. the system agent temperature is available via peci rdpkgconfig command service, parameter value 00ffh.				
					
title:	incorrect retry packets may be sent by a pcie x16 port operating at 8 gt/s				
problem:	a pcie x16 port operating at 8 gt/s transmitting 256 byte completion tlps may not replay tlps correctly.				
implication:	due to this erratum, unpredictable system behavior may result when a 256 byte completion tlp is replayed on a pcie x16 port operating at 8 gt/s.				
workaround:	a bios code change has been identified and may be implemented as a workaround for this erratum.				
					
title:	intel® quickdata technology may incorrectly signal a master abort				
problem:	under complex conditions, a master abort error suffered by an intel quickdata technology dma channel running non-raid operations may be reported for both the failing  transfer  and  a  transfer  on  a  different  channel  actively  performing  raid operations. note that master abort errors on intel quickdata technology dma transfers are unusual, generally indicating dma transfer configuration errors.				
implication:	due to this erratum, raid intel quickdata technology transfers may receive spurious master abort errors.				
workaround:	none identified. to avoid this erratum any master aborts errors, (2) do not request fencing (by asserting bit 4) or interrupt on completion (by asserting bit 0) in the descriptor control field, or (3) do not use raid operations.				
					
title:	mci_addr may be incorrect for cache parity errors				
problem:	in cases when a wbinvd instruction evicts a line containing an address or data parity error (mcacod of 0x124, and mscod of 0x10), the address of this error should be logged in the mci_addr register. due to this erratum, the logged address may be incorrect, even though mci_status.addrv (bit 63) is set.				
implication:	the address reported in mci_addr may not be correct for cases of a parity error found during wbinvd execution.				
workaround:	none identified.				
					
title:	instruction fetch page-table walks may be made speculatively to uncacheable memory				
problem:	page-table walks on behalf of instruction fetches may be made speculatively to uncacheable (uc) memory.				
implication:	if any paging structures are located at addresses in uncacheable memory that are used for memory-mapped i/o, such i/o operations may be invoked as a result of speculative execution that would never actually occur in the executed code path. intel has not observed this erratum with any commercially available software.				
workaround:	software should avoid locating paging structures at addresses in uncacheable memory that are used for memory-mapped i/o.				
					
title:	the processor may not properly execute code modified using a floating-point store				
problem:	under complex internal conditions, a floating-point store used to modify the next sequential instruction may result in the old instruction being executed instead of the new instruction.				
implication:	self- or cross-modifying code may not execute as expected. intel has not observed this erratum with any commercially available software.				
workaround:	none identified. do not use floating-point stores to modify code.				
					
title:	execution of getsec[sexit] may cause a debug exception to be lost				
problem:	a debug exception occurring at the same time that getsec[sexit] is executed or when an sexit doorbell event is serviced may be lost.				
implication:	due to this erratum, there may be a loss of a debug exception when it happens concurrently with the execution of getsec[sexit]. intel has not observed this erratum with any commercially available software.				
workaround:	none identified.				
					
title:	warm reset may cause pcie hot-plug to fail				
problem:	the integrated i/o unit uses the vpp (virtual pin port) to communicate with devices that interface to the switches and leds associated with pcie hot-plug sequencing. due to this erratum, vpp operation stalls when a warm reset occurs and then experiences delayed reset. depending on timing alignment with the warm reset event, a vpp transaction in progress around the time of a warm reset may suffer an extended stall or an immediate termination.				
implication:	hot-plug sequencing may suffer failures during or shortly after warm resets which may be temporary or persist until the next cold reset.				
workaround:	none identified.				
					
title:	ia32_mc5_ctl2 is not cleared by a warm reset				
problem:	ia32_mc5_ctl2 msr (285h) is documented to be cleared on any reset. due to this erratum this msr is only cleared upon a cold reset.				
implication:	the algorithm documented in software developer's manual, volume 3, section titled “cmci initialization” or any other algorithm that counts the ia32_mc5_ctl2 msr being cleared on reset will not function as expected after a warm reset.				
workaround:	none identified.				
					
title:	monitor counters may produce incorrect results				
problem:	when operating with smt enabled, a memory at-retirement performance monitoring event (from the list below) may be dropped or may increment an enabled event on the corresponding counter with the same number on the physical core's other thread rather than the thread experiencing the event. processors with smt disabled in bios are not affected by this erratum the list of affected memory at-retirement events is as follows: mem_uop_retired.loads mem_uop_retired.stores mem_uop_retired.lock mem_uop_retired.split mem_uop_retired.stlb_miss mem_load_uops_retired.hit_lfb mem_load_uops_retired.l1_hit mem_load_uops_retired.l2_hit mem_load_uops_retired.llc_hit mem_load_uops_llc_hit_retired.xsnp_hit mem_load_uops_llc_hit_retired.xsnp_hitm mem_load_uops_llc_hit_retired.xsnp_miss mem_load_uops_llc_hit_retired.xsnp_none mem_load_uops_retired.llc_miss mem_load_uops_llc_miss_retired.local_dram mem_load_uops_llc_miss_retired.remote_dram mem_load_uops_retired.l2_miss				
implication:	due to this erratum, certain performance monitoring event will produce unreliable results during hyper-threaded operation.				
workaround:	none identified.				
					
title:	the corrected error count overflow bit in ia32_ mc0_status is not updated when the uc bit is set				
problem:	after a uc (uncorrected) error is logged in the ia32_ mc0_status msr (401h), corrected errors will continue to be counted in the lower 14 bits (bits 51				
implication:	the corrected error count overflow indication will be lost if the overflow occurs after an uncorrectable error has been logged.				
workaround:	none identified.				
					
title:	ia32_vmx_vmcs_enum msr (48ah) does not properly report the highest index value used for vmcs encoding				
problem:	ia32_vmx_vmcs_enum msr (48ah) bits 9 any vmcs encoding. due to this erratum, the value 21 is returned in bits 9:1 although there is a vmcs field whose encoding uses the index value 23.				
implication:	software that uses the value reported in ia32_vmx_vmcs_enum[9 write all vmcs fields may omit one field.				
workaround:	none identified.				
					
title:	the upper 32 bits of cr3 may be incorrectly used with 32-bit paging				
problem:	when 32-bit paging is in use, the processor should use a page directory located at the 32-bit physical address specified in bits 31:12 of cr3; the upper 32 bits of cr3 should be ignored. due to this erratum, the processor will use a page directory located at the 64-bit physical address specified in bits 63:12 of cr3.				
implication:	the processor may use an unexpected page directory or, if ept (extended page tables) is in use, cause an unexpected ept violation. this erratum applies only if software enters 64-bit mode, loads cr3 with a 64-bit value, and then returns to 32-bit paging without changing cr3. intel has not observed this erratum with any commercially available software.				
workaround:	software that has executed in 64-bit mode should reload cr3 with a 32-bit value before returning to 32-bit paging.				
					
title:	ept violations may report bits 11:0 of guest linear address incorrectly				
problem:	if a memory access to a linear address requires the processor to update an accessed or dirty flag in a paging-structure entry and if that update causes an ept violation, the processor should store the linear address into the “guest linear address” field in the vmcs. due to this erratum, the processor may store an incorrect value into bits 11:0 of this field. (the processor correctly stores the guest-physical address of the paging- structure entry into the “guest-physical address” field in the vmcs.)				
implication:	software may not be easily able to determine the page offset of the original memory access that caused the ept violation. intel has not observed this erratum to impact the operation of any commercially available software.				
workaround:	software requiring the page offset of the original memory access address can derive it by simulating the effective address computation of the instruction that caused the ept violation.				
					
title:	virtual-apic page accesses with 32-bit pae paging may cause a system crash				
problem:	if a logical processor has ept (extended page tables) enabled, is using 32-bit pae paging, and accesses the virtual-apic page then a complex sequence of internal processor micro-architectural events may cause an incorrect address translation or machine check on either logical processor.				
implication:	this erratum may result in unexpected faults, an uncorrectable tlb error logged in ia32_mci_status.mcacod (bits [15:0]) with a value of 0000_0000_0001_xxxxb (where x stands for 0 or 1), a guest or hypervisor crash, or other unpredictable system behavior.				
workaround:	it is possible for the bios to contain a workaround for this erratum.				
					
title:	pcie* header of a malformed tlp is logged incorrectly				
problem:	if a pcie port receives a malformed tlp (transaction layer packet), an error is logged in the uncerrsts register (device 0; function 0; offset 14ch and device 2-3; function 0-3; offset 14ch). due to this erratum, the header of the malformed tlp is logged incorrectly in the hdrlog register (device 0; function 0; offset 164h and device 2-3; function 0-3; offset 164h).				
implication:	the pcie header of a malformed tlp is not logged correctly.				
workaround:	none identified.				
					
title:	vm exit may set ia32_efer set to 1				
problem:	when “xd bit disable” in the ia32_misc_enable msr (1a0h) bit 34 is set to 1, it should not be possible to enable the “execute disable” feature by setting ia32_efer.nxe.  due to this erratum, a vm exit that occurs with the 1-setting of the “load ia32_efer” vm-exit control may set ia32_efer.nxe even if ia32_misc_enable bit 34 is set to 1. this erratum can occur only if ia32_misc_enable bit 34 was set by guest software in vmx non-root operation.				
implication:	software in vmx root operation may execute with the “execute disable” feature enabled despite the fact that the feature should be disabled by the ia32_misc_enable msr. intel has not observed this erratum with any commercially available software.				
workaround:	a virtual-machine monitor should not allow guest software to write to the ia32_misc_enable msr.				
					
title:	pcie* correctable error status register may not log receiver error at caused by a caterr#. 8.0 gt/s				
problem:	due to this erratum, correctable pcie receiver errors may not be logged in the dpe field (bit 15) of the pcists csr (bus:0; device 1,2,3; function 0-1,0-3,0-3; offset 6h) when operating at 8.0 gt/s.				
implication:	correctable receiver errors during 8.0 gt/s operation may not be visible to the os or driver software.				
workaround:	none identified				
					
title:	configuring pcie* port 3a as an ntb disables eoi forwarding to port 2a				
problem:	configuring pcie port 3a as an ntb (non-transparent bridge) requires disabling eoi (end of interrupt) broadcast forwarding to this port by setting bit 26 of miscctrlsts csr (bus 0; device 3; function 0; offset 188h) to 0. due to this erratum, disabling eoi broadcast forwarding to port 3a improperly disables eoi broadcast forwarding to port 2a.				
implication:	some platform configurations will not behave as expected.				
workaround:	if port 3a is configured as an ntb then devices requiring eoi messages (those using message signaled interrupts and those with their own io apic) must not be connected to port 2a.				
					
title:	pcie* lbms bit incorrectly set				
problem:	if a pcie link autonomously changes width or speed for reasons other than to attempt to correct unreliable link operation, the port should set labs bit (link autonomous bandwidth status) (bus 0; device 0; function 0 and device 1; function 0-1 and device 2-3; function 0-3; offset 0x1a2; bit 15). due to this erratum, the processor will not set this bit and will incorrectly set lbms bit (link bandwidth management status) (bus 0; device 0; function 0 and device 1; function 0-1 and device 2-3; function 0-3; offset 0x1a2; bit14) instead.				
implication:	software that uses the lbms bit or labs bit may behave incorrectly.				
workaround:	none identified				
					
title:	local pcie* p2p traffic on x4 ports may cause a system hang				
problem:	under certain conditions, p2p (peer-to-peer) traffic between x4 pcie ports on the same processor (i.e., local) may cause a system hang.				
implication:	due to this erratum, the system may hang.				
workaround:	none identified.				
					
title:	pcie* slave loopback may transmit incorrect sync headers				
problem:	the pcie base specification requires that, in the loopback.active state, a loopback slave re-transmits the received bit stream bit-for-bit on the corresponding tx. if the link is directed to enter loopback slave mode at 8 gt/s via ts1 ordered sets with both the loopback and compliance receive bits set, the processor may place sync headers in incorrect locations in the loopback bit stream.				
implication:	in pcie cem (card electromechanical specification) rx compliance testing directing the link to loopback slave mode, the received data may not be correctly re-transmitted on the tx, causing the test to fail.				
workaround:	none identified				
					
title:	performance monitor instructions retired event may not count consistently				
problem:	the performance monitor instructions retired event (event c0h; umask 00h) and the instruction retired fixed counter ia32_fixed_ctr0 msr (309h) are used to count the number of instructions retired. due to this erratum, certain internal conditions may cause the counter(s) to increment when no instruction has retired or to intermittently not increment when instructions have retired.				
implication:	a performance counter counting instructions retired may over count or under count. the count may not be consistent between multiple executions of the same code.				
workaround:	none identified.				
					
title:	intel® vt-d memory check error on an intel® quickdata technology channel may cause all other channels to master abort				
problem:	an intel quickdata dma access to intel® vt-d protected memory that results in a protected memory check error may cause master abort completions on all other intel quickdata dma channels.				
implication:	due to this erratum, an error during intel quickdata dma access to an intel® vt-d protected memory address may cause a master abort on other intel quickdata dma channels.				
workaround:	none identified.				
					
title:	movntdqa from wc memory may pass earlier locked instructions				
problem:	an execution of (v)movntdqa (streaming load instruction) that loads from wc (write combining) memory may appear to pass an earlier locked instruction that accesses a different cache line.				
implication:	software that expects a lock to fence subsequent (v)movntdqa instructions may not operate properly.				
workaround:	none identified. software that relies on a locked instruction to fence subsequent executions of (v)movntdqa should insert an mfence instruction between the locked instruction and subsequent (v)movntdqa instruction.				